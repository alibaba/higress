// File generated by hgctl. Modify as required.
// See:

package main

import (
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"strconv"
	"strings"

	"github.com/alibaba/higress/plugins/wasm-go/pkg/wrapper"
	"github.com/higress-group/proxy-wasm-go-sdk/proxywasm"
	"github.com/higress-group/proxy-wasm-go-sdk/proxywasm/types"
	"github.com/tidwall/gjson"
)

const (
	DefaultPrompt = "你是一个智能类别识别助手，负责根据用户提出的问题和预设的类别，确定问题属于哪个预设的类别，并给出相应的类别。用户提出的问题为:%s,预设的类别为%s，直接返回具体类别，如果没有找到就返回'NotFound'。"
)

func main() {
	wrapper.SetCtx(
		"ai-intent",
		wrapper.ParseConfigBy(parseConfig),
		wrapper.ProcessRequestHeadersBy(onHttpRequestHeaders),
		wrapper.ProcessRequestBodyBy(onHttpRequestBody),
		wrapper.ProcessResponseHeadersBy(onHttpResponseHeaders),
		wrapper.ProcessStreamingResponseBodyBy(onStreamingResponseBody),
		wrapper.ProcessResponseBodyBy(onHttpResponseBody),
	)
}

// @Name ai-intent
// @Category protocol
// @Phase AUTHN
// @Priority 1000
// @Title zh-CN AI intent
// @Description zh-CN 大模型意图识别
// @IconUrl
// @Version 0.1.0
//
// @Contact.name jose
// @Contact.url
// @Contact.email
//@Example
// dashscope:
//   ServiceName: "dashscope"
//   model: "qwen-xxx"

// scene:
//   category: ['金融','电商','法律','Higress']
//   prompt:你是一个智能类别识别助手，负责根据用户提出的问题和预设的类别，确定问题属于哪个预设的类别，并给出相应的类别。用户提出的问题为:%s,预设的类别为%s，直接返回具体类别，如果没有找到就返回'NotFound'。
// 例："你是一个智能类别识别助手，负责根据用户提出的问题和预设的类别，确定问题属于哪个预设的类别，并给出相应的类别。用户提出的问题为:今天天气怎么样？,预设的类别为 ["金融","电商","法律"]，直接返回具体类别，如果没有找到就返回"NotFound"。"

type DashScopeInfo struct {
	DashScopeServiceName string             `require:"true" yaml:"DashScopeServiceName" json:"DashScopeServiceName"`
	DashScopeDomain      string             `require:"true" yaml:"DashScopeDomain" json:"DashScopeDomain"`
	DashScopeKey         string             `require:"true" yaml:"DashScopeKey" json:"DashScopeKey"`
	Url                  string             `require:"true" yaml:"Url" json:"Url"`
	Model                string             `require:"Model" yaml:"Model" json:"Model"`
	DashScopeClient      wrapper.HttpClient `yaml:"-" json:"-"`
}

type SceneInfo struct {
	Category string `require:"true" yaml:"Category" json:"Category"`
	Prompt   string `require:"false" yaml:"Prompt" json:"Prompt"`
}

type PluginConfig struct {
	// @Title zh-CN 意图相关配置
	// @Description zh-CN SceneInfo
	SceneInfo SceneInfo `required:"true" yaml:"Scene" json:"Scene"`
	// @Title zh-CN 通义千问 地址信息
	// @Description zh-CN 用于意图类型获取
	DashScopeInfo DashScopeInfo `required:"true" yaml:"dashScopeInfo" json:"dashScopeInfo"`
	// @Title zh-CN 缓存 key 的来源
	// @Description zh-CN 往 redis 里存时，使用的 key 的提取方式
	CacheKeyFrom KVExtractor `required:"true" yaml:"cacheKeyFrom" json:"cacheKeyFrom"`
}

type KVExtractor struct {
	// @Title zh-CN 从请求 Body 中基于 [GJSON PATH](https://github.com/tidwall/gjson/blob/master/SYNTAX.md) 语法提取字符串
	RequestBody string `required:"false" yaml:"requestBody" json:"requestBody"`
	// @Title zh-CN 从响应 Body 中基于 [GJSON PATH](https://github.com/tidwall/gjson/blob/master/SYNTAX.md) 语法提取字符串
	ResponseBody string `required:"false" yaml:"responseBody" json:"responseBody"`
}

type DashScopeRequest struct {
	Model    string                    `json:"model"`
	Messages []DashScopeRequestMessage `json:"messages"`
	//Input      Input                     `json:"input"`
	//Parameters Parameters                `json:"parameters"`
}

type DashScopeRequestMessage struct {
	Role    string `json:"role"`
	Content string `json:"content"`
}

type Parameters struct {
	//TextType     string `json:"text_type"`
	ResultFormat string `json:"result_format"`
	//Temperature  string `json:"temperature"`
}

type Usage struct {
	TotalTokens int `json:"total_tokens"`
}

func parseConfig(json gjson.Result, c *PluginConfig, log wrapper.Log) error {

	log.Infof("config:%s", json.Raw)
	// init scene
	c.SceneInfo.Category = json.Get("Scene.Category").String()
	log.Infof("SceneInfo.Category:%s", c.SceneInfo.Category)
	c.SceneInfo.Prompt = json.Get("Scene.Prompt").String()
	if c.SceneInfo.Prompt == "" {
		c.SceneInfo.Prompt = DefaultPrompt
	}
	log.Infof("SceneInfo.Prompt:%s", c.SceneInfo.Prompt)
	// init DashScope http client
	log.Infof("Start to init DashScope's http client.")
	c.DashScopeInfo.DashScopeServiceName = json.Get("DashScope.DashScopeServiceName").String()
	log.Infof("DashScopeServiceName:%s", c.DashScopeInfo.DashScopeServiceName)
	if c.DashScopeInfo.DashScopeServiceName == "" {
		return errors.New("DashScope.DashScopeServiceName must not by empty")
	}
	c.DashScopeInfo.DashScopeDomain = json.Get("DashScope.DashScopeDomain").String()
	log.Infof("DashScopeDomain:%s", c.DashScopeInfo.DashScopeDomain)
	if c.DashScopeInfo.DashScopeDomain == "" {
		return errors.New("DashScope.DashScopeDomain must not by empty")
	}
	c.DashScopeInfo.DashScopeKey = json.Get("DashScope.DashScopeKey").String()
	log.Infof("DashScopeKey:%s", c.DashScopeInfo.DashScopeKey)
	if c.DashScopeInfo.DashScopeKey == "" {
		return errors.New("DashScope.DashScopeKey must not by empty")
	}
	c.DashScopeInfo.Url = json.Get("DashScope.Url").String()
	log.Infof("c.DashScopeInfo.Url:%s", c.DashScopeInfo.Url)
	if c.DashScopeInfo.Url == "" {
		c.DashScopeInfo.Url = "/compatible-mode/v1/chat/completions"
	}
	c.DashScopeInfo.Model = json.Get("DashScope.Model").String()
	log.Infof("c.DashScopeInfo.Model:%s", c.DashScopeInfo.Model)
	if c.DashScopeInfo.Model == "" {
		c.DashScopeInfo.Model = "qwen-long"
	}
	c.DashScopeInfo.DashScopeClient = wrapper.NewClusterClient(wrapper.StaticIpCluster{
		ServiceName: c.DashScopeInfo.DashScopeServiceName,
		Port:        80,
		Host:        "127.0.0.1",
	})
	c.CacheKeyFrom.RequestBody = json.Get("cacheKeyFrom.requestBody").String()
	if c.CacheKeyFrom.RequestBody == "" {
		c.CacheKeyFrom.RequestBody = "messages.@reverse.0.content"
	}
	log.Info("Init ai intent's components successfully.")
	return nil
}

func onHttpRequestHeaders(ctx wrapper.HttpContext, config PluginConfig, log wrapper.Log) types.Action {
	log.Infof("start onHttpRequestHeaders function.")

	log.Infof("end onHttpRequestHeaders function.")
	return types.ActionContinue
}

func onHttpRequestBody(ctx wrapper.HttpContext, config PluginConfig, body []byte, log wrapper.Log) types.Action {
	log.Infof("start onHttpRequestBody function.")
	bodyJson := gjson.ParseBytes(body)
	TempKey := strings.Trim(bodyJson.Get(config.CacheKeyFrom.RequestBody).Raw, `"`)
	//原始问题
	originalQuestion, _ := zhToUnicode([]byte(TempKey))
	log.Infof("originalQuestion is:  %s", string(originalQuestion))
	//prompt拼接,替换问题和预设的场景类别
	//参数占位替换
	promptStr := fmt.Sprintf(config.SceneInfo.Prompt, string(originalQuestion), config.SceneInfo.Category)
	log.Infof("after prompt is:  %s", promptStr)
	dashscopeUrl, dashscopeRequestBody, dashscopeHeader := GenerateDashScopeRequest(&config, []string{string(promptStr)}, log)
	log.Infof("dashscopeUrl is:  %s", dashscopeUrl)
	log.Infof("dashscopeRequestBody is:  %s", string(dashscopeRequestBody))
	//调用大模型 获取意向类型
	dashscopeErr := config.DashScopeInfo.DashScopeClient.Post(
		dashscopeUrl,
		dashscopeHeader,
		dashscopeRequestBody,
		func(statusCode int, responseHeaders http.Header, responseBody []byte) {
			log.Infof("DashScopeInfo.DashScopeClient statusCode is:%s", statusCode)
			log.Infof("DashScopeInfo intent responseBody is: %s", string(responseBody))
			log.Infof("Start DashScopeInfo.DashScopeClient func")
			if statusCode == 200 {
				DashScopeResponseBody, _ := DashScopeResponseHandle(ctx, responseBody, log)
				//大模型返回的识别到的意图类型
				if nil != DashScopeResponseBody && nil != DashScopeResponseBody.Choices && len(DashScopeResponseBody.Choices) > 0 {
					category := DashScopeResponseBody.Choices[0].Message.Content
					log.Infof("DashScopeInfo intent category is: %s", category)
					if "NotFound" == category {
						log.Infof("DashScopeInfo intent NotFound")
					} else {
						// 把意图类型加入到Property中
						log.Infof("DashScopeInfo intent category set to Property")
						proErr := proxywasm.SetProperty([]string{"intent_category"}, []byte(category))
						if proErr != nil {
							log.Errorf("dashscope proxywasm SetProperty error: %s", proErr.Error())
						}
					}
				}
			}
			_ = proxywasm.ResumeHttpRequest()
			return
		}, 10000)
	if dashscopeErr != nil {
		log.Errorf("dashscope intent error: %s", dashscopeErr.Error())
		_ = proxywasm.ResumeHttpRequest()
	}
	log.Infof("end onHttpRequestHeaders function.")
	return types.ActionPause
}

func onHttpResponseHeaders(ctx wrapper.HttpContext, config PluginConfig, log wrapper.Log) types.Action {
	log.Infof("start onHttpResponseHeaders function.")

	log.Infof("end onHttpResponseHeaders function.")
	return types.ActionContinue
}

func onStreamingResponseBody(ctx wrapper.HttpContext, config PluginConfig, chunk []byte, isLastChunk bool, log wrapper.Log) []byte {
	log.Infof("start onStreamingResponseBody function.")

	log.Infof("end onStreamingResponseBody function.")
	return chunk
}

func onHttpResponseBody(ctx wrapper.HttpContext, config PluginConfig, body []byte, log wrapper.Log) types.Action {
	log.Infof("start onHttpResponseBody function.")

	log.Infof("end onHttpResponseBody function.")
	return types.ActionContinue
}

func GenerateDashScopeRequest(c *PluginConfig, texts []string, log wrapper.Log) (string, []byte, [][2]string) {
	url := c.DashScopeInfo.Url
	var userMessage DashScopeRequestMessage
	userMessage.Role = "user"
	userMessage.Content = texts[0]
	var messages []DashScopeRequestMessage
	messages = append(messages, userMessage)
	data := DashScopeRequest{
		Model:    c.DashScopeInfo.Model,
		Messages: messages,
	}
	requestBody, err := json.Marshal(data)
	if err != nil {
		log.Errorf("Marshal json error:%s, data:%s.", err, data)
		return "", nil, nil
	}

	headers := [][2]string{
		{"Authorization", "Bearer " + c.DashScopeInfo.DashScopeKey},
		{"Content-Type", "application/json"},
	}
	return url, requestBody, headers
}

func zhToUnicode(raw []byte) ([]byte, error) {
	str, err := strconv.Unquote(strings.Replace(strconv.Quote(string(raw)), `\\u`, `\u`, -1))
	if err != nil {
		return nil, err
	}
	return []byte(str), nil
}

type DashScopeResponse struct {
	Status  int                              `json:"code"`
	Id      string                           `json:"id"`
	Choices []DashScopeResponseOutputChoices `json:"choices"`
}
type DashScopeResponseOutputChoices struct {
	FinishReason string                                `json:"finish_reason"`
	Message      DashScopeResponseOutputChoicesMessage `json:"message"`
}
type DashScopeResponseOutputChoicesMessage struct {
	Role    string `json:"role"`
	Content string `json:"content"`
}

func DashScopeResponseHandle(ctx wrapper.HttpContext, responseBody []byte, log wrapper.Log) (*DashScopeResponse, error) {
	var response DashScopeResponse
	err := json.Unmarshal(responseBody, &response)
	if err != nil {
		log.Errorf("[DashScopeResponseHandle]Unmarshal json error:%s", err)
		return nil, err
	}
	return &response, nil
}
