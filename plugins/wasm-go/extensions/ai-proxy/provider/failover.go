package provider

import (
	"encoding/binary"
	"errors"
	"fmt"
	"math/rand"
	"net/http"
	"strconv"
	"strings"
	"time"

	"github.com/alibaba/higress/plugins/wasm-go/pkg/wrapper"
	"github.com/higress-group/proxy-wasm-go-sdk/proxywasm"
	"github.com/higress-group/proxy-wasm-go-sdk/proxywasm/types"
	"github.com/tidwall/gjson"
)

type failover struct {
	// @Title zh-CN 是否启用 apiToken 的 failover 机制
	enabled bool `required:"true" yaml:"enabled" json:"enabled"`
	// @Title zh-CN 触发 failover 的失败阈值
	failureThreshold int64 `required:"false" yaml:"failureThreshold" json:"failureThreshold"`
	// @Title zh-CN 健康检测的成功阈值
	successThreshold int64 `required:"false" yaml:"successThreshold" json:"successThreshold"`
	// @Title zh-CN 健康检测的间隔时间，单位毫秒
	healthCheckInterval int64 `required:"false" yaml:"healthCheckInterval" json:"healthCheckInterval"`
	// @Title zh-CN 健康检测的超时时间，单位毫秒
	healthCheckTimeout int64 `required:"false" yaml:"healthCheckTimeout" json:"healthCheckTimeout"`
	// @Title zh-CN 健康检测使用的模型
	healthCheckModel string `required:"true" yaml:"healthCheckModel" json:"healthCheckModel"`
}

type lease struct {
	vmID      string
	timestamp int64
}

var (
	healthCheckClient wrapper.HttpClient
)

const (
	ApiTokenInUse       = "apiTokenInUse"
	ApiTokenHealthCheck = "apiTokenHealthCheck"
	vmLease             = "vmLease"
	// The length of vmID generated by generateVMID is fixed to 16 bytes
	vmIDLength = 16
	// The timestamp is 8 bytes (int64)
	leaseLength                    = vmIDLength + 8
	ctxApiTokenRequestFailureCount = "apiTokenRequestFailureCount"
	ctxApiTokenRequestSuccessCount = "apiTokenRequestSuccessCount"
	ctxApiTokens                   = "apiTokens"
	ctxUnavailableApiTokens        = "unavailableApiTokens"
)

func (f *failover) FromJson(json gjson.Result) {
	f.enabled = json.Get("enabled").Bool()
	f.failureThreshold = json.Get("failureThreshold").Int()
	if f.failureThreshold == 0 {
		f.failureThreshold = 3
	}
	f.successThreshold = json.Get("successThreshold").Int()
	if f.successThreshold == 0 {
		f.successThreshold = 1
	}
	f.healthCheckInterval = json.Get("healthCheckInterval").Int()
	if f.healthCheckInterval == 0 {
		f.healthCheckInterval = 5000
	}
	f.healthCheckTimeout = json.Get("healthCheckTimeout").Int()
	if f.healthCheckTimeout == 0 {
		f.healthCheckTimeout = 5000
	}
	f.healthCheckModel = json.Get("healthCheckModel").String()
}

func (f *failover) Validate() error {
	if f.healthCheckModel == "" {
		return errors.New("missing healthCheckModel in failover config")
	}
	return nil
}

func (c *ProviderConfig) SetApiTokensFailover(log wrapper.Log) {
	// TODO: 目前需要手动加一个 cluster 指向本地的地址，健康检测需要访问该地址
	healthCheckClient = wrapper.NewClusterClient(wrapper.StaticIpCluster{
		ServiceName: "local_cluster",
		Port:        10000,
	})

	vmID := generateVMID()
	err := c.initApiTokens()
	if err != nil {
		log.Errorf("Failed to init apiTokens: %v", err)
	}

	if c.failover != nil && c.failover.enabled {
		wrapper.RegisteTickFunc(c.failover.healthCheckTimeout, func() {
			// Only the Wasm VM that successfully acquires the lease will perform health check
			if tryAcquireOrRenewLease(vmID, log) {
				log.Debugf("Successfully acquired or renewed lease: %s", vmID)
				unavailableTokens, _, err := getApiTokens(ctxUnavailableApiTokens)
				if err != nil {
					log.Errorf("Failed to get unavailable tokens: %v", err)
					return
				}
				if len(unavailableTokens) > 0 {
					for _, apiToken := range unavailableTokens {
						log.Debugf("Perform health check for unavailable apiTokens: %s", strings.Join(unavailableTokens, ", "))

						path := "/v1/chat/completions"
						headers := [][2]string{
							{"Content-Type", "application/json"},
							{"ApiToken-Health-Check", apiToken},
						}
						body := []byte(fmt.Sprintf(`{
                      "model": "%s",
                      "messages": [
                        {
                          "role": "user",
                          "content": "who are you?"
                        }
                      ]
                    }`, c.failover.healthCheckModel))
						err := healthCheckClient.Post(path, headers, body, func(statusCode int, responseHeaders http.Header, responseBody []byte) {
							if statusCode == 200 {
								c.HandleAvailableApiToken(apiToken, log)
							}
						}, uint32(c.failover.healthCheckTimeout))
						if err != nil {
							log.Errorf("Failed to perform health check request: %v", err)
						}
					}
				}
			}
		})
	}
}

func tryAcquireOrRenewLease(vmID string, log wrapper.Log) bool {
	data, cas, err := proxywasm.GetSharedData(vmLease)
	if err != nil && !errors.Is(err, types.ErrorStatusNotFound) {
		log.Errorf("Failed to get lease: %v", err)
		return false
	}

	now := time.Now().Unix()
	if data == nil {
		return setLease(vmID, now, cas, log)
	}

	leaseData := leaseFromBytes(data)
	// If vmID is itself, try to renew the lease directly
	// If the lease is expired, try to acquire the lease
	if leaseData.vmID == vmID || now-leaseData.timestamp > 60 {
		leaseData.vmID = vmID
		leaseData.timestamp = now
		return setLease(vmID, now, cas, log)
	}

	return false
}

func setLease(vmID string, timestamp int64, cas uint32, log wrapper.Log) bool {
	leaseData := lease{
		vmID:      vmID,
		timestamp: timestamp,
	}
	if err := proxywasm.SetSharedData(vmLease, leaseData.toBytes(), cas); err != nil {
		log.Errorf("Failed to set or renew lease: %v", err)
		return false
	}
	return true
}

func (l *lease) toBytes() []byte {
	b := make([]byte, leaseLength)
	copy(b[:vmIDLength], l.vmID)
	binary.LittleEndian.PutUint64(b[vmIDLength:], uint64(l.timestamp))

	return b
}

func leaseFromBytes(b []byte) *lease {
	if len(b) != leaseLength {
		return nil
	}

	return &lease{
		vmID:      string(b[:vmIDLength]),
		timestamp: int64(binary.LittleEndian.Uint64(b[vmIDLength:])),
	}
}

func generateVMID() string {
	return fmt.Sprintf("%016x", time.Now().Nanosecond())
}

// When number of request successes exceeds the threshold during health check,
// add the apiToken back to the available list and remove it from the unavailable list
func (c *ProviderConfig) HandleAvailableApiToken(apiToken string, log wrapper.Log) {
	successCount, successCountCas, err := getApiTokenRequestCount(ctxApiTokenRequestSuccessCount)
	if err != nil {
		log.Errorf("Failed to get apiToken health check success count: %v", err)
		return
	}

	successCount[apiToken]++

	if successCount[apiToken] >= c.failover.successThreshold {
		unavailableTokens, unavailableTokensCas, err := getApiTokens(ctxUnavailableApiTokens)
		if err != nil {
			log.Errorf("Failed to get unavailable apiToken: %v", err)
			return
		}
		log.Infof("apiToken %s is available now, add it back to the list", apiToken)
		c.removeApiToken(ctxUnavailableApiTokens, apiToken, unavailableTokens, unavailableTokensCas, log)

		availableTokens, availableCas, err := getApiTokens(ctxApiTokens)
		if err != nil {
			log.Errorf("Failed to get available apiToken: %v", err)
			return
		}
		c.addApiToken(ctxApiTokens, apiToken, availableTokens, availableCas, log)
		c.resetApiTokenRequestCounter(ctxApiTokenRequestSuccessCount, apiToken, successCount, successCountCas, log)
	} else {
		setApiTokenRequestCount(ctxApiTokenRequestSuccessCount, successCount, successCountCas, log)
	}
}

// When number of request failures exceeds the threshold,
// remove the apiToken from the available list and add it to the unavailable list
func (c *ProviderConfig) HandleUnavailableApiToken(apiToken string, log wrapper.Log) {
	failureCount, failureCountCas, err := getApiTokenRequestCount(ctxApiTokenRequestFailureCount)
	if err != nil {
		log.Errorf("Failed to get apiToken request failure count: %v", err)
		return
	}

	availableTokens, availableTokensCas, err := getApiTokens(ctxApiTokens)
	if err != nil {
		log.Errorf("Failed to get available apiToken: %v", err)
		return
	}
	// unavailable apiToken has been removed from the available list
	if !containsElement(availableTokens, apiToken) {
		return
	}

	failureCount[apiToken]++
	if failureCount[apiToken] >= c.failover.failureThreshold {
		log.Infof("Remove unavailable apiToken from list: %s", apiToken)
		c.removeApiToken(ctxApiTokens, apiToken, availableTokens, availableTokensCas, log)

		unavailableTokens, unavailableCas, err := getApiTokens(ctxUnavailableApiTokens)
		if err != nil {
			log.Errorf("Failed to get unavailable apiToken: %v", err)
			return
		}
		c.addApiToken(ctxUnavailableApiTokens, apiToken, unavailableTokens, unavailableCas, log)
		c.resetApiTokenRequestCounter(ctxApiTokenRequestFailureCount, apiToken, failureCount, failureCountCas, log)
	} else {
		setApiTokenRequestCount(ctxApiTokenRequestFailureCount, failureCount, failureCountCas, log)
	}
}

func (c *ProviderConfig) removeApiToken(key string, apiToken string, tokens []string, cas uint32, log wrapper.Log) {
	err := setApiTokens(key, removeElement(tokens, apiToken), cas)
	if err != nil {
		log.Errorf("Failed to remove %s from %s, err: %v", apiToken, key, err)
	}
}

func (c *ProviderConfig) resetApiTokenRequestCounter(key string, apiToken string, tokens map[string]int64, cas uint32, log wrapper.Log) {
	delete(tokens, apiToken)
	setApiTokenRequestCount(key, tokens, cas, log)
}

func (c *ProviderConfig) addApiToken(key string, apiToken string, tokens []string, cas uint32, log wrapper.Log) {
	if !containsElement(tokens, apiToken) {
		tokens = append(tokens, apiToken)
		err := setApiTokens(key, tokens, cas)
		if err != nil {
			log.Errorf("Failed to add %s to %s, err: %v", apiToken, key, err)
		}
	}
}

func getApiTokenRequestCount(key string) (map[string]int64, uint32, error) {
	data, cas, err := proxywasm.GetSharedData(key)
	if err != nil && !errors.Is(err, types.ErrorStatusNotFound) {
		return nil, 0, err
	}
	tokens := make(map[string]int64)
	if len(data) > 0 {
		pairs := strings.Split(string(data), "\n")
		for _, pair := range pairs {
			kv := strings.Split(pair, "\x00")
			if len(kv) == 2 {
				value, _ := strconv.ParseInt(kv[1], 10, 64)
				tokens[kv[0]] = value
			}
		}
	}
	return tokens, cas, nil
}

func setApiTokenRequestCount(key string, tokens map[string]int64, cas uint32, log wrapper.Log) {
	var pairs []string
	for k, v := range tokens {
		// use a special character "\x00" to separate key (token) and value (failure or success count),
		// in order to retrieve tokens from byte in getApiTokenRequestCount
		pair := fmt.Sprintf("%s\x00%d", k, v)
		pairs = append(pairs, pair)
	}
	// use a special character "\n" to separate tokens
	data := strings.Join(pairs, "\n")
	err := proxywasm.SetSharedData(key, []byte(data), cas)
	if err != nil {
		log.Errorf("Failed to update %s, err: %v", key, err)
	}
}

func getApiTokens(key string) ([]string, uint32, error) {
	data, cas, err := proxywasm.GetSharedData(key)
	if err != nil && !errors.Is(err, types.ErrorStatusNotFound) {
		return nil, 0, err
	}
	var tokens []string
	if len(data) > 0 {
		tokens = strings.Split(string(data), "\n")
	}
	return tokens, cas, nil
}

func setApiTokens(key string, tokens []string, cas uint32) error {
	// use a special character "\n" to separate tokens, in order to retrieve tokens from byte in getApiTokens
	data := strings.Join(tokens, "\n")
	return proxywasm.SetSharedData(key, []byte(data), cas)
}

func removeElement(slice []string, s string) []string {
	for i := 0; i < len(slice); i++ {
		if slice[i] == s {
			slice = append(slice[:i], slice[i+1:]...)
			i--
		}
	}
	return slice
}

func containsElement(slice []string, s string) bool {
	for _, item := range slice {
		if item == s {
			return true
		}
	}
	return false
}

func (c *ProviderConfig) initApiTokens() error {
	return setApiTokens(ctxApiTokens, c.apiTokens, 0)
}

func (c *ProviderConfig) GetGlobalRandomToken(log wrapper.Log) string {
	apiTokens, _, err := getApiTokens(ctxApiTokens)
	unavailableApiTokens, _, err := getApiTokens(ctxUnavailableApiTokens)
	log.Debugf("apiTokens: %v, unavailableApiTokens: %v", apiTokens, unavailableApiTokens)

	if err != nil {
		return ""
	}
	count := len(apiTokens)
	switch count {
	case 0:
		return ""
	case 1:
		return apiTokens[0]
	default:
		return apiTokens[rand.Intn(count)]
	}
}

func (c *ProviderConfig) IsFailoverEnabled() bool {
	return c.failover != nil && c.failover.enabled
}
