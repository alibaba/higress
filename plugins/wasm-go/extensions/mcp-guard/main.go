// File generated by hgctl. Modify as required.
// See: https://higress.io/zh-cn/docs/user/wasm-go

package main

import (
    "fmt"
    "strings"

    cfgpkg "github.com/alibaba/higress/plugins/wasm-go/extensions/mcp-guard/config"
    "github.com/alibaba/higress/plugins/wasm-go/extensions/mcp-guard/decision"

    "github.com/higress-group/wasm-go/pkg/log"
    "github.com/higress-group/wasm-go/pkg/wrapper"

    "github.com/higress-group/proxy-wasm-go-sdk/proxywasm"
    "github.com/higress-group/proxy-wasm-go-sdk/proxywasm/types"
    "github.com/tidwall/gjson"
)

const pluginName = "mcp-guard"

func main() {}

func init() {
    wrapper.SetCtx(
        pluginName,
        wrapper.ParseOverrideConfig(parseGlobalConfig, parseOverrideRuleConfig),
        wrapper.ProcessRequestHeaders(onHttpRequestHeader),
    )
}

func parseGlobalConfig(json gjson.Result, pluginConfig *cfgpkg.PluginConfig) error {
    log.Debugf("loading mcp-guard global config: %s", json.String())
    pluginConfig.FromJson(json)
    if err := pluginConfig.Validate(); err != nil { return err }
    return pluginConfig.Complete()
}

func parseOverrideRuleConfig(json gjson.Result, global cfgpkg.PluginConfig, pluginConfig *cfgpkg.PluginConfig) error {
    *pluginConfig = global
    pluginConfig.FromJson(json)
    if err := pluginConfig.Validate(); err != nil { return err }
    return pluginConfig.Complete()
}

func onHttpRequestHeader(ctx wrapper.HttpContext, pluginConfig cfgpkg.PluginConfig) types.Action {
    headers := map[string]string{}
    // Collect request headers (case-insensitive convenience map)
    if kvs, err := proxywasm.GetHttpRequestHeaders(); err == nil {
        for _, kv := range kvs {
            k := kv[0]
            v := kv[1]
            headers[strings.ToLower(k)] = v
            headers[k] = v
        }
    }

    // Determine allowed capabilities: prefer rule matched by path prefix, fallback to global AllowedCapabilities
    allowedCaps := pluginConfig.AllowedCapabilities
    reqPath := wrapper.GetRequestPath()
    if len(pluginConfig.Rules) > 0 {
        for _, r := range pluginConfig.Rules {
            if r.PathPrefix != "" && strings.HasPrefix(reqPath, r.PathPrefix) {
                allowedCaps = r.AllowedCapabilities
                break
            }
        }
    }

    res := decision.CheckAccess(decision.Config{
        AllowedCapabilities:       allowedCaps,
        SubjectPolicy:             pluginConfig.SubjectPolicy,
        RequestedCapabilityHeader: pluginConfig.RequestedCapabilityHeader,
        Shadow:                    pluginConfig.Shadow,
    }, decision.Input{Headers: headers})

    if res.Allowed {
        log.Debugf("mcp-guard allow subject=%s cap=%s eff=%v", res.Subject, res.RequestedCap, res.EffectiveAllow)
        return types.ActionContinue
    }

    // Shadow mode: log only
    if res.Shadow {
        log.Warnf("mcp-guard shadow deny subject=%s reason=%s reqCap=%s eff=%v", res.Subject, res.Reason, res.RequestedCap, res.EffectiveAllow)
        return types.ActionContinue
    }

    body := fmt.Sprintf("mcp-guard deny: reason=%s\n", res.Reason)
    _ = proxywasm.SendHttpResponse(403, [][2]string{{"Content-Type", "text/plain"}}, []byte(body), -1)
    return types.ActionPause
}
