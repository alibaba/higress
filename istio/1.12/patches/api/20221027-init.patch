diff --git a/kubernetes/customresourcedefinitions.gen.yaml b/kubernetes/customresourcedefinitions.gen.yaml
index a3c80c55..1eda08f6 100644
--- a/kubernetes/customresourcedefinitions.gen.yaml
+++ b/kubernetes/customresourcedefinitions.gen.yaml
@@ -230,6 +230,225 @@ spec:
                                   type: object
                               type: object
                           type: object
+                        healthChecks:
+                          items:
+                            oneOf:
+                            - not:
+                                anyOf:
+                                - required:
+                                  - httpHealthCheck
+                                - required:
+                                  - tcpHealthCheck
+                                - required:
+                                  - grpcHealthCheck
+                                - required:
+                                  - customHealthCheck
+                            - required:
+                              - httpHealthCheck
+                            - required:
+                              - tcpHealthCheck
+                            - required:
+                              - grpcHealthCheck
+                            - required:
+                              - customHealthCheck
+                            properties:
+                              altPort:
+                                nullable: true
+                                type: integer
+                              alwaysLogHealthCheckFailures:
+                                type: boolean
+                              customHealthCheck:
+                                description: Custom health check.
+                                properties:
+                                  name:
+                                    description: The registered name of the custom
+                                      health checker.
+                                    type: string
+                                type: object
+                              eventLogPath:
+                                description: Specifies the path to the :ref:`health
+                                  check event log <arch_overview_health_check_logging>`.
+                                type: string
+                              grpcHealthCheck:
+                                description: gRPC health check.
+                                properties:
+                                  authority:
+                                    type: string
+                                  serviceName:
+                                    type: string
+                                type: object
+                              healthyEdgeInterval:
+                                description: The default value for "healthy edge interval"
+                                  is the same as the default interval.
+                                type: string
+                              healthyThreshold:
+                                nullable: true
+                                type: integer
+                              httpHealthCheck:
+                                description: HTTP health check.
+                                properties:
+                                  expectedStatuses:
+                                    description: Specifies a list of HTTP response
+                                      statuses considered healthy.
+                                    items:
+                                      properties:
+                                        end:
+                                          format: int64
+                                          type: integer
+                                        start:
+                                          format: int64
+                                          type: integer
+                                      type: object
+                                    type: array
+                                  host:
+                                    type: string
+                                  path:
+                                    description: Specifies the HTTP path that will
+                                      be requested during health checking.
+                                    type: string
+                                  receive:
+                                    oneOf:
+                                    - not:
+                                        anyOf:
+                                        - required:
+                                          - text
+                                        - required:
+                                          - binary
+                                    - required:
+                                      - text
+                                    - required:
+                                      - binary
+                                    properties:
+                                      binary:
+                                        format: binary
+                                        type: string
+                                      text:
+                                        type: string
+                                    type: object
+                                  retriableStatuses:
+                                    items:
+                                      properties:
+                                        end:
+                                          format: int64
+                                          type: integer
+                                        start:
+                                          format: int64
+                                          type: integer
+                                      type: object
+                                    type: array
+                                  send:
+                                    oneOf:
+                                    - not:
+                                        anyOf:
+                                        - required:
+                                          - text
+                                        - required:
+                                          - binary
+                                    - required:
+                                      - text
+                                    - required:
+                                      - binary
+                                    properties:
+                                      binary:
+                                        format: binary
+                                        type: string
+                                      text:
+                                        type: string
+                                    type: object
+                                type: object
+                              initialJitter:
+                                description: An optional jitter amount in milliseconds.
+                                type: string
+                              interval:
+                                description: The interval between health checks.
+                                type: string
+                              intervalJitter:
+                                description: An optional jitter amount in milliseconds.
+                                type: string
+                              intervalJitterPercent:
+                                description: An optional jitter amount as a percentage
+                                  of interval_ms.
+                                type: integer
+                              noTrafficHealthyInterval:
+                                type: string
+                              noTrafficInterval:
+                                description: The default value for "no traffic interval"
+                                  is 60 seconds.
+                                type: string
+                              reuseConnection:
+                                nullable: true
+                                type: boolean
+                              tcpHealthCheck:
+                                description: TCP health check.
+                                properties:
+                                  receive:
+                                    items:
+                                      oneOf:
+                                      - not:
+                                          anyOf:
+                                          - required:
+                                            - text
+                                          - required:
+                                            - binary
+                                      - required:
+                                        - text
+                                      - required:
+                                        - binary
+                                      properties:
+                                        binary:
+                                          format: binary
+                                          type: string
+                                        text:
+                                          type: string
+                                      type: object
+                                    type: array
+                                  send:
+                                    description: Empty payloads imply a connect-only
+                                      health check.
+                                    oneOf:
+                                    - not:
+                                        anyOf:
+                                        - required:
+                                          - text
+                                        - required:
+                                          - binary
+                                    - required:
+                                      - text
+                                    - required:
+                                      - binary
+                                    properties:
+                                      binary:
+                                        format: binary
+                                        type: string
+                                      text:
+                                        type: string
+                                    type: object
+                                type: object
+                              timeout:
+                                description: The time to wait for a health check response.
+                                type: string
+                              tlsOptions:
+                                description: This allows overriding the cluster TLS
+                                  settings, just for health check connections.
+                                properties:
+                                  alpnProtocols:
+                                    items:
+                                      type: string
+                                    type: array
+                                type: object
+                              unhealthyEdgeInterval:
+                                description: The default value for "unhealthy edge
+                                  interval" is the same as "unhealthy interval".
+                                type: string
+                              unhealthyInterval:
+                                description: The default value for "unhealthy interval"
+                                  is the same as "interval".
+                                type: string
+                              unhealthyThreshold:
+                                nullable: true
+                                type: integer
+                            type: object
+                          type: array
                         loadBalancer:
                           description: Settings controlling the load balancer algorithms.
                           oneOf:
@@ -366,6 +585,9 @@ spec:
                               - RANDOM
                               - PASSTHROUGH
                               type: string
+                            warmupDurationSecs:
+                              description: Represents the warmup duration of Service.
+                              type: string
                           type: object
                         outlierDetection:
                           properties:
@@ -475,6 +697,227 @@ spec:
                                         type: object
                                     type: object
                                 type: object
+                              healthChecks:
+                                items:
+                                  oneOf:
+                                  - not:
+                                      anyOf:
+                                      - required:
+                                        - httpHealthCheck
+                                      - required:
+                                        - tcpHealthCheck
+                                      - required:
+                                        - grpcHealthCheck
+                                      - required:
+                                        - customHealthCheck
+                                  - required:
+                                    - httpHealthCheck
+                                  - required:
+                                    - tcpHealthCheck
+                                  - required:
+                                    - grpcHealthCheck
+                                  - required:
+                                    - customHealthCheck
+                                  properties:
+                                    altPort:
+                                      nullable: true
+                                      type: integer
+                                    alwaysLogHealthCheckFailures:
+                                      type: boolean
+                                    customHealthCheck:
+                                      description: Custom health check.
+                                      properties:
+                                        name:
+                                          description: The registered name of the
+                                            custom health checker.
+                                          type: string
+                                      type: object
+                                    eventLogPath:
+                                      description: Specifies the path to the :ref:`health
+                                        check event log <arch_overview_health_check_logging>`.
+                                      type: string
+                                    grpcHealthCheck:
+                                      description: gRPC health check.
+                                      properties:
+                                        authority:
+                                          type: string
+                                        serviceName:
+                                          type: string
+                                      type: object
+                                    healthyEdgeInterval:
+                                      description: The default value for "healthy
+                                        edge interval" is the same as the default
+                                        interval.
+                                      type: string
+                                    healthyThreshold:
+                                      nullable: true
+                                      type: integer
+                                    httpHealthCheck:
+                                      description: HTTP health check.
+                                      properties:
+                                        expectedStatuses:
+                                          description: Specifies a list of HTTP response
+                                            statuses considered healthy.
+                                          items:
+                                            properties:
+                                              end:
+                                                format: int64
+                                                type: integer
+                                              start:
+                                                format: int64
+                                                type: integer
+                                            type: object
+                                          type: array
+                                        host:
+                                          type: string
+                                        path:
+                                          description: Specifies the HTTP path that
+                                            will be requested during health checking.
+                                          type: string
+                                        receive:
+                                          oneOf:
+                                          - not:
+                                              anyOf:
+                                              - required:
+                                                - text
+                                              - required:
+                                                - binary
+                                          - required:
+                                            - text
+                                          - required:
+                                            - binary
+                                          properties:
+                                            binary:
+                                              format: binary
+                                              type: string
+                                            text:
+                                              type: string
+                                          type: object
+                                        retriableStatuses:
+                                          items:
+                                            properties:
+                                              end:
+                                                format: int64
+                                                type: integer
+                                              start:
+                                                format: int64
+                                                type: integer
+                                            type: object
+                                          type: array
+                                        send:
+                                          oneOf:
+                                          - not:
+                                              anyOf:
+                                              - required:
+                                                - text
+                                              - required:
+                                                - binary
+                                          - required:
+                                            - text
+                                          - required:
+                                            - binary
+                                          properties:
+                                            binary:
+                                              format: binary
+                                              type: string
+                                            text:
+                                              type: string
+                                          type: object
+                                      type: object
+                                    initialJitter:
+                                      description: An optional jitter amount in milliseconds.
+                                      type: string
+                                    interval:
+                                      description: The interval between health checks.
+                                      type: string
+                                    intervalJitter:
+                                      description: An optional jitter amount in milliseconds.
+                                      type: string
+                                    intervalJitterPercent:
+                                      description: An optional jitter amount as a
+                                        percentage of interval_ms.
+                                      type: integer
+                                    noTrafficHealthyInterval:
+                                      type: string
+                                    noTrafficInterval:
+                                      description: The default value for "no traffic
+                                        interval" is 60 seconds.
+                                      type: string
+                                    reuseConnection:
+                                      nullable: true
+                                      type: boolean
+                                    tcpHealthCheck:
+                                      description: TCP health check.
+                                      properties:
+                                        receive:
+                                          items:
+                                            oneOf:
+                                            - not:
+                                                anyOf:
+                                                - required:
+                                                  - text
+                                                - required:
+                                                  - binary
+                                            - required:
+                                              - text
+                                            - required:
+                                              - binary
+                                            properties:
+                                              binary:
+                                                format: binary
+                                                type: string
+                                              text:
+                                                type: string
+                                            type: object
+                                          type: array
+                                        send:
+                                          description: Empty payloads imply a connect-only
+                                            health check.
+                                          oneOf:
+                                          - not:
+                                              anyOf:
+                                              - required:
+                                                - text
+                                              - required:
+                                                - binary
+                                          - required:
+                                            - text
+                                          - required:
+                                            - binary
+                                          properties:
+                                            binary:
+                                              format: binary
+                                              type: string
+                                            text:
+                                              type: string
+                                          type: object
+                                      type: object
+                                    timeout:
+                                      description: The time to wait for a health check
+                                        response.
+                                      type: string
+                                    tlsOptions:
+                                      description: This allows overriding the cluster
+                                        TLS settings, just for health check connections.
+                                      properties:
+                                        alpnProtocols:
+                                          items:
+                                            type: string
+                                          type: array
+                                      type: object
+                                    unhealthyEdgeInterval:
+                                      description: The default value for "unhealthy
+                                        edge interval" is the same as "unhealthy interval".
+                                      type: string
+                                    unhealthyInterval:
+                                      description: The default value for "unhealthy
+                                        interval" is the same as "interval".
+                                      type: string
+                                    unhealthyThreshold:
+                                      nullable: true
+                                      type: integer
+                                  type: object
+                                type: array
                               loadBalancer:
                                 description: Settings controlling the load balancer
                                   algorithms.
@@ -613,6 +1056,10 @@ spec:
                                     - RANDOM
                                     - PASSTHROUGH
                                     type: string
+                                  warmupDurationSecs:
+                                    description: Represents the warmup duration of
+                                      Service.
+                                    type: string
                                 type: object
                               outlierDetection:
                                 properties:
@@ -794,30 +1241,249 @@ spec:
                             type: object
                         type: object
                     type: object
-                  loadBalancer:
-                    description: Settings controlling the load balancer algorithms.
-                    oneOf:
-                    - not:
-                        anyOf:
-                        - required:
-                          - simple
-                        - properties:
-                            consistentHash:
+                  healthChecks:
+                    items:
+                      oneOf:
+                      - not:
+                          anyOf:
+                          - required:
+                            - httpHealthCheck
+                          - required:
+                            - tcpHealthCheck
+                          - required:
+                            - grpcHealthCheck
+                          - required:
+                            - customHealthCheck
+                      - required:
+                        - httpHealthCheck
+                      - required:
+                        - tcpHealthCheck
+                      - required:
+                        - grpcHealthCheck
+                      - required:
+                        - customHealthCheck
+                      properties:
+                        altPort:
+                          nullable: true
+                          type: integer
+                        alwaysLogHealthCheckFailures:
+                          type: boolean
+                        customHealthCheck:
+                          description: Custom health check.
+                          properties:
+                            name:
+                              description: The registered name of the custom health
+                                checker.
+                              type: string
+                          type: object
+                        eventLogPath:
+                          description: Specifies the path to the :ref:`health check
+                            event log <arch_overview_health_check_logging>`.
+                          type: string
+                        grpcHealthCheck:
+                          description: gRPC health check.
+                          properties:
+                            authority:
+                              type: string
+                            serviceName:
+                              type: string
+                          type: object
+                        healthyEdgeInterval:
+                          description: The default value for "healthy edge interval"
+                            is the same as the default interval.
+                          type: string
+                        healthyThreshold:
+                          nullable: true
+                          type: integer
+                        httpHealthCheck:
+                          description: HTTP health check.
+                          properties:
+                            expectedStatuses:
+                              description: Specifies a list of HTTP response statuses
+                                considered healthy.
+                              items:
+                                properties:
+                                  end:
+                                    format: int64
+                                    type: integer
+                                  start:
+                                    format: int64
+                                    type: integer
+                                type: object
+                              type: array
+                            host:
+                              type: string
+                            path:
+                              description: Specifies the HTTP path that will be requested
+                                during health checking.
+                              type: string
+                            receive:
                               oneOf:
                               - not:
                                   anyOf:
                                   - required:
-                                    - httpHeaderName
+                                    - text
                                   - required:
-                                    - httpCookie
+                                    - binary
+                              - required:
+                                - text
+                              - required:
+                                - binary
+                              properties:
+                                binary:
+                                  format: binary
+                                  type: string
+                                text:
+                                  type: string
+                              type: object
+                            retriableStatuses:
+                              items:
+                                properties:
+                                  end:
+                                    format: int64
+                                    type: integer
+                                  start:
+                                    format: int64
+                                    type: integer
+                                type: object
+                              type: array
+                            send:
+                              oneOf:
+                              - not:
+                                  anyOf:
                                   - required:
-                                    - useSourceIp
+                                    - text
                                   - required:
-                                    - httpQueryParameterName
+                                    - binary
                               - required:
-                                - httpHeaderName
+                                - text
                               - required:
-                                - httpCookie
+                                - binary
+                              properties:
+                                binary:
+                                  format: binary
+                                  type: string
+                                text:
+                                  type: string
+                              type: object
+                          type: object
+                        initialJitter:
+                          description: An optional jitter amount in milliseconds.
+                          type: string
+                        interval:
+                          description: The interval between health checks.
+                          type: string
+                        intervalJitter:
+                          description: An optional jitter amount in milliseconds.
+                          type: string
+                        intervalJitterPercent:
+                          description: An optional jitter amount as a percentage of
+                            interval_ms.
+                          type: integer
+                        noTrafficHealthyInterval:
+                          type: string
+                        noTrafficInterval:
+                          description: The default value for "no traffic interval"
+                            is 60 seconds.
+                          type: string
+                        reuseConnection:
+                          nullable: true
+                          type: boolean
+                        tcpHealthCheck:
+                          description: TCP health check.
+                          properties:
+                            receive:
+                              items:
+                                oneOf:
+                                - not:
+                                    anyOf:
+                                    - required:
+                                      - text
+                                    - required:
+                                      - binary
+                                - required:
+                                  - text
+                                - required:
+                                  - binary
+                                properties:
+                                  binary:
+                                    format: binary
+                                    type: string
+                                  text:
+                                    type: string
+                                type: object
+                              type: array
+                            send:
+                              description: Empty payloads imply a connect-only health
+                                check.
+                              oneOf:
+                              - not:
+                                  anyOf:
+                                  - required:
+                                    - text
+                                  - required:
+                                    - binary
+                              - required:
+                                - text
+                              - required:
+                                - binary
+                              properties:
+                                binary:
+                                  format: binary
+                                  type: string
+                                text:
+                                  type: string
+                              type: object
+                          type: object
+                        timeout:
+                          description: The time to wait for a health check response.
+                          type: string
+                        tlsOptions:
+                          description: This allows overriding the cluster TLS settings,
+                            just for health check connections.
+                          properties:
+                            alpnProtocols:
+                              items:
+                                type: string
+                              type: array
+                          type: object
+                        unhealthyEdgeInterval:
+                          description: The default value for "unhealthy edge interval"
+                            is the same as "unhealthy interval".
+                          type: string
+                        unhealthyInterval:
+                          description: The default value for "unhealthy interval"
+                            is the same as "interval".
+                          type: string
+                        unhealthyThreshold:
+                          nullable: true
+                          type: integer
+                      type: object
+                    type: array
+                  loadBalancer:
+                    description: Settings controlling the load balancer algorithms.
+                    oneOf:
+                    - not:
+                        anyOf:
+                        - required:
+                          - simple
+                        - properties:
+                            consistentHash:
+                              oneOf:
+                              - not:
+                                  anyOf:
+                                  - required:
+                                    - httpHeaderName
+                                  - required:
+                                    - httpCookie
+                                  - required:
+                                    - useSourceIp
+                                  - required:
+                                    - httpQueryParameterName
+                              - required:
+                                - httpHeaderName
+                              - required:
+                                - httpCookie
                               - required:
                                 - useSourceIp
                               - required:
@@ -927,6 +1593,9 @@ spec:
                         - RANDOM
                         - PASSTHROUGH
                         type: string
+                      warmupDurationSecs:
+                        description: Represents the warmup duration of Service.
+                        type: string
                     type: object
                   outlierDetection:
                     properties:
@@ -1033,6 +1702,225 @@ spec:
                                   type: object
                               type: object
                           type: object
+                        healthChecks:
+                          items:
+                            oneOf:
+                            - not:
+                                anyOf:
+                                - required:
+                                  - httpHealthCheck
+                                - required:
+                                  - tcpHealthCheck
+                                - required:
+                                  - grpcHealthCheck
+                                - required:
+                                  - customHealthCheck
+                            - required:
+                              - httpHealthCheck
+                            - required:
+                              - tcpHealthCheck
+                            - required:
+                              - grpcHealthCheck
+                            - required:
+                              - customHealthCheck
+                            properties:
+                              altPort:
+                                nullable: true
+                                type: integer
+                              alwaysLogHealthCheckFailures:
+                                type: boolean
+                              customHealthCheck:
+                                description: Custom health check.
+                                properties:
+                                  name:
+                                    description: The registered name of the custom
+                                      health checker.
+                                    type: string
+                                type: object
+                              eventLogPath:
+                                description: Specifies the path to the :ref:`health
+                                  check event log <arch_overview_health_check_logging>`.
+                                type: string
+                              grpcHealthCheck:
+                                description: gRPC health check.
+                                properties:
+                                  authority:
+                                    type: string
+                                  serviceName:
+                                    type: string
+                                type: object
+                              healthyEdgeInterval:
+                                description: The default value for "healthy edge interval"
+                                  is the same as the default interval.
+                                type: string
+                              healthyThreshold:
+                                nullable: true
+                                type: integer
+                              httpHealthCheck:
+                                description: HTTP health check.
+                                properties:
+                                  expectedStatuses:
+                                    description: Specifies a list of HTTP response
+                                      statuses considered healthy.
+                                    items:
+                                      properties:
+                                        end:
+                                          format: int64
+                                          type: integer
+                                        start:
+                                          format: int64
+                                          type: integer
+                                      type: object
+                                    type: array
+                                  host:
+                                    type: string
+                                  path:
+                                    description: Specifies the HTTP path that will
+                                      be requested during health checking.
+                                    type: string
+                                  receive:
+                                    oneOf:
+                                    - not:
+                                        anyOf:
+                                        - required:
+                                          - text
+                                        - required:
+                                          - binary
+                                    - required:
+                                      - text
+                                    - required:
+                                      - binary
+                                    properties:
+                                      binary:
+                                        format: binary
+                                        type: string
+                                      text:
+                                        type: string
+                                    type: object
+                                  retriableStatuses:
+                                    items:
+                                      properties:
+                                        end:
+                                          format: int64
+                                          type: integer
+                                        start:
+                                          format: int64
+                                          type: integer
+                                      type: object
+                                    type: array
+                                  send:
+                                    oneOf:
+                                    - not:
+                                        anyOf:
+                                        - required:
+                                          - text
+                                        - required:
+                                          - binary
+                                    - required:
+                                      - text
+                                    - required:
+                                      - binary
+                                    properties:
+                                      binary:
+                                        format: binary
+                                        type: string
+                                      text:
+                                        type: string
+                                    type: object
+                                type: object
+                              initialJitter:
+                                description: An optional jitter amount in milliseconds.
+                                type: string
+                              interval:
+                                description: The interval between health checks.
+                                type: string
+                              intervalJitter:
+                                description: An optional jitter amount in milliseconds.
+                                type: string
+                              intervalJitterPercent:
+                                description: An optional jitter amount as a percentage
+                                  of interval_ms.
+                                type: integer
+                              noTrafficHealthyInterval:
+                                type: string
+                              noTrafficInterval:
+                                description: The default value for "no traffic interval"
+                                  is 60 seconds.
+                                type: string
+                              reuseConnection:
+                                nullable: true
+                                type: boolean
+                              tcpHealthCheck:
+                                description: TCP health check.
+                                properties:
+                                  receive:
+                                    items:
+                                      oneOf:
+                                      - not:
+                                          anyOf:
+                                          - required:
+                                            - text
+                                          - required:
+                                            - binary
+                                      - required:
+                                        - text
+                                      - required:
+                                        - binary
+                                      properties:
+                                        binary:
+                                          format: binary
+                                          type: string
+                                        text:
+                                          type: string
+                                      type: object
+                                    type: array
+                                  send:
+                                    description: Empty payloads imply a connect-only
+                                      health check.
+                                    oneOf:
+                                    - not:
+                                        anyOf:
+                                        - required:
+                                          - text
+                                        - required:
+                                          - binary
+                                    - required:
+                                      - text
+                                    - required:
+                                      - binary
+                                    properties:
+                                      binary:
+                                        format: binary
+                                        type: string
+                                      text:
+                                        type: string
+                                    type: object
+                                type: object
+                              timeout:
+                                description: The time to wait for a health check response.
+                                type: string
+                              tlsOptions:
+                                description: This allows overriding the cluster TLS
+                                  settings, just for health check connections.
+                                properties:
+                                  alpnProtocols:
+                                    items:
+                                      type: string
+                                    type: array
+                                type: object
+                              unhealthyEdgeInterval:
+                                description: The default value for "unhealthy edge
+                                  interval" is the same as "unhealthy interval".
+                                type: string
+                              unhealthyInterval:
+                                description: The default value for "unhealthy interval"
+                                  is the same as "interval".
+                                type: string
+                              unhealthyThreshold:
+                                nullable: true
+                                type: integer
+                            type: object
+                          type: array
                         loadBalancer:
                           description: Settings controlling the load balancer algorithms.
                           oneOf:
@@ -1169,6 +2057,9 @@ spec:
                               - RANDOM
                               - PASSTHROUGH
                               type: string
+                            warmupDurationSecs:
+                              description: Represents the warmup duration of Service.
+                              type: string
                           type: object
                         outlierDetection:
                           properties:
@@ -1397,40 +2288,259 @@ spec:
                                   type: object
                               type: object
                           type: object
-                        loadBalancer:
-                          description: Settings controlling the load balancer algorithms.
-                          oneOf:
-                          - not:
-                              anyOf:
-                              - required:
-                                - simple
-                              - properties:
-                                  consistentHash:
+                        healthChecks:
+                          items:
+                            oneOf:
+                            - not:
+                                anyOf:
+                                - required:
+                                  - httpHealthCheck
+                                - required:
+                                  - tcpHealthCheck
+                                - required:
+                                  - grpcHealthCheck
+                                - required:
+                                  - customHealthCheck
+                            - required:
+                              - httpHealthCheck
+                            - required:
+                              - tcpHealthCheck
+                            - required:
+                              - grpcHealthCheck
+                            - required:
+                              - customHealthCheck
+                            properties:
+                              altPort:
+                                nullable: true
+                                type: integer
+                              alwaysLogHealthCheckFailures:
+                                type: boolean
+                              customHealthCheck:
+                                description: Custom health check.
+                                properties:
+                                  name:
+                                    description: The registered name of the custom
+                                      health checker.
+                                    type: string
+                                type: object
+                              eventLogPath:
+                                description: Specifies the path to the :ref:`health
+                                  check event log <arch_overview_health_check_logging>`.
+                                type: string
+                              grpcHealthCheck:
+                                description: gRPC health check.
+                                properties:
+                                  authority:
+                                    type: string
+                                  serviceName:
+                                    type: string
+                                type: object
+                              healthyEdgeInterval:
+                                description: The default value for "healthy edge interval"
+                                  is the same as the default interval.
+                                type: string
+                              healthyThreshold:
+                                nullable: true
+                                type: integer
+                              httpHealthCheck:
+                                description: HTTP health check.
+                                properties:
+                                  expectedStatuses:
+                                    description: Specifies a list of HTTP response
+                                      statuses considered healthy.
+                                    items:
+                                      properties:
+                                        end:
+                                          format: int64
+                                          type: integer
+                                        start:
+                                          format: int64
+                                          type: integer
+                                      type: object
+                                    type: array
+                                  host:
+                                    type: string
+                                  path:
+                                    description: Specifies the HTTP path that will
+                                      be requested during health checking.
+                                    type: string
+                                  receive:
                                     oneOf:
                                     - not:
                                         anyOf:
                                         - required:
-                                          - httpHeaderName
-                                        - required:
-                                          - httpCookie
-                                        - required:
-                                          - useSourceIp
+                                          - text
                                         - required:
-                                          - httpQueryParameterName
+                                          - binary
                                     - required:
-                                      - httpHeaderName
+                                      - text
                                     - required:
-                                      - httpCookie
+                                      - binary
+                                    properties:
+                                      binary:
+                                        format: binary
+                                        type: string
+                                      text:
+                                        type: string
+                                    type: object
+                                  retriableStatuses:
+                                    items:
+                                      properties:
+                                        end:
+                                          format: int64
+                                          type: integer
+                                        start:
+                                          format: int64
+                                          type: integer
+                                      type: object
+                                    type: array
+                                  send:
+                                    oneOf:
+                                    - not:
+                                        anyOf:
+                                        - required:
+                                          - text
+                                        - required:
+                                          - binary
                                     - required:
-                                      - useSourceIp
+                                      - text
                                     - required:
-                                      - httpQueryParameterName
-                                required:
-                                - consistentHash
-                          - required:
-                            - simple
-                          - properties:
-                              consistentHash:
+                                      - binary
+                                    properties:
+                                      binary:
+                                        format: binary
+                                        type: string
+                                      text:
+                                        type: string
+                                    type: object
+                                type: object
+                              initialJitter:
+                                description: An optional jitter amount in milliseconds.
+                                type: string
+                              interval:
+                                description: The interval between health checks.
+                                type: string
+                              intervalJitter:
+                                description: An optional jitter amount in milliseconds.
+                                type: string
+                              intervalJitterPercent:
+                                description: An optional jitter amount as a percentage
+                                  of interval_ms.
+                                type: integer
+                              noTrafficHealthyInterval:
+                                type: string
+                              noTrafficInterval:
+                                description: The default value for "no traffic interval"
+                                  is 60 seconds.
+                                type: string
+                              reuseConnection:
+                                nullable: true
+                                type: boolean
+                              tcpHealthCheck:
+                                description: TCP health check.
+                                properties:
+                                  receive:
+                                    items:
+                                      oneOf:
+                                      - not:
+                                          anyOf:
+                                          - required:
+                                            - text
+                                          - required:
+                                            - binary
+                                      - required:
+                                        - text
+                                      - required:
+                                        - binary
+                                      properties:
+                                        binary:
+                                          format: binary
+                                          type: string
+                                        text:
+                                          type: string
+                                      type: object
+                                    type: array
+                                  send:
+                                    description: Empty payloads imply a connect-only
+                                      health check.
+                                    oneOf:
+                                    - not:
+                                        anyOf:
+                                        - required:
+                                          - text
+                                        - required:
+                                          - binary
+                                    - required:
+                                      - text
+                                    - required:
+                                      - binary
+                                    properties:
+                                      binary:
+                                        format: binary
+                                        type: string
+                                      text:
+                                        type: string
+                                    type: object
+                                type: object
+                              timeout:
+                                description: The time to wait for a health check response.
+                                type: string
+                              tlsOptions:
+                                description: This allows overriding the cluster TLS
+                                  settings, just for health check connections.
+                                properties:
+                                  alpnProtocols:
+                                    items:
+                                      type: string
+                                    type: array
+                                type: object
+                              unhealthyEdgeInterval:
+                                description: The default value for "unhealthy edge
+                                  interval" is the same as "unhealthy interval".
+                                type: string
+                              unhealthyInterval:
+                                description: The default value for "unhealthy interval"
+                                  is the same as "interval".
+                                type: string
+                              unhealthyThreshold:
+                                nullable: true
+                                type: integer
+                            type: object
+                          type: array
+                        loadBalancer:
+                          description: Settings controlling the load balancer algorithms.
+                          oneOf:
+                          - not:
+                              anyOf:
+                              - required:
+                                - simple
+                              - properties:
+                                  consistentHash:
+                                    oneOf:
+                                    - not:
+                                        anyOf:
+                                        - required:
+                                          - httpHeaderName
+                                        - required:
+                                          - httpCookie
+                                        - required:
+                                          - useSourceIp
+                                        - required:
+                                          - httpQueryParameterName
+                                    - required:
+                                      - httpHeaderName
+                                    - required:
+                                      - httpCookie
+                                    - required:
+                                      - useSourceIp
+                                    - required:
+                                      - httpQueryParameterName
+                                required:
+                                - consistentHash
+                          - required:
+                            - simple
+                          - properties:
+                              consistentHash:
                                 oneOf:
                                 - not:
                                     anyOf:
@@ -1533,6 +2643,9 @@ spec:
                               - RANDOM
                               - PASSTHROUGH
                               type: string
+                            warmupDurationSecs:
+                              description: Represents the warmup duration of Service.
+                              type: string
                           type: object
                         outlierDetection:
                           properties:
@@ -1642,6 +2755,227 @@ spec:
                                         type: object
                                     type: object
                                 type: object
+                              healthChecks:
+                                items:
+                                  oneOf:
+                                  - not:
+                                      anyOf:
+                                      - required:
+                                        - httpHealthCheck
+                                      - required:
+                                        - tcpHealthCheck
+                                      - required:
+                                        - grpcHealthCheck
+                                      - required:
+                                        - customHealthCheck
+                                  - required:
+                                    - httpHealthCheck
+                                  - required:
+                                    - tcpHealthCheck
+                                  - required:
+                                    - grpcHealthCheck
+                                  - required:
+                                    - customHealthCheck
+                                  properties:
+                                    altPort:
+                                      nullable: true
+                                      type: integer
+                                    alwaysLogHealthCheckFailures:
+                                      type: boolean
+                                    customHealthCheck:
+                                      description: Custom health check.
+                                      properties:
+                                        name:
+                                          description: The registered name of the
+                                            custom health checker.
+                                          type: string
+                                      type: object
+                                    eventLogPath:
+                                      description: Specifies the path to the :ref:`health
+                                        check event log <arch_overview_health_check_logging>`.
+                                      type: string
+                                    grpcHealthCheck:
+                                      description: gRPC health check.
+                                      properties:
+                                        authority:
+                                          type: string
+                                        serviceName:
+                                          type: string
+                                      type: object
+                                    healthyEdgeInterval:
+                                      description: The default value for "healthy
+                                        edge interval" is the same as the default
+                                        interval.
+                                      type: string
+                                    healthyThreshold:
+                                      nullable: true
+                                      type: integer
+                                    httpHealthCheck:
+                                      description: HTTP health check.
+                                      properties:
+                                        expectedStatuses:
+                                          description: Specifies a list of HTTP response
+                                            statuses considered healthy.
+                                          items:
+                                            properties:
+                                              end:
+                                                format: int64
+                                                type: integer
+                                              start:
+                                                format: int64
+                                                type: integer
+                                            type: object
+                                          type: array
+                                        host:
+                                          type: string
+                                        path:
+                                          description: Specifies the HTTP path that
+                                            will be requested during health checking.
+                                          type: string
+                                        receive:
+                                          oneOf:
+                                          - not:
+                                              anyOf:
+                                              - required:
+                                                - text
+                                              - required:
+                                                - binary
+                                          - required:
+                                            - text
+                                          - required:
+                                            - binary
+                                          properties:
+                                            binary:
+                                              format: binary
+                                              type: string
+                                            text:
+                                              type: string
+                                          type: object
+                                        retriableStatuses:
+                                          items:
+                                            properties:
+                                              end:
+                                                format: int64
+                                                type: integer
+                                              start:
+                                                format: int64
+                                                type: integer
+                                            type: object
+                                          type: array
+                                        send:
+                                          oneOf:
+                                          - not:
+                                              anyOf:
+                                              - required:
+                                                - text
+                                              - required:
+                                                - binary
+                                          - required:
+                                            - text
+                                          - required:
+                                            - binary
+                                          properties:
+                                            binary:
+                                              format: binary
+                                              type: string
+                                            text:
+                                              type: string
+                                          type: object
+                                      type: object
+                                    initialJitter:
+                                      description: An optional jitter amount in milliseconds.
+                                      type: string
+                                    interval:
+                                      description: The interval between health checks.
+                                      type: string
+                                    intervalJitter:
+                                      description: An optional jitter amount in milliseconds.
+                                      type: string
+                                    intervalJitterPercent:
+                                      description: An optional jitter amount as a
+                                        percentage of interval_ms.
+                                      type: integer
+                                    noTrafficHealthyInterval:
+                                      type: string
+                                    noTrafficInterval:
+                                      description: The default value for "no traffic
+                                        interval" is 60 seconds.
+                                      type: string
+                                    reuseConnection:
+                                      nullable: true
+                                      type: boolean
+                                    tcpHealthCheck:
+                                      description: TCP health check.
+                                      properties:
+                                        receive:
+                                          items:
+                                            oneOf:
+                                            - not:
+                                                anyOf:
+                                                - required:
+                                                  - text
+                                                - required:
+                                                  - binary
+                                            - required:
+                                              - text
+                                            - required:
+                                              - binary
+                                            properties:
+                                              binary:
+                                                format: binary
+                                                type: string
+                                              text:
+                                                type: string
+                                            type: object
+                                          type: array
+                                        send:
+                                          description: Empty payloads imply a connect-only
+                                            health check.
+                                          oneOf:
+                                          - not:
+                                              anyOf:
+                                              - required:
+                                                - text
+                                              - required:
+                                                - binary
+                                          - required:
+                                            - text
+                                          - required:
+                                            - binary
+                                          properties:
+                                            binary:
+                                              format: binary
+                                              type: string
+                                            text:
+                                              type: string
+                                          type: object
+                                      type: object
+                                    timeout:
+                                      description: The time to wait for a health check
+                                        response.
+                                      type: string
+                                    tlsOptions:
+                                      description: This allows overriding the cluster
+                                        TLS settings, just for health check connections.
+                                      properties:
+                                        alpnProtocols:
+                                          items:
+                                            type: string
+                                          type: array
+                                      type: object
+                                    unhealthyEdgeInterval:
+                                      description: The default value for "unhealthy
+                                        edge interval" is the same as "unhealthy interval".
+                                      type: string
+                                    unhealthyInterval:
+                                      description: The default value for "unhealthy
+                                        interval" is the same as "interval".
+                                      type: string
+                                    unhealthyThreshold:
+                                      nullable: true
+                                      type: integer
+                                  type: object
+                                type: array
                               loadBalancer:
                                 description: Settings controlling the load balancer
                                   algorithms.
@@ -1780,6 +3114,10 @@ spec:
                                     - RANDOM
                                     - PASSTHROUGH
                                     type: string
+                                  warmupDurationSecs:
+                                    description: Represents the warmup duration of
+                                      Service.
+                                    type: string
                                 type: object
                               outlierDetection:
                                 properties:
@@ -1961,6 +3299,225 @@ spec:
                             type: object
                         type: object
                     type: object
+                  healthChecks:
+                    items:
+                      oneOf:
+                      - not:
+                          anyOf:
+                          - required:
+                            - httpHealthCheck
+                          - required:
+                            - tcpHealthCheck
+                          - required:
+                            - grpcHealthCheck
+                          - required:
+                            - customHealthCheck
+                      - required:
+                        - httpHealthCheck
+                      - required:
+                        - tcpHealthCheck
+                      - required:
+                        - grpcHealthCheck
+                      - required:
+                        - customHealthCheck
+                      properties:
+                        altPort:
+                          nullable: true
+                          type: integer
+                        alwaysLogHealthCheckFailures:
+                          type: boolean
+                        customHealthCheck:
+                          description: Custom health check.
+                          properties:
+                            name:
+                              description: The registered name of the custom health
+                                checker.
+                              type: string
+                          type: object
+                        eventLogPath:
+                          description: Specifies the path to the :ref:`health check
+                            event log <arch_overview_health_check_logging>`.
+                          type: string
+                        grpcHealthCheck:
+                          description: gRPC health check.
+                          properties:
+                            authority:
+                              type: string
+                            serviceName:
+                              type: string
+                          type: object
+                        healthyEdgeInterval:
+                          description: The default value for "healthy edge interval"
+                            is the same as the default interval.
+                          type: string
+                        healthyThreshold:
+                          nullable: true
+                          type: integer
+                        httpHealthCheck:
+                          description: HTTP health check.
+                          properties:
+                            expectedStatuses:
+                              description: Specifies a list of HTTP response statuses
+                                considered healthy.
+                              items:
+                                properties:
+                                  end:
+                                    format: int64
+                                    type: integer
+                                  start:
+                                    format: int64
+                                    type: integer
+                                type: object
+                              type: array
+                            host:
+                              type: string
+                            path:
+                              description: Specifies the HTTP path that will be requested
+                                during health checking.
+                              type: string
+                            receive:
+                              oneOf:
+                              - not:
+                                  anyOf:
+                                  - required:
+                                    - text
+                                  - required:
+                                    - binary
+                              - required:
+                                - text
+                              - required:
+                                - binary
+                              properties:
+                                binary:
+                                  format: binary
+                                  type: string
+                                text:
+                                  type: string
+                              type: object
+                            retriableStatuses:
+                              items:
+                                properties:
+                                  end:
+                                    format: int64
+                                    type: integer
+                                  start:
+                                    format: int64
+                                    type: integer
+                                type: object
+                              type: array
+                            send:
+                              oneOf:
+                              - not:
+                                  anyOf:
+                                  - required:
+                                    - text
+                                  - required:
+                                    - binary
+                              - required:
+                                - text
+                              - required:
+                                - binary
+                              properties:
+                                binary:
+                                  format: binary
+                                  type: string
+                                text:
+                                  type: string
+                              type: object
+                          type: object
+                        initialJitter:
+                          description: An optional jitter amount in milliseconds.
+                          type: string
+                        interval:
+                          description: The interval between health checks.
+                          type: string
+                        intervalJitter:
+                          description: An optional jitter amount in milliseconds.
+                          type: string
+                        intervalJitterPercent:
+                          description: An optional jitter amount as a percentage of
+                            interval_ms.
+                          type: integer
+                        noTrafficHealthyInterval:
+                          type: string
+                        noTrafficInterval:
+                          description: The default value for "no traffic interval"
+                            is 60 seconds.
+                          type: string
+                        reuseConnection:
+                          nullable: true
+                          type: boolean
+                        tcpHealthCheck:
+                          description: TCP health check.
+                          properties:
+                            receive:
+                              items:
+                                oneOf:
+                                - not:
+                                    anyOf:
+                                    - required:
+                                      - text
+                                    - required:
+                                      - binary
+                                - required:
+                                  - text
+                                - required:
+                                  - binary
+                                properties:
+                                  binary:
+                                    format: binary
+                                    type: string
+                                  text:
+                                    type: string
+                                type: object
+                              type: array
+                            send:
+                              description: Empty payloads imply a connect-only health
+                                check.
+                              oneOf:
+                              - not:
+                                  anyOf:
+                                  - required:
+                                    - text
+                                  - required:
+                                    - binary
+                              - required:
+                                - text
+                              - required:
+                                - binary
+                              properties:
+                                binary:
+                                  format: binary
+                                  type: string
+                                text:
+                                  type: string
+                              type: object
+                          type: object
+                        timeout:
+                          description: The time to wait for a health check response.
+                          type: string
+                        tlsOptions:
+                          description: This allows overriding the cluster TLS settings,
+                            just for health check connections.
+                          properties:
+                            alpnProtocols:
+                              items:
+                                type: string
+                              type: array
+                          type: object
+                        unhealthyEdgeInterval:
+                          description: The default value for "unhealthy edge interval"
+                            is the same as "unhealthy interval".
+                          type: string
+                        unhealthyInterval:
+                          description: The default value for "unhealthy interval"
+                            is the same as "interval".
+                          type: string
+                        unhealthyThreshold:
+                          nullable: true
+                          type: integer
+                      type: object
+                    type: array
                   loadBalancer:
                     description: Settings controlling the load balancer algorithms.
                     oneOf:
@@ -2094,6 +3651,9 @@ spec:
                         - RANDOM
                         - PASSTHROUGH
                         type: string
+                      warmupDurationSecs:
+                        description: Represents the warmup duration of Service.
+                        type: string
                     type: object
                   outlierDetection:
                     properties:
@@ -2197,9 +3757,228 @@ spec:
                                       type: integer
                                     time:
                                       type: string
-                                  type: object
-                              type: object
-                          type: object
+                                  type: object
+                              type: object
+                          type: object
+                        healthChecks:
+                          items:
+                            oneOf:
+                            - not:
+                                anyOf:
+                                - required:
+                                  - httpHealthCheck
+                                - required:
+                                  - tcpHealthCheck
+                                - required:
+                                  - grpcHealthCheck
+                                - required:
+                                  - customHealthCheck
+                            - required:
+                              - httpHealthCheck
+                            - required:
+                              - tcpHealthCheck
+                            - required:
+                              - grpcHealthCheck
+                            - required:
+                              - customHealthCheck
+                            properties:
+                              altPort:
+                                nullable: true
+                                type: integer
+                              alwaysLogHealthCheckFailures:
+                                type: boolean
+                              customHealthCheck:
+                                description: Custom health check.
+                                properties:
+                                  name:
+                                    description: The registered name of the custom
+                                      health checker.
+                                    type: string
+                                type: object
+                              eventLogPath:
+                                description: Specifies the path to the :ref:`health
+                                  check event log <arch_overview_health_check_logging>`.
+                                type: string
+                              grpcHealthCheck:
+                                description: gRPC health check.
+                                properties:
+                                  authority:
+                                    type: string
+                                  serviceName:
+                                    type: string
+                                type: object
+                              healthyEdgeInterval:
+                                description: The default value for "healthy edge interval"
+                                  is the same as the default interval.
+                                type: string
+                              healthyThreshold:
+                                nullable: true
+                                type: integer
+                              httpHealthCheck:
+                                description: HTTP health check.
+                                properties:
+                                  expectedStatuses:
+                                    description: Specifies a list of HTTP response
+                                      statuses considered healthy.
+                                    items:
+                                      properties:
+                                        end:
+                                          format: int64
+                                          type: integer
+                                        start:
+                                          format: int64
+                                          type: integer
+                                      type: object
+                                    type: array
+                                  host:
+                                    type: string
+                                  path:
+                                    description: Specifies the HTTP path that will
+                                      be requested during health checking.
+                                    type: string
+                                  receive:
+                                    oneOf:
+                                    - not:
+                                        anyOf:
+                                        - required:
+                                          - text
+                                        - required:
+                                          - binary
+                                    - required:
+                                      - text
+                                    - required:
+                                      - binary
+                                    properties:
+                                      binary:
+                                        format: binary
+                                        type: string
+                                      text:
+                                        type: string
+                                    type: object
+                                  retriableStatuses:
+                                    items:
+                                      properties:
+                                        end:
+                                          format: int64
+                                          type: integer
+                                        start:
+                                          format: int64
+                                          type: integer
+                                      type: object
+                                    type: array
+                                  send:
+                                    oneOf:
+                                    - not:
+                                        anyOf:
+                                        - required:
+                                          - text
+                                        - required:
+                                          - binary
+                                    - required:
+                                      - text
+                                    - required:
+                                      - binary
+                                    properties:
+                                      binary:
+                                        format: binary
+                                        type: string
+                                      text:
+                                        type: string
+                                    type: object
+                                type: object
+                              initialJitter:
+                                description: An optional jitter amount in milliseconds.
+                                type: string
+                              interval:
+                                description: The interval between health checks.
+                                type: string
+                              intervalJitter:
+                                description: An optional jitter amount in milliseconds.
+                                type: string
+                              intervalJitterPercent:
+                                description: An optional jitter amount as a percentage
+                                  of interval_ms.
+                                type: integer
+                              noTrafficHealthyInterval:
+                                type: string
+                              noTrafficInterval:
+                                description: The default value for "no traffic interval"
+                                  is 60 seconds.
+                                type: string
+                              reuseConnection:
+                                nullable: true
+                                type: boolean
+                              tcpHealthCheck:
+                                description: TCP health check.
+                                properties:
+                                  receive:
+                                    items:
+                                      oneOf:
+                                      - not:
+                                          anyOf:
+                                          - required:
+                                            - text
+                                          - required:
+                                            - binary
+                                      - required:
+                                        - text
+                                      - required:
+                                        - binary
+                                      properties:
+                                        binary:
+                                          format: binary
+                                          type: string
+                                        text:
+                                          type: string
+                                      type: object
+                                    type: array
+                                  send:
+                                    description: Empty payloads imply a connect-only
+                                      health check.
+                                    oneOf:
+                                    - not:
+                                        anyOf:
+                                        - required:
+                                          - text
+                                        - required:
+                                          - binary
+                                    - required:
+                                      - text
+                                    - required:
+                                      - binary
+                                    properties:
+                                      binary:
+                                        format: binary
+                                        type: string
+                                      text:
+                                        type: string
+                                    type: object
+                                type: object
+                              timeout:
+                                description: The time to wait for a health check response.
+                                type: string
+                              tlsOptions:
+                                description: This allows overriding the cluster TLS
+                                  settings, just for health check connections.
+                                properties:
+                                  alpnProtocols:
+                                    items:
+                                      type: string
+                                    type: array
+                                type: object
+                              unhealthyEdgeInterval:
+                                description: The default value for "unhealthy edge
+                                  interval" is the same as "unhealthy interval".
+                                type: string
+                              unhealthyInterval:
+                                description: The default value for "unhealthy interval"
+                                  is the same as "interval".
+                                type: string
+                              unhealthyThreshold:
+                                nullable: true
+                                type: integer
+                            type: object
+                          type: array
                         loadBalancer:
                           description: Settings controlling the load balancer algorithms.
                           oneOf:
@@ -2336,6 +4115,9 @@ spec:
                               - RANDOM
                               - PASSTHROUGH
                               type: string
+                            warmupDurationSecs:
+                              description: Represents the warmup duration of Service.
+                              type: string
                           type: object
                         outlierDetection:
                           properties:
@@ -3229,6 +5011,139 @@ spec:
     subresources:
       status: {}
 
+---
+apiVersion: apiextensions.k8s.io/v1
+kind: CustomResourceDefinition
+metadata:
+  annotations:
+    "helm.sh/resource-policy": keep
+  labels:
+    app: istio-pilot
+    chart: istio
+    heritage: Tiller
+    release: istio
+  name: servicesubscriptionlists.networking.istio.io
+spec:
+  group: networking.istio.io
+  names:
+    categories:
+    - istio-io
+    - networking-istio-io
+    kind: ServiceSubscriptionList
+    listKind: ServiceSubscriptionListList
+    plural: servicesubscriptionlists
+    singular: servicesubscriptionlist
+  scope: Namespaced
+  versions:
+  - name: v1alpha3
+    schema:
+      openAPIV3Schema:
+        properties:
+          spec:
+            properties:
+              resolution:
+                enum:
+                - CONFIGSERVER
+                - VIPSERVER
+                - NACOS
+                type: string
+              subscriptions:
+                items:
+                  properties:
+                    group:
+                      type: string
+                    hostname:
+                      type: string
+                    labels:
+                      additionalProperties:
+                        type: string
+                      type: object
+                    port:
+                      properties:
+                        name:
+                          description: Label assigned to the port.
+                          type: string
+                        number:
+                          description: A valid non-negative integer port number.
+                          type: integer
+                        protocol:
+                          description: The protocol exposed on the port.
+                          type: string
+                        targetPort:
+                          type: integer
+                      type: object
+                    units:
+                      items:
+                        type: string
+                      type: array
+                    version:
+                      type: string
+                  type: object
+                type: array
+            type: object
+          status:
+            type: object
+            x-kubernetes-preserve-unknown-fields: true
+        type: object
+    served: true
+    storage: true
+    subresources:
+      status: {}
+  - name: v1beta1
+    schema:
+      openAPIV3Schema:
+        properties:
+          spec:
+            properties:
+              resolution:
+                enum:
+                - CONFIGSERVER
+                - VIPSERVER
+                - NACOS
+                type: string
+              subscriptions:
+                items:
+                  properties:
+                    group:
+                      type: string
+                    hostname:
+                      type: string
+                    labels:
+                      additionalProperties:
+                        type: string
+                      type: object
+                    port:
+                      properties:
+                        name:
+                          description: Label assigned to the port.
+                          type: string
+                        number:
+                          description: A valid non-negative integer port number.
+                          type: integer
+                        protocol:
+                          description: The protocol exposed on the port.
+                          type: string
+                        targetPort:
+                          type: integer
+                      type: object
+                    units:
+                      items:
+                        type: string
+                      type: array
+                    version:
+                      type: string
+                  type: object
+                type: array
+            type: object
+          status:
+            type: object
+            x-kubernetes-preserve-unknown-fields: true
+        type: object
+    served: true
+    storage: false
+    subresources:
+      status: {}
+
 ---
 apiVersion: apiextensions.k8s.io/v1
 kind: CustomResourceDefinition
@@ -3541,6 +5456,57 @@ spec:
                 items:
                   type: string
                 type: array
+              hostHTTPFilters:
+                description: HTTP Filters for host scope.
+                items:
+                  oneOf:
+                  - not:
+                      anyOf:
+                      - required:
+                        - ipAccessControl
+                      - required:
+                        - localRateLimit
+                  - required:
+                    - ipAccessControl
+                  - required:
+                    - localRateLimit
+                  properties:
+                    disable:
+                      description: Disable this filter and all request will pass.
+                      type: boolean
+                    ipAccessControl:
+                      properties:
+                        notRemoteIpBlocks:
+                          items:
+                            type: string
+                          type: array
+                        remoteIpBlocks:
+                          items:
+                            type: string
+                          type: array
+                      type: object
+                    localRateLimit:
+                      properties:
+                        perDownstreamConnection:
+                          type: boolean
+                        statusCode:
+                          description: Default rate limit status code is 429.
+                          type: integer
+                        tokenBucket:
+                          properties:
+                            fillInterval:
+                              type: string
+                            maxTokens:
+                              type: integer
+                            tokensPefFill:
+                              type: integer
+                          type: object
+                      type: object
+                    name:
+                      description: The http filter name should be meaningful.
+                      type: string
+                  type: object
+                type: array
               hosts:
                 description: The destination hosts to which traffic is being sent.
                 items:
@@ -3617,6 +5583,14 @@ spec:
                             delegate VirtualService resides.
                           type: string
                       type: object
+                    directResponse:
+                      properties:
+                        body:
+                          type: string
+                        responseCode:
+                          description: Response code for downstream client.
+                          type: integer
+                      type: object
                     fault:
                       description: Fault injection policy to apply on HTTP traffic
                         at the client side.
@@ -3723,6 +5697,162 @@ spec:
                               type: object
                           type: object
                       type: object
+                    internalActiveRedirect:
+                      oneOf:
+                      - not:
+                          anyOf:
+                          - required:
+                            - redirectUrl
+                          - required:
+                            - redirectUrlRewriteRegex
+                      - required:
+                        - redirectUrl
+                      - required:
+                        - redirectUrlRewriteRegex
+                      properties:
+                        allowCrossScheme:
+                          type: boolean
+                        authority:
+                          description: During internal redirect, rewrite the Authority/Host
+                            header with this value.
+                          type: string
+                        forcedAddHeaderBeforeRouteMatcher:
+                          type: boolean
+                        forcedUseOriginalHost:
+                          description: If true, the host name in the downstream request
+                            is used for redirection.
+                          type: boolean
+                        headers:
+                          description: Currently, only support for the add operation
+                            for request header.
+                          properties:
+                            request:
+                              properties:
+                                add:
+                                  additionalProperties:
+                                    type: string
+                                  type: object
+                                remove:
+                                  items:
+                                    type: string
+                                  type: array
+                                set:
+                                  additionalProperties:
+                                    type: string
+                                  type: object
+                              type: object
+                            response:
+                              properties:
+                                add:
+                                  additionalProperties:
+                                    type: string
+                                  type: object
+                                remove:
+                                  items:
+                                    type: string
+                                  type: array
+                                set:
+                                  additionalProperties:
+                                    type: string
+                                  type: object
+                              type: object
+                          type: object
+                        maxInternalRedirects:
+                          type: integer
+                        policies:
+                          items:
+                            oneOf:
+                            - not:
+                                anyOf:
+                                - required:
+                                  - redirectUrl
+                                - required:
+                                  - redirectUrlRewriteRegex
+                            - required:
+                              - redirectUrl
+                            - required:
+                              - redirectUrlRewriteRegex
+                            properties:
+                              allowCrossScheme:
+                                type: boolean
+                              authority:
+                                description: During internal redirect, rewrite the
+                                  Authority/Host header with this value.
+                                type: string
+                              forcedAddHeaderBeforeRouteMatcher:
+                                type: boolean
+                              forcedUseOriginalHost:
+                                description: If true, the host name in the downstream
+                                  request is used for redirection.
+                                type: boolean
+                              headers:
+                                description: Currently, only support for the add operation
+                                  for request header.
+                                properties:
+                                  request:
+                                    properties:
+                                      add:
+                                        additionalProperties:
+                                          type: string
+                                        type: object
+                                      remove:
+                                        items:
+                                          type: string
+                                        type: array
+                                      set:
+                                        additionalProperties:
+                                          type: string
+                                        type: object
+                                    type: object
+                                  response:
+                                    properties:
+                                      add:
+                                        additionalProperties:
+                                          type: string
+                                        type: object
+                                      remove:
+                                        items:
+                                          type: string
+                                        type: array
+                                      set:
+                                        additionalProperties:
+                                          type: string
+                                        type: object
+                                    type: object
+                                type: object
+                              maxInternalRedirects:
+                                type: integer
+                              redirectResponseCodes:
+                                items:
+                                  type: integer
+                                type: array
+                              redirectUrl:
+                                type: string
+                              redirectUrlRewriteRegex:
+                                properties:
+                                  pattern:
+                                    description: RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
+                                    type: string
+                                  substitution:
+                                    type: string
+                                type: object
+                            type: object
+                          type: array
+                        redirectResponseCodes:
+                          items:
+                            type: integer
+                          type: array
+                        redirectUrl:
+                          type: string
+                        redirectUrlRewriteRegex:
+                          properties:
+                            pattern:
+                              description: RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
+                              type: string
+                            substitution:
+                              type: string
+                          type: object
+                      type: object
                     match:
                       items:
                         properties:
@@ -4040,6 +6170,14 @@ spec:
                           type: string
                         uri:
                           type: string
+                        uriRegex:
+                          properties:
+                            pattern:
+                              description: RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
+                              type: string
+                            substitution:
+                              type: string
+                          type: object
                       type: object
                     route:
                       description: A HTTP rule can either redirect or forward (default)
@@ -4063,6 +6201,25 @@ spec:
                                 description: The name of a subset within the service.
                                 type: string
                             type: object
+                          fallbackClusters:
+                            items:
+                              properties:
+                                host:
+                                  description: The name of a service from the service
+                                    registry.
+                                  type: string
+                                port:
+                                  description: Specifies the port on the host that
+                                    is being addressed.
+                                  properties:
+                                    number:
+                                      type: integer
+                                  type: object
+                                subset:
+                                  description: The name of a subset within the service.
+                                  type: string
+                              type: object
+                            type: array
                           headers:
                             properties:
                               request:
@@ -4101,6 +6258,58 @@ spec:
                             type: integer
                         type: object
                       type: array
+                    routeHTTPFilters:
+                      description: HTTP Filters for route scope.
+                      items:
+                        oneOf:
+                        - not:
+                            anyOf:
+                            - required:
+                              - ipAccessControl
+                            - required:
+                              - localRateLimit
+                        - required:
+                          - ipAccessControl
+                        - required:
+                          - localRateLimit
+                        properties:
+                          disable:
+                            description: Disable this filter and all request will
+                              pass.
+                            type: boolean
+                          ipAccessControl:
+                            properties:
+                              notRemoteIpBlocks:
+                                items:
+                                  type: string
+                                type: array
+                              remoteIpBlocks:
+                                items:
+                                  type: string
+                                type: array
+                            type: object
+                          localRateLimit:
+                            properties:
+                              perDownstreamConnection:
+                                type: boolean
+                              statusCode:
+                                description: Default rate limit status code is 429.
+                                type: integer
+                              tokenBucket:
+                                properties:
+                                  fillInterval:
+                                    type: string
+                                  maxTokens:
+                                    type: integer
+                                  tokensPefFill:
+                                    type: integer
+                                type: object
+                            type: object
+                          name:
+                            description: The http filter name should be meaningful.
+                            type: string
+                        type: object
+                      type: array
                     timeout:
                       description: Timeout for HTTP requests, default is disabled.
                       type: string
@@ -4284,6 +6493,57 @@ spec:
                 items:
                   type: string
                 type: array
+              hostHTTPFilters:
+                description: HTTP Filters for host scope.
+                items:
+                  oneOf:
+                  - not:
+                      anyOf:
+                      - required:
+                        - ipAccessControl
+                      - required:
+                        - localRateLimit
+                  - required:
+                    - ipAccessControl
+                  - required:
+                    - localRateLimit
+                  properties:
+                    disable:
+                      description: Disable this filter and all request will pass.
+                      type: boolean
+                    ipAccessControl:
+                      properties:
+                        notRemoteIpBlocks:
+                          items:
+                            type: string
+                          type: array
+                        remoteIpBlocks:
+                          items:
+                            type: string
+                          type: array
+                      type: object
+                    localRateLimit:
+                      properties:
+                        perDownstreamConnection:
+                          type: boolean
+                        statusCode:
+                          description: Default rate limit status code is 429.
+                          type: integer
+                        tokenBucket:
+                          properties:
+                            fillInterval:
+                              type: string
+                            maxTokens:
+                              type: integer
+                            tokensPefFill:
+                              type: integer
+                          type: object
+                      type: object
+                    name:
+                      description: The http filter name should be meaningful.
+                      type: string
+                  type: object
+                type: array
               hosts:
                 description: The destination hosts to which traffic is being sent.
                 items:
@@ -4360,6 +6620,14 @@ spec:
                             delegate VirtualService resides.
                           type: string
                       type: object
+                    directResponse:
+                      properties:
+                        body:
+                          type: string
+                        responseCode:
+                          description: Response code for downstream client.
+                          type: integer
+                      type: object
                     fault:
                       description: Fault injection policy to apply on HTTP traffic
                         at the client side.
@@ -4466,6 +6734,162 @@ spec:
                               type: object
                           type: object
                       type: object
+                    internalActiveRedirect:
+                      oneOf:
+                      - not:
+                          anyOf:
+                          - required:
+                            - redirectUrl
+                          - required:
+                            - redirectUrlRewriteRegex
+                      - required:
+                        - redirectUrl
+                      - required:
+                        - redirectUrlRewriteRegex
+                      properties:
+                        allowCrossScheme:
+                          type: boolean
+                        authority:
+                          description: During internal redirect, rewrite the Authority/Host
+                            header with this value.
+                          type: string
+                        forcedAddHeaderBeforeRouteMatcher:
+                          type: boolean
+                        forcedUseOriginalHost:
+                          description: If true, the host name in the downstream request
+                            is used for redirection.
+                          type: boolean
+                        headers:
+                          description: Currently, only support for the add operation
+                            for request header.
+                          properties:
+                            request:
+                              properties:
+                                add:
+                                  additionalProperties:
+                                    type: string
+                                  type: object
+                                remove:
+                                  items:
+                                    type: string
+                                  type: array
+                                set:
+                                  additionalProperties:
+                                    type: string
+                                  type: object
+                              type: object
+                            response:
+                              properties:
+                                add:
+                                  additionalProperties:
+                                    type: string
+                                  type: object
+                                remove:
+                                  items:
+                                    type: string
+                                  type: array
+                                set:
+                                  additionalProperties:
+                                    type: string
+                                  type: object
+                              type: object
+                          type: object
+                        maxInternalRedirects:
+                          type: integer
+                        policies:
+                          items:
+                            oneOf:
+                            - not:
+                                anyOf:
+                                - required:
+                                  - redirectUrl
+                                - required:
+                                  - redirectUrlRewriteRegex
+                            - required:
+                              - redirectUrl
+                            - required:
+                              - redirectUrlRewriteRegex
+                            properties:
+                              allowCrossScheme:
+                                type: boolean
+                              authority:
+                                description: During internal redirect, rewrite the
+                                  Authority/Host header with this value.
+                                type: string
+                              forcedAddHeaderBeforeRouteMatcher:
+                                type: boolean
+                              forcedUseOriginalHost:
+                                description: If true, the host name in the downstream
+                                  request is used for redirection.
+                                type: boolean
+                              headers:
+                                description: Currently, only support for the add operation
+                                  for request header.
+                                properties:
+                                  request:
+                                    properties:
+                                      add:
+                                        additionalProperties:
+                                          type: string
+                                        type: object
+                                      remove:
+                                        items:
+                                          type: string
+                                        type: array
+                                      set:
+                                        additionalProperties:
+                                          type: string
+                                        type: object
+                                    type: object
+                                  response:
+                                    properties:
+                                      add:
+                                        additionalProperties:
+                                          type: string
+                                        type: object
+                                      remove:
+                                        items:
+                                          type: string
+                                        type: array
+                                      set:
+                                        additionalProperties:
+                                          type: string
+                                        type: object
+                                    type: object
+                                type: object
+                              maxInternalRedirects:
+                                type: integer
+                              redirectResponseCodes:
+                                items:
+                                  type: integer
+                                type: array
+                              redirectUrl:
+                                type: string
+                              redirectUrlRewriteRegex:
+                                properties:
+                                  pattern:
+                                    description: RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
+                                    type: string
+                                  substitution:
+                                    type: string
+                                type: object
+                            type: object
+                          type: array
+                        redirectResponseCodes:
+                          items:
+                            type: integer
+                          type: array
+                        redirectUrl:
+                          type: string
+                        redirectUrlRewriteRegex:
+                          properties:
+                            pattern:
+                              description: RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
+                              type: string
+                            substitution:
+                              type: string
+                          type: object
+                      type: object
                     match:
                       items:
                         properties:
@@ -4783,6 +7207,14 @@ spec:
                           type: string
                         uri:
                           type: string
+                        uriRegex:
+                          properties:
+                            pattern:
+                              description: RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
+                              type: string
+                            substitution:
+                              type: string
+                          type: object
                       type: object
                     route:
                       description: A HTTP rule can either redirect or forward (default)
@@ -4806,6 +7238,25 @@ spec:
                                 description: The name of a subset within the service.
                                 type: string
                             type: object
+                          fallbackClusters:
+                            items:
+                              properties:
+                                host:
+                                  description: The name of a service from the service
+                                    registry.
+                                  type: string
+                                port:
+                                  description: Specifies the port on the host that
+                                    is being addressed.
+                                  properties:
+                                    number:
+                                      type: integer
+                                  type: object
+                                subset:
+                                  description: The name of a subset within the service.
+                                  type: string
+                              type: object
+                            type: array
                           headers:
                             properties:
                               request:
@@ -4844,6 +7295,58 @@ spec:
                             type: integer
                         type: object
                       type: array
+                    routeHTTPFilters:
+                      description: HTTP Filters for route scope.
+                      items:
+                        oneOf:
+                        - not:
+                            anyOf:
+                            - required:
+                              - ipAccessControl
+                            - required:
+                              - localRateLimit
+                        - required:
+                          - ipAccessControl
+                        - required:
+                          - localRateLimit
+                        properties:
+                          disable:
+                            description: Disable this filter and all request will
+                              pass.
+                            type: boolean
+                          ipAccessControl:
+                            properties:
+                              notRemoteIpBlocks:
+                                items:
+                                  type: string
+                                type: array
+                              remoteIpBlocks:
+                                items:
+                                  type: string
+                                type: array
+                            type: object
+                          localRateLimit:
+                            properties:
+                              perDownstreamConnection:
+                                type: boolean
+                              statusCode:
+                                description: Default rate limit status code is 429.
+                                type: integer
+                              tokenBucket:
+                                properties:
+                                  fillInterval:
+                                    type: string
+                                  maxTokens:
+                                    type: integer
+                                  tokensPefFill:
+                                    type: integer
+                                type: object
+                            type: object
+                          name:
+                            description: The http filter name should be meaningful.
+                            type: string
+                        type: object
+                      type: array
                     timeout:
                       description: Timeout for HTTP requests, default is disabled.
                       type: string
@@ -5424,6 +7927,60 @@ spec:
                           operation:
                             description: Operation specifies the operation of a request.
                             properties:
+                              extensionNotPaths:
+                                items:
+                                  oneOf:
+                                  - not:
+                                      anyOf:
+                                      - required:
+                                        - exact
+                                      - required:
+                                        - prefix
+                                      - required:
+                                        - regex
+                                  - required:
+                                    - exact
+                                  - required:
+                                    - prefix
+                                  - required:
+                                    - regex
+                                  properties:
+                                    exact:
+                                      type: string
+                                    prefix:
+                                      type: string
+                                    regex:
+                                      description: RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
+                                      type: string
+                                  type: object
+                                type: array
+                              extensionPaths:
+                                items:
+                                  oneOf:
+                                  - not:
+                                      anyOf:
+                                      - required:
+                                        - exact
+                                      - required:
+                                        - prefix
+                                      - required:
+                                        - regex
+                                  - required:
+                                    - exact
+                                  - required:
+                                    - prefix
+                                  - required:
+                                    - regex
+                                  properties:
+                                    exact:
+                                      type: string
+                                    prefix:
+                                      type: string
+                                    regex:
+                                      description: RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
+                                      type: string
+                                  type: object
+                                type: array
                               hosts:
                                 description: Optional.
                                 items:
diff --git a/mesh/v1alpha1/config.pb.go b/mesh/v1alpha1/config.pb.go
index d9ab0e5b..923d300b 100644
--- a/mesh/v1alpha1/config.pb.go
+++ b/mesh/v1alpha1/config.pb.go
@@ -590,10 +590,12 @@ type MeshConfig struct {
 	// API.
 	// All settings in the retry policy except `perTryTimeout` can currently be
 	// configured globally via this field.
-	DefaultHttpRetryPolicy *v1alpha3.HTTPRetry `protobuf:"bytes,62,opt,name=default_http_retry_policy,json=defaultHttpRetryPolicy,proto3" json:"defaultHttpRetryPolicy,omitempty"`
-	XXX_NoUnkeyedLiteral   struct{}            `json:"-"`
-	XXX_unrecognized       []byte              `json:"-"`
-	XXX_sizecache          int32               `json:"-"`
+	DefaultHttpRetryPolicy *v1alpha3.HTTPRetry                  `protobuf:"bytes,62,opt,name=default_http_retry_policy,json=defaultHttpRetryPolicy,proto3" json:"defaultHttpRetryPolicy,omitempty"`
+	CryptombConfig         *MeshConfig_CryptombPrivateKeyConfig `protobuf:"bytes,1001,opt,name=cryptomb_config,json=cryptombConfig,proto3" json:"cryptombConfig,omitempty"`
+	MseIngressGlobalConfig *MSEIngressGlobalConfig              `protobuf:"bytes,1002,opt,name=mse_ingress_global_config,json=mseIngressGlobalConfig,proto3" json:"mseIngressGlobalConfig,omitempty"`
+	XXX_NoUnkeyedLiteral   struct{}                             `json:"-"`
+	XXX_unrecognized       []byte                               `json:"-"`
+	XXX_sizecache          int32                                `json:"-"`
 }
 
 func (m *MeshConfig) Reset()         { *m = MeshConfig{} }
@@ -924,6 +926,20 @@ func (m *MeshConfig) GetDefaultHttpRetryPolicy() *v1alpha3.HTTPRetry {
 	return nil
 }
 
+func (m *MeshConfig) GetCryptombConfig() *MeshConfig_CryptombPrivateKeyConfig {
+	if m != nil {
+		return m.CryptombConfig
+	}
+	return nil
+}
+
+func (m *MeshConfig) GetMseIngressGlobalConfig() *MSEIngressGlobalConfig {
+	if m != nil {
+		return m.MseIngressGlobalConfig
+	}
+	return nil
+}
+
 type MeshConfig_OutboundTrafficPolicy struct {
 	Mode                 MeshConfig_OutboundTrafficPolicy_Mode `protobuf:"varint,1,opt,name=mode,proto3,enum=istio.mesh.v1alpha1.MeshConfig_OutboundTrafficPolicy_Mode" json:"mode,omitempty"`
 	XXX_NoUnkeyedLiteral struct{}                              `json:"-"`
@@ -2673,6 +2689,61 @@ func (m *MeshConfig_ProxyPathNormalization) GetNormalization() MeshConfig_ProxyP
 	return MeshConfig_ProxyPathNormalization_DEFAULT
 }
 
+type MeshConfig_CryptombPrivateKeyConfig struct {
+	EnableCryptomb       bool            `protobuf:"varint,1,opt,name=enable_cryptomb,json=enableCryptomb,proto3" json:"enableCryptomb,omitempty"`
+	PoolDelay            *types.Duration `protobuf:"bytes,2,opt,name=pool_delay,json=poolDelay,proto3" json:"poolDelay,omitempty"`
+	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
+	XXX_unrecognized     []byte          `json:"-"`
+	XXX_sizecache        int32           `json:"-"`
+}
+
+func (m *MeshConfig_CryptombPrivateKeyConfig) Reset()         { *m = MeshConfig_CryptombPrivateKeyConfig{} }
+func (m *MeshConfig_CryptombPrivateKeyConfig) String() string { return proto.CompactTextString(m) }
+func (*MeshConfig_CryptombPrivateKeyConfig) ProtoMessage()    {}
+func (*MeshConfig_CryptombPrivateKeyConfig) Descriptor() ([]byte, []int) {
+	return fileDescriptor_b5c7ece76d5d5022, []int{0, 8}
+}
+func (m *MeshConfig_CryptombPrivateKeyConfig) XXX_Unmarshal(b []byte) error {
+	return m.Unmarshal(b)
+}
+func (m *MeshConfig_CryptombPrivateKeyConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	if deterministic {
+		return xxx_messageInfo_MeshConfig_CryptombPrivateKeyConfig.Marshal(b, m, deterministic)
+	} else {
+		b = b[:cap(b)]
+		n, err := m.MarshalToSizedBuffer(b)
+		if err != nil {
+			return nil, err
+		}
+		return b[:n], nil
+	}
+}
+func (m *MeshConfig_CryptombPrivateKeyConfig) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_MeshConfig_CryptombPrivateKeyConfig.Merge(m, src)
+}
+func (m *MeshConfig_CryptombPrivateKeyConfig) XXX_Size() int {
+	return m.Size()
+}
+func (m *MeshConfig_CryptombPrivateKeyConfig) XXX_DiscardUnknown() {
+	xxx_messageInfo_MeshConfig_CryptombPrivateKeyConfig.DiscardUnknown(m)
+}
+
+var xxx_messageInfo_MeshConfig_CryptombPrivateKeyConfig proto.InternalMessageInfo
+
+func (m *MeshConfig_CryptombPrivateKeyConfig) GetEnableCryptomb() bool {
+	if m != nil {
+		return m.EnableCryptomb
+	}
+	return false
+}
+
+func (m *MeshConfig_CryptombPrivateKeyConfig) GetPoolDelay() *types.Duration {
+	if m != nil {
+		return m.PoolDelay
+	}
+	return nil
+}
+
 // ConfigSource describes information about a configuration store inside a
 // mesh. A single control plane instance can interact with one or more data
 // sources.
@@ -2824,6 +2895,80 @@ func (m *Certificate) GetDnsNames() []string {
 	return nil
 }
 
+type MSEIngressGlobalConfig struct {
+	// Control tls min protocol version for all gateways.
+	TlsMinProtocolVersion string `protobuf:"bytes,1,opt,name=tls_min_protocol_version,json=tlsMinProtocolVersion,proto3" json:"tlsMinProtocolVersion,omitempty"`
+	// Control tls max protocol version for all gateways.
+	TlsMaxProtocolVersion string `protobuf:"bytes,2,opt,name=tls_max_protocol_version,json=tlsMaxProtocolVersion,proto3" json:"tlsMaxProtocolVersion,omitempty"`
+	// Control tls cipher suites for all gateways.
+	TlsCipherSuites      []string        `protobuf:"bytes,3,rep,name=tls_cipher_suites,json=tlsCipherSuites,proto3" json:"tlsCipherSuites,omitempty"`
+	UpstreamIdleTimeout  *types.Duration `protobuf:"bytes,4,opt,name=upstream_idle_timeout,json=upstreamIdleTimeout,proto3" json:"upstreamIdleTimeout,omitempty"`
+	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
+	XXX_unrecognized     []byte          `json:"-"`
+	XXX_sizecache        int32           `json:"-"`
+}
+
+func (m *MSEIngressGlobalConfig) Reset()         { *m = MSEIngressGlobalConfig{} }
+func (m *MSEIngressGlobalConfig) String() string { return proto.CompactTextString(m) }
+func (*MSEIngressGlobalConfig) ProtoMessage()    {}
+func (*MSEIngressGlobalConfig) Descriptor() ([]byte, []int) {
+	return fileDescriptor_b5c7ece76d5d5022, []int{3}
+}
+func (m *MSEIngressGlobalConfig) XXX_Unmarshal(b []byte) error {
+	return m.Unmarshal(b)
+}
+func (m *MSEIngressGlobalConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	if deterministic {
+		return xxx_messageInfo_MSEIngressGlobalConfig.Marshal(b, m, deterministic)
+	} else {
+		b = b[:cap(b)]
+		n, err := m.MarshalToSizedBuffer(b)
+		if err != nil {
+			return nil, err
+		}
+		return b[:n], nil
+	}
+}
+func (m *MSEIngressGlobalConfig) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_MSEIngressGlobalConfig.Merge(m, src)
+}
+func (m *MSEIngressGlobalConfig) XXX_Size() int {
+	return m.Size()
+}
+func (m *MSEIngressGlobalConfig) XXX_DiscardUnknown() {
+	xxx_messageInfo_MSEIngressGlobalConfig.DiscardUnknown(m)
+}
+
+var xxx_messageInfo_MSEIngressGlobalConfig proto.InternalMessageInfo
+
+func (m *MSEIngressGlobalConfig) GetTlsMinProtocolVersion() string {
+	if m != nil {
+		return m.TlsMinProtocolVersion
+	}
+	return ""
+}
+
+func (m *MSEIngressGlobalConfig) GetTlsMaxProtocolVersion() string {
+	if m != nil {
+		return m.TlsMaxProtocolVersion
+	}
+	return ""
+}
+
+func (m *MSEIngressGlobalConfig) GetTlsCipherSuites() []string {
+	if m != nil {
+		return m.TlsCipherSuites
+	}
+	return nil
+}
+
+func (m *MSEIngressGlobalConfig) GetUpstreamIdleTimeout() *types.Duration {
+	if m != nil {
+		return m.UpstreamIdleTimeout
+	}
+	return nil
+}
+
 func init() {
 	proto.RegisterEnum("istio.mesh.v1alpha1.Resource", Resource_name, Resource_value)
 	proto.RegisterEnum("istio.mesh.v1alpha1.MeshConfig_IngressControllerMode", MeshConfig_IngressControllerMode_name, MeshConfig_IngressControllerMode_value)
@@ -2855,232 +3000,248 @@ func init() {
 	proto.RegisterType((*MeshConfig_ExtensionProvider_EnvoyFileAccessLogProvider)(nil), "istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.EnvoyFileAccessLogProvider")
 	proto.RegisterType((*MeshConfig_DefaultProviders)(nil), "istio.mesh.v1alpha1.MeshConfig.DefaultProviders")
 	proto.RegisterType((*MeshConfig_ProxyPathNormalization)(nil), "istio.mesh.v1alpha1.MeshConfig.ProxyPathNormalization")
+	proto.RegisterType((*MeshConfig_CryptombPrivateKeyConfig)(nil), "istio.mesh.v1alpha1.MeshConfig.CryptombPrivateKeyConfig")
 	proto.RegisterType((*ConfigSource)(nil), "istio.mesh.v1alpha1.ConfigSource")
 	proto.RegisterType((*Certificate)(nil), "istio.mesh.v1alpha1.Certificate")
+	proto.RegisterType((*MSEIngressGlobalConfig)(nil), "istio.mesh.v1alpha1.MSEIngressGlobalConfig")
 }
 
 func init() { proto.RegisterFile("mesh/v1alpha1/config.proto", fileDescriptor_b5c7ece76d5d5022) }
 
 var fileDescriptor_b5c7ece76d5d5022 = []byte{
-	// 3487 bytes of a gzipped FileDescriptorProto
-	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x5a, 0xcd, 0x6f, 0x1b, 0x49,
-	0x76, 0x37, 0x29, 0xda, 0xa2, 0x1e, 0x49, 0xa9, 0x59, 0xfa, 0x70, 0x8b, 0xb6, 0x65, 0x59, 0x63,
-	0x7b, 0x34, 0xce, 0x84, 0x1a, 0xcb, 0xb3, 0xb3, 0xde, 0xd9, 0x64, 0x11, 0x8a, 0xa4, 0x2d, 0x71,
-	0x68, 0x49, 0x29, 0x52, 0xf6, 0xcc, 0x2c, 0x16, 0x85, 0x52, 0x77, 0x91, 0xec, 0x55, 0xb3, 0x9b,
-	0xe9, 0x2a, 0xca, 0xe2, 0x00, 0x7b, 0xc8, 0x39, 0xa7, 0x1c, 0x73, 0xcc, 0x39, 0x48, 0x02, 0xe4,
-	0xaf, 0x08, 0xb0, 0x97, 0x1c, 0xf6, 0x98, 0x43, 0x30, 0xe7, 0x00, 0x39, 0xe7, 0x16, 0xd4, 0x47,
-	0x93, 0x2d, 0x89, 0xb6, 0x2c, 0x63, 0x36, 0x7b, 0x63, 0xbf, 0x7a, 0xef, 0xf7, 0xaa, 0x5e, 0xd5,
-	0xfb, 0xa8, 0x57, 0x84, 0x52, 0x9f, 0xf1, 0xde, 0xd6, 0xe9, 0x53, 0xea, 0x0f, 0x7a, 0xf4, 0xe9,
-	0x96, 0x13, 0x06, 0x1d, 0xaf, 0x5b, 0x1e, 0x44, 0xa1, 0x08, 0xd1, 0xa2, 0xc7, 0x85, 0x17, 0x96,
-	0x25, 0x47, 0x39, 0xe6, 0x28, 0xad, 0x75, 0xc3, 0xb0, 0xeb, 0xb3, 0x2d, 0xc5, 0x72, 0x3c, 0xec,
-	0x6c, 0xb9, 0xc3, 0x88, 0x0a, 0x2f, 0x0c, 0xb4, 0xd0, 0xe5, 0xf1, 0xb7, 0x11, 0x1d, 0x0c, 0x58,
-	0xc4, 0xcd, 0xf8, 0xea, 0x79, 0x85, 0x83, 0x28, 0x3c, 0x1b, 0x99, 0xa1, 0x27, 0x01, 0x13, 0x6f,
-	0xc3, 0xe8, 0xc4, 0x0b, 0xba, 0x31, 0xc3, 0xb3, 0x2d, 0x97, 0x71, 0xe1, 0x05, 0x4a, 0x03, 0x89,
-	0x86, 0x3e, 0x33, 0xbc, 0x9f, 0x4d, 0xe3, 0x3d, 0xf5, 0x22, 0x31, 0xa4, 0x3e, 0xe1, 0x2c, 0x3a,
-	0xf5, 0x9c, 0x98, 0xf5, 0xcb, 0x93, 0xe7, 0xbc, 0xec, 0x85, 0x5b, 0x74, 0xe0, 0xf5, 0xa9, 0xd3,
-	0xf3, 0x02, 0x16, 0x8d, 0xb6, 0x06, 0x27, 0x5d, 0x49, 0xe0, 0x5b, 0x7d, 0x26, 0xe8, 0xd6, 0xe9,
-	0xd3, 0xad, 0x2e, 0x0b, 0x58, 0x44, 0x05, 0x73, 0xb5, 0xd4, 0xc6, 0x3f, 0xbe, 0x00, 0x78, 0xc5,
-	0x78, 0xaf, 0xaa, 0x2c, 0x82, 0x9e, 0x40, 0x51, 0x4d, 0x95, 0xf8, 0x1e, 0x17, 0x2c, 0x20, 0x83,
-	0x30, 0x12, 0x76, 0x66, 0x3d, 0xb5, 0x79, 0x13, 0x2f, 0xa8, 0x81, 0xa6, 0xa2, 0x1f, 0x86, 0x91,
-	0x40, 0x8f, 0x41, 0x93, 0x48, 0x4f, 0x88, 0x81, 0xe6, 0xbc, 0xa9, 0x38, 0x0b, 0x8a, 0xbc, 0x2b,
-	0xc4, 0x40, 0xf1, 0xed, 0xc0, 0x82, 0x13, 0x06, 0x01, 0x73, 0x04, 0x11, 0x5e, 0x9f, 0x85, 0x43,
-	0x61, 0xdf, 0x5a, 0x4f, 0x6d, 0xe6, 0xb6, 0x57, 0xcb, 0xda, 0x88, 0xe5, 0xd8, 0x88, 0xe5, 0x9a,
-	0x31, 0x32, 0x9e, 0x37, 0x12, 0x6d, 0x2d, 0x80, 0xde, 0x40, 0x49, 0x31, 0x39, 0xa1, 0x4f, 0x5c,
-	0x26, 0x98, 0xa3, 0x0c, 0x15, 0xc3, 0x3d, 0xb9, 0x0a, 0xce, 0x8e, 0x85, 0x6b, 0xb1, 0x6c, 0x0c,
-	0x1c, 0x42, 0x41, 0x38, 0x03, 0x72, 0xc2, 0xd8, 0x80, 0xfa, 0xde, 0x29, 0xb3, 0xef, 0x2a, 0xac,
-	0x46, 0x59, 0x1f, 0x8a, 0x89, 0xf9, 0xe3, 0xa3, 0xf1, 0xac, 0x5c, 0xd5, 0x53, 0xf3, 0xc2, 0xe0,
-	0x30, 0x0c, 0xfd, 0x16, 0x13, 0xc2, 0x0b, 0xba, 0xbc, 0xdc, 0xae, 0x1e, 0x4e, 0x7e, 0x3b, 0x83,
-	0x6f, 0x62, 0x44, 0x9c, 0x17, 0x89, 0x2f, 0xf4, 0x09, 0x14, 0xbc, 0xa0, 0x1b, 0x31, 0xce, 0x89,
-	0xe3, 0x53, 0xce, 0xed, 0xd9, 0xf5, 0xd4, 0xe6, 0x1c, 0xce, 0x1b, 0x62, 0x55, 0xd2, 0xd0, 0xa7,
-	0xb0, 0x10, 0x33, 0x99, 0x4d, 0xb6, 0xb3, 0x8a, 0x6d, 0xde, 0x90, 0x5b, 0x9a, 0x8a, 0xfa, 0x70,
-	0x7b, 0x8c, 0x16, 0x06, 0x22, 0x0a, 0x7d, 0x9f, 0x45, 0xa4, 0x1f, 0xba, 0xcc, 0x9e, 0x5b, 0x4f,
-	0x6d, 0xce, 0x6f, 0xff, 0xac, 0x3c, 0xe5, 0x74, 0x97, 0x27, 0x3b, 0x5e, 0xde, 0x33, 0x7a, 0xc7,
-	0xd2, 0xaf, 0x42, 0x97, 0xe1, 0x65, 0x6f, 0x1a, 0x19, 0x7d, 0x06, 0xd6, 0x64, 0x5e, 0x3e, 0x73,
-	0x44, 0x18, 0xd9, 0x5f, 0xaa, 0x89, 0x2d, 0x8c, 0x27, 0xa6, 0xc9, 0xe8, 0x11, 0xcc, 0xb3, 0x80,
-	0x1e, 0xfb, 0x8c, 0x88, 0x88, 0x3a, 0x5e, 0xd0, 0xb5, 0xf3, 0xeb, 0xa9, 0xcd, 0x2c, 0x2e, 0x68,
-	0x6a, 0x5b, 0x13, 0xe5, 0x21, 0xa2, 0x8e, 0x23, 0x01, 0xfd, 0xb0, 0x4b, 0x3a, 0x9e, 0xcf, 0xec,
-	0x82, 0x02, 0x2c, 0x68, 0x72, 0x33, 0xec, 0xbe, 0xf0, 0x7c, 0x26, 0x0f, 0x66, 0x92, 0x2f, 0x8c,
-	0xfa, 0x54, 0xd8, 0xb6, 0x56, 0x3d, 0xe1, 0x54, 0x64, 0x44, 0x61, 0x31, 0xc1, 0xcb, 0x02, 0x27,
-	0x74, 0xa5, 0xfe, 0x3b, 0xca, 0x20, 0x4f, 0xaf, 0x32, 0x48, 0x25, 0x46, 0xab, 0x1b, 0x41, 0x5c,
-	0xa4, 0x17, 0x49, 0xa8, 0x06, 0xf7, 0xcd, 0xea, 0x58, 0x70, 0x1a, 0x8e, 0x48, 0x42, 0x5f, 0xbc,
-	0x61, 0x9b, 0x6a, 0xb9, 0x77, 0x34, 0x5b, 0x5d, 0x72, 0x8d, 0x91, 0xe3, 0xdd, 0xfb, 0x25, 0x94,
-	0x5c, 0x8f, 0x27, 0x60, 0xb4, 0xd7, 0xb1, 0x48, 0x02, 0xd9, 0xcf, 0x15, 0xc0, 0x6d, 0xc3, 0xa1,
-	0x10, 0x9a, 0x66, 0xbc, 0x19, 0x76, 0xd1, 0x4b, 0x98, 0x77, 0x59, 0x87, 0x0e, 0x7d, 0x41, 0x74,
-	0x38, 0xb3, 0xe7, 0xd5, 0xd1, 0x5d, 0x9f, 0xba, 0xc0, 0x43, 0xe9, 0x92, 0x7a, 0x85, 0xb8, 0x60,
-	0xe4, 0x8c, 0xcf, 0xf7, 0xe1, 0x76, 0x38, 0x14, 0xc7, 0xe1, 0x30, 0x70, 0xe5, 0x5e, 0x75, 0x3a,
-	0x9e, 0x43, 0x06, 0xa1, 0xef, 0x39, 0x23, 0xbb, 0xa8, 0x10, 0xaf, 0x3c, 0x43, 0x07, 0x46, 0xbc,
-	0xad, 0xa5, 0x0f, 0x95, 0x30, 0x5e, 0x0e, 0xa7, 0x91, 0xd1, 0x2e, 0xcc, 0xeb, 0xf9, 0x12, 0x1e,
-	0x0e, 0x23, 0x87, 0x71, 0x7b, 0x65, 0x7d, 0x66, 0x33, 0xb7, 0xfd, 0x60, 0xaa, 0x16, 0xad, 0xa1,
-	0xa5, 0x38, 0x71, 0xc1, 0x49, 0x7c, 0x71, 0x54, 0x03, 0xcb, 0x6c, 0x02, 0x1d, 0x8a, 0x90, 0xf4,
-	0x85, 0xcf, 0xed, 0x3f, 0x53, 0x33, 0x2e, 0x5d, 0x0a, 0x05, 0x3b, 0x61, 0xe8, 0xbf, 0xa6, 0xfe,
-	0x90, 0x61, 0x73, 0x2c, 0x2b, 0x43, 0x11, 0xbe, 0x12, 0x3e, 0x47, 0x0f, 0x20, 0x2f, 0xa2, 0x21,
-	0x17, 0xc4, 0x0d, 0xfb, 0xd4, 0x0b, 0xec, 0x92, 0x3a, 0x54, 0x39, 0x45, 0xab, 0x29, 0x12, 0xfa,
-	0x02, 0x96, 0x92, 0x2c, 0x84, 0xfa, 0x1e, 0xe5, 0x8c, 0xdb, 0xe5, 0xf5, 0x99, 0xcd, 0x39, 0x8c,
-	0x12, 0xac, 0x15, 0x3d, 0x82, 0xbe, 0x85, 0x05, 0x87, 0x12, 0x87, 0x45, 0xc2, 0xeb, 0x78, 0x0e,
-	0x15, 0x8c, 0xdb, 0x5f, 0xab, 0x55, 0x6e, 0x5d, 0x65, 0xcb, 0xea, 0x44, 0xa6, 0x46, 0x05, 0xc5,
-	0xf3, 0x0e, 0x4d, 0x90, 0x38, 0xfa, 0x05, 0xac, 0xc6, 0xdb, 0x6e, 0x4e, 0x1a, 0x61, 0x67, 0x32,
-	0xf8, 0x12, 0x11, 0xda, 0xf7, 0xd5, 0x84, 0x56, 0x0c, 0x83, 0x39, 0x66, 0x75, 0x35, 0xdc, 0x0e,
-	0xd1, 0x2e, 0x3c, 0x88, 0x45, 0x2f, 0xa4, 0x90, 0x04, 0xc4, 0xba, 0x82, 0xb8, 0x67, 0x18, 0x5f,
-	0x6b, 0xbe, 0x8b, 0x48, 0x0d, 0xd8, 0x88, 0x91, 0x2e, 0x26, 0xae, 0x04, 0xd4, 0x03, 0x05, 0xb5,
-	0x66, 0x38, 0x6b, 0x13, 0x46, 0x3c, 0xf4, 0x27, 0x58, 0x8f, 0x60, 0x3e, 0x0a, 0x43, 0x41, 0x02,
-	0xda, 0x67, 0x7c, 0x40, 0x1d, 0x66, 0x6f, 0xe8, 0x00, 0x20, 0xa9, 0xfb, 0x31, 0x11, 0x75, 0x60,
-	0xd1, 0x0f, 0x1d, 0xea, 0x7b, 0x62, 0x44, 0xfc, 0x63, 0xc2, 0x75, 0xa8, 0xb5, 0x3f, 0x51, 0xfb,
-	0xfd, 0xd5, 0x7b, 0xc2, 0x75, 0xd3, 0x48, 0x35, 0x43, 0xea, 0xee, 0x50, 0x9f, 0x06, 0x0e, 0x8b,
-	0x4c, 0xa0, 0xc6, 0xc5, 0x18, 0xb2, 0x79, 0x6c, 0x48, 0xa8, 0x0a, 0x96, 0x1b, 0x70, 0x12, 0xb1,
-	0x4e, 0xc4, 0x78, 0x8f, 0xc8, 0x5c, 0x69, 0x3f, 0xbc, 0x32, 0x5d, 0xb9, 0x01, 0xc7, 0x5a, 0x02,
-	0x53, 0xc1, 0xd0, 0xaf, 0xa1, 0xd8, 0xdb, 0x26, 0xc3, 0x41, 0x37, 0xa2, 0x2e, 0x8b, 0x9d, 0xe9,
-	0x33, 0x15, 0x7f, 0xae, 0x3c, 0x00, 0xbb, 0xdb, 0x47, 0x5a, 0xce, 0xb8, 0xd1, 0x42, 0xef, 0x3c,
-	0x41, 0x9e, 0x00, 0x2f, 0xd0, 0xee, 0xea, 0xf8, 0x43, 0x2e, 0x58, 0x44, 0xb8, 0xa0, 0xda, 0x80,
-	0xf6, 0xe7, 0xca, 0x76, 0x2b, 0x86, 0xa1, 0xaa, 0xc7, 0x5b, 0x82, 0x2a, 0x4b, 0xca, 0x80, 0x33,
-	0x76, 0xf5, 0xcb, 0xb2, 0x7f, 0xae, 0x64, 0xc7, 0xc1, 0xe0, 0xa2, 0x70, 0x0d, 0xf2, 0xe7, 0x0e,
-	0xf4, 0x96, 0x3a, 0xd0, 0xd3, 0xc3, 0x4d, 0xe2, 0xc8, 0xe2, 0x73, 0x52, 0xe8, 0xaf, 0xa1, 0x20,
-	0x7a, 0x91, 0xd7, 0x19, 0x47, 0xad, 0xa7, 0xca, 0xb8, 0x9f, 0x5f, 0x65, 0x96, 0xb6, 0x12, 0x32,
-	0x11, 0x2c, 0x2f, 0x12, 0x5f, 0xe8, 0x7b, 0xb0, 0xe2, 0x73, 0x6c, 0x8e, 0x05, 0xb7, 0xb7, 0x3f,
-	0xcc, 0xdb, 0xcc, 0xc1, 0x8e, 0x13, 0x37, 0x5e, 0xe0, 0xe7, 0x09, 0x08, 0xc3, 0x6d, 0x13, 0x63,
-	0x06, 0x51, 0xd8, 0x67, 0xa2, 0xc7, 0x86, 0x9c, 0xf4, 0x59, 0xd4, 0x65, 0xf6, 0xb3, 0x2b, 0x43,
-	0xcd, 0xb2, 0x16, 0x3d, 0x1c, 0x4b, 0xbe, 0x92, 0x82, 0x88, 0xc0, 0xdd, 0x53, 0x16, 0x79, 0x9d,
-	0x51, 0x32, 0x40, 0x10, 0x2a, 0x88, 0xe3, 0x7b, 0x2c, 0x10, 0xf6, 0x57, 0x57, 0x01, 0xef, 0xa4,
-	0xed, 0x14, 0x5e, 0xd5, 0x18, 0x09, 0x4b, 0x57, 0x44, 0x55, 0x01, 0xa0, 0x6d, 0x48, 0x3b, 0xd4,
-	0xfe, 0xb9, 0x82, 0xd9, 0xb8, 0x32, 0xe0, 0x54, 0x70, 0xda, 0xa1, 0xe8, 0x18, 0x16, 0xd9, 0x99,
-	0x60, 0x01, 0x97, 0x8e, 0x3c, 0x88, 0xc2, 0x53, 0xcf, 0x65, 0x11, 0xb7, 0x7f, 0xa1, 0xec, 0x78,
-	0x65, 0xd2, 0xac, 0xc7, 0xa2, 0x87, 0x46, 0x12, 0x23, 0x76, 0x91, 0xc4, 0xd1, 0x6f, 0xa0, 0x18,
-	0x87, 0x8d, 0x89, 0x86, 0xbf, 0x50, 0xd3, 0xfc, 0xe2, 0x2a, 0x0d, 0x35, 0x2d, 0x38, 0x06, 0xc3,
-	0x96, 0x7b, 0x81, 0x82, 0x5c, 0x58, 0x74, 0x3d, 0xee, 0x84, 0xa7, 0x2c, 0x1a, 0x8d, 0xeb, 0x13,
-	0x6e, 0xff, 0x52, 0x2d, 0xe1, 0x59, 0x59, 0xd7, 0xc7, 0xe5, 0x64, 0x7d, 0x5c, 0x1e, 0x9c, 0x74,
-	0x25, 0x81, 0x97, 0x65, 0x7d, 0x5c, 0x3e, 0x7d, 0x5a, 0x6e, 0xd2, 0x63, 0xe6, 0xc7, 0x45, 0x0c,
-	0x46, 0x63, 0xbc, 0x98, 0xc4, 0x11, 0x03, 0x34, 0xa0, 0xa2, 0x47, 0x02, 0x59, 0x6c, 0xf8, 0xde,
-	0x0f, 0x2a, 0x02, 0xd8, 0x7f, 0x79, 0x2e, 0x0e, 0xbd, 0x73, 0x15, 0x2a, 0x0d, 0x1f, 0x52, 0xd1,
-	0xdb, 0x4f, 0x4a, 0xe3, 0xe2, 0xe0, 0x22, 0x09, 0x91, 0x49, 0x9c, 0x57, 0xf5, 0x75, 0xc4, 0x44,
-	0x34, 0x8a, 0x43, 0xc9, 0xaf, 0x94, 0xb6, 0x87, 0xef, 0x89, 0x7a, 0xbb, 0xed, 0xf6, 0x21, 0x96,
-	0x22, 0xe3, 0x6c, 0x20, 0xeb, 0x71, 0x45, 0xd1, 0x61, 0xa4, 0xf4, 0xcf, 0x29, 0x58, 0x9e, 0x9a,
-	0xb8, 0xd1, 0x3e, 0x64, 0x54, 0x05, 0x99, 0x52, 0x01, 0xeb, 0xeb, 0x8f, 0xca, 0xfe, 0x65, 0x55,
-	0x46, 0x2a, 0x9c, 0x8d, 0x1a, 0x64, 0x54, 0xf5, 0x58, 0x84, 0x02, 0xae, 0xbf, 0xdc, 0x6b, 0xb5,
-	0xf1, 0x77, 0xe4, 0x60, 0xbf, 0xf9, 0x9d, 0x75, 0x03, 0x15, 0x60, 0xae, 0xd2, 0x6c, 0x1e, 0xbc,
-	0x21, 0x95, 0xfd, 0xef, 0xac, 0xd4, 0x46, 0x26, 0x9b, 0xb6, 0xd2, 0x4f, 0x96, 0x5e, 0xef, 0xe1,
-	0xf6, 0x51, 0xa5, 0x49, 0x5a, 0x75, 0xfc, 0x7a, 0xaf, 0x5a, 0x57, 0xcc, 0xa5, 0x7f, 0x4d, 0xc1,
-	0xc2, 0x85, 0xe4, 0x88, 0x10, 0xcc, 0x0c, 0x58, 0x5f, 0x4d, 0x74, 0x6e, 0xf7, 0x06, 0x96, 0x1f,
-	0xe8, 0x73, 0x28, 0xf2, 0x81, 0xd7, 0xe9, 0x30, 0x72, 0x3c, 0x0c, 0x5c, 0x9f, 0x91, 0x61, 0xe4,
-	0xdb, 0x69, 0xc3, 0xb1, 0xa0, 0x87, 0x76, 0xd4, 0xc8, 0x51, 0xe4, 0xcb, 0xec, 0x2f, 0x9d, 0x90,
-	0x70, 0xaf, 0x1b, 0xc8, 0xd3, 0x38, 0xa3, 0x72, 0x56, 0x4e, 0xd2, 0x5a, 0x9a, 0x24, 0x2b, 0xf6,
-	0x64, 0xf6, 0xe7, 0x76, 0x46, 0xf1, 0xe4, 0x13, 0x69, 0x9f, 0xef, 0x20, 0xb0, 0x92, 0xce, 0xec,
-	0x52, 0x41, 0x4b, 0xbf, 0x83, 0x7c, 0x32, 0x6a, 0xa1, 0x87, 0x30, 0x2f, 0xd3, 0x09, 0xf1, 0xbd,
-	0xbe, 0x27, 0xd4, 0xb4, 0x52, 0xba, 0xf6, 0x97, 0xd4, 0xa6, 0x24, 0xca, 0x19, 0xbd, 0x04, 0x94,
-	0xe0, 0x8a, 0xaf, 0x38, 0xe9, 0xab, 0x52, 0x90, 0x35, 0x06, 0x31, 0x57, 0x9b, 0xd2, 0xbf, 0xa4,
-	0x60, 0xe1, 0x42, 0x7c, 0x43, 0x6d, 0xc8, 0x8e, 0x43, 0x64, 0x4a, 0x41, 0x3e, 0xbf, 0x66, 0x88,
-	0x2c, 0x8f, 0x63, 0xe5, 0x18, 0x09, 0x2d, 0xc1, 0xcd, 0x5e, 0xc8, 0x05, 0xb7, 0xd3, 0xca, 0x32,
-	0xfa, 0xa3, 0xb4, 0x05, 0xd9, 0xb1, 0xde, 0x4f, 0xa0, 0x10, 0xe7, 0x1b, 0x95, 0x72, 0x95, 0xf2,
-	0x2c, 0xce, 0x1b, 0xa2, 0xca, 0xd1, 0xa5, 0x3f, 0xa4, 0x20, 0x5d, 0xad, 0x20, 0x1b, 0x66, 0xa9,
-	0xeb, 0xca, 0xcb, 0x84, 0xb1, 0x4f, 0xfc, 0x89, 0x0e, 0x20, 0x2f, 0x7c, 0x3e, 0x09, 0xf2, 0xe9,
-	0x73, 0xa9, 0x63, 0xea, 0x5d, 0x4d, 0x05, 0xc4, 0x76, 0xb3, 0x35, 0x9e, 0x75, 0x4e, 0xf8, 0x7c,
-	0x3c, 0xad, 0x1d, 0x58, 0x88, 0xd8, 0xdf, 0x0c, 0x19, 0x9f, 0x18, 0x7a, 0xe6, 0xca, 0x5c, 0x6f,
-	0x24, 0xe2, 0x1b, 0xe4, 0x7d, 0xc8, 0x29, 0xfd, 0x2e, 0xe1, 0x9e, 0xcb, 0xd4, 0x65, 0x39, 0x8b,
-	0x41, 0x93, 0x5a, 0x9e, 0xcb, 0x4a, 0xff, 0xbb, 0x06, 0xc5, 0x4b, 0xf1, 0x11, 0x21, 0xc8, 0xa8,
-	0xa4, 0xab, 0x97, 0xa8, 0x7e, 0xa3, 0xbf, 0x4b, 0xc1, 0x92, 0xbe, 0x08, 0xb0, 0x33, 0x21, 0x8b,
-	0xda, 0xde, 0x0f, 0xca, 0xf9, 0xcd, 0x42, 0xbf, 0xbd, 0x76, 0x14, 0x2e, 0xab, 0x5b, 0x83, 0x24,
-	0x47, 0x01, 0xf5, 0x2b, 0x43, 0xd1, 0x0b, 0x23, 0x13, 0x60, 0xd4, 0xf5, 0xdc, 0xb0, 0xed, 0xde,
-	0xc0, 0x45, 0x66, 0x38, 0x25, 0xd3, 0x0f, 0x72, 0x70, 0xea, 0x6c, 0xba, 0xd1, 0xc0, 0x31, 0x26,
-	0xfa, 0x49, 0x67, 0xf3, 0x32, 0x1a, 0x38, 0xef, 0x9c, 0x8d, 0x1c, 0x44, 0x14, 0x6e, 0xfd, 0xe0,
-	0x0d, 0x4e, 0xbc, 0x40, 0x59, 0x38, 0xb7, 0xfd, 0xf2, 0xfa, 0xea, 0xbf, 0x57, 0xf2, 0xe6, 0xe6,
-	0x99, 0xd0, 0x66, 0x80, 0xd1, 0x6f, 0x61, 0xce, 0xf7, 0xba, 0x3d, 0xc1, 0x05, 0x1b, 0xa8, 0x56,
-	0xc6, 0xa4, 0x0f, 0x70, 0x0d, 0x2d, 0xcd, 0x18, 0xe2, 0xb2, 0xa2, 0x09, 0x3c, 0x72, 0x61, 0x56,
-	0xc6, 0x08, 0x37, 0xec, 0x9a, 0x66, 0xc8, 0xee, 0xf5, 0x35, 0xd5, 0x34, 0xc0, 0x65, 0x3d, 0x31,
-	0x34, 0xf2, 0x20, 0xc7, 0x05, 0x75, 0x4e, 0xdc, 0xc8, 0x3b, 0x65, 0x91, 0x6a, 0x35, 0xe4, 0xb6,
-	0xeb, 0xd7, 0xd7, 0xd4, 0x9a, 0x80, 0x24, 0xd4, 0x24, 0xb1, 0x51, 0x04, 0x10, 0x0e, 0x58, 0xe0,
-	0xb0, 0x80, 0x0f, 0xb9, 0xea, 0x56, 0xe4, 0xb6, 0x0f, 0xaf, 0xaf, 0xe9, 0x60, 0xc0, 0x82, 0xaa,
-	0xc2, 0xa8, 0x74, 0xa5, 0xe7, 0x5e, 0x5a, 0x5b, 0x42, 0x0b, 0xea, 0x03, 0xf0, 0x93, 0xd1, 0x5b,
-	0xea, 0x4b, 0xa7, 0x57, 0x0d, 0x8f, 0xdc, 0xf6, 0x37, 0x1f, 0xb1, 0xba, 0x93, 0xd1, 0x1b, 0x8d,
-	0x31, 0x45, 0xdd, 0x44, 0x81, 0x54, 0x37, 0x29, 0x02, 0x6d, 0xf8, 0x58, 0x75, 0xc9, 0x72, 0x50,
-	0x44, 0x9e, 0xc3, 0x93, 0xea, 0x26, 0x0a, 0xd0, 0xdf, 0xa6, 0x60, 0x59, 0xfb, 0x5f, 0xc7, 0x93,
-	0x77, 0xdc, 0x71, 0x8b, 0xc1, 0xce, 0x29, 0xd5, 0xcd, 0x8f, 0x74, 0xc0, 0x17, 0x9e, 0xcf, 0xc6,
-	0xad, 0x88, 0x84, 0x6e, 0xc4, 0x2e, 0x8d, 0x96, 0xfe, 0x29, 0x05, 0x8f, 0xde, 0xed, 0xb5, 0x58,
-	0x47, 0xc2, 0x9d, 0xd0, 0x1d, 0xa1, 0x27, 0x50, 0xec, 0xd3, 0x33, 0x12, 0x87, 0xd3, 0xe3, 0x91,
-	0xbc, 0x22, 0xc8, 0xe0, 0x56, 0xc0, 0x0b, 0x7d, 0x7a, 0x16, 0xb3, 0x4a, 0x32, 0xda, 0x86, 0x65,
-	0xea, 0xfb, 0xe1, 0x5b, 0x32, 0xa0, 0x91, 0xf0, 0xa8, 0x4f, 0xfa, 0x8c, 0x73, 0xda, 0x65, 0x2a,
-	0xce, 0x65, 0xf1, 0xa2, 0x1a, 0x3c, 0xd4, 0x63, 0xaf, 0xf4, 0x10, 0xda, 0x80, 0xc2, 0x80, 0x3a,
-	0x27, 0x84, 0x72, 0x83, 0x3d, 0xa3, 0x78, 0x73, 0x92, 0x58, 0xe1, 0x0a, 0xb7, 0xf4, 0x6f, 0xb3,
-	0xf0, 0xf8, 0xc3, 0x22, 0x9e, 0x4c, 0x32, 0x71, 0xa3, 0xc6, 0x24, 0x19, 0xf3, 0x29, 0x03, 0xb3,
-	0xea, 0x65, 0xa6, 0xd5, 0xdc, 0xd5, 0x6f, 0xf4, 0x0c, 0x66, 0xe3, 0xfc, 0x30, 0x77, 0x55, 0x7e,
-	0x88, 0x39, 0x65, 0x62, 0x50, 0x85, 0xe2, 0x20, 0x62, 0x1d, 0xef, 0x4c, 0xcd, 0x77, 0x0e, 0x83,
-	0x24, 0x1d, 0x2a, 0x0a, 0xba, 0x03, 0x73, 0x1d, 0xea, 0xf9, 0x44, 0x9e, 0x68, 0x93, 0x37, 0xb2,
-	0x92, 0x20, 0x7d, 0x00, 0x3d, 0x86, 0x05, 0x79, 0x33, 0x1b, 0x72, 0x12, 0x06, 0x84, 0x45, 0x51,
-	0x18, 0xa9, 0x90, 0x34, 0x87, 0x0b, 0x9a, 0x7c, 0x10, 0xd4, 0x25, 0x11, 0xfd, 0x1c, 0x6c, 0x2f,
-	0x70, 0xfc, 0xa1, 0xcb, 0x48, 0x8f, 0x51, 0x59, 0x07, 0x13, 0x2f, 0x20, 0x4e, 0x8f, 0x39, 0x27,
-	0xf6, 0x2d, 0x95, 0x8e, 0x97, 0xcd, 0xf8, 0xae, 0x1e, 0xde, 0x0b, 0xaa, 0x72, 0x10, 0xbd, 0x80,
-	0xf5, 0x58, 0x30, 0xde, 0xb4, 0x4b, 0x00, 0xa0, 0x00, 0xee, 0x1a, 0x3e, 0xb3, 0x87, 0x17, 0x70,
-	0x7e, 0x9f, 0x82, 0x4f, 0x62, 0x20, 0xea, 0xba, 0x9e, 0x34, 0x02, 0xf5, 0x2f, 0x63, 0xe5, 0x54,
-	0x19, 0xfe, 0xbb, 0x3f, 0x56, 0x0e, 0x2b, 0xef, 0xe9, 0x39, 0x54, 0xc6, 0x53, 0x38, 0x3f, 0xcf,
-	0x7a, 0x20, 0x8b, 0xe1, 0xfb, 0xde, 0xfb, 0xb9, 0xd0, 0x3f, 0xa4, 0xe0, 0xde, 0x45, 0xb3, 0x1c,
-	0x87, 0xee, 0x68, 0xb2, 0x8e, 0xbc, 0x3a, 0x00, 0x6f, 0x7e, 0xca, 0x75, 0x24, 0xfc, 0x08, 0xaf,
-	0x9e, 0x37, 0xb6, 0xa4, 0xc5, 0x73, 0xfb, 0x15, 0xdc, 0x8d, 0xad, 0x2a, 0x42, 0x32, 0x1c, 0x70,
-	0x11, 0x31, 0xda, 0x97, 0xe7, 0x43, 0x39, 0x8c, 0x3d, 0xab, 0x76, 0xcb, 0x36, 0x3c, 0xed, 0xf0,
-	0xc8, 0x70, 0x1c, 0x04, 0x15, 0x39, 0x8e, 0xfe, 0x0a, 0xee, 0x25, 0xe4, 0xdd, 0xf0, 0x6d, 0x30,
-	0x41, 0x70, 0x59, 0x30, 0xb2, 0xb3, 0x0a, 0x60, 0x75, 0x0c, 0x50, 0x1b, 0xb3, 0x1c, 0x04, 0x35,
-	0x16, 0x8c, 0x4a, 0x18, 0x1e, 0x7e, 0x88, 0x99, 0x91, 0x05, 0x33, 0x27, 0x6c, 0x64, 0x3c, 0x4b,
-	0xfe, 0x94, 0x25, 0xe2, 0xa9, 0xbc, 0xba, 0xea, 0x4a, 0x1c, 0xeb, 0x8f, 0xaf, 0xd3, 0xcf, 0x53,
-	0xa5, 0xff, 0x4e, 0xbf, 0xcf, 0x69, 0x93, 0x85, 0xc1, 0xc7, 0x3b, 0xed, 0xcd, 0x0f, 0x76, 0xda,
-	0x73, 0x3e, 0x39, 0x73, 0xb5, 0x4f, 0x66, 0xa6, 0xf9, 0xe4, 0xd5, 0x87, 0xe8, 0xd6, 0x9f, 0xea,
-	0x10, 0x95, 0x4e, 0x60, 0x79, 0x6a, 0x1d, 0x74, 0x4d, 0xe3, 0x3e, 0x84, 0x79, 0x19, 0xee, 0x05,
-	0xed, 0x12, 0x9f, 0x05, 0x5d, 0xd1, 0x53, 0xc6, 0x2a, 0xe0, 0x7c, 0x9f, 0x9e, 0xb5, 0x69, 0xb7,
-	0xa9, 0x68, 0xa5, 0xbf, 0x4f, 0x81, 0xfd, 0xae, 0x7a, 0xe8, 0x9a, 0x0a, 0x1f, 0x40, 0xde, 0x64,
-	0x40, 0x11, 0x9e, 0x98, 0xbd, 0x99, 0xc3, 0x39, 0x4d, 0x6b, 0x4b, 0xd2, 0x94, 0x39, 0x65, 0xa6,
-	0xcc, 0xc9, 0x87, 0x95, 0xe9, 0x85, 0xd3, 0x1f, 0xc5, 0x02, 0x3e, 0xac, 0xbe, 0xb3, 0xbc, 0xf8,
-	0xc9, 0x2d, 0x50, 0xfa, 0xcf, 0x34, 0x2c, 0x4e, 0xa9, 0xd5, 0xa4, 0xf7, 0xb9, 0xec, 0x78, 0xd8,
-	0x35, 0xd7, 0x2e, 0xfd, 0x81, 0xda, 0x60, 0xcb, 0x15, 0x04, 0xc3, 0xfe, 0x31, 0x8b, 0x48, 0xd8,
-	0x21, 0x54, 0x88, 0xc8, 0x3b, 0x1e, 0xca, 0xec, 0xaa, 0x6f, 0x1c, 0x77, 0x2e, 0x79, 0xcc, 0x5e,
-	0x20, 0xbe, 0xfa, 0xd2, 0x74, 0xb7, 0xfa, 0xf4, 0x6c, 0x5f, 0xc9, 0x1e, 0x74, 0x2a, 0x63, 0x49,
-	0xf4, 0x1a, 0x56, 0x2f, 0xa0, 0x06, 0x41, 0x28, 0xd4, 0x11, 0xe5, 0xe6, 0xea, 0xf0, 0x5e, 0xd8,
-	0x95, 0x24, 0xec, 0x44, 0x14, 0xfd, 0x1a, 0xee, 0x9e, 0xc7, 0x35, 0x45, 0x03, 0x61, 0xa7, 0x2c,
-	0x10, 0xdc, 0x5c, 0x0b, 0xde, 0x0b, 0x6d, 0x27, 0xa0, 0x4d, 0x5d, 0x51, 0x57, 0xc2, 0x53, 0x36,
-	0xf3, 0xe6, 0x94, 0xcd, 0xfc, 0x43, 0x1a, 0xd6, 0xde, 0x5f, 0xa0, 0x5e, 0x73, 0x4b, 0xdf, 0xc2,
-	0xac, 0x13, 0x06, 0x82, 0x9d, 0x09, 0xd5, 0x78, 0x98, 0xdf, 0xfe, 0xcd, 0x4f, 0x5d, 0x31, 0x97,
-	0xe5, 0x37, 0xab, 0x6a, 0x25, 0x38, 0xd6, 0xf6, 0x61, 0xae, 0xb2, 0xc1, 0x20, 0x9f, 0x14, 0x47,
-	0x0b, 0x90, 0x3b, 0xda, 0x6f, 0x1d, 0xd6, 0xab, 0x7b, 0x2f, 0xf6, 0xea, 0x35, 0xeb, 0x06, 0x5a,
-	0x86, 0xe2, 0x9b, 0x67, 0x55, 0xd2, 0xc6, 0x95, 0x6a, 0x9d, 0x54, 0x0f, 0xf6, 0xdb, 0xf5, 0x6f,
-	0xdb, 0x56, 0x0a, 0xe5, 0x21, 0xfb, 0x12, 0x1f, 0x56, 0xc9, 0xce, 0xde, 0xbe, 0x95, 0x46, 0xb7,
-	0x61, 0xb1, 0xda, 0x3c, 0x38, 0xaa, 0x5d, 0x60, 0x9b, 0x41, 0xb7, 0x20, 0xbd, 0xf3, 0xcc, 0xca,
-	0x94, 0xee, 0xc0, 0xea, 0x3b, 0x6b, 0xe2, 0xd2, 0x17, 0x50, 0x7a, 0x77, 0xd5, 0xaa, 0x8c, 0x4a,
-	0x45, 0x2f, 0xbe, 0x45, 0xcb, 0xdf, 0x3b, 0x00, 0xd9, 0xb8, 0xbb, 0x58, 0xea, 0x83, 0x75, 0xb1,
-	0x71, 0x28, 0xb7, 0x28, 0x7e, 0x92, 0x4c, 0xa9, 0x84, 0x17, 0x7f, 0xca, 0x91, 0xbe, 0x56, 0x6f,
-	0x3a, 0x19, 0xf1, 0x27, 0x7a, 0x04, 0xf3, 0x93, 0xfa, 0xbb, 0x2b, 0x45, 0x75, 0xa3, 0x68, 0xf2,
-	0x4a, 0x29, 0x89, 0xa5, 0xff, 0x49, 0xc1, 0xca, 0xf4, 0x16, 0x1f, 0x0a, 0xa0, 0x70, 0xbe, 0x63,
-	0xa8, 0xbb, 0x6b, 0xbb, 0x1f, 0xd7, 0x31, 0x2c, 0x9f, 0xfb, 0x6a, 0x8f, 0x06, 0x0c, 0x9f, 0x87,
-	0xdf, 0x60, 0x50, 0xbc, 0xc4, 0x83, 0x72, 0x30, 0x5b, 0xab, 0xbf, 0xa8, 0x1c, 0x35, 0xdb, 0xd6,
-	0x0d, 0x94, 0x85, 0xcc, 0xfe, 0xc1, 0x7e, 0xdd, 0x4a, 0xc9, 0x5f, 0x3b, 0x95, 0x56, 0xdd, 0x4a,
-	0xa3, 0x22, 0x14, 0x5e, 0xd5, 0xf1, 0xcb, 0x3a, 0x69, 0x35, 0x2b, 0xad, 0xdd, 0x7a, 0xcb, 0x9a,
-	0x41, 0x77, 0xc1, 0xae, 0xd5, 0xab, 0x07, 0xb5, 0x3a, 0xa9, 0xec, 0xd7, 0xc8, 0xf9, 0xd1, 0xcc,
-	0x46, 0x03, 0x96, 0xa7, 0xbe, 0x20, 0x5f, 0x3e, 0x2b, 0xb3, 0x30, 0x73, 0xf0, 0xe2, 0x85, 0x95,
-	0x4a, 0x4e, 0x22, 0x8d, 0x00, 0x6e, 0xb5, 0xda, 0x78, 0xaf, 0xda, 0xb6, 0x66, 0x36, 0x1e, 0x03,
-	0xc8, 0x8c, 0x66, 0xba, 0x90, 0xf1, 0xf4, 0x6e, 0xa0, 0x79, 0x80, 0x57, 0x47, 0xaa, 0x21, 0xd8,
-	0x6e, 0xb6, 0xac, 0xd4, 0xc6, 0xa7, 0x50, 0xbc, 0xf4, 0x48, 0x2b, 0xd9, 0xd5, 0xb1, 0x52, 0xeb,
-	0x6a, 0xb4, 0x0e, 0xf6, 0xad, 0xd4, 0xc6, 0x36, 0x2c, 0x5c, 0x78, 0x4d, 0x41, 0x08, 0xe6, 0x6b,
-	0x07, 0x64, 0xff, 0xa0, 0x4d, 0x8e, 0x0e, 0x5f, 0xe2, 0x4a, 0x4d, 0xe2, 0xe7, 0x60, 0x36, 0xfe,
-	0x48, 0x35, 0x32, 0xd9, 0x94, 0x95, 0x6e, 0x64, 0xb2, 0x69, 0x6b, 0xa6, 0x91, 0xc9, 0xce, 0x58,
-	0x99, 0x46, 0x26, 0xfb, 0x85, 0xf5, 0xb4, 0x91, 0xc9, 0xae, 0x5a, 0xa5, 0x46, 0x26, 0xbb, 0x66,
-	0xdd, 0x6f, 0x64, 0xb2, 0x60, 0xe5, 0x1a, 0x99, 0x6c, 0xce, 0xca, 0x37, 0x32, 0xd9, 0x05, 0xcb,
-	0x6a, 0x64, 0xb2, 0x96, 0x55, 0x6c, 0x64, 0xb2, 0xc8, 0x5a, 0x6c, 0x64, 0xb2, 0x8b, 0xd6, 0x52,
-	0x23, 0x93, 0x5d, 0xb2, 0x96, 0x1b, 0x99, 0xec, 0xb2, 0xb5, 0xd2, 0xc8, 0x64, 0x6f, 0x5b, 0x76,
-	0x23, 0x93, 0xbd, 0x67, 0xad, 0x35, 0x32, 0xd9, 0x9f, 0x59, 0x5f, 0x35, 0x32, 0xd9, 0x47, 0xd6,
-	0xe3, 0x46, 0x26, 0xfb, 0xd8, 0xfa, 0xb4, 0x91, 0xc9, 0x7e, 0x6a, 0x6d, 0x62, 0xd4, 0xf7, 0xce,
-	0x58, 0xa4, 0xcb, 0x03, 0xf5, 0x2c, 0xc7, 0x22, 0xbc, 0xa8, 0x69, 0x11, 0x53, 0x2f, 0x6a, 0x86,
-	0xb8, 0x1c, 0x3f, 0x19, 0xeb, 0x5e, 0xb0, 0x96, 0xe0, 0x78, 0xfc, 0x92, 0xac, 0x65, 0x4c, 0xcf,
-	0x58, 0x0a, 0x72, 0xbc, 0x92, 0x64, 0x25, 0xe3, 0xfa, 0x06, 0x3f, 0xe2, 0x9e, 0xcb, 0x1c, 0x1a,
-	0xc9, 0x72, 0x50, 0x30, 0x9f, 0xf5, 0x55, 0x8f, 0x99, 0x33, 0xae, 0x1e, 0x01, 0x68, 0xa7, 0xe3,
-	0x05, 0x9e, 0x18, 0xe1, 0x1c, 0x1d, 0xca, 0x6b, 0x8c, 0x7e, 0x8e, 0x2a, 0x46, 0xee, 0xe4, 0x75,
-	0xcc, 0x65, 0x3e, 0x1d, 0xe1, 0x82, 0x56, 0x69, 0xba, 0x74, 0x38, 0x7e, 0x19, 0xd7, 0xaf, 0x19,
-	0xaa, 0x2b, 0x76, 0x6e, 0xae, 0x38, 0xcf, 0x5d, 0x4e, 0x86, 0x2e, 0x27, 0xd2, 0x5d, 0x71, 0x91,
-	0x5f, 0x02, 0x5c, 0x31, 0x08, 0x72, 0x44, 0xe5, 0x3a, 0xd2, 0x0f, 0x87, 0x81, 0xc0, 0x48, 0x09,
-	0x72, 0x46, 0x4e, 0x9e, 0x73, 0xc2, 0x29, 0xf9, 0xed, 0x5b, 0x81, 0x4b, 0x82, 0x45, 0xfd, 0xf8,
-	0x01, 0xd2, 0x8d, 0xa8, 0x17, 0x90, 0xf8, 0xaf, 0x3a, 0x78, 0x29, 0xb6, 0x89, 0xb1, 0xe0, 0x31,
-	0x15, 0x4e, 0x0f, 0xdb, 0xc9, 0x2f, 0x22, 0xc3, 0x20, 0x0b, 0x44, 0xe4, 0x31, 0x8e, 0x97, 0x2f,
-	0x8d, 0xc8, 0xb2, 0x70, 0xe3, 0xf7, 0x29, 0xc8, 0x27, 0xdf, 0xa1, 0xff, 0x3f, 0x3b, 0x94, 0x87,
-	0xb0, 0xc4, 0x87, 0xc7, 0xdc, 0x89, 0xbc, 0x63, 0xe6, 0x92, 0x88, 0xc5, 0x6f, 0xe6, 0x3a, 0x5d,
-	0xdc, 0x9b, 0x1a, 0x3d, 0xb0, 0xe1, 0xc2, 0x8b, 0x13, 0xd1, 0x98, 0xc6, 0x37, 0xbe, 0x81, 0x5c,
-	0xa2, 0x8d, 0x2e, 0x6f, 0xa9, 0x9c, 0x39, 0x11, 0x33, 0x6f, 0x80, 0x7a, 0x3d, 0xa0, 0x49, 0xea,
-	0xd9, 0xef, 0x0e, 0xcc, 0xb9, 0x01, 0xd7, 0xcf, 0xb3, 0x26, 0x2c, 0x66, 0xdd, 0x80, 0xab, 0x97,
-	0xd9, 0x27, 0xeb, 0x90, 0x8d, 0x91, 0xd1, 0x12, 0x58, 0x71, 0xc3, 0x3e, 0x6e, 0xf3, 0x5b, 0x37,
-	0x76, 0x36, 0xff, 0xfd, 0xc7, 0xb5, 0xd4, 0x7f, 0xfc, 0xb8, 0x96, 0xfa, 0xaf, 0x1f, 0xd7, 0x52,
-	0xdf, 0x97, 0xf4, 0x7c, 0xf5, 0xdf, 0x94, 0xb6, 0xce, 0xfd, 0x47, 0xea, 0xf8, 0x96, 0x4a, 0xd9,
-	0xcf, 0xfe, 0x2f, 0x00, 0x00, 0xff, 0xff, 0x0f, 0x8f, 0xe8, 0xaa, 0xac, 0x25, 0x00, 0x00,
+	// 3698 bytes of a gzipped FileDescriptorProto
+	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x7a, 0x4b, 0x73, 0x1b, 0x49,
+	0x72, 0xbf, 0x00, 0x42, 0x22, 0x98, 0x20, 0x88, 0x46, 0x51, 0xa4, 0x9a, 0xd0, 0x8b, 0xe2, 0xe8,
+	0xc1, 0xd1, 0xce, 0x1f, 0x1c, 0x51, 0xb3, 0xb3, 0xda, 0xd9, 0xbf, 0x37, 0x0c, 0x02, 0x90, 0x48,
+	0x0c, 0x44, 0xd2, 0x0d, 0x48, 0x9a, 0x99, 0x8d, 0x8d, 0x8a, 0x42, 0x77, 0x01, 0xe8, 0x65, 0xa3,
+	0xbb, 0xdd, 0x55, 0xa0, 0x88, 0x89, 0x98, 0x83, 0x0f, 0x3e, 0xf9, 0xe4, 0xa3, 0x3f, 0x83, 0xc3,
+	0x76, 0x84, 0x3f, 0x85, 0x23, 0xf6, 0xe2, 0xc3, 0x1e, 0x7d, 0x70, 0xcc, 0xcd, 0x0e, 0x3b, 0x7c,
+	0xf6, 0xcd, 0x51, 0x8f, 0x06, 0x9a, 0x20, 0x24, 0x88, 0x8a, 0x59, 0xfb, 0x86, 0xce, 0xca, 0xfc,
+	0x65, 0x55, 0x56, 0x56, 0x66, 0x56, 0x16, 0xa0, 0x34, 0xa0, 0xac, 0xbf, 0x73, 0xfa, 0x84, 0x78,
+	0x61, 0x9f, 0x3c, 0xd9, 0xb1, 0x03, 0xbf, 0xeb, 0xf6, 0xca, 0x61, 0x14, 0xf0, 0x00, 0xad, 0xba,
+	0x8c, 0xbb, 0x41, 0x59, 0x70, 0x94, 0x63, 0x8e, 0xd2, 0x9d, 0x5e, 0x10, 0xf4, 0x3c, 0xba, 0x23,
+	0x59, 0x3a, 0xc3, 0xee, 0x8e, 0x33, 0x8c, 0x08, 0x77, 0x03, 0x5f, 0x09, 0x5d, 0x1c, 0x7f, 0x1b,
+	0x91, 0x30, 0xa4, 0x11, 0xd3, 0xe3, 0x1b, 0xe7, 0x15, 0x86, 0x51, 0x70, 0x36, 0xd2, 0x43, 0x8f,
+	0x7d, 0xca, 0xdf, 0x06, 0xd1, 0x89, 0xeb, 0xf7, 0x62, 0x86, 0xa7, 0x3b, 0x0e, 0x65, 0xdc, 0xf5,
+	0xa5, 0x06, 0x1c, 0x0d, 0x3d, 0xaa, 0x79, 0x3f, 0x9d, 0xc5, 0x7b, 0xea, 0x46, 0x7c, 0x48, 0x3c,
+	0xcc, 0x68, 0x74, 0xea, 0xda, 0x31, 0xeb, 0x17, 0x27, 0xcf, 0x58, 0xd9, 0x0d, 0x76, 0x48, 0xe8,
+	0x0e, 0x88, 0xdd, 0x77, 0x7d, 0x1a, 0x8d, 0x76, 0xc2, 0x93, 0x9e, 0x20, 0xb0, 0x9d, 0x01, 0xe5,
+	0x64, 0xe7, 0xf4, 0xc9, 0x4e, 0x8f, 0xfa, 0x34, 0x22, 0x9c, 0x3a, 0x4a, 0x6a, 0xeb, 0x3f, 0xf7,
+	0x01, 0x5e, 0x52, 0xd6, 0xaf, 0x4a, 0x8b, 0xa0, 0xc7, 0x50, 0x94, 0x53, 0xc5, 0x9e, 0xcb, 0x38,
+	0xf5, 0x71, 0x18, 0x44, 0xdc, 0xcc, 0x6c, 0xa6, 0xb6, 0xaf, 0x5a, 0x05, 0x39, 0xd0, 0x94, 0xf4,
+	0xe3, 0x20, 0xe2, 0xe8, 0x21, 0x28, 0x12, 0xee, 0x73, 0x1e, 0x2a, 0xce, 0xab, 0x92, 0x33, 0x2f,
+	0xc9, 0xfb, 0x9c, 0x87, 0x92, 0x6f, 0x0f, 0x0a, 0x76, 0xe0, 0xfb, 0xd4, 0xe6, 0x98, 0xbb, 0x03,
+	0x1a, 0x0c, 0xb9, 0x79, 0x6d, 0x33, 0xb5, 0x9d, 0xdb, 0xdd, 0x28, 0x2b, 0x23, 0x96, 0x63, 0x23,
+	0x96, 0x6b, 0xda, 0xc8, 0xd6, 0x8a, 0x96, 0x68, 0x2b, 0x01, 0xf4, 0x06, 0x4a, 0x92, 0xc9, 0x0e,
+	0x3c, 0xec, 0x50, 0x4e, 0x6d, 0x69, 0xa8, 0x18, 0xee, 0xf1, 0x3c, 0x38, 0x33, 0x16, 0xae, 0xc5,
+	0xb2, 0x31, 0x70, 0x00, 0x79, 0x6e, 0x87, 0xf8, 0x84, 0xd2, 0x90, 0x78, 0xee, 0x29, 0x35, 0x6f,
+	0x49, 0xac, 0x46, 0x59, 0x39, 0xc5, 0xc4, 0xfc, 0xb1, 0x6b, 0x3c, 0x2d, 0x57, 0xd5, 0xd4, 0xdc,
+	0xc0, 0x3f, 0x0e, 0x02, 0xaf, 0x45, 0x39, 0x77, 0xfd, 0x1e, 0x2b, 0xb7, 0xab, 0xc7, 0x93, 0xdf,
+	0x76, 0xf8, 0x75, 0x8c, 0x68, 0x2d, 0xf3, 0xc4, 0x17, 0xfa, 0x04, 0xf2, 0xae, 0xdf, 0x8b, 0x28,
+	0x63, 0xd8, 0xf6, 0x08, 0x63, 0xe6, 0xe2, 0x66, 0x6a, 0x7b, 0xc9, 0x5a, 0xd6, 0xc4, 0xaa, 0xa0,
+	0xa1, 0x47, 0x50, 0x88, 0x99, 0xf4, 0x26, 0x9b, 0x59, 0xc9, 0xb6, 0xa2, 0xc9, 0x2d, 0x45, 0x45,
+	0x03, 0xb8, 0x31, 0x46, 0x0b, 0x7c, 0x1e, 0x05, 0x9e, 0x47, 0x23, 0x3c, 0x08, 0x1c, 0x6a, 0x2e,
+	0x6d, 0xa6, 0xb6, 0x57, 0x76, 0x7f, 0x5e, 0x9e, 0xe1, 0xdd, 0xe5, 0xc9, 0x8e, 0x97, 0x0f, 0xb4,
+	0xde, 0xb1, 0xf4, 0xcb, 0xc0, 0xa1, 0xd6, 0x9a, 0x3b, 0x8b, 0x8c, 0x3e, 0x05, 0x63, 0x32, 0x2f,
+	0x8f, 0xda, 0x3c, 0x88, 0xcc, 0x2f, 0xe4, 0xc4, 0x0a, 0xe3, 0x89, 0x29, 0x32, 0x7a, 0x00, 0x2b,
+	0xd4, 0x27, 0x1d, 0x8f, 0x62, 0x1e, 0x11, 0xdb, 0xf5, 0x7b, 0xe6, 0xf2, 0x66, 0x6a, 0x3b, 0x6b,
+	0xe5, 0x15, 0xb5, 0xad, 0x88, 0xc2, 0x89, 0x88, 0x6d, 0x0b, 0x40, 0x2f, 0xe8, 0xe1, 0xae, 0xeb,
+	0x51, 0x33, 0x2f, 0x01, 0xf3, 0x8a, 0xdc, 0x0c, 0x7a, 0xcf, 0x5d, 0x8f, 0x0a, 0xc7, 0x4c, 0xf2,
+	0x05, 0xd1, 0x80, 0x70, 0xd3, 0x54, 0xaa, 0x27, 0x9c, 0x92, 0x8c, 0x08, 0xac, 0x26, 0x78, 0xa9,
+	0x6f, 0x07, 0x8e, 0xd0, 0x7f, 0x53, 0x1a, 0xe4, 0xc9, 0x3c, 0x83, 0x54, 0x62, 0xb4, 0xba, 0x16,
+	0xb4, 0x8a, 0x64, 0x9a, 0x84, 0x6a, 0x70, 0x57, 0xaf, 0x8e, 0xfa, 0xa7, 0xc1, 0x08, 0x27, 0xf4,
+	0xc5, 0x1b, 0xb6, 0x2d, 0x97, 0x7b, 0x53, 0xb1, 0xd5, 0x05, 0xd7, 0x18, 0x39, 0xde, 0xbd, 0x5f,
+	0x41, 0xc9, 0x71, 0x59, 0x02, 0x46, 0x9d, 0x3a, 0x1a, 0x09, 0x20, 0xf3, 0x99, 0x04, 0xb8, 0xa1,
+	0x39, 0x24, 0x42, 0x53, 0x8f, 0x37, 0x83, 0x1e, 0x7a, 0x01, 0x2b, 0x0e, 0xed, 0x92, 0xa1, 0xc7,
+	0xb1, 0x0a, 0x67, 0xe6, 0x8a, 0x74, 0xdd, 0xcd, 0x99, 0x0b, 0x3c, 0x16, 0x47, 0x52, 0xad, 0xd0,
+	0xca, 0x6b, 0x39, 0x7d, 0xe6, 0x07, 0x70, 0x23, 0x18, 0xf2, 0x4e, 0x30, 0xf4, 0x1d, 0xb1, 0x57,
+	0xdd, 0xae, 0x6b, 0xe3, 0x30, 0xf0, 0x5c, 0x7b, 0x64, 0x16, 0x25, 0xe2, 0x5c, 0x1f, 0x3a, 0xd2,
+	0xe2, 0x6d, 0x25, 0x7d, 0x2c, 0x85, 0xad, 0xb5, 0x60, 0x16, 0x19, 0xed, 0xc3, 0x8a, 0x9a, 0x2f,
+	0x66, 0xc1, 0x30, 0xb2, 0x29, 0x33, 0xd7, 0x37, 0x17, 0xb6, 0x73, 0xbb, 0xf7, 0x66, 0x6a, 0x51,
+	0x1a, 0x5a, 0x92, 0xd3, 0xca, 0xdb, 0x89, 0x2f, 0x86, 0x6a, 0x60, 0xe8, 0x4d, 0x20, 0x43, 0x1e,
+	0xe0, 0x01, 0xf7, 0x98, 0xf9, 0x33, 0x39, 0xe3, 0xd2, 0x85, 0x50, 0xb0, 0x17, 0x04, 0xde, 0x6b,
+	0xe2, 0x0d, 0xa9, 0xa5, 0xdd, 0xb2, 0x32, 0xe4, 0xc1, 0x4b, 0xee, 0x31, 0x74, 0x0f, 0x96, 0x79,
+	0x34, 0x64, 0x1c, 0x3b, 0xc1, 0x80, 0xb8, 0xbe, 0x59, 0x92, 0x4e, 0x95, 0x93, 0xb4, 0x9a, 0x24,
+	0xa1, 0xcf, 0xe1, 0x7a, 0x92, 0x05, 0x13, 0xcf, 0x25, 0x8c, 0x32, 0xb3, 0xbc, 0xb9, 0xb0, 0xbd,
+	0x64, 0xa1, 0x04, 0x6b, 0x45, 0x8d, 0xa0, 0x6f, 0xa0, 0x60, 0x13, 0x6c, 0xd3, 0x88, 0xbb, 0x5d,
+	0xd7, 0x26, 0x9c, 0x32, 0xf3, 0x2b, 0xb9, 0xca, 0x9d, 0x79, 0xb6, 0xac, 0x4e, 0x64, 0x6a, 0x84,
+	0x13, 0x6b, 0xc5, 0x26, 0x09, 0x12, 0x43, 0xbf, 0x84, 0x8d, 0x78, 0xdb, 0xb5, 0xa7, 0x61, 0x7a,
+	0x26, 0x82, 0x2f, 0xe6, 0x81, 0x79, 0x57, 0x4e, 0x68, 0x5d, 0x33, 0x68, 0x37, 0xab, 0xcb, 0xe1,
+	0x76, 0x80, 0xf6, 0xe1, 0x5e, 0x2c, 0x3a, 0x95, 0x42, 0x12, 0x10, 0x9b, 0x12, 0xe2, 0xb6, 0x66,
+	0x7c, 0xad, 0xf8, 0xa6, 0x91, 0x1a, 0xb0, 0x15, 0x23, 0x4d, 0x27, 0xae, 0x04, 0xd4, 0x3d, 0x09,
+	0x75, 0x47, 0x73, 0xd6, 0x26, 0x8c, 0xd6, 0xd0, 0x9b, 0x60, 0x3d, 0x80, 0x95, 0x28, 0x08, 0x38,
+	0xf6, 0xc9, 0x80, 0xb2, 0x90, 0xd8, 0xd4, 0xdc, 0x52, 0x01, 0x40, 0x50, 0x0f, 0x63, 0x22, 0xea,
+	0xc2, 0xaa, 0x17, 0xd8, 0xc4, 0x73, 0xf9, 0x08, 0x7b, 0x1d, 0xcc, 0x54, 0xa8, 0x35, 0x3f, 0x91,
+	0xfb, 0xfd, 0xe5, 0x7b, 0xc2, 0x75, 0x53, 0x4b, 0x35, 0x03, 0xe2, 0xec, 0x11, 0x8f, 0xf8, 0x36,
+	0x8d, 0x74, 0xa0, 0xb6, 0x8a, 0x31, 0x64, 0xb3, 0xa3, 0x49, 0xa8, 0x0a, 0x86, 0xe3, 0x33, 0x1c,
+	0xd1, 0x6e, 0x44, 0x59, 0x1f, 0x8b, 0x5c, 0x69, 0xde, 0x9f, 0x9b, 0xae, 0x1c, 0x9f, 0x59, 0x4a,
+	0xc2, 0x22, 0x9c, 0xa2, 0xdf, 0x40, 0xb1, 0xbf, 0x8b, 0x87, 0x61, 0x2f, 0x22, 0x0e, 0x8d, 0x0f,
+	0xd3, 0xa7, 0x32, 0xfe, 0xcc, 0x75, 0x80, 0xfd, 0xdd, 0x57, 0x4a, 0x4e, 0x1f, 0xa3, 0x42, 0xff,
+	0x3c, 0x41, 0x78, 0x80, 0xeb, 0xab, 0xe3, 0x6a, 0x7b, 0x43, 0xc6, 0x69, 0x84, 0x19, 0x27, 0xca,
+	0x80, 0xe6, 0x67, 0xd2, 0x76, 0xeb, 0x9a, 0xa1, 0xaa, 0xc6, 0x5b, 0x9c, 0x48, 0x4b, 0x8a, 0x80,
+	0x33, 0x3e, 0xea, 0x17, 0x65, 0xff, 0x9f, 0x94, 0x1d, 0x07, 0x83, 0x69, 0xe1, 0x1a, 0x2c, 0x9f,
+	0x73, 0xe8, 0x1d, 0xe9, 0xd0, 0xb3, 0xc3, 0x4d, 0xc2, 0x65, 0xad, 0x73, 0x52, 0xe8, 0xcf, 0x20,
+	0xcf, 0xfb, 0x91, 0xdb, 0x1d, 0x47, 0xad, 0x27, 0xd2, 0xb8, 0x9f, 0xcd, 0x33, 0x4b, 0x5b, 0x0a,
+	0xe9, 0x08, 0xb6, 0xcc, 0x13, 0x5f, 0xe8, 0x3b, 0x30, 0x62, 0x3f, 0xd6, 0x6e, 0xc1, 0xcc, 0xdd,
+	0x0f, 0x3b, 0x6d, 0xda, 0xb1, 0xe3, 0xc4, 0x6d, 0x15, 0xd8, 0x79, 0x02, 0xb2, 0xe0, 0x86, 0x8e,
+	0x31, 0x61, 0x14, 0x0c, 0x28, 0xef, 0xd3, 0x21, 0xc3, 0x03, 0x1a, 0xf5, 0xa8, 0xf9, 0x74, 0x6e,
+	0xa8, 0x59, 0x53, 0xa2, 0xc7, 0x63, 0xc9, 0x97, 0x42, 0x10, 0x61, 0xb8, 0x75, 0x4a, 0x23, 0xb7,
+	0x3b, 0x4a, 0x06, 0x08, 0x4c, 0x38, 0xb6, 0x3d, 0x97, 0xfa, 0xdc, 0xfc, 0x72, 0x1e, 0xf0, 0x5e,
+	0xda, 0x4c, 0x59, 0x1b, 0x0a, 0x23, 0x61, 0xe9, 0x0a, 0xaf, 0x4a, 0x00, 0xb4, 0x0b, 0x69, 0x9b,
+	0x98, 0xbf, 0x90, 0x30, 0x5b, 0x73, 0x03, 0x4e, 0xc5, 0x4a, 0xdb, 0x04, 0x75, 0x60, 0x95, 0x9e,
+	0x71, 0xea, 0x33, 0x71, 0x90, 0xc3, 0x28, 0x38, 0x75, 0x1d, 0x1a, 0x31, 0xf3, 0x97, 0xd2, 0x8e,
+	0x73, 0x93, 0x66, 0x3d, 0x16, 0x3d, 0xd6, 0x92, 0x16, 0xa2, 0xd3, 0x24, 0x86, 0x7e, 0x0b, 0xc5,
+	0x38, 0x6c, 0x4c, 0x34, 0xfc, 0x7f, 0x39, 0xcd, 0xcf, 0xe7, 0x69, 0xa8, 0x29, 0xc1, 0x31, 0x98,
+	0x65, 0x38, 0x53, 0x14, 0xe4, 0xc0, 0xaa, 0xe3, 0x32, 0x3b, 0x38, 0xa5, 0xd1, 0x68, 0x5c, 0x9f,
+	0x30, 0xf3, 0x57, 0x72, 0x09, 0x4f, 0xcb, 0xaa, 0x3e, 0x2e, 0x27, 0xeb, 0xe3, 0x72, 0x78, 0xd2,
+	0x13, 0x04, 0x56, 0x16, 0xf5, 0x71, 0xf9, 0xf4, 0x49, 0xb9, 0x49, 0x3a, 0xd4, 0x8b, 0x8b, 0x18,
+	0x0b, 0x8d, 0xf1, 0x62, 0x12, 0x43, 0x14, 0x50, 0x48, 0x78, 0x1f, 0xfb, 0xa2, 0xd8, 0xf0, 0xdc,
+	0xef, 0x65, 0x04, 0x30, 0xff, 0xe4, 0x5c, 0x1c, 0x7a, 0xe7, 0x2a, 0x64, 0x1a, 0x3e, 0x26, 0xbc,
+	0x7f, 0x98, 0x94, 0xb6, 0x8a, 0xe1, 0x34, 0x09, 0xe1, 0x49, 0x9c, 0x97, 0xf5, 0x75, 0x44, 0x79,
+	0x34, 0x8a, 0x43, 0xc9, 0xaf, 0xa5, 0xb6, 0xfb, 0xef, 0x89, 0x7a, 0xfb, 0xed, 0xf6, 0xb1, 0x25,
+	0x44, 0xc6, 0xd9, 0x40, 0xd4, 0xe3, 0x92, 0xa2, 0xc3, 0x48, 0x07, 0x0a, 0x76, 0x34, 0x0a, 0x79,
+	0x30, 0xe8, 0xc4, 0x47, 0xf1, 0xdf, 0x16, 0x25, 0xee, 0xb3, 0xb9, 0x2e, 0xa3, 0xe5, 0x8e, 0x23,
+	0xf7, 0x94, 0x70, 0xfa, 0x35, 0x8d, 0x2b, 0x8b, 0x95, 0x18, 0x51, 0x9f, 0xcc, 0x1e, 0x6c, 0x0c,
+	0x18, 0xc5, 0x71, 0xcd, 0xd8, 0xf3, 0x82, 0x0e, 0xf1, 0x62, 0x6d, 0xff, 0xae, 0xb4, 0xfd, 0x6c,
+	0xb6, 0xb6, 0x56, 0x5d, 0x57, 0xa6, 0x2f, 0xa4, 0x90, 0x56, 0xb0, 0x3e, 0x60, 0x74, 0x06, 0xbd,
+	0xf4, 0x77, 0x29, 0x58, 0x9b, 0x59, 0x85, 0xa0, 0x43, 0xc8, 0xc8, 0x72, 0x38, 0x25, 0xa3, 0xef,
+	0x57, 0x1f, 0x55, 0xca, 0x94, 0x65, 0x4d, 0x2c, 0x71, 0xb6, 0x6a, 0x90, 0x91, 0xa5, 0x70, 0x11,
+	0xf2, 0x56, 0xfd, 0xc5, 0x41, 0xab, 0x6d, 0x7d, 0x8b, 0x8f, 0x0e, 0x9b, 0xdf, 0x1a, 0x57, 0x50,
+	0x1e, 0x96, 0x2a, 0xcd, 0xe6, 0xd1, 0x1b, 0x5c, 0x39, 0xfc, 0xd6, 0x48, 0x6d, 0x65, 0xb2, 0x69,
+	0x23, 0xfd, 0xf8, 0xfa, 0xeb, 0x03, 0xab, 0xfd, 0xaa, 0xd2, 0xc4, 0xad, 0xba, 0xf5, 0xfa, 0xa0,
+	0x5a, 0x97, 0xcc, 0xa5, 0x7f, 0x48, 0x41, 0x61, 0x2a, 0xd3, 0x23, 0x04, 0x0b, 0x21, 0x1d, 0xc8,
+	0x89, 0x2e, 0xed, 0x5f, 0xb1, 0xc4, 0x07, 0xfa, 0x0c, 0x8a, 0x2c, 0x74, 0xbb, 0x5d, 0x8a, 0x3b,
+	0x43, 0xdf, 0xf1, 0x28, 0x1e, 0x46, 0x9e, 0x99, 0xd6, 0x1c, 0x05, 0x35, 0xb4, 0x27, 0x47, 0x5e,
+	0x45, 0x9e, 0x28, 0x65, 0x44, 0x44, 0xc1, 0xcc, 0xed, 0xf9, 0xe2, 0x68, 0x2d, 0xc8, 0x04, 0x9c,
+	0x13, 0xb4, 0x96, 0x22, 0x89, 0xeb, 0x47, 0xb2, 0x94, 0x61, 0x66, 0x46, 0xf2, 0x2c, 0x27, 0x6a,
+	0x18, 0xb6, 0x87, 0xc0, 0x48, 0x46, 0x26, 0x87, 0x70, 0x52, 0xfa, 0x01, 0x96, 0x93, 0x21, 0x18,
+	0xdd, 0x87, 0x15, 0x91, 0x1b, 0xb1, 0xe7, 0x0e, 0x5c, 0x2e, 0xa7, 0x95, 0x52, 0x17, 0x19, 0x41,
+	0x6d, 0x0a, 0xa2, 0x98, 0xd1, 0x0b, 0x40, 0x09, 0xae, 0xf8, 0xbe, 0x96, 0x9e, 0x97, 0x4f, 0x8d,
+	0x31, 0x88, 0xbe, 0xa7, 0x95, 0xfe, 0x3e, 0x05, 0x85, 0xa9, 0x60, 0x8d, 0xda, 0x90, 0x1d, 0xc7,
+	0xfb, 0xd4, 0x87, 0x79, 0xee, 0x14, 0x44, 0x79, 0x1c, 0xf8, 0xc7, 0x48, 0xe8, 0x3a, 0x5c, 0xed,
+	0x07, 0x8c, 0x33, 0x33, 0x2d, 0x2d, 0xa3, 0x3e, 0x4a, 0x3b, 0x90, 0x1d, 0xeb, 0xfd, 0x04, 0xf2,
+	0x71, 0xf2, 0x94, 0xf5, 0x83, 0x54, 0x9e, 0xb5, 0x96, 0x35, 0x51, 0x16, 0x1c, 0xa5, 0x3f, 0xa4,
+	0x20, 0x5d, 0xad, 0x20, 0x13, 0x16, 0x89, 0xe3, 0x08, 0x7f, 0xd5, 0xf6, 0x89, 0x3f, 0xd1, 0x11,
+	0x2c, 0x73, 0x8f, 0x4d, 0x32, 0x56, 0xfa, 0x5c, 0x1e, 0x9c, 0x79, 0xf1, 0x94, 0xd1, 0xbd, 0xdd,
+	0x6c, 0x8d, 0x67, 0x9d, 0xe3, 0x1e, 0x1b, 0x4f, 0x6b, 0x0f, 0x0a, 0x11, 0xfd, 0xf3, 0x21, 0x65,
+	0x13, 0x43, 0x2f, 0xcc, 0x2d, 0x5c, 0xb4, 0x44, 0x7c, 0x1d, 0xbe, 0x0b, 0x39, 0xa9, 0xdf, 0xc1,
+	0xcc, 0x75, 0xa8, 0xbc, 0xf9, 0x67, 0x2d, 0x50, 0xa4, 0x96, 0xeb, 0xd0, 0xd2, 0x7f, 0xdf, 0x81,
+	0xe2, 0x85, 0x60, 0x8f, 0x10, 0x64, 0x64, 0x05, 0xa1, 0x96, 0x28, 0x7f, 0xa3, 0xbf, 0x4a, 0xc1,
+	0x75, 0x75, 0xab, 0xa1, 0x67, 0x5c, 0x54, 0xe8, 0xfd, 0xef, 0x65, 0x24, 0xd3, 0x0b, 0xfd, 0xe6,
+	0xd2, 0x29, 0xa5, 0x2c, 0xaf, 0x40, 0x82, 0x1c, 0xf9, 0xc4, 0xab, 0x0c, 0x79, 0x3f, 0x88, 0x74,
+	0xb4, 0x94, 0xbd, 0x06, 0xcd, 0xb6, 0x7f, 0xc5, 0x2a, 0x52, 0xcd, 0x29, 0x98, 0xbe, 0x17, 0x83,
+	0x33, 0x67, 0xd3, 0x8b, 0x42, 0x5b, 0x9b, 0xe8, 0x27, 0x9d, 0xcd, 0x8b, 0x28, 0xb4, 0xdf, 0x39,
+	0x1b, 0x31, 0x88, 0x08, 0x5c, 0xfb, 0xde, 0x0d, 0x4f, 0x5c, 0x5f, 0x5a, 0x38, 0xb7, 0xfb, 0xe2,
+	0xf2, 0xea, 0xbf, 0x93, 0xf2, 0xfa, 0x1a, 0x9d, 0xd0, 0xa6, 0x81, 0xd1, 0xef, 0x60, 0xc9, 0x73,
+	0x7b, 0x7d, 0xce, 0x38, 0x0d, 0x65, 0x5f, 0x66, 0xd2, 0xd4, 0xb8, 0x84, 0x96, 0x66, 0x0c, 0x71,
+	0x51, 0xd1, 0x04, 0x1e, 0x39, 0xb0, 0x28, 0x62, 0x84, 0x13, 0xf4, 0x74, 0x67, 0x67, 0xff, 0xf2,
+	0x9a, 0x6a, 0x0a, 0xe0, 0xa2, 0x9e, 0x18, 0x1a, 0xb9, 0x90, 0x63, 0x9c, 0xd8, 0x27, 0x4e, 0xe4,
+	0x9e, 0xd2, 0xc8, 0x54, 0xd9, 0xa3, 0x7e, 0x79, 0x4d, 0xad, 0x09, 0x48, 0x42, 0x4d, 0x12, 0x1b,
+	0x45, 0x00, 0x41, 0x48, 0x7d, 0x9b, 0xfa, 0x6c, 0xc8, 0x64, 0xeb, 0x25, 0xb7, 0x7b, 0x7c, 0x79,
+	0x4d, 0x47, 0x21, 0xf5, 0xab, 0x12, 0xa3, 0xd2, 0x13, 0x27, 0xf7, 0xc2, 0xda, 0x12, 0x5a, 0xd0,
+	0x00, 0x80, 0x9d, 0x8c, 0xde, 0x12, 0x4f, 0x1c, 0x7a, 0xd9, 0xbd, 0xc9, 0xed, 0x7e, 0xfd, 0x11,
+	0xab, 0x3b, 0x19, 0xbd, 0x51, 0x18, 0x33, 0xd4, 0x4d, 0x14, 0x08, 0x75, 0x93, 0x8a, 0xd6, 0x84,
+	0x8f, 0x55, 0x97, 0xac, 0x6d, 0x79, 0xe4, 0xda, 0x2c, 0xa9, 0x6e, 0xa2, 0x00, 0xfd, 0x45, 0x0a,
+	0xd6, 0xd4, 0xf9, 0xeb, 0xba, 0xe2, 0xc2, 0x3e, 0xee, 0x97, 0x98, 0x39, 0xa9, 0xba, 0xf9, 0x91,
+	0x07, 0xf0, 0xb9, 0xeb, 0xd1, 0x71, 0x5f, 0x25, 0xa1, 0x1b, 0xd1, 0x0b, 0xa3, 0xa5, 0xbf, 0x4d,
+	0xc1, 0x83, 0x77, 0x9f, 0x5a, 0x4b, 0x45, 0xc2, 0xbd, 0xc0, 0x19, 0xa1, 0xc7, 0x50, 0x1c, 0x90,
+	0x33, 0x1c, 0x87, 0xd3, 0xce, 0x48, 0xdc, 0x77, 0x44, 0x70, 0xcb, 0x5b, 0x85, 0x01, 0x39, 0x8b,
+	0x59, 0x05, 0x19, 0xed, 0xc2, 0x1a, 0xf1, 0xbc, 0xe0, 0x2d, 0x0e, 0x49, 0xc4, 0x5d, 0xe2, 0xe1,
+	0x01, 0x65, 0x8c, 0xf4, 0xa8, 0x8c, 0x73, 0x59, 0x6b, 0x55, 0x0e, 0x1e, 0xab, 0xb1, 0x97, 0x6a,
+	0x08, 0x6d, 0x41, 0x3e, 0x24, 0xf6, 0x09, 0x26, 0x4c, 0x63, 0x2f, 0x48, 0xde, 0x9c, 0x20, 0x56,
+	0x98, 0xc4, 0x2d, 0xfd, 0xe3, 0x22, 0x3c, 0xfc, 0xb0, 0x88, 0x27, 0x92, 0x4c, 0xdc, 0x75, 0xd2,
+	0x49, 0x46, 0x7f, 0x8a, 0xc0, 0x2c, 0x1b, 0xb3, 0x69, 0x39, 0x77, 0xf9, 0x1b, 0x3d, 0x85, 0xc5,
+	0x38, 0x3f, 0x2c, 0xcd, 0xcb, 0x0f, 0x31, 0xa7, 0x48, 0x0c, 0xb2, 0xea, 0x0d, 0x23, 0xda, 0x75,
+	0xcf, 0xe4, 0x7c, 0x97, 0x2c, 0x10, 0xa4, 0x63, 0x49, 0x41, 0x37, 0x61, 0xa9, 0x4b, 0x5c, 0x0f,
+	0x0b, 0x8f, 0xd6, 0x79, 0x23, 0x2b, 0x08, 0xe2, 0x0c, 0xa0, 0x87, 0x50, 0x10, 0xd7, 0xcc, 0x21,
+	0xc3, 0x81, 0x8f, 0x69, 0x14, 0x05, 0x91, 0x0c, 0x49, 0x4b, 0x56, 0x5e, 0x91, 0x8f, 0xfc, 0xba,
+	0x20, 0xa2, 0x5f, 0x80, 0xe9, 0xfa, 0xb6, 0x37, 0x74, 0x28, 0xee, 0x53, 0x22, 0x8a, 0x7a, 0xec,
+	0xfa, 0xd8, 0xee, 0x53, 0xfb, 0xc4, 0xbc, 0x26, 0xd3, 0xf1, 0x9a, 0x1e, 0xdf, 0x57, 0xc3, 0x07,
+	0x7e, 0x55, 0x0c, 0xa2, 0xe7, 0xb0, 0x19, 0x0b, 0xc6, 0x9b, 0x76, 0x01, 0x00, 0x24, 0xc0, 0x2d,
+	0xcd, 0xa7, 0xf7, 0x70, 0x0a, 0xe7, 0xf7, 0x29, 0xf8, 0x24, 0x06, 0x22, 0x8e, 0xe3, 0x0a, 0x23,
+	0x10, 0xef, 0x22, 0x56, 0x4e, 0xde, 0x29, 0x7e, 0xf8, 0x63, 0xe5, 0xb0, 0xf2, 0x81, 0x9a, 0x43,
+	0x65, 0x3c, 0x85, 0xf3, 0xf3, 0xac, 0xfb, 0xa2, 0xb2, 0xbf, 0xeb, 0xbe, 0x9f, 0x0b, 0xfd, 0x4d,
+	0x0a, 0x6e, 0x4f, 0x9b, 0xa5, 0x13, 0x38, 0xa3, 0xc9, 0x3a, 0x96, 0xa5, 0x03, 0xbc, 0xf9, 0x29,
+	0xd7, 0x91, 0x38, 0x47, 0xd6, 0xc6, 0x79, 0x63, 0x0b, 0x5a, 0x3c, 0xb7, 0x5f, 0xc3, 0xad, 0xd8,
+	0xaa, 0x3c, 0xc0, 0xc3, 0x90, 0xf1, 0x88, 0x92, 0x81, 0xf0, 0x0f, 0x79, 0x60, 0xcc, 0x45, 0xb9,
+	0x5b, 0xa6, 0xe6, 0x69, 0x07, 0xaf, 0x34, 0xc7, 0x91, 0x5f, 0x11, 0xe3, 0xe8, 0x4f, 0xe1, 0x76,
+	0x42, 0xde, 0x09, 0xde, 0xfa, 0x13, 0x04, 0x87, 0xfa, 0x23, 0x33, 0x2b, 0x01, 0x36, 0xc6, 0x00,
+	0xb5, 0x31, 0xcb, 0x91, 0x5f, 0xa3, 0xfe, 0xa8, 0x64, 0xc1, 0xfd, 0x0f, 0x31, 0x33, 0x32, 0x60,
+	0xe1, 0x84, 0x8e, 0xf4, 0xc9, 0x12, 0x3f, 0x45, 0x89, 0x78, 0x2a, 0xee, 0xe1, 0xaa, 0x12, 0xb7,
+	0xd4, 0xc7, 0x57, 0xe9, 0x67, 0xa9, 0xd2, 0x7f, 0xa4, 0xdf, 0x77, 0x68, 0x93, 0x85, 0xc1, 0xc7,
+	0x1f, 0xda, 0xab, 0x1f, 0x7c, 0x68, 0xcf, 0x9d, 0xc9, 0x85, 0xf9, 0x67, 0x32, 0x33, 0xeb, 0x4c,
+	0xce, 0x77, 0xa2, 0x6b, 0xff, 0x57, 0x4e, 0x54, 0x3a, 0x81, 0xb5, 0x99, 0x75, 0xd0, 0x25, 0x8d,
+	0x7b, 0x1f, 0x56, 0x44, 0xb8, 0xe7, 0xa4, 0x87, 0x3d, 0xea, 0xf7, 0x78, 0x5f, 0x1a, 0x2b, 0x6f,
+	0x2d, 0x0f, 0xc8, 0x59, 0x9b, 0xf4, 0x9a, 0x92, 0x56, 0xfa, 0xeb, 0x14, 0x98, 0xef, 0xaa, 0x87,
+	0x2e, 0xa9, 0xf0, 0x1e, 0x2c, 0xeb, 0x0c, 0xc8, 0x83, 0x13, 0xbd, 0x37, 0x4b, 0x56, 0x4e, 0xd1,
+	0xda, 0x82, 0x34, 0x63, 0x4e, 0x99, 0x19, 0x73, 0xf2, 0x60, 0x7d, 0x76, 0xe1, 0xf4, 0x47, 0xb1,
+	0x80, 0x07, 0x1b, 0xef, 0x2c, 0x2f, 0x7e, 0x72, 0x0b, 0x94, 0xfe, 0x25, 0x0d, 0xab, 0x33, 0x6a,
+	0x35, 0x71, 0xfa, 0x1c, 0xda, 0x19, 0xf6, 0xf4, 0xb5, 0x4b, 0x7d, 0xa0, 0x36, 0x98, 0x62, 0x05,
+	0xfe, 0x70, 0xd0, 0xa1, 0x11, 0x0e, 0xba, 0x98, 0x70, 0x1e, 0xb9, 0x9d, 0xa1, 0xc8, 0xae, 0xea,
+	0xc6, 0x71, 0xf3, 0xc2, 0x89, 0x39, 0xf0, 0xf9, 0x97, 0x5f, 0xe8, 0x56, 0xdd, 0x80, 0x9c, 0x1d,
+	0x4a, 0xd9, 0xa3, 0x6e, 0x65, 0x2c, 0x89, 0x5e, 0xc3, 0xc6, 0x14, 0xaa, 0xef, 0x07, 0x5c, 0xba,
+	0x28, 0xd3, 0x57, 0x87, 0xf7, 0xc2, 0xae, 0x27, 0x61, 0x27, 0xa2, 0xe8, 0x37, 0x70, 0xeb, 0x3c,
+	0xae, 0x2e, 0x1a, 0x30, 0x3d, 0xa5, 0x3e, 0x67, 0xfa, 0x5a, 0xf0, 0x5e, 0x68, 0x33, 0x01, 0xad,
+	0xeb, 0x8a, 0xba, 0x14, 0x9e, 0xb1, 0x99, 0x57, 0x67, 0x6c, 0xe6, 0x1f, 0xd2, 0x70, 0xe7, 0xfd,
+	0x05, 0xea, 0x25, 0xb7, 0xf4, 0x2d, 0x2c, 0xda, 0x81, 0xcf, 0xe9, 0x19, 0x97, 0x8d, 0x87, 0x95,
+	0xdd, 0xdf, 0xfe, 0xd4, 0x15, 0x73, 0x59, 0x7c, 0xd3, 0xaa, 0x52, 0x62, 0xc5, 0xda, 0x3e, 0xec,
+	0xa8, 0x6c, 0x51, 0x58, 0x4e, 0x8a, 0xa3, 0x02, 0xe4, 0x5e, 0x1d, 0xb6, 0x8e, 0xeb, 0xd5, 0x83,
+	0xe7, 0x07, 0xf5, 0x9a, 0x71, 0x05, 0xad, 0x41, 0xf1, 0xcd, 0xd3, 0x2a, 0x6e, 0x5b, 0x95, 0x6a,
+	0x1d, 0x57, 0x8f, 0x0e, 0xdb, 0xf5, 0x6f, 0xda, 0x46, 0x0a, 0x2d, 0x43, 0xf6, 0x85, 0x75, 0x5c,
+	0xc5, 0x7b, 0x07, 0x87, 0x46, 0x1a, 0xdd, 0x80, 0xd5, 0x6a, 0xf3, 0xe8, 0x55, 0x6d, 0x8a, 0x6d,
+	0x01, 0x5d, 0x83, 0xf4, 0xde, 0x53, 0x23, 0x53, 0xba, 0x09, 0x1b, 0xef, 0xac, 0x89, 0x4b, 0x9f,
+	0x43, 0xe9, 0xdd, 0x55, 0xab, 0x34, 0x2a, 0xe1, 0xfd, 0xf8, 0x16, 0x2d, 0x7e, 0xef, 0x01, 0x64,
+	0xe3, 0x56, 0x69, 0x69, 0x00, 0xc6, 0x74, 0x17, 0x54, 0x6c, 0x51, 0xfc, 0xbe, 0x9a, 0x92, 0x09,
+	0x2f, 0xfe, 0x14, 0x23, 0x03, 0xa5, 0x5e, 0x77, 0x32, 0xe2, 0x4f, 0xf4, 0x00, 0x56, 0x26, 0xf5,
+	0x77, 0x4f, 0x88, 0xaa, 0x46, 0xd1, 0xe4, 0xc9, 0x55, 0x10, 0x4b, 0xff, 0x95, 0x82, 0xf5, 0xd9,
+	0xfd, 0x4a, 0xe4, 0x43, 0xfe, 0x7c, 0xfb, 0x53, 0x75, 0xd7, 0xf6, 0x3f, 0xae, 0xfd, 0x59, 0x3e,
+	0xf7, 0xd5, 0x1e, 0x85, 0xd4, 0x3a, 0x0f, 0xbf, 0x45, 0xa1, 0x78, 0x81, 0x07, 0xe5, 0x60, 0xb1,
+	0x56, 0x7f, 0x5e, 0x79, 0xd5, 0x6c, 0x1b, 0x57, 0x50, 0x16, 0x32, 0x87, 0x47, 0x87, 0x75, 0x23,
+	0x25, 0x7e, 0xed, 0x55, 0x5a, 0x75, 0x23, 0x8d, 0x8a, 0x90, 0x7f, 0x59, 0xb7, 0x5e, 0xd4, 0x71,
+	0xab, 0x59, 0x69, 0xed, 0xd7, 0x5b, 0xc6, 0x02, 0xba, 0x05, 0x66, 0xad, 0x5e, 0x3d, 0xaa, 0xd5,
+	0x71, 0xe5, 0xb0, 0x86, 0xcf, 0x8f, 0x66, 0x4a, 0x3f, 0x80, 0xf9, 0xae, 0xd6, 0x26, 0x7a, 0x04,
+	0x05, 0xfd, 0x10, 0x10, 0xf7, 0x38, 0x75, 0xfc, 0xd1, 0xef, 0x89, 0xb1, 0x20, 0x7a, 0x06, 0x10,
+	0x06, 0xf2, 0x6f, 0x0a, 0x1e, 0x19, 0xcd, 0x6f, 0x75, 0x2d, 0x09, 0xe6, 0x9a, 0xe0, 0xdd, 0x6a,
+	0xc0, 0xda, 0xcc, 0xd7, 0xf8, 0x8b, 0xae, 0xba, 0x08, 0x0b, 0x47, 0xcf, 0x9f, 0x1b, 0xa9, 0xa4,
+	0x0d, 0xd2, 0x08, 0xe0, 0x5a, 0xab, 0x6d, 0x1d, 0x54, 0xdb, 0xc6, 0xc2, 0xd6, 0x43, 0x00, 0x91,
+	0x50, 0x75, 0x13, 0x34, 0xb6, 0xce, 0x15, 0xb4, 0x02, 0xf0, 0xf2, 0x95, 0xec, 0x47, 0xb6, 0x9b,
+	0x2d, 0x23, 0xb5, 0xf5, 0x08, 0x8a, 0x17, 0x1e, 0xbc, 0x05, 0xbb, 0xf4, 0x6a, 0x69, 0xd6, 0x46,
+	0xeb, 0xe8, 0xd0, 0x48, 0x6d, 0xed, 0x42, 0x61, 0xea, 0x65, 0x0a, 0x21, 0x58, 0xa9, 0x1d, 0xe1,
+	0xc3, 0xa3, 0x36, 0x7e, 0x75, 0xfc, 0xc2, 0xaa, 0xd4, 0x04, 0x7e, 0x0e, 0x16, 0xe3, 0x8f, 0x54,
+	0x23, 0x93, 0x4d, 0x19, 0xe9, 0x46, 0x26, 0x9b, 0x36, 0x16, 0x1a, 0x99, 0xec, 0x82, 0x91, 0x69,
+	0x64, 0xb2, 0x9f, 0x1b, 0x4f, 0x1a, 0x99, 0xec, 0x86, 0x51, 0x6a, 0x64, 0xb2, 0x77, 0x8c, 0xbb,
+	0x8d, 0x4c, 0x16, 0x8c, 0x5c, 0x23, 0x93, 0xcd, 0x19, 0xcb, 0x8d, 0x4c, 0xb6, 0x60, 0x18, 0x8d,
+	0x4c, 0xd6, 0x30, 0x8a, 0x8d, 0x4c, 0x16, 0x19, 0xab, 0x8d, 0x4c, 0x76, 0xd5, 0xb8, 0xde, 0xc8,
+	0x64, 0xaf, 0x1b, 0x6b, 0x8d, 0x4c, 0x76, 0xcd, 0x58, 0x6f, 0x64, 0xb2, 0x37, 0x0c, 0xb3, 0x91,
+	0xc9, 0xde, 0x36, 0xee, 0x34, 0x32, 0xd9, 0x9f, 0x1b, 0x5f, 0x36, 0x32, 0xd9, 0x07, 0xc6, 0xc3,
+	0x46, 0x26, 0xfb, 0xd0, 0x78, 0xd4, 0xc8, 0x64, 0x1f, 0x19, 0xdb, 0x16, 0x1a, 0xb8, 0x67, 0x34,
+	0x52, 0xd5, 0x89, 0x7c, 0xe2, 0xa4, 0x91, 0xb5, 0xaa, 0x68, 0x11, 0x95, 0xaf, 0x93, 0x9a, 0xb8,
+	0x16, 0x3f, 0xbf, 0xab, 0xbe, 0xba, 0x92, 0x60, 0xd6, 0xf8, 0x55, 0x5e, 0xc9, 0xe8, 0xfe, 0xbb,
+	0x10, 0x64, 0xd6, 0x7a, 0x92, 0x15, 0x8f, 0xcb, 0x2b, 0xeb, 0x01, 0x73, 0x1d, 0x6a, 0x93, 0x48,
+	0x54, 0xa3, 0x9c, 0x7a, 0x74, 0x20, 0xfb, 0xf5, 0x8c, 0x32, 0xf9, 0xa0, 0x42, 0xba, 0x5d, 0xd7,
+	0x77, 0xf9, 0xc8, 0xca, 0x91, 0xa1, 0xb8, 0x45, 0xa9, 0xa7, 0xbd, 0x62, 0xe4, 0x4c, 0x5e, 0x1a,
+	0xa5, 0xbf, 0x58, 0x79, 0xa5, 0x52, 0x37, 0x09, 0xad, 0xf8, 0x5f, 0x06, 0xea, 0x65, 0x48, 0x36,
+	0xe5, 0xce, 0xcd, 0xd5, 0x5a, 0x66, 0x0e, 0xc3, 0x43, 0x87, 0x61, 0x11, 0x2d, 0xac, 0x22, 0xbb,
+	0x00, 0xb8, 0xae, 0x11, 0xc4, 0x88, 0x4c, 0xb5, 0x78, 0x10, 0x0c, 0x7d, 0x6e, 0x21, 0x29, 0xc8,
+	0x28, 0x3e, 0x79, 0xc6, 0x30, 0x23, 0xf8, 0x77, 0x6f, 0xb9, 0x55, 0xe2, 0x34, 0x1a, 0xc4, 0x8f,
+	0xb9, 0x4e, 0x44, 0x5c, 0x1f, 0xc7, 0x7f, 0x7b, 0xb2, 0xae, 0xc7, 0x36, 0xd1, 0x16, 0xec, 0x10,
+	0x6e, 0xf7, 0x2d, 0x33, 0xf9, 0x85, 0x45, 0x14, 0xa6, 0x3e, 0x8f, 0x5c, 0xca, 0xac, 0xb5, 0x0b,
+	0x23, 0xa2, 0x2a, 0xdd, 0xfa, 0x7d, 0x0a, 0x96, 0x93, 0x6f, 0xfa, 0xff, 0x9b, 0x0d, 0xd2, 0x63,
+	0xb8, 0xce, 0x86, 0x1d, 0x66, 0x47, 0x6e, 0x87, 0x3a, 0x38, 0xa2, 0xf1, 0xff, 0x0f, 0x54, 0xb6,
+	0xba, 0x3d, 0x33, 0x78, 0x59, 0x9a, 0xcb, 0x5a, 0x9d, 0x88, 0xc6, 0x34, 0xb6, 0xf5, 0x35, 0xe4,
+	0x12, 0x5d, 0x7c, 0x71, 0x49, 0x66, 0xd4, 0x8e, 0xa8, 0x7e, 0x4f, 0x55, 0xeb, 0x01, 0x45, 0x92,
+	0x4f, 0xa8, 0x37, 0x61, 0xc9, 0xf1, 0x99, 0x7a, 0xea, 0xd6, 0x51, 0x39, 0xeb, 0xf8, 0x4c, 0xbe,
+	0x72, 0x6f, 0xfd, 0x65, 0x1a, 0xd6, 0x67, 0x3f, 0x7b, 0x88, 0x7b, 0xb1, 0x30, 0xc5, 0xc0, 0x95,
+	0x4f, 0x73, 0xea, 0x6f, 0x50, 0xa7, 0x34, 0x62, 0x71, 0xe8, 0x5d, 0xb2, 0xd6, 0xb8, 0xc7, 0x5e,
+	0xba, 0x22, 0x91, 0xca, 0xd1, 0xd7, 0x6a, 0x70, 0x2c, 0x48, 0xce, 0x2e, 0x0a, 0xa6, 0x27, 0x82,
+	0xe4, 0x6c, 0x5a, 0xf0, 0x31, 0x14, 0x85, 0xa0, 0xed, 0x86, 0x7d, 0x1a, 0x61, 0x36, 0x74, 0x39,
+	0x8d, 0xdf, 0x13, 0x0a, 0xdc, 0x63, 0x55, 0x49, 0x6f, 0x49, 0x32, 0x7a, 0x09, 0x6b, 0xe3, 0xfb,
+	0x9b, 0xeb, 0x78, 0x74, 0xdc, 0x7e, 0xce, 0xcc, 0x0b, 0x7e, 0xab, 0xb1, 0xdc, 0x81, 0xe3, 0x51,
+	0xdd, 0x83, 0x7e, 0xbc, 0x09, 0xd9, 0xd8, 0xc2, 0xe8, 0x3a, 0x18, 0xf1, 0xbb, 0x49, 0xfc, 0xda,
+	0x62, 0x5c, 0xd9, 0xdb, 0xfe, 0xa7, 0x1f, 0xef, 0xa4, 0xfe, 0xf9, 0xc7, 0x3b, 0xa9, 0x7f, 0xfd,
+	0xf1, 0x4e, 0xea, 0xbb, 0x92, 0xda, 0x37, 0xf5, 0xd7, 0xb7, 0x9d, 0x73, 0xff, 0xbb, 0xeb, 0x5c,
+	0x93, 0x3a, 0x9f, 0xfe, 0x4f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x9b, 0xc8, 0xf1, 0xae, 0x00, 0x28,
+	0x00, 0x00,
 }
 
 func (m *MeshConfig) Marshal() (dAtA []byte, err error) {
@@ -3107,6 +3268,34 @@ func (m *MeshConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 		i -= len(m.XXX_unrecognized)
 		copy(dAtA[i:], m.XXX_unrecognized)
 	}
+	if m.MseIngressGlobalConfig != nil {
+		{
+			size, err := m.MseIngressGlobalConfig.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintConfig(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x3e
+		i--
+		dAtA[i] = 0xd2
+	}
+	if m.CryptombConfig != nil {
+		{
+			size, err := m.CryptombConfig.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintConfig(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x3e
+		i--
+		dAtA[i] = 0xca
+	}
 	if m.DefaultHttpRetryPolicy != nil {
 		{
 			size, err := m.DefaultHttpRetryPolicy.MarshalToSizedBuffer(dAtA[:i])
@@ -4727,20 +4916,20 @@ func (m *MeshConfig_ExtensionProvider_OpenCensusAgentTracingProvider) MarshalToS
 		dAtA[i] = 0x20
 	}
 	if len(m.Context) > 0 {
-		dAtA38 := make([]byte, len(m.Context)*10)
-		var j37 int
+		dAtA40 := make([]byte, len(m.Context)*10)
+		var j39 int
 		for _, num := range m.Context {
 			for num >= 1<<7 {
-				dAtA38[j37] = uint8(uint64(num)&0x7f | 0x80)
+				dAtA40[j39] = uint8(uint64(num)&0x7f | 0x80)
 				num >>= 7
-				j37++
+				j39++
 			}
-			dAtA38[j37] = uint8(num)
-			j37++
+			dAtA40[j39] = uint8(num)
+			j39++
 		}
-		i -= j37
-		copy(dAtA[i:], dAtA38[:j37])
-		i = encodeVarintConfig(dAtA, i, uint64(j37))
+		i -= j39
+		copy(dAtA[i:], dAtA40[:j39])
+		i = encodeVarintConfig(dAtA, i, uint64(j39))
 		i--
 		dAtA[i] = 0x1a
 	}
@@ -4906,6 +5095,55 @@ func (m *MeshConfig_ProxyPathNormalization) MarshalToSizedBuffer(dAtA []byte) (i
 	return len(dAtA) - i, nil
 }
 
+func (m *MeshConfig_CryptombPrivateKeyConfig) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *MeshConfig_CryptombPrivateKeyConfig) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *MeshConfig_CryptombPrivateKeyConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
+	var l int
+	_ = l
+	if m.XXX_unrecognized != nil {
+		i -= len(m.XXX_unrecognized)
+		copy(dAtA[i:], m.XXX_unrecognized)
+	}
+	if m.PoolDelay != nil {
+		{
+			size, err := m.PoolDelay.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintConfig(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x12
+	}
+	if m.EnableCryptomb {
+		i--
+		if m.EnableCryptomb {
+			dAtA[i] = 1
+		} else {
+			dAtA[i] = 0
+		}
+		i--
+		dAtA[i] = 0x8
+	}
+	return len(dAtA) - i, nil
+}
+
 func (m *ConfigSource) Marshal() (dAtA []byte, err error) {
 	size := m.Size()
 	dAtA = make([]byte, size)
@@ -4931,20 +5169,20 @@ func (m *ConfigSource) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 		copy(dAtA[i:], m.XXX_unrecognized)
 	}
 	if len(m.SubscribedResources) > 0 {
-		dAtA40 := make([]byte, len(m.SubscribedResources)*10)
-		var j39 int
+		dAtA43 := make([]byte, len(m.SubscribedResources)*10)
+		var j42 int
 		for _, num := range m.SubscribedResources {
 			for num >= 1<<7 {
-				dAtA40[j39] = uint8(uint64(num)&0x7f | 0x80)
+				dAtA43[j42] = uint8(uint64(num)&0x7f | 0x80)
 				num >>= 7
-				j39++
+				j42++
 			}
-			dAtA40[j39] = uint8(num)
-			j39++
+			dAtA43[j42] = uint8(num)
+			j42++
 		}
-		i -= j39
-		copy(dAtA[i:], dAtA40[:j39])
-		i = encodeVarintConfig(dAtA, i, uint64(j39))
+		i -= j42
+		copy(dAtA[i:], dAtA43[:j42])
+		i = encodeVarintConfig(dAtA, i, uint64(j42))
 		i--
 		dAtA[i] = 0x1a
 	}
@@ -5013,6 +5251,68 @@ func (m *Certificate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 	return len(dAtA) - i, nil
 }
 
+func (m *MSEIngressGlobalConfig) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *MSEIngressGlobalConfig) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *MSEIngressGlobalConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
+	var l int
+	_ = l
+	if m.XXX_unrecognized != nil {
+		i -= len(m.XXX_unrecognized)
+		copy(dAtA[i:], m.XXX_unrecognized)
+	}
+	if m.UpstreamIdleTimeout != nil {
+		{
+			size, err := m.UpstreamIdleTimeout.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintConfig(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x22
+	}
+	if len(m.TlsCipherSuites) > 0 {
+		for iNdEx := len(m.TlsCipherSuites) - 1; iNdEx >= 0; iNdEx-- {
+			i -= len(m.TlsCipherSuites[iNdEx])
+			copy(dAtA[i:], m.TlsCipherSuites[iNdEx])
+			i = encodeVarintConfig(dAtA, i, uint64(len(m.TlsCipherSuites[iNdEx])))
+			i--
+			dAtA[i] = 0x1a
+		}
+	}
+	if len(m.TlsMaxProtocolVersion) > 0 {
+		i -= len(m.TlsMaxProtocolVersion)
+		copy(dAtA[i:], m.TlsMaxProtocolVersion)
+		i = encodeVarintConfig(dAtA, i, uint64(len(m.TlsMaxProtocolVersion)))
+		i--
+		dAtA[i] = 0x12
+	}
+	if len(m.TlsMinProtocolVersion) > 0 {
+		i -= len(m.TlsMinProtocolVersion)
+		copy(dAtA[i:], m.TlsMinProtocolVersion)
+		i = encodeVarintConfig(dAtA, i, uint64(len(m.TlsMinProtocolVersion)))
+		i--
+		dAtA[i] = 0xa
+	}
+	return len(dAtA) - i, nil
+}
+
 func encodeVarintConfig(dAtA []byte, offset int, v uint64) int {
 	offset -= sovConfig(v)
 	base := offset
@@ -5210,6 +5510,14 @@ func (m *MeshConfig) Size() (n int) {
 		l = m.DefaultHttpRetryPolicy.Size()
 		n += 2 + l + sovConfig(uint64(l))
 	}
+	if m.CryptombConfig != nil {
+		l = m.CryptombConfig.Size()
+		n += 2 + l + sovConfig(uint64(l))
+	}
+	if m.MseIngressGlobalConfig != nil {
+		l = m.MseIngressGlobalConfig.Size()
+		n += 2 + l + sovConfig(uint64(l))
+	}
 	if m.XXX_unrecognized != nil {
 		n += len(m.XXX_unrecognized)
 	}
@@ -5851,6 +6159,25 @@ func (m *MeshConfig_ProxyPathNormalization) Size() (n int) {
 	return n
 }
 
+func (m *MeshConfig_CryptombPrivateKeyConfig) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if m.EnableCryptomb {
+		n += 2
+	}
+	if m.PoolDelay != nil {
+		l = m.PoolDelay.Size()
+		n += 1 + l + sovConfig(uint64(l))
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
 func (m *ConfigSource) Size() (n int) {
 	if m == nil {
 		return 0
@@ -5900,6 +6227,36 @@ func (m *Certificate) Size() (n int) {
 	return n
 }
 
+func (m *MSEIngressGlobalConfig) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	l = len(m.TlsMinProtocolVersion)
+	if l > 0 {
+		n += 1 + l + sovConfig(uint64(l))
+	}
+	l = len(m.TlsMaxProtocolVersion)
+	if l > 0 {
+		n += 1 + l + sovConfig(uint64(l))
+	}
+	if len(m.TlsCipherSuites) > 0 {
+		for _, s := range m.TlsCipherSuites {
+			l = len(s)
+			n += 1 + l + sovConfig(uint64(l))
+		}
+	}
+	if m.UpstreamIdleTimeout != nil {
+		l = m.UpstreamIdleTimeout.Size()
+		n += 1 + l + sovConfig(uint64(l))
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
 func sovConfig(x uint64) (n int) {
 	return (math_bits.Len64(x|1) + 6) / 7
 }
@@ -7250,9 +7607,81 @@ func (m *MeshConfig) Unmarshal(dAtA []byte) error {
 				return err
 			}
 			iNdEx = postIndex
-		default:
-			iNdEx = preIndex
-			skippy, err := skipConfig(dAtA[iNdEx:])
+		case 1001:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field CryptombConfig", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowConfig
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthConfig
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthConfig
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.CryptombConfig == nil {
+				m.CryptombConfig = &MeshConfig_CryptombPrivateKeyConfig{}
+			}
+			if err := m.CryptombConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 1002:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field MseIngressGlobalConfig", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowConfig
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthConfig
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthConfig
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.MseIngressGlobalConfig == nil {
+				m.MseIngressGlobalConfig = &MSEIngressGlobalConfig{}
+			}
+			if err := m.MseIngressGlobalConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipConfig(dAtA[iNdEx:])
 			if err != nil {
 				return err
 			}
@@ -10555,6 +10984,113 @@ func (m *MeshConfig_ProxyPathNormalization) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
+func (m *MeshConfig_CryptombPrivateKeyConfig) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowConfig
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: CryptombPrivateKeyConfig: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: CryptombPrivateKeyConfig: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field EnableCryptomb", wireType)
+			}
+			var v int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowConfig
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				v |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			m.EnableCryptomb = bool(v != 0)
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field PoolDelay", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowConfig
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthConfig
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthConfig
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.PoolDelay == nil {
+				m.PoolDelay = &types.Duration{}
+			}
+			if err := m.PoolDelay.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipConfig(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthConfig
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
 func (m *ConfigSource) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
@@ -10858,6 +11394,189 @@ func (m *Certificate) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
+func (m *MSEIngressGlobalConfig) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowConfig
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: MSEIngressGlobalConfig: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: MSEIngressGlobalConfig: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field TlsMinProtocolVersion", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowConfig
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthConfig
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthConfig
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.TlsMinProtocolVersion = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field TlsMaxProtocolVersion", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowConfig
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthConfig
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthConfig
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.TlsMaxProtocolVersion = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 3:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field TlsCipherSuites", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowConfig
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthConfig
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthConfig
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.TlsCipherSuites = append(m.TlsCipherSuites, string(dAtA[iNdEx:postIndex]))
+			iNdEx = postIndex
+		case 4:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field UpstreamIdleTimeout", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowConfig
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthConfig
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthConfig
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.UpstreamIdleTimeout == nil {
+				m.UpstreamIdleTimeout = &types.Duration{}
+			}
+			if err := m.UpstreamIdleTimeout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipConfig(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthConfig
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
 func skipConfig(dAtA []byte) (n int, err error) {
 	l := len(dAtA)
 	iNdEx := 0
diff --git a/mesh/v1alpha1/config.proto b/mesh/v1alpha1/config.proto
index 22ec9aed..dc8149c3 100644
--- a/mesh/v1alpha1/config.proto
+++ b/mesh/v1alpha1/config.proto
@@ -890,6 +890,17 @@ message MeshConfig {
   // All settings in the retry policy except `perTryTimeout` can currently be
   // configured globally via this field.
   istio.networking.v1alpha3.HTTPRetry default_http_retry_policy = 62;
+ 
+
+  message CryptombPrivateKeyConfig {
+        bool enable_cryptomb = 1;
+
+        google.protobuf.Duration pool_delay = 2;
+  }
+
+  CryptombPrivateKeyConfig cryptomb_config = 1001;
+
+  MSEIngressGlobalConfig mse_ingress_global_config = 1002;
 
   // $hide_from_docs
   // Next available field number: 63
@@ -986,3 +997,16 @@ message Certificate {
   // multiple DNS names.
   repeated string dns_names = 2;
 }
+
+message MSEIngressGlobalConfig {
+  // Control tls min protocol version for all gateways.
+  string tls_min_protocol_version = 1;
+
+  // Control tls max protocol version for all gateways.
+  string tls_max_protocol_version = 2;
+
+  // Control tls cipher suites for all gateways.
+  repeated string tls_cipher_suites = 3;
+
+  google.protobuf.Duration upstream_idle_timeout = 4;
+}
diff --git a/mesh/v1alpha1/istio.mesh.v1alpha1.gen.json b/mesh/v1alpha1/istio.mesh.v1alpha1.gen.json
index 0a50be13..7a372401 100644
--- a/mesh/v1alpha1/istio.mesh.v1alpha1.gen.json
+++ b/mesh/v1alpha1/istio.mesh.v1alpha1.gen.json
@@ -52,6 +52,29 @@
           }
         }
       },
+      "istio.mesh.v1alpha1.MSEIngressGlobalConfig": {
+        "type": "object",
+        "properties": {
+          "tlsMinProtocolVersion": {
+            "description": "Control tls min protocol version for all gateways.",
+            "type": "string"
+          },
+          "tlsMaxProtocolVersion": {
+            "description": "Control tls max protocol version for all gateways.",
+            "type": "string"
+          },
+          "tlsCipherSuites": {
+            "description": "Control tls cipher suites for all gateways.",
+            "type": "array",
+            "items": {
+              "type": "string"
+            }
+          },
+          "upstreamIdleTimeout": {
+            "type": "string"
+          }
+        }
+      },
       "istio.mesh.v1alpha1.MeshConfig": {
         "description": "MeshConfig defines mesh-wide settings for the Istio service mesh.",
         "type": "object",
@@ -247,6 +270,12 @@
           },
           "defaultHttpRetryPolicy": {
             "$ref": "#/components/schemas/istio.networking.v1alpha3.HTTPRetry"
+          },
+          "cryptombConfig": {
+            "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.CryptombPrivateKeyConfig"
+          },
+          "mseIngressGlobalConfig": {
+            "$ref": "#/components/schemas/istio.mesh.v1alpha1.MSEIngressGlobalConfig"
           }
         }
       },
@@ -355,6 +384,17 @@
           }
         ]
       },
+      "istio.mesh.v1alpha1.MeshConfig.CryptombPrivateKeyConfig": {
+        "type": "object",
+        "properties": {
+          "enableCryptomb": {
+            "type": "boolean"
+          },
+          "poolDelay": {
+            "type": "string"
+          }
+        }
+      },
       "istio.mesh.v1alpha1.MeshConfig.DefaultProviders": {
         "description": "Holds the name references to the providers that will be used by default in other Istio configuration resources if the provider is not specified.",
         "type": "object",
@@ -1205,6 +1245,13 @@
               "type": "string"
             }
           },
+          "runtimeValues": {
+            "description": "Envoy [runtime configuration](https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/operations/runtime) to set during bootstrapping. This enables setting experimental, unsafe, unsupported, and deprecated features that should be used with extreme caution.",
+            "type": "object",
+            "additionalProperties": {
+              "type": "string"
+            }
+          },
           "statusPort": {
             "description": "Port on which the agent should listen for administrative commands such as readiness probe. Default is set to port `15020`.",
             "type": "integer",
@@ -1248,6 +1295,17 @@
           },
           "image": {
             "$ref": "#/components/schemas/istio.mesh.v1alpha1.ProxyImage"
+          },
+          "logPath": {
+            "description": "Added by ingress Configure the log path for envoy proxy.",
+            "type": "string"
+          },
+          "xmoduleConfig": {
+            "$ref": "#/components/schemas/istio.mesh.v1alpha1.XModuleBootstrapConfig"
+          },
+          "disableAlpnH2": {
+            "description": "Disable apln h2 protocol for envoy proxy.",
+            "type": "boolean"
           }
         }
       },
@@ -1434,6 +1492,16 @@
                       "$ref": "#/components/schemas/istio.mesh.v1alpha1.Tracing.OpenCensusAgent"
                     }
                   }
+                },
+                {
+                  "required": [
+                    "eagleeye"
+                  ],
+                  "properties": {
+                    "eagleeye": {
+                      "$ref": "#/components/schemas/istio.mesh.v1alpha1.Tracing.EagleEye"
+                    }
+                  }
                 }
               ]
             }
@@ -1487,6 +1555,16 @@
                 "$ref": "#/components/schemas/istio.mesh.v1alpha1.Tracing.OpenCensusAgent"
               }
             }
+          },
+          {
+            "required": [
+              "eagleeye"
+            ],
+            "properties": {
+              "eagleeye": {
+                "$ref": "#/components/schemas/istio.mesh.v1alpha1.Tracing.EagleEye"
+              }
+            }
           }
         ]
       },
@@ -1572,6 +1650,27 @@
           }
         }
       },
+      "istio.mesh.v1alpha1.Tracing.EagleEye": {
+        "type": "object",
+        "properties": {
+          "turnOnRpcLog": {
+            "description": "The flag of open rpc logging. if not specified, the default is true.",
+            "type": "boolean"
+          },
+          "turnOnBusinessLog": {
+            "description": "The flag of open business logging. if not specified, the default is false.",
+            "type": "boolean"
+          },
+          "samplingInterval": {
+            "description": "Log sampling interval, value range [1, 9000].",
+            "type": "integer"
+          },
+          "passUserData": {
+            "description": "The flag that passes user data to the other end. if not specified, the default is true.",
+            "type": "boolean"
+          }
+        }
+      },
       "istio.mesh.v1alpha1.Tracing.Environment": {
         "description": "Environment is the proxy's environment variable to be used for populating the custom span tag. $hide_from_docs",
         "type": "object",
@@ -1687,6 +1786,68 @@
           }
         }
       },
+      "istio.mesh.v1alpha1.XModuleBootstrapConfig": {
+        "type": "object",
+        "properties": {
+          "configPath": {
+            "description": "XAgent module.json path",
+            "type": "string"
+          },
+          "configCheckRate": {
+            "description": "check XAgent module.json update interval",
+            "type": "integer"
+          },
+          "agentSock": {
+            "type": "string"
+          },
+          "punishCluster": {
+            "type": "string"
+          },
+          "punishHost": {
+            "description": "punish center host name",
+            "type": "string"
+          },
+          "x5Proxy": {
+            "description": "punish center uri prefix",
+            "type": "string"
+          },
+          "flowSlsProducer": {
+            "description": "log producer name",
+            "type": "string"
+          },
+          "slsPort": {
+            "description": "local watch dog port",
+            "type": "integer"
+          },
+          "decompressBufferSize": {
+            "description": "gzip decompress buffer size",
+            "type": "integer"
+          },
+          "sndbufSize": {
+            "description": "send buffer size",
+            "type": "integer"
+          },
+          "maxIpcLen": {
+            "type": "integer"
+          },
+          "abnormalReportEnable": {
+            "description": "enable abnormal req report",
+            "type": "boolean"
+          },
+          "cloudMode": {
+            "description": "enable cloud mode",
+            "type": "boolean"
+          },
+          "region": {
+            "description": "cloud mode region",
+            "type": "string"
+          },
+          "cluster": {
+            "description": "cloud mode cluster",
+            "type": "string"
+          }
+        }
+      },
       "istio.networking.v1alpha3.ClientTLSSettings": {
         "description": "SSL/TLS related settings for upstream connections. See Envoy's [TLS context](https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/transport_sockets/tls/v3/common.proto.html#common-tls-configuration) for more details. These settings are common to both HTTP and TCP upstreams.",
         "type": "object",
diff --git a/mesh/v1alpha1/istio.mesh.v1alpha1.pb.html b/mesh/v1alpha1/istio.mesh.v1alpha1.pb.html
index 56e36b2f..f5fe7630 100644
--- a/mesh/v1alpha1/istio.mesh.v1alpha1.pb.html
+++ b/mesh/v1alpha1/istio.mesh.v1alpha1.pb.html
@@ -5,7 +5,7 @@ location: https://istio.io/docs/reference/config/istio.mesh.v1alpha1.html
 layout: protoc-gen-docs
 generator: protoc-gen-docs
 weight: 20
-number_of_entries: 47
+number_of_entries: 51
 ---
 <p>Configuration affecting the service mesh as a whole.</p>
 
@@ -641,6 +641,24 @@ API.
 All settings in the retry policy except <code>perTryTimeout</code> can currently be
 configured globally via this field.</p>
 
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="MeshConfig-cryptomb_config">
+<td><code>cryptombConfig</code></td>
+<td><code><a href="#MeshConfig-CryptombPrivateKeyConfig">CryptombPrivateKeyConfig</a></code></td>
+<td>
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="MeshConfig-mse_ingress_global_config">
+<td><code>mseIngressGlobalConfig</code></td>
+<td><code><a href="#MSEIngressGlobalConfig">MSEIngressGlobalConfig</a></code></td>
+<td>
 </td>
 <td>
 No
@@ -757,6 +775,63 @@ No
 <p>The DNS names for the certificate. A certificate may contain
 multiple DNS names.</p>
 
+</td>
+<td>
+No
+</td>
+</tr>
+</tbody>
+</table>
+</section>
+<h2 id="MSEIngressGlobalConfig">MSEIngressGlobalConfig</h2>
+<section>
+<table class="message-fields">
+<thead>
+<tr>
+<th>Field</th>
+<th>Type</th>
+<th>Description</th>
+<th>Required</th>
+</tr>
+</thead>
+<tbody>
+<tr id="MSEIngressGlobalConfig-tls_min_protocol_version">
+<td><code>tlsMinProtocolVersion</code></td>
+<td><code>string</code></td>
+<td>
+<p>Control tls min protocol version for all gateways.</p>
+
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="MSEIngressGlobalConfig-tls_max_protocol_version">
+<td><code>tlsMaxProtocolVersion</code></td>
+<td><code>string</code></td>
+<td>
+<p>Control tls max protocol version for all gateways.</p>
+
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="MSEIngressGlobalConfig-tls_cipher_suites">
+<td><code>tlsCipherSuites</code></td>
+<td><code>string[]</code></td>
+<td>
+<p>Control tls cipher suites for all gateways.</p>
+
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="MSEIngressGlobalConfig-upstream_idle_timeout">
+<td><code>upstreamIdleTimeout</code></td>
+<td><code><a href="https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#duration">Duration</a></code></td>
+<td>
 </td>
 <td>
 No
@@ -1184,6 +1259,39 @@ No
 </tbody>
 </table>
 </section>
+<h2 id="MeshConfig-CryptombPrivateKeyConfig">MeshConfig.CryptombPrivateKeyConfig</h2>
+<section>
+<table class="message-fields">
+<thead>
+<tr>
+<th>Field</th>
+<th>Type</th>
+<th>Description</th>
+<th>Required</th>
+</tr>
+</thead>
+<tbody>
+<tr id="MeshConfig-CryptombPrivateKeyConfig-enable_cryptomb">
+<td><code>enableCryptomb</code></td>
+<td><code>bool</code></td>
+<td>
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="MeshConfig-CryptombPrivateKeyConfig-pool_delay">
+<td><code>poolDelay</code></td>
+<td><code><a href="https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#duration">Duration</a></code></td>
+<td>
+</td>
+<td>
+No
+</td>
+</tr>
+</tbody>
+</table>
+</section>
 <h2 id="MeshConfig-ServiceSettings-Settings">MeshConfig.ServiceSettings.Settings</h2>
 <section>
 <p>Settings for the selected services.</p>
@@ -2044,6 +2152,17 @@ No
 <td>
 <p>Use an OpenCensus tracer exporting to an OpenCensus agent.</p>
 
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="Tracing-eagleeye" class="oneof">
+<td><code>eagleeye</code></td>
+<td><code><a href="#Tracing-EagleEye">EagleEye (oneof)</a></code></td>
+<td>
+<p>Use a EagleEye tracer.</p>
+
 </td>
 <td>
 No
@@ -2110,6 +2229,180 @@ No
 <td>
 <p>Path of k8s service account JWT path.</p>
 
+</td>
+<td>
+No
+</td>
+</tr>
+</tbody>
+</table>
+</section>
+<h2 id="XModuleBootstrapConfig">XModuleBootstrapConfig</h2>
+<section>
+<table class="message-fields">
+<thead>
+<tr>
+<th>Field</th>
+<th>Type</th>
+<th>Description</th>
+<th>Required</th>
+</tr>
+</thead>
+<tbody>
+<tr id="XModuleBootstrapConfig-config_path">
+<td><code>configPath</code></td>
+<td><code>string</code></td>
+<td>
+<p>XAgent module.json path</p>
+
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="XModuleBootstrapConfig-config_check_rate">
+<td><code>configCheckRate</code></td>
+<td><code>uint32</code></td>
+<td>
+<p>check XAgent module.json update interval</p>
+
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="XModuleBootstrapConfig-agent_sock">
+<td><code>agentSock</code></td>
+<td><code>string</code></td>
+<td>
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="XModuleBootstrapConfig-punish_cluster">
+<td><code>punishCluster</code></td>
+<td><code>string</code></td>
+<td>
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="XModuleBootstrapConfig-punish_host">
+<td><code>punishHost</code></td>
+<td><code>string</code></td>
+<td>
+<p>punish center host name</p>
+
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="XModuleBootstrapConfig-x5_proxy">
+<td><code>x5Proxy</code></td>
+<td><code>string</code></td>
+<td>
+<p>punish center uri prefix</p>
+
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="XModuleBootstrapConfig-flow_sls_producer">
+<td><code>flowSlsProducer</code></td>
+<td><code>string</code></td>
+<td>
+<p>log producer name</p>
+
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="XModuleBootstrapConfig-sls_port">
+<td><code>slsPort</code></td>
+<td><code>uint32</code></td>
+<td>
+<p>local watch dog port</p>
+
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="XModuleBootstrapConfig-decompress_buffer_size">
+<td><code>decompressBufferSize</code></td>
+<td><code>uint32</code></td>
+<td>
+<p>gzip decompress buffer size</p>
+
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="XModuleBootstrapConfig-sndbuf_size">
+<td><code>sndbufSize</code></td>
+<td><code>uint32</code></td>
+<td>
+<p>send buffer size</p>
+
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="XModuleBootstrapConfig-max_ipc_len">
+<td><code>maxIpcLen</code></td>
+<td><code>uint32</code></td>
+<td>
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="XModuleBootstrapConfig-abnormal_report_enable">
+<td><code>abnormalReportEnable</code></td>
+<td><code>bool</code></td>
+<td>
+<p>enable abnormal req report</p>
+
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="XModuleBootstrapConfig-cloud_mode">
+<td><code>cloudMode</code></td>
+<td><code>bool</code></td>
+<td>
+<p>enable cloud mode</p>
+
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="XModuleBootstrapConfig-region">
+<td><code>region</code></td>
+<td><code>string</code></td>
+<td>
+<p>cloud mode region</p>
+
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="XModuleBootstrapConfig-cluster">
+<td><code>cluster</code></td>
+<td><code>string</code></td>
+<td>
+<p>cloud mode cluster</p>
+
 </td>
 <td>
 No
@@ -2392,6 +2685,18 @@ No
 <p>Additional environment variables for the proxy.
 Names starting with <code>ISTIO_META_</code> will be included in the generated bootstrap and sent to the XDS server.</p>
 
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="ProxyConfig-runtime_values">
+<td><code>runtimeValues</code></td>
+<td><code>map&lt;string,&nbsp;string&gt;</code></td>
+<td>
+<p>Envoy <a href="https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/operations/runtime">runtime configuration</a> to set during bootstrapping.
+This enables setting experimental, unsafe, unsupported, and deprecated features that should be used with extreme caution.</p>
+
 </td>
 <td>
 No
@@ -2520,6 +2825,40 @@ This includes the certificates defined in MeshConfig and any other certificates
 The plugin certificates (the &lsquo;cacerts&rsquo; secret), self-signed certificates (the &lsquo;istio-ca-secret&rsquo; secret)
 are added automatically by Istiod.</p>
 
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="ProxyConfig-log_path">
+<td><code>logPath</code></td>
+<td><code>string</code></td>
+<td>
+<p>Added by ingress
+Configure the log path for envoy proxy.</p>
+
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="ProxyConfig-xmodule_config">
+<td><code>xmoduleConfig</code></td>
+<td><code><a href="#XModuleBootstrapConfig">XModuleBootstrapConfig</a></code></td>
+<td>
+<p>Startup configuration of XModule(Alibaba Waf) filters.</p>
+
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="ProxyConfig-disable_alpn_h2">
+<td><code>disableAlpnH2</code></td>
+<td><code>bool</code></td>
+<td>
+<p>Disable apln h2 protocol for envoy proxy.</p>
+
 </td>
 <td>
 No
@@ -2749,6 +3088,65 @@ tracing. Default is <code>[&quot;W3C_TRACE_CONTEXT&quot;]</code>. If multiple va
 the proxy will attempt to read each header for each request and will
 write all headers.</p>
 
+</td>
+<td>
+No
+</td>
+</tr>
+</tbody>
+</table>
+</section>
+<h2 id="Tracing-EagleEye">Tracing.EagleEye</h2>
+<section>
+<table class="message-fields">
+<thead>
+<tr>
+<th>Field</th>
+<th>Type</th>
+<th>Description</th>
+<th>Required</th>
+</tr>
+</thead>
+<tbody>
+<tr id="Tracing-EagleEye-turn_on_rpc_log">
+<td><code>turnOnRpcLog</code></td>
+<td><code>bool</code></td>
+<td>
+<p>The flag of open rpc logging. if not specified, the default is true.</p>
+
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="Tracing-EagleEye-turn_on_business_log">
+<td><code>turnOnBusinessLog</code></td>
+<td><code>bool</code></td>
+<td>
+<p>The flag of open business logging. if not specified, the default is false.</p>
+
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="Tracing-EagleEye-sampling_interval">
+<td><code>samplingInterval</code></td>
+<td><code>uint32</code></td>
+<td>
+<p>Log sampling interval, value range [1, 9000].</p>
+
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="Tracing-EagleEye-pass_user_data">
+<td><code>passUserData</code></td>
+<td><code>bool</code></td>
+<td>
+<p>The flag that passes user data to the other end. if not specified, the default is true.</p>
+
 </td>
 <td>
 No
diff --git a/mesh/v1alpha1/proxy.pb.go b/mesh/v1alpha1/proxy.pb.go
index c23bdcfb..4c1d99ae 100644
--- a/mesh/v1alpha1/proxy.pb.go
+++ b/mesh/v1alpha1/proxy.pb.go
@@ -192,7 +192,7 @@ func (x ProxyConfig_InboundInterceptionMode) String() string {
 }
 
 func (ProxyConfig_InboundInterceptionMode) EnumDescriptor() ([]byte, []int) {
-	return fileDescriptor_5efecd978cf3d28d, []int{3, 0}
+	return fileDescriptor_5efecd978cf3d28d, []int{4, 0}
 }
 
 // Tracing defines configuration for the tracing performed by Envoy instances.
@@ -205,6 +205,7 @@ type Tracing struct {
 	//	*Tracing_Datadog_
 	//	*Tracing_Stackdriver_
 	//	*Tracing_OpenCensusAgent_
+	//	*Tracing_Eagleeye
 	Tracer isTracing_Tracer `protobuf_oneof:"tracer"`
 	// Configures the custom tags to be added to active span by all proxies (i.e. sidecars
 	// and gateways).
@@ -290,12 +291,16 @@ type Tracing_Stackdriver_ struct {
 type Tracing_OpenCensusAgent_ struct {
 	OpenCensusAgent *Tracing_OpenCensusAgent `protobuf:"bytes,9,opt,name=open_census_agent,json=openCensusAgent,proto3,oneof" json:"openCensusAgent,omitempty"`
 }
+type Tracing_Eagleeye struct {
+	Eagleeye *Tracing_EagleEye `protobuf:"bytes,10,opt,name=eagleeye,proto3,oneof" json:"eagleeye,omitempty"`
+}
 
 func (*Tracing_Zipkin_) isTracing_Tracer()          {}
 func (*Tracing_Lightstep_) isTracing_Tracer()       {}
 func (*Tracing_Datadog_) isTracing_Tracer()         {}
 func (*Tracing_Stackdriver_) isTracing_Tracer()     {}
 func (*Tracing_OpenCensusAgent_) isTracing_Tracer() {}
+func (*Tracing_Eagleeye) isTracing_Tracer()         {}
 
 func (m *Tracing) GetTracer() isTracing_Tracer {
 	if m != nil {
@@ -339,6 +344,13 @@ func (m *Tracing) GetOpenCensusAgent() *Tracing_OpenCensusAgent {
 	return nil
 }
 
+func (m *Tracing) GetEagleeye() *Tracing_EagleEye {
+	if x, ok := m.GetTracer().(*Tracing_Eagleeye); ok {
+		return x.Eagleeye
+	}
+	return nil
+}
+
 func (m *Tracing) GetCustomTags() map[string]*Tracing_CustomTag {
 	if m != nil {
 		return m.CustomTags
@@ -375,6 +387,7 @@ func (*Tracing) XXX_OneofWrappers() []interface{} {
 		(*Tracing_Datadog_)(nil),
 		(*Tracing_Stackdriver_)(nil),
 		(*Tracing_OpenCensusAgent_)(nil),
+		(*Tracing_Eagleeye)(nil),
 	}
 }
 
@@ -689,6 +702,81 @@ func (m *Tracing_OpenCensusAgent) GetContext() []Tracing_OpenCensusAgent_TraceCo
 	return nil
 }
 
+type Tracing_EagleEye struct {
+	// The flag of open rpc logging. if not specified, the default is true.
+	TurnOnRpcLog bool `protobuf:"varint,1,opt,name=turn_on_rpc_log,json=turnOnRpcLog,proto3" json:"turnOnRpcLog,omitempty"`
+	// The flag of open business logging. if not specified, the default is false.
+	TurnOnBusinessLog bool `protobuf:"varint,2,opt,name=turn_on_business_log,json=turnOnBusinessLog,proto3" json:"turnOnBusinessLog,omitempty"`
+	// Log sampling interval, value range [1, 9000].
+	SamplingInterval uint32 `protobuf:"varint,3,opt,name=sampling_interval,json=samplingInterval,proto3" json:"samplingInterval,omitempty"`
+	// The flag that passes user data to the other end. if not specified, the default is true.
+	PassUserData         bool     `protobuf:"varint,4,opt,name=pass_user_data,json=passUserData,proto3" json:"passUserData,omitempty"`
+	XXX_NoUnkeyedLiteral struct{} `json:"-"`
+	XXX_unrecognized     []byte   `json:"-"`
+	XXX_sizecache        int32    `json:"-"`
+}
+
+func (m *Tracing_EagleEye) Reset()         { *m = Tracing_EagleEye{} }
+func (m *Tracing_EagleEye) String() string { return proto.CompactTextString(m) }
+func (*Tracing_EagleEye) ProtoMessage()    {}
+func (*Tracing_EagleEye) Descriptor() ([]byte, []int) {
+	return fileDescriptor_5efecd978cf3d28d, []int{0, 5}
+}
+func (m *Tracing_EagleEye) XXX_Unmarshal(b []byte) error {
+	return m.Unmarshal(b)
+}
+func (m *Tracing_EagleEye) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	if deterministic {
+		return xxx_messageInfo_Tracing_EagleEye.Marshal(b, m, deterministic)
+	} else {
+		b = b[:cap(b)]
+		n, err := m.MarshalToSizedBuffer(b)
+		if err != nil {
+			return nil, err
+		}
+		return b[:n], nil
+	}
+}
+func (m *Tracing_EagleEye) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_Tracing_EagleEye.Merge(m, src)
+}
+func (m *Tracing_EagleEye) XXX_Size() int {
+	return m.Size()
+}
+func (m *Tracing_EagleEye) XXX_DiscardUnknown() {
+	xxx_messageInfo_Tracing_EagleEye.DiscardUnknown(m)
+}
+
+var xxx_messageInfo_Tracing_EagleEye proto.InternalMessageInfo
+
+func (m *Tracing_EagleEye) GetTurnOnRpcLog() bool {
+	if m != nil {
+		return m.TurnOnRpcLog
+	}
+	return false
+}
+
+func (m *Tracing_EagleEye) GetTurnOnBusinessLog() bool {
+	if m != nil {
+		return m.TurnOnBusinessLog
+	}
+	return false
+}
+
+func (m *Tracing_EagleEye) GetSamplingInterval() uint32 {
+	if m != nil {
+		return m.SamplingInterval
+	}
+	return 0
+}
+
+func (m *Tracing_EagleEye) GetPassUserData() bool {
+	if m != nil {
+		return m.PassUserData
+	}
+	return false
+}
+
 // Configure custom tags that will be added to any active span.
 // Tags can be generated via literals, environment variables or an incoming request header.
 // $hide_from_docs
@@ -709,7 +797,7 @@ func (m *Tracing_CustomTag) Reset()         { *m = Tracing_CustomTag{} }
 func (m *Tracing_CustomTag) String() string { return proto.CompactTextString(m) }
 func (*Tracing_CustomTag) ProtoMessage()    {}
 func (*Tracing_CustomTag) Descriptor() ([]byte, []int) {
-	return fileDescriptor_5efecd978cf3d28d, []int{0, 5}
+	return fileDescriptor_5efecd978cf3d28d, []int{0, 6}
 }
 func (m *Tracing_CustomTag) XXX_Unmarshal(b []byte) error {
 	return m.Unmarshal(b)
@@ -809,7 +897,7 @@ func (m *Tracing_Literal) Reset()         { *m = Tracing_Literal{} }
 func (m *Tracing_Literal) String() string { return proto.CompactTextString(m) }
 func (*Tracing_Literal) ProtoMessage()    {}
 func (*Tracing_Literal) Descriptor() ([]byte, []int) {
-	return fileDescriptor_5efecd978cf3d28d, []int{0, 6}
+	return fileDescriptor_5efecd978cf3d28d, []int{0, 7}
 }
 func (m *Tracing_Literal) XXX_Unmarshal(b []byte) error {
 	return m.Unmarshal(b)
@@ -863,7 +951,7 @@ func (m *Tracing_Environment) Reset()         { *m = Tracing_Environment{} }
 func (m *Tracing_Environment) String() string { return proto.CompactTextString(m) }
 func (*Tracing_Environment) ProtoMessage()    {}
 func (*Tracing_Environment) Descriptor() ([]byte, []int) {
-	return fileDescriptor_5efecd978cf3d28d, []int{0, 7}
+	return fileDescriptor_5efecd978cf3d28d, []int{0, 8}
 }
 func (m *Tracing_Environment) XXX_Unmarshal(b []byte) error {
 	return m.Unmarshal(b)
@@ -924,7 +1012,7 @@ func (m *Tracing_RequestHeader) Reset()         { *m = Tracing_RequestHeader{} }
 func (m *Tracing_RequestHeader) String() string { return proto.CompactTextString(m) }
 func (*Tracing_RequestHeader) ProtoMessage()    {}
 func (*Tracing_RequestHeader) Descriptor() ([]byte, []int) {
-	return fileDescriptor_5efecd978cf3d28d, []int{0, 8}
+	return fileDescriptor_5efecd978cf3d28d, []int{0, 9}
 }
 func (m *Tracing_RequestHeader) XXX_Unmarshal(b []byte) error {
 	return m.Unmarshal(b)
@@ -1105,6 +1193,177 @@ func (m *Topology) GetForwardClientCertDetails() Topology_ForwardClientCertDetai
 	return Topology_UNDEFINED
 }
 
+type XModuleBootstrapConfig struct {
+	// XAgent module.json path
+	ConfigPath string `protobuf:"bytes,1,opt,name=config_path,json=configPath,proto3" json:"configPath,omitempty"`
+	// check XAgent module.json update interval
+	ConfigCheckRate uint32 `protobuf:"varint,2,opt,name=config_check_rate,json=configCheckRate,proto3" json:"configCheckRate,omitempty"`
+	AgentSock       string `protobuf:"bytes,3,opt,name=agent_sock,json=agentSock,proto3" json:"agentSock,omitempty"`
+	PunishCluster   string `protobuf:"bytes,4,opt,name=punish_cluster,json=punishCluster,proto3" json:"punishCluster,omitempty"`
+	// punish center host name
+	PunishHost string `protobuf:"bytes,5,opt,name=punish_host,json=punishHost,proto3" json:"punishHost,omitempty"`
+	// punish center uri prefix
+	X5Proxy string `protobuf:"bytes,6,opt,name=x5_proxy,json=x5Proxy,proto3" json:"x5Proxy,omitempty"`
+	// log producer name
+	FlowSlsProducer string `protobuf:"bytes,7,opt,name=flow_sls_producer,json=flowSlsProducer,proto3" json:"flowSlsProducer,omitempty"`
+	// local watch dog port
+	SlsPort uint32 `protobuf:"varint,8,opt,name=sls_port,json=slsPort,proto3" json:"slsPort,omitempty"`
+	// gzip decompress buffer size
+	DecompressBufferSize uint32 `protobuf:"varint,9,opt,name=decompress_buffer_size,json=decompressBufferSize,proto3" json:"decompressBufferSize,omitempty"`
+	// send buffer size
+	SndbufSize uint32 `protobuf:"varint,10,opt,name=sndbuf_size,json=sndbufSize,proto3" json:"sndbufSize,omitempty"`
+	MaxIpcLen  uint32 `protobuf:"varint,11,opt,name=max_ipc_len,json=maxIpcLen,proto3" json:"maxIpcLen,omitempty"`
+	// enable abnormal req report
+	AbnormalReportEnable bool `protobuf:"varint,12,opt,name=abnormal_report_enable,json=abnormalReportEnable,proto3" json:"abnormalReportEnable,omitempty"`
+	// enable cloud mode
+	CloudMode bool `protobuf:"varint,13,opt,name=cloud_mode,json=cloudMode,proto3" json:"cloudMode,omitempty"`
+	// cloud mode region
+	Region string `protobuf:"bytes,14,opt,name=region,proto3" json:"region,omitempty"`
+	// cloud mode cluster
+	Cluster              string   `protobuf:"bytes,15,opt,name=cluster,proto3" json:"cluster,omitempty"`
+	XXX_NoUnkeyedLiteral struct{} `json:"-"`
+	XXX_unrecognized     []byte   `json:"-"`
+	XXX_sizecache        int32    `json:"-"`
+}
+
+func (m *XModuleBootstrapConfig) Reset()         { *m = XModuleBootstrapConfig{} }
+func (m *XModuleBootstrapConfig) String() string { return proto.CompactTextString(m) }
+func (*XModuleBootstrapConfig) ProtoMessage()    {}
+func (*XModuleBootstrapConfig) Descriptor() ([]byte, []int) {
+	return fileDescriptor_5efecd978cf3d28d, []int{3}
+}
+func (m *XModuleBootstrapConfig) XXX_Unmarshal(b []byte) error {
+	return m.Unmarshal(b)
+}
+func (m *XModuleBootstrapConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	if deterministic {
+		return xxx_messageInfo_XModuleBootstrapConfig.Marshal(b, m, deterministic)
+	} else {
+		b = b[:cap(b)]
+		n, err := m.MarshalToSizedBuffer(b)
+		if err != nil {
+			return nil, err
+		}
+		return b[:n], nil
+	}
+}
+func (m *XModuleBootstrapConfig) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_XModuleBootstrapConfig.Merge(m, src)
+}
+func (m *XModuleBootstrapConfig) XXX_Size() int {
+	return m.Size()
+}
+func (m *XModuleBootstrapConfig) XXX_DiscardUnknown() {
+	xxx_messageInfo_XModuleBootstrapConfig.DiscardUnknown(m)
+}
+
+var xxx_messageInfo_XModuleBootstrapConfig proto.InternalMessageInfo
+
+func (m *XModuleBootstrapConfig) GetConfigPath() string {
+	if m != nil {
+		return m.ConfigPath
+	}
+	return ""
+}
+
+func (m *XModuleBootstrapConfig) GetConfigCheckRate() uint32 {
+	if m != nil {
+		return m.ConfigCheckRate
+	}
+	return 0
+}
+
+func (m *XModuleBootstrapConfig) GetAgentSock() string {
+	if m != nil {
+		return m.AgentSock
+	}
+	return ""
+}
+
+func (m *XModuleBootstrapConfig) GetPunishCluster() string {
+	if m != nil {
+		return m.PunishCluster
+	}
+	return ""
+}
+
+func (m *XModuleBootstrapConfig) GetPunishHost() string {
+	if m != nil {
+		return m.PunishHost
+	}
+	return ""
+}
+
+func (m *XModuleBootstrapConfig) GetX5Proxy() string {
+	if m != nil {
+		return m.X5Proxy
+	}
+	return ""
+}
+
+func (m *XModuleBootstrapConfig) GetFlowSlsProducer() string {
+	if m != nil {
+		return m.FlowSlsProducer
+	}
+	return ""
+}
+
+func (m *XModuleBootstrapConfig) GetSlsPort() uint32 {
+	if m != nil {
+		return m.SlsPort
+	}
+	return 0
+}
+
+func (m *XModuleBootstrapConfig) GetDecompressBufferSize() uint32 {
+	if m != nil {
+		return m.DecompressBufferSize
+	}
+	return 0
+}
+
+func (m *XModuleBootstrapConfig) GetSndbufSize() uint32 {
+	if m != nil {
+		return m.SndbufSize
+	}
+	return 0
+}
+
+func (m *XModuleBootstrapConfig) GetMaxIpcLen() uint32 {
+	if m != nil {
+		return m.MaxIpcLen
+	}
+	return 0
+}
+
+func (m *XModuleBootstrapConfig) GetAbnormalReportEnable() bool {
+	if m != nil {
+		return m.AbnormalReportEnable
+	}
+	return false
+}
+
+func (m *XModuleBootstrapConfig) GetCloudMode() bool {
+	if m != nil {
+		return m.CloudMode
+	}
+	return false
+}
+
+func (m *XModuleBootstrapConfig) GetRegion() string {
+	if m != nil {
+		return m.Region
+	}
+	return ""
+}
+
+func (m *XModuleBootstrapConfig) GetCluster() string {
+	if m != nil {
+		return m.Cluster
+	}
+	return ""
+}
+
 // ProxyConfig defines variables for individual Envoy instances. This can be configured on a per-workload basis
 // as well as by the mesh-wide defaults.
 // To set the mesh wide defaults, configure the `defaultConfig` section of `meshConfig`. For example:
@@ -1212,6 +1471,9 @@ type ProxyConfig struct {
 	// Additional environment variables for the proxy.
 	// Names starting with `ISTIO_META_` will be included in the generated bootstrap and sent to the XDS server.
 	ProxyMetadata map[string]string `protobuf:"bytes,24,rep,name=proxy_metadata,json=proxyMetadata,proto3" json:"proxyMetadata,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
+	// Envoy [runtime configuration](https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/operations/runtime) to set during bootstrapping.
+	// This enables setting experimental, unsafe, unsupported, and deprecated features that should be used with extreme caution.
+	RuntimeValues map[string]string `protobuf:"bytes,37,rep,name=runtime_values,json=runtimeValues,proto3" json:"runtimeValues,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
 	// Port on which the agent should listen for administrative commands such as readiness probe.
 	// Default is set to port `15020`.
 	StatusPort int32 `protobuf:"varint,26,opt,name=status_port,json=statusPort,proto3" json:"statusPort,omitempty"`
@@ -1276,17 +1538,24 @@ type ProxyConfig struct {
 	CaCertificatesPem []string `protobuf:"bytes,34,rep,name=ca_certificates_pem,json=caCertificatesPem,proto3" json:"caCertificatesPem,omitempty"`
 	// Specifies the details of the proxy image.
 	// $hide_from_docs
-	Image                *ProxyImage `protobuf:"bytes,35,opt,name=image,proto3" json:"image,omitempty"`
-	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
-	XXX_unrecognized     []byte      `json:"-"`
-	XXX_sizecache        int32       `json:"-"`
+	Image *ProxyImage `protobuf:"bytes,35,opt,name=image,proto3" json:"image,omitempty"`
+	// Added by ingress
+	// Configure the log path for envoy proxy.
+	LogPath string `protobuf:"bytes,100,opt,name=log_path,json=logPath,proto3" json:"logPath,omitempty"`
+	// Startup configuration of XModule(Alibaba Waf) filters.
+	XmoduleConfig *XModuleBootstrapConfig `protobuf:"bytes,101,opt,name=xmodule_config,json=xmoduleConfig,proto3" json:"xmoduleConfig,omitempty"`
+	// Disable apln h2 protocol for envoy proxy.
+	DisableAlpnH2        bool     `protobuf:"varint,110,opt,name=disable_alpn_h2,json=disableAlpnH2,proto3" json:"disableAlpnH2,omitempty"`
+	XXX_NoUnkeyedLiteral struct{} `json:"-"`
+	XXX_unrecognized     []byte   `json:"-"`
+	XXX_sizecache        int32    `json:"-"`
 }
 
 func (m *ProxyConfig) Reset()         { *m = ProxyConfig{} }
 func (m *ProxyConfig) String() string { return proto.CompactTextString(m) }
 func (*ProxyConfig) ProtoMessage()    {}
 func (*ProxyConfig) Descriptor() ([]byte, []int) {
-	return fileDescriptor_5efecd978cf3d28d, []int{3}
+	return fileDescriptor_5efecd978cf3d28d, []int{4}
 }
 func (m *ProxyConfig) XXX_Unmarshal(b []byte) error {
 	return m.Unmarshal(b)
@@ -1480,6 +1749,13 @@ func (m *ProxyConfig) GetProxyMetadata() map[string]string {
 	return nil
 }
 
+func (m *ProxyConfig) GetRuntimeValues() map[string]string {
+	if m != nil {
+		return m.RuntimeValues
+	}
+	return nil
+}
+
 func (m *ProxyConfig) GetStatusPort() int32 {
 	if m != nil {
 		return m.StatusPort
@@ -1550,6 +1826,27 @@ func (m *ProxyConfig) GetImage() *ProxyImage {
 	return nil
 }
 
+func (m *ProxyConfig) GetLogPath() string {
+	if m != nil {
+		return m.LogPath
+	}
+	return ""
+}
+
+func (m *ProxyConfig) GetXmoduleConfig() *XModuleBootstrapConfig {
+	if m != nil {
+		return m.XmoduleConfig
+	}
+	return nil
+}
+
+func (m *ProxyConfig) GetDisableAlpnH2() bool {
+	if m != nil {
+		return m.DisableAlpnH2
+	}
+	return false
+}
+
 // Proxy stats name matchers for stats creation. Note this is in addition to
 // the minimum Envoy stats that Istio generates by default.
 type ProxyConfig_ProxyStatsMatcher struct {
@@ -1568,7 +1865,7 @@ func (m *ProxyConfig_ProxyStatsMatcher) Reset()         { *m = ProxyConfig_Proxy
 func (m *ProxyConfig_ProxyStatsMatcher) String() string { return proto.CompactTextString(m) }
 func (*ProxyConfig_ProxyStatsMatcher) ProtoMessage()    {}
 func (*ProxyConfig_ProxyStatsMatcher) Descriptor() ([]byte, []int) {
-	return fileDescriptor_5efecd978cf3d28d, []int{3, 1}
+	return fileDescriptor_5efecd978cf3d28d, []int{4, 2}
 }
 func (m *ProxyConfig_ProxyStatsMatcher) XXX_Unmarshal(b []byte) error {
 	return m.Unmarshal(b)
@@ -1638,7 +1935,7 @@ func (m *RemoteService) Reset()         { *m = RemoteService{} }
 func (m *RemoteService) String() string { return proto.CompactTextString(m) }
 func (*RemoteService) ProtoMessage()    {}
 func (*RemoteService) Descriptor() ([]byte, []int) {
-	return fileDescriptor_5efecd978cf3d28d, []int{4}
+	return fileDescriptor_5efecd978cf3d28d, []int{5}
 }
 func (m *RemoteService) XXX_Unmarshal(b []byte) error {
 	return m.Unmarshal(b)
@@ -1708,7 +2005,7 @@ func (m *ProxyImage) Reset()         { *m = ProxyImage{} }
 func (m *ProxyImage) String() string { return proto.CompactTextString(m) }
 func (*ProxyImage) ProtoMessage()    {}
 func (*ProxyImage) Descriptor() ([]byte, []int) {
-	return fileDescriptor_5efecd978cf3d28d, []int{5}
+	return fileDescriptor_5efecd978cf3d28d, []int{6}
 }
 func (m *ProxyImage) XXX_Unmarshal(b []byte) error {
 	return m.Unmarshal(b)
@@ -1756,14 +2053,17 @@ func init() {
 	proto.RegisterType((*Tracing_Datadog)(nil), "istio.mesh.v1alpha1.Tracing.Datadog")
 	proto.RegisterType((*Tracing_Stackdriver)(nil), "istio.mesh.v1alpha1.Tracing.Stackdriver")
 	proto.RegisterType((*Tracing_OpenCensusAgent)(nil), "istio.mesh.v1alpha1.Tracing.OpenCensusAgent")
+	proto.RegisterType((*Tracing_EagleEye)(nil), "istio.mesh.v1alpha1.Tracing.EagleEye")
 	proto.RegisterType((*Tracing_CustomTag)(nil), "istio.mesh.v1alpha1.Tracing.CustomTag")
 	proto.RegisterType((*Tracing_Literal)(nil), "istio.mesh.v1alpha1.Tracing.Literal")
 	proto.RegisterType((*Tracing_Environment)(nil), "istio.mesh.v1alpha1.Tracing.Environment")
 	proto.RegisterType((*Tracing_RequestHeader)(nil), "istio.mesh.v1alpha1.Tracing.RequestHeader")
 	proto.RegisterType((*SDS)(nil), "istio.mesh.v1alpha1.SDS")
 	proto.RegisterType((*Topology)(nil), "istio.mesh.v1alpha1.Topology")
+	proto.RegisterType((*XModuleBootstrapConfig)(nil), "istio.mesh.v1alpha1.XModuleBootstrapConfig")
 	proto.RegisterType((*ProxyConfig)(nil), "istio.mesh.v1alpha1.ProxyConfig")
 	proto.RegisterMapType((map[string]string)(nil), "istio.mesh.v1alpha1.ProxyConfig.ProxyMetadataEntry")
+	proto.RegisterMapType((map[string]string)(nil), "istio.mesh.v1alpha1.ProxyConfig.RuntimeValuesEntry")
 	proto.RegisterType((*ProxyConfig_ProxyStatsMatcher)(nil), "istio.mesh.v1alpha1.ProxyConfig.ProxyStatsMatcher")
 	proto.RegisterType((*RemoteService)(nil), "istio.mesh.v1alpha1.RemoteService")
 	proto.RegisterType((*ProxyImage)(nil), "istio.mesh.v1alpha1.ProxyImage")
@@ -1772,146 +2072,176 @@ func init() {
 func init() { proto.RegisterFile("mesh/v1alpha1/proxy.proto", fileDescriptor_5efecd978cf3d28d) }
 
 var fileDescriptor_5efecd978cf3d28d = []byte{
-	// 2210 bytes of a gzipped FileDescriptorProto
-	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x58, 0xdb, 0x72, 0x1b, 0xb9,
-	0xd1, 0x16, 0xa9, 0x23, 0x5b, 0x27, 0x0a, 0xb2, 0xec, 0x31, 0xd7, 0x07, 0x2d, 0xbd, 0xff, 0xfe,
-	0xb2, 0x77, 0x97, 0xaa, 0xb5, 0x12, 0x97, 0x93, 0xca, 0xa6, 0x4c, 0x91, 0x54, 0x44, 0x47, 0xa2,
-	0x58, 0x43, 0xca, 0x5e, 0x6b, 0x2f, 0x50, 0xe0, 0x0c, 0x38, 0x9c, 0x68, 0x06, 0x98, 0x60, 0x30,
-	0x92, 0xb8, 0x4f, 0x90, 0xa7, 0xc8, 0x5d, 0x6e, 0xf3, 0x04, 0x79, 0x80, 0x5c, 0xe6, 0x11, 0x52,
-	0xbe, 0xd9, 0xa4, 0xf2, 0x12, 0x29, 0x00, 0x33, 0x14, 0x25, 0x4b, 0xb4, 0x93, 0xdc, 0x11, 0x8d,
-	0xef, 0xfb, 0x06, 0x68, 0x74, 0x37, 0x1a, 0x84, 0xfb, 0x21, 0x8d, 0x07, 0xdb, 0x67, 0xdf, 0x92,
-	0x20, 0x1a, 0x90, 0x6f, 0xb7, 0x23, 0xc1, 0x2f, 0x86, 0x95, 0x48, 0x70, 0xc9, 0xd1, 0xba, 0x1f,
-	0x4b, 0x9f, 0x57, 0x14, 0xa0, 0x92, 0x01, 0x4a, 0x8f, 0x3c, 0xce, 0xbd, 0x80, 0x6e, 0x6b, 0x48,
-	0x2f, 0xe9, 0x6f, 0xbb, 0x89, 0x20, 0xd2, 0xe7, 0xcc, 0x90, 0x3e, 0x9c, 0x3f, 0x17, 0x24, 0x8a,
-	0xa8, 0x88, 0xd3, 0xf9, 0x67, 0x8c, 0xca, 0x73, 0x2e, 0x4e, 0x7d, 0xe6, 0x65, 0x5f, 0xdd, 0xd9,
-	0x76, 0x69, 0x2c, 0x7d, 0xa6, 0x65, 0xb0, 0x48, 0x02, 0x9a, 0x62, 0xb7, 0x6e, 0xc2, 0x2a, 0x43,
-	0xc0, 0x89, 0x8b, 0x3d, 0xc1, 0x93, 0xc8, 0x20, 0xcb, 0x7f, 0x5a, 0x81, 0xf9, 0xae, 0x20, 0x8e,
-	0xcf, 0x3c, 0xf4, 0x1d, 0xcc, 0xfd, 0xe8, 0x47, 0xa7, 0x3e, 0xb3, 0x72, 0x9b, 0xb9, 0xad, 0xc5,
-	0xe7, 0x4f, 0x2a, 0x37, 0xec, 0xa3, 0x92, 0xa2, 0x2b, 0x27, 0x1a, 0xba, 0x3f, 0x65, 0xa7, 0x24,
-	0xb4, 0x07, 0x85, 0xc0, 0xf7, 0x06, 0x32, 0x96, 0x34, 0xb2, 0xf2, 0x5a, 0xe1, 0xcb, 0x89, 0x0a,
-	0x07, 0x19, 0x7a, 0x7f, 0xca, 0xbe, 0xa4, 0xa2, 0x57, 0x30, 0xef, 0x12, 0x49, 0x5c, 0xee, 0x59,
-	0xd3, 0x5a, 0xe5, 0x8b, 0x89, 0x2a, 0x75, 0x83, 0xdd, 0x9f, 0xb2, 0x33, 0x1a, 0x3a, 0x80, 0xc5,
-	0x58, 0x12, 0xe7, 0xd4, 0x15, 0xfe, 0x19, 0x15, 0xd6, 0x8c, 0x56, 0xd9, 0x9a, 0xa8, 0xd2, 0xb9,
-	0xc4, 0xef, 0x4f, 0xd9, 0xe3, 0x74, 0x74, 0x02, 0x6b, 0x3c, 0xa2, 0x0c, 0x3b, 0x94, 0xc5, 0x49,
-	0x8c, 0x89, 0x47, 0x99, 0xb4, 0x0a, 0x5a, 0xf3, 0xeb, 0x89, 0x9a, 0x47, 0x11, 0x65, 0x35, 0x4d,
-	0xaa, 0x2a, 0xce, 0xfe, 0x94, 0xbd, 0xca, 0xaf, 0x9a, 0xd0, 0x21, 0x2c, 0x3a, 0x49, 0x2c, 0x79,
-	0x88, 0x25, 0xf1, 0x62, 0x6b, 0x76, 0x73, 0xfa, 0xa3, 0xaa, 0x35, 0x8d, 0xef, 0x12, 0x2f, 0x6e,
-	0x30, 0x29, 0x86, 0x36, 0x38, 0x23, 0x03, 0xfa, 0x06, 0xd6, 0x43, 0x72, 0x81, 0x23, 0x22, 0x07,
-	0x4a, 0x10, 0x07, 0x94, 0x79, 0x72, 0x60, 0xcd, 0x6d, 0xe6, 0xb6, 0x96, 0xed, 0x62, 0x48, 0x2e,
-	0xda, 0x44, 0x0e, 0xba, 0xc4, 0x3b, 0xd0, 0x76, 0x54, 0x82, 0x85, 0x98, 0x84, 0x51, 0xe0, 0x33,
-	0xcf, 0x9a, 0xdf, 0xcc, 0x6d, 0xe5, 0xec, 0xd1, 0x18, 0x1d, 0xc1, 0x92, 0x0c, 0x62, 0x1c, 0x53,
-	0x29, 0x7d, 0xe6, 0xc5, 0xd6, 0xc2, 0x95, 0x0d, 0x5f, 0xc6, 0x57, 0xb6, 0xc0, 0x9d, 0x4a, 0x2d,
-	0xf0, 0x29, 0x93, 0xdd, 0x83, 0x4e, 0x27, 0xe5, 0xd8, 0x8b, 0x32, 0x88, 0xb3, 0x41, 0xa9, 0x0c,
-	0x73, 0x26, 0x64, 0x90, 0x05, 0xf3, 0xc4, 0x75, 0x05, 0x8d, 0x63, 0x1d, 0x68, 0x05, 0x3b, 0x1b,
-	0x96, 0xf6, 0xa1, 0x30, 0x0a, 0x8a, 0xdb, 0x61, 0xe8, 0x73, 0x58, 0x22, 0x8e, 0x43, 0xe3, 0x18,
-	0x4b, 0x7e, 0x4a, 0x99, 0x0e, 0xb6, 0x82, 0xbd, 0x68, 0x6c, 0x5d, 0x65, 0x2a, 0x3d, 0x81, 0xf9,
-	0x34, 0x30, 0x26, 0x7c, 0xee, 0xcf, 0x79, 0x58, 0x1c, 0x3b, 0x78, 0x74, 0x07, 0x66, 0x5d, 0xda,
-	0x4b, 0x3c, 0x8d, 0x5b, 0xb0, 0xcd, 0x00, 0x75, 0xc1, 0x52, 0x4e, 0x65, 0x49, 0xd8, 0xa3, 0x02,
-	0xf3, 0x3e, 0x26, 0x52, 0x0a, 0xbf, 0x97, 0x48, 0x1a, 0xa7, 0x61, 0xfe, 0x59, 0xc5, 0xe4, 0x6e,
-	0x25, 0xcb, 0xdd, 0x4a, 0x93, 0xc9, 0x17, 0x3f, 0x7b, 0x43, 0x82, 0x84, 0xda, 0x1b, 0x21, 0xb9,
-	0x68, 0x69, 0xee, 0x51, 0xbf, 0x3a, 0x62, 0xa2, 0x37, 0x70, 0xff, 0x9a, 0x2a, 0x63, 0x5c, 0xea,
-	0x4c, 0x8e, 0xd3, 0xb8, 0x9f, 0x28, 0x7b, 0x77, 0x5c, 0xf6, 0x92, 0x8a, 0x7e, 0x80, 0x07, 0x57,
-	0x75, 0x43, 0x1a, 0xc7, 0xc4, 0xa3, 0x98, 0x9e, 0x51, 0x26, 0xe3, 0x34, 0x19, 0x26, 0x4a, 0x5b,
-	0x63, 0xd2, 0x87, 0x86, 0xdd, 0xd0, 0xe4, 0xd2, 0x4f, 0x39, 0x58, 0xbd, 0x16, 0xd5, 0x13, 0x8e,
-	0xa9, 0x03, 0xf3, 0x0e, 0x67, 0x92, 0x5e, 0x48, 0x2b, 0xbf, 0x39, 0xbd, 0xb5, 0xf2, 0xfc, 0x17,
-	0xff, 0x49, 0xba, 0x68, 0x3b, 0xad, 0x19, 0x01, 0x3b, 0x53, 0x2a, 0x53, 0x58, 0x1a, 0x9f, 0x40,
-	0xab, 0xb0, 0x78, 0xdc, 0xea, 0xb4, 0x1b, 0xb5, 0xe6, 0x5e, 0xb3, 0x51, 0x2f, 0x4e, 0xa1, 0x0d,
-	0x58, 0x7b, 0xbb, 0x53, 0xc3, 0x5d, 0xbb, 0x5a, 0x6b, 0xe0, 0xda, 0x51, 0xab, 0xdb, 0xf8, 0xbe,
-	0x5b, 0xcc, 0xa1, 0x25, 0x58, 0xf8, 0x8d, 0xdd, 0xae, 0xe1, 0xdd, 0x66, 0xab, 0x98, 0x47, 0xf7,
-	0x60, 0xbd, 0x76, 0x70, 0x74, 0x5c, 0xbf, 0x06, 0x9b, 0x46, 0x73, 0x90, 0xdf, 0xdd, 0x29, 0xce,
-	0x94, 0xfe, 0x99, 0x83, 0xc2, 0x28, 0xd3, 0x54, 0x49, 0x0a, 0x7c, 0x49, 0x05, 0x09, 0xd2, 0xd2,
-	0xf8, 0xc5, 0x47, 0x0a, 0x9b, 0xc6, 0xaa, 0x92, 0x94, 0xd2, 0x54, 0x49, 0xa2, 0xec, 0xcc, 0x17,
-	0x9c, 0x85, 0xaa, 0x7c, 0xe4, 0x3f, 0xa1, 0x24, 0x35, 0x2e, 0xf1, 0xaa, 0x24, 0x8d, 0xd1, 0x51,
-	0x1d, 0xe6, 0x06, 0x94, 0xb8, 0x54, 0xa4, 0x91, 0xf2, 0x6c, 0xa2, 0x90, 0x4d, 0x7f, 0x9f, 0xd0,
-	0x58, 0xee, 0x6b, 0x86, 0x2a, 0xd8, 0x86, 0xbb, 0x3b, 0x07, 0x33, 0x72, 0x18, 0xd1, 0xd2, 0x63,
-	0x98, 0x4f, 0x57, 0xac, 0x32, 0xe0, 0x4c, 0xc5, 0x40, 0x7a, 0x94, 0x66, 0x50, 0xda, 0x83, 0xc5,
-	0xb1, 0xc5, 0x20, 0x04, 0x33, 0x8c, 0x84, 0x19, 0x46, 0xff, 0x46, 0x4f, 0x60, 0xd9, 0xa5, 0x7d,
-	0x92, 0x04, 0x12, 0x1b, 0x01, 0x93, 0x93, 0x4b, 0xa9, 0x51, 0x07, 0x56, 0x69, 0x1f, 0x96, 0xaf,
-	0xac, 0xe5, 0xbf, 0x57, 0xa2, 0xb0, 0x7a, 0xad, 0x0e, 0xa2, 0x22, 0x4c, 0x9f, 0xd2, 0x61, 0x2a,
-	0xa5, 0x7e, 0xa2, 0x5f, 0x65, 0x9b, 0xf9, 0x94, 0xcb, 0x68, 0x24, 0x97, 0x6e, 0xfa, 0x97, 0xf9,
-	0x97, 0xb9, 0xdd, 0x05, 0x98, 0x93, 0x2a, 0xd8, 0x44, 0x79, 0x0f, 0xa6, 0x3b, 0xf5, 0x8e, 0x0a,
-	0x76, 0xca, 0x48, 0x2f, 0xa0, 0x6e, 0x5a, 0x23, 0xb2, 0x21, 0xfa, 0x3f, 0x58, 0x3d, 0x7d, 0x19,
-	0xe3, 0x98, 0xe0, 0xdf, 0x9d, 0x4b, 0x5d, 0x81, 0xb3, 0x85, 0x9f, 0xbe, 0x8c, 0x3b, 0xe4, 0xf5,
-	0xb9, 0x54, 0xb5, 0xb7, 0xfc, 0x97, 0x3c, 0x2c, 0x74, 0x79, 0xc4, 0x03, 0xee, 0x0d, 0x51, 0x05,
-	0xd6, 0x59, 0x12, 0x62, 0x29, 0x92, 0x58, 0x52, 0x17, 0xab, 0x16, 0xc2, 0xa7, 0x26, 0x8d, 0x96,
-	0xed, 0x35, 0x96, 0x84, 0x5d, 0x33, 0xd3, 0x36, 0x13, 0x28, 0x81, 0xcf, 0xfa, 0x5c, 0x9c, 0x13,
-	0xe1, 0x62, 0x47, 0x17, 0x5b, 0xec, 0x50, 0x21, 0xb1, 0x4b, 0x25, 0xf1, 0x03, 0x53, 0x8c, 0x56,
-	0x9e, 0xbf, 0xb8, 0x79, 0x9b, 0xe9, 0x37, 0x2b, 0x7b, 0x46, 0xc0, 0x14, 0xeb, 0x1a, 0x15, 0xb2,
-	0x6e, 0xd8, 0xb6, 0xd5, 0xbf, 0x65, 0xa6, 0xfc, 0x87, 0x1c, 0x58, 0xb7, 0xd1, 0xd0, 0x32, 0x14,
-	0x8e, 0x5b, 0xf5, 0xc6, 0x5e, 0xb3, 0xa5, 0xb3, 0x6f, 0x09, 0x16, 0x3a, 0xd5, 0x56, 0xb3, 0xdb,
-	0x3c, 0x69, 0x14, 0x73, 0xa8, 0x08, 0x4b, 0x7b, 0x47, 0xf6, 0xdb, 0xaa, 0x5d, 0xc7, 0x47, 0xad,
-	0x83, 0x77, 0xc5, 0x3c, 0x42, 0xb0, 0x52, 0x6d, 0xb7, 0x1b, 0xad, 0x3a, 0x4e, 0x27, 0x8a, 0xd3,
-	0x0a, 0x95, 0x71, 0x70, 0xa7, 0xd1, 0x2d, 0xce, 0xa8, 0xf4, 0xac, 0x1e, 0xbc, 0xad, 0xbe, 0xeb,
-	0xe0, 0x2b, 0xf4, 0xd9, 0xf2, 0x4f, 0x08, 0x16, 0x95, 0x37, 0x86, 0x35, 0xce, 0xfa, 0xbe, 0x87,
-	0x1e, 0xc3, 0xa2, 0xa3, 0x7f, 0x19, 0x8f, 0x9b, 0xc3, 0x07, 0x63, 0x52, 0xfe, 0x56, 0x80, 0x9e,
-	0xcf, 0x88, 0x18, 0x8e, 0x1f, 0x09, 0x18, 0x93, 0x06, 0xfc, 0x3f, 0xac, 0xc6, 0x54, 0x9c, 0xf9,
-	0x0e, 0xc5, 0x4e, 0xa0, 0xbc, 0x6d, 0x72, 0xaa, 0x60, 0xaf, 0xa4, 0xe6, 0x9a, 0xb1, 0xa2, 0x57,
-	0xb0, 0xe2, 0x0a, 0xe2, 0x33, 0x9c, 0xf5, 0x6d, 0x69, 0x29, 0xbd, 0xff, 0x41, 0x29, 0xad, 0xa7,
-	0x00, 0x7b, 0x59, 0x13, 0xb2, 0x21, 0xea, 0x80, 0x15, 0x11, 0xa1, 0x8e, 0x2d, 0x1e, 0x24, 0xd2,
-	0xe5, 0xe7, 0x63, 0x5a, 0xb3, 0x1f, 0xd3, 0xba, 0x6b, 0xa8, 0x9d, 0x94, 0x39, 0x12, 0xfd, 0x0a,
-	0xd6, 0x5c, 0x3f, 0x76, 0xf8, 0x19, 0x15, 0x43, 0x9c, 0x15, 0xe2, 0x39, 0xbd, 0x83, 0xe2, 0x68,
-	0xa2, 0x9a, 0x56, 0xe4, 0x63, 0xb8, 0x77, 0x09, 0x16, 0xb4, 0x2f, 0x68, 0x3c, 0xc0, 0x2e, 0x0d,
-	0xc8, 0x50, 0xdf, 0xff, 0x93, 0x16, 0xb0, 0x9b, 0xb7, 0x72, 0xf6, 0xc6, 0x88, 0x6d, 0x1b, 0x72,
-	0x5d, 0x71, 0xd1, 0x53, 0x58, 0x31, 0x3d, 0xe0, 0x68, 0x01, 0xaa, 0x5b, 0x28, 0x68, 0xca, 0xb2,
-	0x99, 0xc9, 0x56, 0xf0, 0x35, 0xa0, 0x58, 0x12, 0x19, 0xbb, 0x38, 0x71, 0xa3, 0x11, 0x1c, 0xcc,
-	0x7a, 0xcd, 0xcc, 0xb1, 0x1b, 0x65, 0xe8, 0x06, 0x3c, 0xa4, 0xec, 0x8c, 0x0f, 0x71, 0x48, 0xa5,
-	0xf0, 0x1d, 0xd5, 0x8e, 0x98, 0xa3, 0xca, 0x88, 0x77, 0x46, 0xdf, 0x29, 0x69, 0xe0, 0xa1, 0xc1,
-	0x75, 0x0c, 0x2c, 0x93, 0xd9, 0x82, 0xa2, 0x6e, 0xcf, 0x31, 0x71, 0x43, 0x9f, 0xe1, 0x88, 0x0b,
-	0x69, 0x2d, 0x6e, 0xe6, 0xb6, 0x66, 0xed, 0x15, 0x6d, 0xaf, 0x2a, 0x73, 0x9b, 0x0b, 0x89, 0xb6,
-	0x61, 0x8d, 0x9c, 0x11, 0x3f, 0x20, 0x3d, 0x3f, 0xf0, 0xe5, 0x10, 0xff, 0xc8, 0x19, 0xb5, 0x96,
-	0x46, 0x1f, 0x29, 0x8e, 0x4f, 0x9e, 0x70, 0x46, 0x91, 0x0b, 0xf7, 0xd5, 0xcd, 0x24, 0x78, 0x80,
-	0xa3, 0x80, 0x30, 0x8a, 0x49, 0x22, 0x07, 0x38, 0xe2, 0x81, 0xef, 0x0c, 0xad, 0x65, 0x9d, 0x90,
-	0x4f, 0x6f, 0x4c, 0xc8, 0x6a, 0x22, 0x07, 0x94, 0x49, 0xdf, 0xd1, 0xde, 0x6d, 0x6b, 0x82, 0x7d,
-	0x37, 0xd5, 0x6a, 0x2b, 0x29, 0x85, 0x30, 0x76, 0xe5, 0xb5, 0xb4, 0x4d, 0x4c, 0xa3, 0xbd, 0xef,
-	0x07, 0xd4, 0x5a, 0x31, 0x5e, 0x33, 0x33, 0x26, 0x21, 0xf6, 0xfc, 0x80, 0xaa, 0xed, 0x2a, 0x4f,
-	0x62, 0x55, 0x4e, 0xb3, 0x16, 0x70, 0xd5, 0x6c, 0x57, 0xd9, 0x5b, 0x24, 0xa4, 0x69, 0x03, 0xf8,
-	0x9d, 0x4e, 0x1f, 0x27, 0x11, 0x82, 0x32, 0x67, 0x68, 0x15, 0x6f, 0xef, 0x0d, 0x76, 0x9e, 0x9b,
-	0xde, 0x60, 0x1c, 0x8f, 0xaa, 0xf0, 0xd0, 0xf8, 0xb5, 0xc7, 0xb9, 0x8c, 0xa5, 0x20, 0x11, 0x96,
-	0x34, 0x8c, 0x02, 0x22, 0xa9, 0x49, 0xb7, 0x35, 0xbd, 0xc2, 0x92, 0x06, 0xed, 0x66, 0x98, 0x6e,
-	0x0a, 0xd1, 0xe9, 0x47, 0x61, 0xcd, 0x67, 0x92, 0x0a, 0x87, 0x46, 0xfa, 0x11, 0x13, 0x72, 0x97,
-	0x5a, 0x48, 0xfb, 0xed, 0xe5, 0x8d, 0x7e, 0x1b, 0xcb, 0xfe, 0x4a, 0x93, 0xf5, 0x78, 0xc2, 0xdc,
-	0xe6, 0x98, 0xc0, 0x21, 0x77, 0xa9, 0x5d, 0xf4, 0xaf, 0x59, 0xd0, 0x0b, 0x98, 0x97, 0xa6, 0xd0,
-	0x5b, 0xeb, 0x7a, 0x93, 0x0f, 0x26, 0x5d, 0x06, 0x76, 0x06, 0x46, 0xcf, 0x60, 0x3a, 0x76, 0x63,
-	0x6b, 0x43, 0x73, 0xac, 0x1b, 0x39, 0x9d, 0x7a, 0xc7, 0x56, 0x20, 0xf4, 0x03, 0x58, 0x26, 0x58,
-	0xd3, 0xde, 0x34, 0xe0, 0x5e, 0x16, 0xaf, 0xd6, 0x5d, 0x2d, 0x50, 0xbe, 0x51, 0xc0, 0xa6, 0x21,
-	0x97, 0x34, 0x0d, 0x59, 0x7b, 0x43, 0x6b, 0x54, 0xb5, 0xc4, 0x01, 0xf7, 0x52, 0x33, 0x7a, 0x03,
-	0x1b, 0x37, 0x66, 0x82, 0x75, 0xef, 0x93, 0x95, 0xd7, 0x6f, 0xc8, 0x10, 0x74, 0x02, 0x26, 0x05,
-	0x94, 0x2e, 0x51, 0xef, 0x27, 0xcb, 0xd2, 0x6f, 0x90, 0x9d, 0x8f, 0x3a, 0x5f, 0xff, 0x3e, 0x4c,
-	0x59, 0xe6, 0x29, 0xb2, 0x1c, 0x8d, 0xdb, 0x54, 0xed, 0x55, 0xf1, 0x96, 0xc4, 0x26, 0xe3, 0x4a,
-	0x3a, 0x04, 0xc1, 0x98, 0x74, 0xb6, 0x7d, 0x09, 0xab, 0xf4, 0x42, 0x0a, 0x82, 0x75, 0xb8, 0xea,
-	0x17, 0xd0, 0x67, 0x9b, 0xd3, 0x5b, 0x05, 0x7b, 0x59, 0x9b, 0x3b, 0x92, 0x48, 0xfd, 0xac, 0xd9,
-	0x87, 0xa2, 0x47, 0x24, 0x3d, 0x27, 0x43, 0x2c, 0xd3, 0x7b, 0xcc, 0x7a, 0xa0, 0xf7, 0xfd, 0x70,
-	0xe2, 0x65, 0x67, 0xaf, 0xa6, 0xb4, 0xd1, 0x8d, 0xfb, 0x16, 0x4a, 0x92, 0x8a, 0x30, 0x7b, 0x32,
-	0x5f, 0x2b, 0xe8, 0x0f, 0x3f, 0x56, 0x84, 0xad, 0x31, 0x72, 0xfd, 0x4a, 0x6d, 0xbf, 0x07, 0xf3,
-	0x6a, 0x0d, 0xd8, 0x77, 0xad, 0x47, 0x3a, 0xe8, 0xe7, 0xd4, 0xb0, 0xe9, 0x22, 0x1b, 0x56, 0x05,
-	0x25, 0xae, 0xcf, 0x54, 0x48, 0x44, 0x82, 0xf7, 0xa8, 0xf5, 0x58, 0x7f, 0xe6, 0xe9, 0x84, 0xa7,
-	0x94, 0x9d, 0x31, 0xda, 0x8a, 0x60, 0xaf, 0x88, 0x2b, 0x63, 0xd4, 0x83, 0x75, 0x73, 0x68, 0xba,
-	0x60, 0xe2, 0x90, 0x48, 0x67, 0x40, 0x85, 0xb5, 0xa9, 0x75, 0x9f, 0x7f, 0xda, 0xc9, 0x29, 0xe7,
-	0xc6, 0x87, 0x86, 0x69, 0xaf, 0x45, 0xd7, 0x4d, 0x68, 0x00, 0x4f, 0x06, 0x3c, 0x70, 0x31, 0x89,
-	0xa2, 0x20, 0x2d, 0x52, 0x38, 0x61, 0xd2, 0x0f, 0xf0, 0xe8, 0xd3, 0x42, 0xc6, 0xd6, 0xe7, 0xfa,
-	0x9b, 0xa5, 0x0f, 0x5c, 0xb6, 0xcb, 0x79, 0x60, 0x2a, 0xc6, 0x63, 0x25, 0x53, 0xbd, 0x54, 0x39,
-	0x56, 0x22, 0xd9, 0x12, 0x84, 0x8c, 0x55, 0x17, 0xe4, 0x10, 0xdd, 0xc9, 0xf8, 0x7d, 0x85, 0xa1,
-	0x31, 0x8e, 0x68, 0x68, 0x95, 0x75, 0x24, 0xac, 0x39, 0xa4, 0x36, 0x36, 0xd3, 0xa6, 0x21, 0xfa,
-	0x39, 0xcc, 0xfa, 0x21, 0xf1, 0xa8, 0xf5, 0x44, 0x7f, 0xfb, 0xf1, 0xed, 0xfb, 0x6d, 0x2a, 0x98,
-	0x6d, 0xd0, 0xa5, 0x57, 0x80, 0x3e, 0x0c, 0xd9, 0x1b, 0xba, 0xc6, 0x3b, 0xe3, 0x5d, 0x63, 0x61,
-	0xac, 0x1b, 0x2c, 0xfd, 0x31, 0x07, 0x6b, 0x1f, 0xf8, 0x0e, 0x7d, 0x03, 0xc8, 0x67, 0xaa, 0x75,
-	0x50, 0x1e, 0x8a, 0x04, 0xed, 0xfb, 0x17, 0xba, 0x87, 0xd3, 0xab, 0x1f, 0xcd, 0xb4, 0xd3, 0x89,
-	0xab, 0xf0, 0x38, 0xe9, 0x1b, 0x78, 0xfe, 0x1a, 0xbc, 0x93, 0x4e, 0xa8, 0xeb, 0xfd, 0x12, 0x2e,
-	0xa8, 0x47, 0x2f, 0x22, 0xf5, 0x3c, 0x54, 0xe8, 0xe2, 0x68, 0xc2, 0x36, 0xf6, 0xf2, 0x0e, 0xdc,
-	0xbb, 0xa5, 0x24, 0xaa, 0xbe, 0xcc, 0x6e, 0xd4, 0x9b, 0x76, 0xa3, 0xd6, 0x2d, 0x4e, 0x21, 0x80,
-	0xb9, 0x6e, 0xdb, 0x3e, 0xfa, 0xfe, 0x5d, 0x31, 0xf7, 0x7a, 0x66, 0xa1, 0x50, 0x04, 0x7b, 0xd5,
-	0xe1, 0x8c, 0x51, 0x47, 0x62, 0xe9, 0x87, 0x94, 0x27, 0xb2, 0xfc, 0xaf, 0x9c, 0x6a, 0xd6, 0xc7,
-	0xea, 0xc7, 0x84, 0x87, 0xde, 0xf5, 0xff, 0x0a, 0xf2, 0xff, 0xe3, 0x7f, 0x05, 0x88, 0xc3, 0xb2,
-	0x74, 0x22, 0x7c, 0x4a, 0x69, 0x44, 0x02, 0xff, 0x8c, 0xa6, 0xcf, 0x9c, 0xd7, 0x93, 0x14, 0xcd,
-	0xfa, 0xf5, 0x5d, 0xca, 0x83, 0x4c, 0xa9, 0xd2, 0xad, 0xb5, 0x2f, 0x7f, 0x3b, 0xd1, 0x6f, 0x33,
-	0x45, 0x7b, 0x49, 0x8e, 0x8d, 0xca, 0x5f, 0x01, 0x5c, 0x46, 0x0c, 0x7a, 0x08, 0xa0, 0x63, 0x06,
-	0xab, 0xe7, 0x51, 0xba, 0xd9, 0x82, 0xb6, 0x74, 0x87, 0x11, 0x7d, 0xf6, 0x6b, 0xb8, 0x73, 0xd3,
-	0xed, 0x8d, 0x16, 0x60, 0xa6, 0x75, 0xd4, 0x6a, 0x14, 0xa7, 0xd0, 0x0a, 0xc0, 0xe1, 0x71, 0xf7,
-	0xb8, 0x7a, 0x80, 0xbb, 0x07, 0x1d, 0xfd, 0xf8, 0x9c, 0x6f, 0xb6, 0xf6, 0x1b, 0x76, 0xb3, 0x5b,
-	0xfc, 0xc7, 0xfc, 0xee, 0xd6, 0x5f, 0xdf, 0x3f, 0xca, 0xfd, 0xed, 0xfd, 0xa3, 0xdc, 0xdf, 0xdf,
-	0x3f, 0xca, 0x9d, 0x94, 0xcc, 0x9e, 0x7c, 0xbe, 0x4d, 0x22, 0x7f, 0xfb, 0xca, 0x9f, 0x8a, 0xbd,
-	0x39, 0x9d, 0x4f, 0x3b, 0xff, 0x0e, 0x00, 0x00, 0xff, 0xff, 0xa0, 0xc8, 0xe8, 0xc3, 0x6c, 0x14,
-	0x00, 0x00,
+	// 2693 bytes of a gzipped FileDescriptorProto
+	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x59, 0xdd, 0x72, 0x1b, 0xb7,
+	0xf5, 0x17, 0x25, 0x59, 0x12, 0x8f, 0x44, 0x89, 0x82, 0xbf, 0xd6, 0x4c, 0xfc, 0x11, 0x39, 0xce,
+	0x5f, 0xb1, 0x13, 0x69, 0x22, 0x25, 0x19, 0xff, 0x3b, 0x4d, 0x27, 0x14, 0x49, 0x55, 0x4c, 0xf5,
+	0xc1, 0x01, 0xa9, 0x38, 0x71, 0x2e, 0x30, 0xe0, 0x2e, 0x48, 0x6e, 0xb5, 0x0b, 0x6c, 0x01, 0xac,
+	0x24, 0xfa, 0x09, 0xfa, 0x10, 0x9d, 0x5e, 0xf4, 0xba, 0xd3, 0xbb, 0xde, 0xf5, 0x01, 0x7a, 0xd9,
+	0x47, 0xe8, 0xe4, 0xa6, 0xed, 0xf4, 0x25, 0x3a, 0x00, 0x76, 0x29, 0x4a, 0x96, 0x69, 0xa7, 0xbd,
+	0x23, 0xce, 0xf9, 0xfd, 0x7e, 0x8b, 0x05, 0xce, 0x39, 0x38, 0x58, 0xc2, 0xbd, 0x98, 0xa9, 0xc1,
+	0xe6, 0xe9, 0x67, 0x34, 0x4a, 0x06, 0xf4, 0xb3, 0xcd, 0x44, 0x8a, 0xf3, 0xe1, 0x46, 0x22, 0x85,
+	0x16, 0xe8, 0x66, 0xa8, 0x74, 0x28, 0x36, 0x0c, 0x60, 0x23, 0x07, 0x54, 0x1e, 0xf4, 0x85, 0xe8,
+	0x47, 0x6c, 0xd3, 0x42, 0xba, 0x69, 0x6f, 0x33, 0x48, 0x25, 0xd5, 0xa1, 0xe0, 0x8e, 0xf4, 0xba,
+	0xff, 0x4c, 0xd2, 0x24, 0x61, 0x52, 0x65, 0xfe, 0xa7, 0x9c, 0xe9, 0x33, 0x21, 0x4f, 0x42, 0xde,
+	0xcf, 0x9f, 0xba, 0xbd, 0x19, 0x30, 0xa5, 0x43, 0x6e, 0x65, 0x88, 0x4c, 0x23, 0x96, 0x61, 0xd7,
+	0xaf, 0xc3, 0x1a, 0x43, 0x24, 0x68, 0x40, 0xfa, 0x52, 0xa4, 0x89, 0x43, 0xae, 0xfd, 0xa1, 0x0c,
+	0xf3, 0x1d, 0x49, 0xfd, 0x90, 0xf7, 0xd1, 0x57, 0x30, 0xf7, 0x2a, 0x4c, 0x4e, 0x42, 0xee, 0x15,
+	0x1e, 0x15, 0xd6, 0x17, 0xb7, 0x1e, 0x6f, 0x5c, 0xf3, 0x1e, 0x1b, 0x19, 0x7a, 0xe3, 0xa5, 0x85,
+	0xee, 0x4d, 0xe1, 0x8c, 0x84, 0x76, 0xa1, 0x18, 0x85, 0xfd, 0x81, 0x56, 0x9a, 0x25, 0xde, 0xb4,
+	0x55, 0xf8, 0x68, 0xa2, 0xc2, 0x7e, 0x8e, 0xde, 0x9b, 0xc2, 0x17, 0x54, 0xf4, 0x35, 0xcc, 0x07,
+	0x54, 0xd3, 0x40, 0xf4, 0xbd, 0x19, 0xab, 0xf2, 0xe1, 0x44, 0x95, 0xba, 0xc3, 0xee, 0x4d, 0xe1,
+	0x9c, 0x86, 0xf6, 0x61, 0x51, 0x69, 0xea, 0x9f, 0x04, 0x32, 0x3c, 0x65, 0xd2, 0x9b, 0xb5, 0x2a,
+	0xeb, 0x13, 0x55, 0xda, 0x17, 0xf8, 0xbd, 0x29, 0x3c, 0x4e, 0x47, 0x2f, 0x61, 0x55, 0x24, 0x8c,
+	0x13, 0x9f, 0x71, 0x95, 0x2a, 0x42, 0xfb, 0x8c, 0x6b, 0xaf, 0x68, 0x35, 0x3f, 0x99, 0xa8, 0x79,
+	0x94, 0x30, 0x5e, 0xb3, 0xa4, 0xaa, 0xe1, 0xec, 0x4d, 0xe1, 0x15, 0x71, 0xd9, 0x84, 0x6a, 0xb0,
+	0xc0, 0x68, 0x3f, 0x62, 0x6c, 0xc8, 0x3c, 0xb0, 0x92, 0x4f, 0x26, 0x4a, 0x36, 0x0c, 0xb8, 0x31,
+	0x64, 0x7b, 0x53, 0x78, 0x44, 0x44, 0x07, 0xb0, 0xe8, 0xa7, 0x4a, 0x8b, 0x98, 0x68, 0xda, 0x57,
+	0xde, 0x8d, 0x47, 0x33, 0x6f, 0x9d, 0x5a, 0xcd, 0xe2, 0x3b, 0xb4, 0xaf, 0x1a, 0x5c, 0xcb, 0x21,
+	0x06, 0x7f, 0x64, 0x40, 0x9f, 0xc2, 0xcd, 0x98, 0x9e, 0x93, 0x84, 0xea, 0x81, 0x11, 0x24, 0x11,
+	0xe3, 0x7d, 0x3d, 0xf0, 0xe6, 0x1e, 0x15, 0xd6, 0x4b, 0xb8, 0x1c, 0xd3, 0xf3, 0x16, 0xd5, 0x83,
+	0x0e, 0xed, 0xef, 0x5b, 0x3b, 0xaa, 0xc0, 0x82, 0xa2, 0x71, 0x12, 0x85, 0xbc, 0xef, 0xcd, 0x3f,
+	0x2a, 0xac, 0x17, 0xf0, 0x68, 0x8c, 0x8e, 0x60, 0x49, 0x47, 0x8a, 0x28, 0xa6, 0x75, 0xc8, 0xfb,
+	0xca, 0x5b, 0xb8, 0xb4, 0x6a, 0x17, 0x41, 0x9a, 0x4f, 0x70, 0x7b, 0xa3, 0x16, 0x85, 0x8c, 0xeb,
+	0xce, 0x7e, 0xbb, 0x9d, 0x71, 0xf0, 0xa2, 0x8e, 0x54, 0x3e, 0xa8, 0xac, 0xc1, 0x9c, 0x8b, 0x3b,
+	0xe4, 0xc1, 0x3c, 0x0d, 0x02, 0xc9, 0x94, 0xb2, 0xd1, 0x5a, 0xc4, 0xf9, 0xb0, 0xb2, 0x07, 0xc5,
+	0x51, 0x64, 0xbd, 0x19, 0x86, 0x3e, 0x80, 0x25, 0xea, 0xfb, 0x4c, 0x29, 0xa2, 0xc5, 0x09, 0xe3,
+	0x36, 0x62, 0x8b, 0x78, 0xd1, 0xd9, 0x3a, 0xc6, 0x54, 0x79, 0x0c, 0xf3, 0x59, 0x74, 0x4d, 0x78,
+	0xdc, 0x9f, 0xa6, 0x61, 0x71, 0x2c, 0x7a, 0xd0, 0x2d, 0xb8, 0x11, 0xb0, 0x6e, 0xda, 0xb7, 0xb8,
+	0x05, 0xec, 0x06, 0xa8, 0x03, 0x9e, 0x59, 0x54, 0x9e, 0xc6, 0x5d, 0x26, 0x89, 0xe8, 0x11, 0xaa,
+	0xb5, 0x0c, 0xbb, 0xa9, 0x66, 0x2a, 0xcb, 0x95, 0xf7, 0x36, 0x5c, 0x01, 0xd8, 0xc8, 0x0b, 0xc0,
+	0x46, 0x93, 0xeb, 0x2f, 0x3f, 0xff, 0x96, 0x46, 0x29, 0xc3, 0xb7, 0x63, 0x7a, 0x7e, 0x68, 0xb9,
+	0x47, 0xbd, 0xea, 0x88, 0x89, 0xbe, 0x85, 0x7b, 0x57, 0x54, 0x39, 0x17, 0xda, 0x96, 0x03, 0x95,
+	0x25, 0xcf, 0x44, 0xd9, 0x3b, 0xe3, 0xb2, 0x17, 0x54, 0xf4, 0x03, 0xbc, 0x7f, 0x59, 0x37, 0x66,
+	0x4a, 0xd1, 0x3e, 0x23, 0xec, 0x94, 0x71, 0xad, 0xb2, 0x8c, 0x9a, 0x28, 0xed, 0x8d, 0x49, 0x1f,
+	0x38, 0x76, 0xc3, 0x92, 0x2b, 0xff, 0x28, 0xc0, 0xca, 0x95, 0xd4, 0x98, 0xb0, 0x4d, 0x6d, 0x98,
+	0xf7, 0x05, 0xd7, 0xec, 0x5c, 0x7b, 0xd3, 0x8f, 0x66, 0xd6, 0x97, 0xb7, 0xfe, 0xff, 0xa7, 0xe4,
+	0x9c, 0xb5, 0xb3, 0x9a, 0x13, 0xc0, 0xb9, 0xd2, 0x1a, 0x83, 0xa5, 0x71, 0x07, 0x5a, 0x81, 0xc5,
+	0xe3, 0xc3, 0x76, 0xab, 0x51, 0x6b, 0xee, 0x36, 0x1b, 0xf5, 0xf2, 0x14, 0xba, 0x0d, 0xab, 0x2f,
+	0xb6, 0x6b, 0xa4, 0x83, 0xab, 0xb5, 0x06, 0xa9, 0x1d, 0x1d, 0x76, 0x1a, 0xdf, 0x75, 0xca, 0x05,
+	0xb4, 0x04, 0x0b, 0xbf, 0xc4, 0xad, 0x1a, 0xd9, 0x69, 0x1e, 0x96, 0xa7, 0xd1, 0x5d, 0xb8, 0x59,
+	0xdb, 0x3f, 0x3a, 0xae, 0x5f, 0x81, 0xcd, 0xa0, 0x39, 0x98, 0xde, 0xd9, 0x2e, 0xcf, 0x56, 0xfe,
+	0x5c, 0x80, 0x85, 0x3c, 0x63, 0xd1, 0x13, 0x58, 0xd1, 0xa9, 0xe4, 0xc4, 0x54, 0xea, 0xc4, 0x27,
+	0x91, 0xc8, 0x23, 0x64, 0xc9, 0x98, 0x8f, 0x38, 0x4e, 0xfc, 0x7d, 0xd1, 0x47, 0x9b, 0x70, 0x2b,
+	0x87, 0x75, 0x53, 0x15, 0x72, 0x13, 0xa0, 0x06, 0x3b, 0x6d, 0xb1, 0xab, 0x0e, 0xbb, 0x93, 0x79,
+	0x0c, 0xe1, 0x19, 0xac, 0xe6, 0xf9, 0x46, 0x42, 0xae, 0x99, 0x3c, 0xa5, 0x91, 0xdd, 0xfb, 0x12,
+	0x2e, 0xe7, 0x8e, 0x66, 0x66, 0x47, 0x1f, 0xc2, 0x72, 0x42, 0x95, 0x22, 0xa9, 0x62, 0x92, 0x98,
+	0x72, 0x69, 0xb7, 0x72, 0x01, 0x2f, 0x19, 0xeb, 0xb1, 0x62, 0xd2, 0xc4, 0x7b, 0xe5, 0x5f, 0x05,
+	0x28, 0x8e, 0x2a, 0x84, 0xa9, 0xc7, 0x51, 0xa8, 0x99, 0xa4, 0x51, 0x76, 0x2e, 0x7c, 0xf8, 0x96,
+	0xaa, 0x6e, 0xb1, 0xa6, 0x1e, 0x67, 0x34, 0x53, 0x8f, 0x19, 0x3f, 0x0d, 0xa5, 0xe0, 0xb1, 0xa9,
+	0x9d, 0xd3, 0xef, 0x50, 0x8f, 0x1b, 0x17, 0x78, 0x53, 0x8f, 0xc7, 0xe8, 0xa8, 0x0e, 0x73, 0x03,
+	0x46, 0x03, 0x26, 0xb3, 0x08, 0x7f, 0x3a, 0x51, 0x08, 0xb3, 0xdf, 0xa4, 0x4c, 0xe9, 0x3d, 0xcb,
+	0x30, 0xa7, 0x95, 0xe3, 0xee, 0xcc, 0xc1, 0xac, 0x1e, 0x26, 0xac, 0xf2, 0x10, 0xe6, 0xb3, 0x19,
+	0x9b, 0xcc, 0x3d, 0x35, 0xb1, 0x9b, 0x85, 0xa0, 0x1b, 0x54, 0x76, 0x61, 0x71, 0x6c, 0x32, 0x08,
+	0xc1, 0x2c, 0xa7, 0x71, 0x8e, 0xb1, 0xbf, 0xd1, 0x63, 0x28, 0x05, 0xac, 0x47, 0xd3, 0x48, 0x13,
+	0x27, 0xe0, 0x6a, 0xc9, 0x52, 0x66, 0xb4, 0x09, 0x51, 0xd9, 0x83, 0xd2, 0xa5, 0xb9, 0xfc, 0xf7,
+	0x4a, 0x0c, 0x56, 0xae, 0xd4, 0x6f, 0x54, 0x86, 0x99, 0x13, 0x36, 0xcc, 0xa4, 0xcc, 0x4f, 0xf4,
+	0xf3, 0xfc, 0x65, 0xde, 0xe5, 0x24, 0x1e, 0xc9, 0x65, 0x2f, 0xfd, 0xb3, 0xe9, 0xe7, 0x85, 0x9d,
+	0x05, 0x98, 0xd3, 0x26, 0x49, 0xe4, 0xda, 0x2e, 0xcc, 0xb4, 0xeb, 0x6d, 0x93, 0xa4, 0x8c, 0xd3,
+	0x6e, 0xc4, 0x82, 0x2c, 0x72, 0xf3, 0xa1, 0x89, 0xed, 0x93, 0xe7, 0x8a, 0x28, 0x4a, 0x7e, 0x7d,
+	0xa6, 0xed, 0xc9, 0x91, 0x4f, 0xfc, 0xe4, 0xb9, 0x6a, 0xd3, 0x6f, 0xce, 0xb4, 0x39, 0x33, 0xd6,
+	0xfe, 0x32, 0x0d, 0x0b, 0x1d, 0x91, 0x88, 0x48, 0xf4, 0x87, 0x68, 0x03, 0x6e, 0xf2, 0x34, 0x26,
+	0x5a, 0xa6, 0x4a, 0xb3, 0x80, 0x98, 0xfe, 0x29, 0x64, 0x2e, 0xfd, 0x4b, 0x78, 0x95, 0xa7, 0x71,
+	0xc7, 0x79, 0x5a, 0xce, 0x81, 0x52, 0x78, 0xaf, 0x27, 0xe4, 0x19, 0x95, 0x01, 0xf1, 0xed, 0x21,
+	0x41, 0x7c, 0x26, 0x35, 0x09, 0x98, 0xa6, 0x61, 0xe4, 0x8a, 0xe8, 0xf2, 0xd6, 0x97, 0xd7, 0xbf,
+	0x66, 0xf6, 0xcc, 0x8d, 0x5d, 0x27, 0xe0, 0x0e, 0x99, 0x1a, 0x93, 0xba, 0xee, 0xd8, 0xd8, 0xeb,
+	0xbd, 0xc1, 0xb3, 0xf6, 0xdb, 0x02, 0x78, 0x6f, 0xa2, 0xa1, 0x12, 0x14, 0x8f, 0x0f, 0xeb, 0x8d,
+	0xdd, 0xe6, 0xa1, 0xad, 0x1a, 0x4b, 0xb0, 0xd0, 0xae, 0x1e, 0x36, 0x3b, 0xcd, 0x97, 0x8d, 0x72,
+	0x01, 0x95, 0x61, 0x69, 0xf7, 0x08, 0xbf, 0xa8, 0xe2, 0x3a, 0x39, 0x3a, 0xdc, 0xff, 0xbe, 0x3c,
+	0x8d, 0x10, 0x2c, 0x57, 0x5b, 0xad, 0xc6, 0x61, 0x9d, 0x64, 0x8e, 0xf2, 0x8c, 0x41, 0xe5, 0x1c,
+	0xd2, 0x6e, 0x74, 0xca, 0xb3, 0xa6, 0xac, 0x54, 0xf7, 0x5f, 0x54, 0xbf, 0x6f, 0x93, 0x4b, 0xf4,
+	0x1b, 0x6b, 0x7f, 0x9c, 0x85, 0x3b, 0xdf, 0x1d, 0x88, 0x20, 0x8d, 0xd8, 0x8e, 0x10, 0x5a, 0x69,
+	0x49, 0x93, 0x9a, 0xe0, 0xbd, 0xb0, 0x8f, 0x1e, 0xc2, 0xa2, 0x6f, 0x7f, 0xb9, 0xc5, 0x77, 0x71,
+	0x00, 0xce, 0x64, 0x96, 0x1e, 0x3d, 0x85, 0xd5, 0x0c, 0xe0, 0x0f, 0x98, 0x7f, 0x42, 0x24, 0xd5,
+	0x2e, 0x34, 0x4a, 0x78, 0xc5, 0x39, 0x6a, 0xc6, 0x8e, 0xa9, 0x66, 0xe8, 0x3e, 0x80, 0x6d, 0x72,
+	0x88, 0x12, 0xfe, 0x89, 0x4d, 0xb2, 0x22, 0x2e, 0x5a, 0x4b, 0x5b, 0xf8, 0x27, 0xe8, 0x09, 0x2c,
+	0x27, 0x29, 0x0f, 0xd5, 0x80, 0xf8, 0x91, 0xd9, 0x21, 0xd7, 0x60, 0x15, 0x71, 0xc9, 0x59, 0x6b,
+	0xce, 0x68, 0xa6, 0x94, 0xc1, 0x06, 0x42, 0x69, 0xef, 0x86, 0x9b, 0x92, 0x33, 0xed, 0x09, 0xa5,
+	0xd1, 0x3d, 0x58, 0x38, 0xff, 0xc2, 0xee, 0xfb, 0xd0, 0x36, 0x17, 0x45, 0x3c, 0x7f, 0xfe, 0x85,
+	0xd9, 0xed, 0xa1, 0x99, 0x6d, 0x2f, 0x12, 0x67, 0x44, 0x45, 0xca, 0x00, 0x82, 0xd4, 0x67, 0xd2,
+	0x36, 0x17, 0x45, 0xbc, 0x62, 0x1c, 0xed, 0x48, 0xb5, 0x32, 0xb3, 0x91, 0xb1, 0x30, 0x21, 0xb5,
+	0xed, 0x2f, 0x4a, 0x78, 0x5e, 0x45, 0xaa, 0x25, 0xa4, 0x46, 0x9f, 0xc3, 0x9d, 0x80, 0xf9, 0x22,
+	0x4e, 0xcc, 0x49, 0x42, 0xba, 0x69, 0xaf, 0xc7, 0x24, 0x51, 0xe1, 0x2b, 0x66, 0xdb, 0xb7, 0x12,
+	0xbe, 0x75, 0xe1, 0xdd, 0xb1, 0xce, 0x76, 0xf8, 0x8a, 0x99, 0x89, 0x2b, 0x1e, 0x74, 0xd3, 0x9e,
+	0x83, 0x82, 0x85, 0x82, 0x33, 0x59, 0xc0, 0x03, 0x58, 0x34, 0xa7, 0x63, 0x68, 0xaa, 0x38, 0xe3,
+	0xde, 0xa2, 0x05, 0x14, 0x63, 0x7a, 0xde, 0x4c, 0xfc, 0x7d, 0xc6, 0xcd, 0x63, 0x69, 0x97, 0x0b,
+	0x19, 0xd3, 0x88, 0x48, 0x66, 0x26, 0x46, 0x5c, 0xa2, 0x78, 0x4b, 0x36, 0x6d, 0x6e, 0xe5, 0x5e,
+	0x6c, 0x9d, 0x0d, 0xeb, 0x33, 0xab, 0xee, 0x47, 0x22, 0x0d, 0x48, 0x2c, 0x02, 0xe6, 0x95, 0x2c,
+	0xb2, 0x68, 0x2d, 0x07, 0x22, 0x60, 0xe8, 0x0e, 0xcc, 0x49, 0xd6, 0x0f, 0x05, 0xf7, 0x96, 0xed,
+	0x3a, 0x64, 0x23, 0x93, 0x94, 0xf9, 0x36, 0xac, 0xb8, 0x45, 0xcc, 0x86, 0x6b, 0xbf, 0xbb, 0x0d,
+	0x8b, 0x76, 0x39, 0xdf, 0x35, 0x46, 0x1e, 0xc2, 0x62, 0x37, 0xe4, 0x54, 0x0e, 0xc7, 0x33, 0x18,
+	0x9c, 0xc9, 0x02, 0xfe, 0x0f, 0x56, 0x14, 0x93, 0xa7, 0xa1, 0xcf, 0x46, 0x5b, 0xef, 0xa2, 0x63,
+	0x39, 0x33, 0xe7, 0x7b, 0xff, 0x35, 0x2c, 0x07, 0x92, 0x86, 0x9c, 0xe4, 0x77, 0x9c, 0xac, 0x63,
+	0xb8, 0xf7, 0x5a, 0xc7, 0x50, 0xcf, 0x00, 0xb8, 0x64, 0x09, 0xf9, 0x10, 0xb5, 0xc1, 0x4b, 0xa8,
+	0xb4, 0x41, 0x38, 0x48, 0x75, 0x20, 0xce, 0xc6, 0xb4, 0x6e, 0xbc, 0x4d, 0xeb, 0x8e, 0xa3, 0xb6,
+	0x33, 0xe6, 0x48, 0xf4, 0x19, 0xac, 0x06, 0xa1, 0xf2, 0xc5, 0x29, 0x93, 0x43, 0x92, 0xf7, 0x1b,
+	0x2e, 0xf4, 0xca, 0x23, 0x47, 0x35, 0x6b, 0x3c, 0x8e, 0xe1, 0xee, 0x05, 0x58, 0xb2, 0x9e, 0x64,
+	0x6a, 0x40, 0x02, 0x16, 0xd1, 0xa1, 0x8d, 0xc4, 0x49, 0x13, 0xd8, 0x99, 0xf6, 0x0a, 0xf8, 0xf6,
+	0x88, 0x8d, 0x1d, 0xb9, 0x6e, 0xb8, 0xe8, 0x63, 0x58, 0x76, 0xf7, 0xa5, 0xd1, 0x04, 0x4c, 0xd0,
+	0x16, 0x2d, 0xa5, 0xe4, 0x3c, 0xf9, 0x0c, 0x3e, 0x01, 0xa4, 0x34, 0xd5, 0x2a, 0x20, 0x69, 0x90,
+	0x8c, 0xe0, 0xe0, 0xe6, 0xeb, 0x3c, 0xc7, 0x41, 0x92, 0xa3, 0x1b, 0x70, 0x9f, 0xf1, 0x53, 0x31,
+	0x24, 0x31, 0xd3, 0x32, 0xf4, 0x4d, 0xd7, 0xed, 0xb6, 0x2a, 0x27, 0xde, 0x1a, 0x3d, 0xa7, 0x62,
+	0x81, 0x07, 0x0e, 0xd7, 0x76, 0xb0, 0x5c, 0x66, 0x1d, 0xca, 0x36, 0x25, 0x09, 0x0d, 0xe2, 0x90,
+	0xbb, 0xb4, 0x32, 0x11, 0x7e, 0x03, 0x2f, 0x5b, 0x7b, 0xd5, 0x98, 0x6d, 0x76, 0x6d, 0xc2, 0x2a,
+	0x3d, 0xa5, 0x61, 0x44, 0xbb, 0x61, 0x14, 0xea, 0x21, 0x79, 0x25, 0xb8, 0x8b, 0x70, 0xf7, 0x90,
+	0xf2, 0xb8, 0xf3, 0xa5, 0xe0, 0x0c, 0x05, 0x70, 0xcf, 0x34, 0x60, 0x52, 0x44, 0x24, 0x89, 0x28,
+	0x67, 0x84, 0xa6, 0x7a, 0x40, 0x12, 0x11, 0x85, 0xfe, 0xd0, 0x06, 0xfc, 0xf2, 0xd6, 0xc7, 0xd7,
+	0xd6, 0xef, 0x6a, 0xaa, 0x07, 0x8c, 0xeb, 0xd0, 0xb7, 0xab, 0xdb, 0xb2, 0x04, 0x7c, 0x27, 0xd3,
+	0x6a, 0x19, 0x29, 0x83, 0x70, 0x76, 0xb3, 0x6a, 0xd9, 0x6d, 0x28, 0x8b, 0xf6, 0x5e, 0x18, 0xb1,
+	0x2c, 0x69, 0xca, 0xce, 0xe3, 0x12, 0x62, 0x37, 0x8c, 0x98, 0x79, 0x5d, 0xb3, 0x92, 0xc4, 0x9c,
+	0xbe, 0xf9, 0x4d, 0x67, 0xc5, 0xbd, 0xae, 0xb1, 0x1f, 0xd2, 0x98, 0x65, 0xf7, 0x9c, 0xaf, 0x6c,
+	0xfa, 0xf8, 0xa9, 0x94, 0x8c, 0xfb, 0x43, 0xaf, 0xfc, 0xe6, 0x16, 0x78, 0x7b, 0xcb, 0xb5, 0xc0,
+	0xe3, 0x78, 0x54, 0x85, 0xfb, 0x6e, 0x5d, 0xbb, 0x79, 0xe9, 0x26, 0x9a, 0xc5, 0x49, 0x44, 0x35,
+	0x73, 0xe9, 0xb6, 0x6a, 0x67, 0x58, 0xb1, 0xa0, 0x51, 0x79, 0xef, 0x64, 0x10, 0x9b, 0x7e, 0x0c,
+	0x56, 0x6d, 0x83, 0xe7, 0xb3, 0xc4, 0x5e, 0xf8, 0x6d, 0xa1, 0x40, 0x76, 0xdd, 0x9e, 0x5f, 0xbb,
+	0x6e, 0x63, 0xd9, 0xbf, 0xd1, 0xe4, 0x5d, 0x91, 0xf2, 0xa0, 0x39, 0x26, 0x60, 0xea, 0x0a, 0x2e,
+	0x87, 0x57, 0x2c, 0xe8, 0x4b, 0x98, 0xd7, 0xae, 0x2f, 0xf0, 0x6e, 0xda, 0x97, 0x7c, 0x7f, 0x52,
+	0xef, 0x80, 0x73, 0x30, 0x7a, 0x0a, 0x33, 0x2a, 0x50, 0xde, 0x6d, 0xcb, 0xf1, 0xae, 0xe5, 0xb4,
+	0xeb, 0x6d, 0x6c, 0x40, 0xe8, 0x07, 0xf0, 0x5c, 0xb0, 0x66, 0x57, 0xb0, 0x48, 0xf4, 0xf3, 0x78,
+	0xf5, 0xee, 0x58, 0x81, 0xb5, 0x6b, 0x05, 0x30, 0x8b, 0x85, 0x66, 0x59, 0xc8, 0xe2, 0xdb, 0x56,
+	0xa3, 0x6a, 0x25, 0xf6, 0x45, 0x3f, 0x33, 0xa3, 0x6f, 0xe1, 0xf6, 0xb5, 0x99, 0xe0, 0xdd, 0x7d,
+	0x67, 0xe5, 0x9b, 0xd7, 0x64, 0x08, 0x7a, 0x09, 0x2e, 0x05, 0x8c, 0x2e, 0xb5, 0xcd, 0xb3, 0x67,
+	0xaf, 0xda, 0xdb, 0x6f, 0x5d, 0x7c, 0xfb, 0xfb, 0x20, 0x63, 0xb9, 0x1b, 0x77, 0x29, 0x19, 0xb7,
+	0x19, 0x6d, 0x99, 0x72, 0x1d, 0xc6, 0xcc, 0x35, 0x7e, 0xca, 0x7b, 0xf2, 0x8e, 0xda, 0xd8, 0xd1,
+	0x6c, 0xc8, 0x65, 0xb7, 0xf9, 0x92, 0x1c, 0xb7, 0xd9, 0x03, 0x4d, 0x53, 0x9d, 0x66, 0x87, 0x64,
+	0xc5, 0x86, 0x37, 0x38, 0x93, 0xcd, 0xe4, 0x8f, 0x60, 0x85, 0x9d, 0x6b, 0x49, 0x89, 0x4d, 0x05,
+	0xfb, 0x11, 0xe1, 0xbd, 0x47, 0x33, 0xe6, 0x48, 0xb7, 0xe6, 0xb6, 0xa6, 0xda, 0x7e, 0x19, 0xd8,
+	0x83, 0x72, 0x9f, 0x6a, 0x76, 0x46, 0x87, 0x44, 0x67, 0x2d, 0x95, 0xf7, 0xbe, 0x5d, 0xd3, 0xfb,
+	0x13, 0xfb, 0x2e, 0xbc, 0x92, 0xd1, 0x46, 0xcd, 0xdf, 0x0b, 0xa8, 0x68, 0x26, 0xe3, 0xfc, 0xd3,
+	0xd5, 0x95, 0xc3, 0xe2, 0xfe, 0xdb, 0x0a, 0xbc, 0x37, 0x46, 0xae, 0x5f, 0x3a, 0x37, 0xee, 0xc2,
+	0xbc, 0x99, 0x03, 0x09, 0x03, 0xef, 0x81, 0x3b, 0x27, 0xcd, 0xb0, 0x19, 0x20, 0x0c, 0x2b, 0x92,
+	0xd1, 0xc0, 0x5d, 0xa8, 0x12, 0x29, 0xba, 0xcc, 0x7b, 0x68, 0x1f, 0xf3, 0xf1, 0x84, 0xaf, 0x11,
+	0x38, 0x67, 0xb4, 0x0c, 0x01, 0x2f, 0xcb, 0x4b, 0x63, 0xd4, 0x85, 0x9b, 0x2e, 0x20, 0x6c, 0x31,
+	0x26, 0x31, 0xd5, 0xfe, 0x80, 0x49, 0xef, 0x91, 0xd5, 0xdd, 0x7a, 0xb7, 0xa8, 0x30, 0x8b, 0xab,
+	0x0e, 0x1c, 0x13, 0xaf, 0x26, 0x57, 0x4d, 0x68, 0x00, 0x8f, 0x07, 0x22, 0x0a, 0x08, 0x4d, 0x92,
+	0x28, 0x2b, 0x80, 0xc4, 0xec, 0x6e, 0x44, 0x46, 0x8f, 0x96, 0x5a, 0x79, 0x1f, 0xd8, 0x67, 0x56,
+	0x5e, 0x5b, 0xb2, 0x1d, 0x21, 0x22, 0x57, 0x8d, 0x1e, 0x1a, 0x99, 0xea, 0x85, 0xca, 0xb1, 0x11,
+	0xc9, 0xa7, 0x20, 0xb5, 0x32, 0x0d, 0xb9, 0x4f, 0x6d, 0x53, 0x1d, 0xf6, 0x0c, 0x86, 0x29, 0x92,
+	0xb0, 0xd8, 0x5b, 0xb3, 0x91, 0xb0, 0xea, 0xd3, 0xda, 0x98, 0xa7, 0xc5, 0x62, 0xf4, 0x05, 0xdc,
+	0x08, 0x63, 0xda, 0x67, 0xde, 0x63, 0xfb, 0xec, 0x87, 0x6f, 0x7e, 0xdf, 0xa6, 0x81, 0x61, 0x87,
+	0x36, 0xfd, 0x9a, 0xc9, 0x76, 0x5b, 0xf3, 0x02, 0xd7, 0xb1, 0x44, 0xc2, 0x35, 0x20, 0x18, 0x96,
+	0xcf, 0x63, 0xdb, 0xdf, 0x66, 0xb5, 0xdb, 0x63, 0x56, 0xfa, 0xd9, 0xb5, 0xd2, 0xd7, 0xb7, 0xc2,
+	0xb8, 0x94, 0x49, 0x64, 0x5d, 0xcf, 0x47, 0xb0, 0x12, 0x84, 0xca, 0x74, 0x58, 0x84, 0x46, 0x09,
+	0x27, 0x83, 0x2d, 0x8f, 0xdb, 0xde, 0xaa, 0x94, 0x99, 0xab, 0x51, 0xc2, 0xf7, 0xb6, 0x2a, 0x5f,
+	0x03, 0x7a, 0x3d, 0x4b, 0xaf, 0xb9, 0x57, 0xdd, 0x1a, 0xbf, 0x57, 0x15, 0xc7, 0xee, 0x4b, 0x46,
+	0xe1, 0xf5, 0x5c, 0xfc, 0x49, 0x0a, 0xbf, 0x2f, 0xc0, 0xea, 0x6b, 0x41, 0x81, 0x3e, 0x05, 0x14,
+	0x72, 0xd3, 0x6f, 0x99, 0xad, 0x4f, 0x24, 0xeb, 0x85, 0xe7, 0xf6, 0x9e, 0x64, 0xb7, 0x65, 0xe4,
+	0x69, 0x65, 0x8e, 0xcb, 0x70, 0x95, 0xf6, 0x1c, 0x7c, 0xfa, 0x0a, 0xbc, 0x9d, 0x39, 0x4c, 0x4f,
+	0x74, 0x01, 0x97, 0xac, 0xcf, 0xce, 0x13, 0xe5, 0xcd, 0x58, 0x74, 0x79, 0xe4, 0xc0, 0xce, 0xbe,
+	0xb6, 0x0d, 0x77, 0xdf, 0x70, 0x8e, 0x98, 0xbb, 0x0f, 0x6e, 0xd4, 0x9b, 0xb8, 0x51, 0xeb, 0x94,
+	0xa7, 0x10, 0xc0, 0x5c, 0xa7, 0x85, 0x8f, 0xbe, 0xfb, 0xbe, 0x5c, 0xf8, 0x66, 0x76, 0xa1, 0x58,
+	0x06, 0x7b, 0xcb, 0xe0, 0xcc, 0xd7, 0xc4, 0x2c, 0x90, 0x48, 0xf5, 0xda, 0xbf, 0x0b, 0xe6, 0x42,
+	0x3c, 0x56, 0x74, 0x27, 0x7c, 0x04, 0xba, 0xfa, 0x1d, 0x71, 0xfa, 0x7f, 0xfc, 0x8e, 0x88, 0x04,
+	0x94, 0xb4, 0x9f, 0x90, 0x13, 0xc6, 0x12, 0x1a, 0x85, 0xa7, 0x2c, 0xfb, 0x94, 0xf0, 0xcd, 0x24,
+	0x45, 0x37, 0x7f, 0xdb, 0x80, 0x88, 0x28, 0x57, 0xda, 0xe8, 0xd4, 0x5a, 0x17, 0xbf, 0xfd, 0xe4,
+	0x57, 0xb9, 0x22, 0x5e, 0xd2, 0x63, 0xa3, 0xb5, 0x67, 0x00, 0x17, 0xa9, 0x60, 0x7a, 0x7d, 0x9b,
+	0x0c, 0x44, 0x0f, 0x93, 0xfc, 0x03, 0x40, 0xd1, 0x5a, 0x3a, 0xc3, 0x84, 0x3d, 0xfd, 0x05, 0xdc,
+	0xba, 0xae, 0xe5, 0x41, 0x0b, 0x30, 0x7b, 0x78, 0x74, 0xd8, 0x28, 0x4f, 0xa1, 0x65, 0x80, 0x83,
+	0xe3, 0xce, 0x71, 0x75, 0x9f, 0x74, 0xf6, 0xdb, 0xf6, 0xc3, 0xd4, 0x7c, 0xf3, 0x70, 0xaf, 0x81,
+	0x9b, 0x9d, 0xf2, 0x3f, 0xe7, 0x77, 0xd6, 0xff, 0xfa, 0xe3, 0x83, 0xc2, 0xdf, 0x7e, 0x7c, 0x50,
+	0xf8, 0xfb, 0x8f, 0x0f, 0x0a, 0x2f, 0x2b, 0xee, 0x9d, 0x42, 0xb1, 0x49, 0x93, 0x70, 0xf3, 0xd2,
+	0xbf, 0x16, 0xdd, 0x39, 0x5b, 0x28, 0xb6, 0xff, 0x13, 0x00, 0x00, 0xff, 0xff, 0xbf, 0xe5, 0x95,
+	0x28, 0xcd, 0x18, 0x00, 0x00,
 }
 
 func (m *Tracing) Marshal() (dAtA []byte, err error) {
@@ -2104,6 +2434,27 @@ func (m *Tracing_OpenCensusAgent_) MarshalToSizedBuffer(dAtA []byte) (int, error
 	}
 	return len(dAtA) - i, nil
 }
+func (m *Tracing_Eagleeye) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *Tracing_Eagleeye) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	if m.Eagleeye != nil {
+		{
+			size, err := m.Eagleeye.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintProxy(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x52
+	}
+	return len(dAtA) - i, nil
+}
 func (m *Tracing_Zipkin) Marshal() (dAtA []byte, err error) {
 	size := m.Size()
 	dAtA = make([]byte, size)
@@ -2311,20 +2662,20 @@ func (m *Tracing_OpenCensusAgent) MarshalToSizedBuffer(dAtA []byte) (int, error)
 		copy(dAtA[i:], m.XXX_unrecognized)
 	}
 	if len(m.Context) > 0 {
-		dAtA12 := make([]byte, len(m.Context)*10)
-		var j11 int
+		dAtA13 := make([]byte, len(m.Context)*10)
+		var j12 int
 		for _, num := range m.Context {
 			for num >= 1<<7 {
-				dAtA12[j11] = uint8(uint64(num)&0x7f | 0x80)
+				dAtA13[j12] = uint8(uint64(num)&0x7f | 0x80)
 				num >>= 7
-				j11++
+				j12++
 			}
-			dAtA12[j11] = uint8(num)
-			j11++
+			dAtA13[j12] = uint8(num)
+			j12++
 		}
-		i -= j11
-		copy(dAtA[i:], dAtA12[:j11])
-		i = encodeVarintProxy(dAtA, i, uint64(j11))
+		i -= j12
+		copy(dAtA[i:], dAtA13[:j12])
+		i = encodeVarintProxy(dAtA, i, uint64(j12))
 		i--
 		dAtA[i] = 0x12
 	}
@@ -2338,6 +2689,68 @@ func (m *Tracing_OpenCensusAgent) MarshalToSizedBuffer(dAtA []byte) (int, error)
 	return len(dAtA) - i, nil
 }
 
+func (m *Tracing_EagleEye) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *Tracing_EagleEye) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *Tracing_EagleEye) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
+	var l int
+	_ = l
+	if m.XXX_unrecognized != nil {
+		i -= len(m.XXX_unrecognized)
+		copy(dAtA[i:], m.XXX_unrecognized)
+	}
+	if m.PassUserData {
+		i--
+		if m.PassUserData {
+			dAtA[i] = 1
+		} else {
+			dAtA[i] = 0
+		}
+		i--
+		dAtA[i] = 0x20
+	}
+	if m.SamplingInterval != 0 {
+		i = encodeVarintProxy(dAtA, i, uint64(m.SamplingInterval))
+		i--
+		dAtA[i] = 0x18
+	}
+	if m.TurnOnBusinessLog {
+		i--
+		if m.TurnOnBusinessLog {
+			dAtA[i] = 1
+		} else {
+			dAtA[i] = 0
+		}
+		i--
+		dAtA[i] = 0x10
+	}
+	if m.TurnOnRpcLog {
+		i--
+		if m.TurnOnRpcLog {
+			dAtA[i] = 1
+		} else {
+			dAtA[i] = 0
+		}
+		i--
+		dAtA[i] = 0x8
+	}
+	return len(dAtA) - i, nil
+}
+
 func (m *Tracing_CustomTag) Marshal() (dAtA []byte, err error) {
 	size := m.Size()
 	dAtA = make([]byte, size)
@@ -2634,7 +3047,7 @@ func (m *Topology) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 	return len(dAtA) - i, nil
 }
 
-func (m *ProxyConfig) Marshal() (dAtA []byte, err error) {
+func (m *XModuleBootstrapConfig) Marshal() (dAtA []byte, err error) {
 	size := m.Size()
 	dAtA = make([]byte, size)
 	n, err := m.MarshalToSizedBuffer(dAtA[:size])
@@ -2644,12 +3057,12 @@ func (m *ProxyConfig) Marshal() (dAtA []byte, err error) {
 	return dAtA[:n], nil
 }
 
-func (m *ProxyConfig) MarshalTo(dAtA []byte) (int, error) {
+func (m *XModuleBootstrapConfig) MarshalTo(dAtA []byte) (int, error) {
 	size := m.Size()
 	return m.MarshalToSizedBuffer(dAtA[:size])
 }
 
-func (m *ProxyConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+func (m *XModuleBootstrapConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 	i := len(dAtA)
 	_ = i
 	var l int
@@ -2658,6 +3071,190 @@ func (m *ProxyConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 		i -= len(m.XXX_unrecognized)
 		copy(dAtA[i:], m.XXX_unrecognized)
 	}
+	if len(m.Cluster) > 0 {
+		i -= len(m.Cluster)
+		copy(dAtA[i:], m.Cluster)
+		i = encodeVarintProxy(dAtA, i, uint64(len(m.Cluster)))
+		i--
+		dAtA[i] = 0x7a
+	}
+	if len(m.Region) > 0 {
+		i -= len(m.Region)
+		copy(dAtA[i:], m.Region)
+		i = encodeVarintProxy(dAtA, i, uint64(len(m.Region)))
+		i--
+		dAtA[i] = 0x72
+	}
+	if m.CloudMode {
+		i--
+		if m.CloudMode {
+			dAtA[i] = 1
+		} else {
+			dAtA[i] = 0
+		}
+		i--
+		dAtA[i] = 0x68
+	}
+	if m.AbnormalReportEnable {
+		i--
+		if m.AbnormalReportEnable {
+			dAtA[i] = 1
+		} else {
+			dAtA[i] = 0
+		}
+		i--
+		dAtA[i] = 0x60
+	}
+	if m.MaxIpcLen != 0 {
+		i = encodeVarintProxy(dAtA, i, uint64(m.MaxIpcLen))
+		i--
+		dAtA[i] = 0x58
+	}
+	if m.SndbufSize != 0 {
+		i = encodeVarintProxy(dAtA, i, uint64(m.SndbufSize))
+		i--
+		dAtA[i] = 0x50
+	}
+	if m.DecompressBufferSize != 0 {
+		i = encodeVarintProxy(dAtA, i, uint64(m.DecompressBufferSize))
+		i--
+		dAtA[i] = 0x48
+	}
+	if m.SlsPort != 0 {
+		i = encodeVarintProxy(dAtA, i, uint64(m.SlsPort))
+		i--
+		dAtA[i] = 0x40
+	}
+	if len(m.FlowSlsProducer) > 0 {
+		i -= len(m.FlowSlsProducer)
+		copy(dAtA[i:], m.FlowSlsProducer)
+		i = encodeVarintProxy(dAtA, i, uint64(len(m.FlowSlsProducer)))
+		i--
+		dAtA[i] = 0x3a
+	}
+	if len(m.X5Proxy) > 0 {
+		i -= len(m.X5Proxy)
+		copy(dAtA[i:], m.X5Proxy)
+		i = encodeVarintProxy(dAtA, i, uint64(len(m.X5Proxy)))
+		i--
+		dAtA[i] = 0x32
+	}
+	if len(m.PunishHost) > 0 {
+		i -= len(m.PunishHost)
+		copy(dAtA[i:], m.PunishHost)
+		i = encodeVarintProxy(dAtA, i, uint64(len(m.PunishHost)))
+		i--
+		dAtA[i] = 0x2a
+	}
+	if len(m.PunishCluster) > 0 {
+		i -= len(m.PunishCluster)
+		copy(dAtA[i:], m.PunishCluster)
+		i = encodeVarintProxy(dAtA, i, uint64(len(m.PunishCluster)))
+		i--
+		dAtA[i] = 0x22
+	}
+	if len(m.AgentSock) > 0 {
+		i -= len(m.AgentSock)
+		copy(dAtA[i:], m.AgentSock)
+		i = encodeVarintProxy(dAtA, i, uint64(len(m.AgentSock)))
+		i--
+		dAtA[i] = 0x1a
+	}
+	if m.ConfigCheckRate != 0 {
+		i = encodeVarintProxy(dAtA, i, uint64(m.ConfigCheckRate))
+		i--
+		dAtA[i] = 0x10
+	}
+	if len(m.ConfigPath) > 0 {
+		i -= len(m.ConfigPath)
+		copy(dAtA[i:], m.ConfigPath)
+		i = encodeVarintProxy(dAtA, i, uint64(len(m.ConfigPath)))
+		i--
+		dAtA[i] = 0xa
+	}
+	return len(dAtA) - i, nil
+}
+
+func (m *ProxyConfig) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *ProxyConfig) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *ProxyConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
+	var l int
+	_ = l
+	if m.XXX_unrecognized != nil {
+		i -= len(m.XXX_unrecognized)
+		copy(dAtA[i:], m.XXX_unrecognized)
+	}
+	if m.DisableAlpnH2 {
+		i--
+		if m.DisableAlpnH2 {
+			dAtA[i] = 1
+		} else {
+			dAtA[i] = 0
+		}
+		i--
+		dAtA[i] = 0x6
+		i--
+		dAtA[i] = 0xf0
+	}
+	if m.XmoduleConfig != nil {
+		{
+			size, err := m.XmoduleConfig.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintProxy(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x6
+		i--
+		dAtA[i] = 0xaa
+	}
+	if len(m.LogPath) > 0 {
+		i -= len(m.LogPath)
+		copy(dAtA[i:], m.LogPath)
+		i = encodeVarintProxy(dAtA, i, uint64(len(m.LogPath)))
+		i--
+		dAtA[i] = 0x6
+		i--
+		dAtA[i] = 0xa2
+	}
+	if len(m.RuntimeValues) > 0 {
+		for k := range m.RuntimeValues {
+			v := m.RuntimeValues[k]
+			baseI := i
+			i -= len(v)
+			copy(dAtA[i:], v)
+			i = encodeVarintProxy(dAtA, i, uint64(len(v)))
+			i--
+			dAtA[i] = 0x12
+			i -= len(k)
+			copy(dAtA[i:], k)
+			i = encodeVarintProxy(dAtA, i, uint64(len(k)))
+			i--
+			dAtA[i] = 0xa
+			i = encodeVarintProxy(dAtA, i, uint64(baseI-i))
+			i--
+			dAtA[i] = 0x2
+			i--
+			dAtA[i] = 0xaa
+		}
+	}
 	if m.Image != nil {
 		{
 			size, err := m.Image.MarshalToSizedBuffer(dAtA[:i])
@@ -3261,6 +3858,18 @@ func (m *Tracing_OpenCensusAgent_) Size() (n int) {
 	}
 	return n
 }
+func (m *Tracing_Eagleeye) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if m.Eagleeye != nil {
+		l = m.Eagleeye.Size()
+		n += 1 + l + sovProxy(uint64(l))
+	}
+	return n
+}
 func (m *Tracing_Zipkin) Size() (n int) {
 	if m == nil {
 		return 0
@@ -3363,6 +3972,30 @@ func (m *Tracing_OpenCensusAgent) Size() (n int) {
 	return n
 }
 
+func (m *Tracing_EagleEye) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if m.TurnOnRpcLog {
+		n += 2
+	}
+	if m.TurnOnBusinessLog {
+		n += 2
+	}
+	if m.SamplingInterval != 0 {
+		n += 1 + sovProxy(uint64(m.SamplingInterval))
+	}
+	if m.PassUserData {
+		n += 2
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
 func (m *Tracing_CustomTag) Size() (n int) {
 	if m == nil {
 		return 0
@@ -3507,6 +4140,71 @@ func (m *Topology) Size() (n int) {
 	return n
 }
 
+func (m *XModuleBootstrapConfig) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	l = len(m.ConfigPath)
+	if l > 0 {
+		n += 1 + l + sovProxy(uint64(l))
+	}
+	if m.ConfigCheckRate != 0 {
+		n += 1 + sovProxy(uint64(m.ConfigCheckRate))
+	}
+	l = len(m.AgentSock)
+	if l > 0 {
+		n += 1 + l + sovProxy(uint64(l))
+	}
+	l = len(m.PunishCluster)
+	if l > 0 {
+		n += 1 + l + sovProxy(uint64(l))
+	}
+	l = len(m.PunishHost)
+	if l > 0 {
+		n += 1 + l + sovProxy(uint64(l))
+	}
+	l = len(m.X5Proxy)
+	if l > 0 {
+		n += 1 + l + sovProxy(uint64(l))
+	}
+	l = len(m.FlowSlsProducer)
+	if l > 0 {
+		n += 1 + l + sovProxy(uint64(l))
+	}
+	if m.SlsPort != 0 {
+		n += 1 + sovProxy(uint64(m.SlsPort))
+	}
+	if m.DecompressBufferSize != 0 {
+		n += 1 + sovProxy(uint64(m.DecompressBufferSize))
+	}
+	if m.SndbufSize != 0 {
+		n += 1 + sovProxy(uint64(m.SndbufSize))
+	}
+	if m.MaxIpcLen != 0 {
+		n += 1 + sovProxy(uint64(m.MaxIpcLen))
+	}
+	if m.AbnormalReportEnable {
+		n += 2
+	}
+	if m.CloudMode {
+		n += 2
+	}
+	l = len(m.Region)
+	if l > 0 {
+		n += 1 + l + sovProxy(uint64(l))
+	}
+	l = len(m.Cluster)
+	if l > 0 {
+		n += 1 + l + sovProxy(uint64(l))
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
 func (m *ProxyConfig) Size() (n int) {
 	if m == nil {
 		return 0
@@ -3648,6 +4346,25 @@ func (m *ProxyConfig) Size() (n int) {
 		l = m.Image.Size()
 		n += 2 + l + sovProxy(uint64(l))
 	}
+	if len(m.RuntimeValues) > 0 {
+		for k, v := range m.RuntimeValues {
+			_ = k
+			_ = v
+			mapEntrySize := 1 + len(k) + sovProxy(uint64(len(k))) + 1 + len(v) + sovProxy(uint64(len(v)))
+			n += mapEntrySize + 2 + sovProxy(uint64(mapEntrySize))
+		}
+	}
+	l = len(m.LogPath)
+	if l > 0 {
+		n += 2 + l + sovProxy(uint64(l))
+	}
+	if m.XmoduleConfig != nil {
+		l = m.XmoduleConfig.Size()
+		n += 2 + l + sovProxy(uint64(l))
+	}
+	if m.DisableAlpnH2 {
+		n += 3
+	}
 	if m.XXX_unrecognized != nil {
 		n += len(m.XXX_unrecognized)
 	}
@@ -4129,6 +4846,41 @@ func (m *Tracing) Unmarshal(dAtA []byte) error {
 			}
 			m.Tracer = &Tracing_OpenCensusAgent_{v}
 			iNdEx = postIndex
+		case 10:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Eagleeye", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowProxy
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthProxy
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthProxy
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			v := &Tracing_EagleEye{}
+			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			m.Tracer = &Tracing_Eagleeye{v}
+			iNdEx = postIndex
 		default:
 			iNdEx = preIndex
 			skippy, err := skipProxy(dAtA[iNdEx:])
@@ -4763,7 +5515,7 @@ func (m *Tracing_OpenCensusAgent) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
-func (m *Tracing_CustomTag) Unmarshal(dAtA []byte) error {
+func (m *Tracing_EagleEye) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
 	for iNdEx < l {
@@ -4786,17 +5538,17 @@ func (m *Tracing_CustomTag) Unmarshal(dAtA []byte) error {
 		fieldNum := int32(wire >> 3)
 		wireType := int(wire & 0x7)
 		if wireType == 4 {
-			return fmt.Errorf("proto: CustomTag: wiretype end group for non-group")
+			return fmt.Errorf("proto: EagleEye: wiretype end group for non-group")
 		}
 		if fieldNum <= 0 {
-			return fmt.Errorf("proto: CustomTag: illegal tag %d (wire type %d)", fieldNum, wire)
+			return fmt.Errorf("proto: EagleEye: illegal tag %d (wire type %d)", fieldNum, wire)
 		}
 		switch fieldNum {
 		case 1:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Literal", wireType)
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field TurnOnRpcLog", wireType)
 			}
-			var msglen int
+			var v int
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowProxy
@@ -4806,19 +5558,149 @@ func (m *Tracing_CustomTag) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				msglen |= int(b&0x7F) << shift
+				v |= int(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			if msglen < 0 {
-				return ErrInvalidLengthProxy
-			}
-			postIndex := iNdEx + msglen
-			if postIndex < 0 {
-				return ErrInvalidLengthProxy
+			m.TurnOnRpcLog = bool(v != 0)
+		case 2:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field TurnOnBusinessLog", wireType)
 			}
-			if postIndex > l {
+			var v int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowProxy
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				v |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			m.TurnOnBusinessLog = bool(v != 0)
+		case 3:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field SamplingInterval", wireType)
+			}
+			m.SamplingInterval = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowProxy
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.SamplingInterval |= uint32(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		case 4:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field PassUserData", wireType)
+			}
+			var v int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowProxy
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				v |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			m.PassUserData = bool(v != 0)
+		default:
+			iNdEx = preIndex
+			skippy, err := skipProxy(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthProxy
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *Tracing_CustomTag) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowProxy
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: CustomTag: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: CustomTag: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Literal", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowProxy
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthProxy
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthProxy
+			}
+			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
 			v := &Tracing_Literal{}
@@ -5366,9 +6248,405 @@ func (m *Topology) Unmarshal(dAtA []byte) error {
 		switch fieldNum {
 		case 1:
 			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field NumTrustedProxies", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field NumTrustedProxies", wireType)
+			}
+			m.NumTrustedProxies = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowProxy
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.NumTrustedProxies |= uint32(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		case 2:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field ForwardClientCertDetails", wireType)
+			}
+			m.ForwardClientCertDetails = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowProxy
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.ForwardClientCertDetails |= Topology_ForwardClientCertDetails(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		default:
+			iNdEx = preIndex
+			skippy, err := skipProxy(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthProxy
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *XModuleBootstrapConfig) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowProxy
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: XModuleBootstrapConfig: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: XModuleBootstrapConfig: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field ConfigPath", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowProxy
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthProxy
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthProxy
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.ConfigPath = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 2:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field ConfigCheckRate", wireType)
+			}
+			m.ConfigCheckRate = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowProxy
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.ConfigCheckRate |= uint32(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		case 3:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field AgentSock", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowProxy
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthProxy
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthProxy
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.AgentSock = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 4:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field PunishCluster", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowProxy
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthProxy
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthProxy
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.PunishCluster = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 5:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field PunishHost", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowProxy
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthProxy
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthProxy
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.PunishHost = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 6:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field X5Proxy", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowProxy
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthProxy
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthProxy
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.X5Proxy = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 7:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field FlowSlsProducer", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowProxy
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthProxy
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthProxy
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.FlowSlsProducer = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 8:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field SlsPort", wireType)
+			}
+			m.SlsPort = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowProxy
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.SlsPort |= uint32(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		case 9:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field DecompressBufferSize", wireType)
+			}
+			m.DecompressBufferSize = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowProxy
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.DecompressBufferSize |= uint32(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		case 10:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field SndbufSize", wireType)
+			}
+			m.SndbufSize = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowProxy
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.SndbufSize |= uint32(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		case 11:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field MaxIpcLen", wireType)
+			}
+			m.MaxIpcLen = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowProxy
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.MaxIpcLen |= uint32(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		case 12:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field AbnormalReportEnable", wireType)
+			}
+			var v int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowProxy
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				v |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			m.AbnormalReportEnable = bool(v != 0)
+		case 13:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field CloudMode", wireType)
 			}
-			m.NumTrustedProxies = 0
+			var v int
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowProxy
@@ -5378,16 +6656,17 @@ func (m *Topology) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				m.NumTrustedProxies |= uint32(b&0x7F) << shift
+				v |= int(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-		case 2:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field ForwardClientCertDetails", wireType)
+			m.CloudMode = bool(v != 0)
+		case 14:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
 			}
-			m.ForwardClientCertDetails = 0
+			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowProxy
@@ -5397,11 +6676,56 @@ func (m *Topology) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				m.ForwardClientCertDetails |= Topology_ForwardClientCertDetails(b&0x7F) << shift
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthProxy
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthProxy
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Region = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 15:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Cluster", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowProxy
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthProxy
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthProxy
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Cluster = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
 		default:
 			iNdEx = preIndex
 			skippy, err := skipProxy(dAtA[iNdEx:])
@@ -6595,6 +7919,221 @@ func (m *ProxyConfig) Unmarshal(dAtA []byte) error {
 				return err
 			}
 			iNdEx = postIndex
+		case 37:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeValues", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowProxy
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthProxy
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthProxy
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.RuntimeValues == nil {
+				m.RuntimeValues = make(map[string]string)
+			}
+			var mapkey string
+			var mapvalue string
+			for iNdEx < postIndex {
+				entryPreIndex := iNdEx
+				var wire uint64
+				for shift := uint(0); ; shift += 7 {
+					if shift >= 64 {
+						return ErrIntOverflowProxy
+					}
+					if iNdEx >= l {
+						return io.ErrUnexpectedEOF
+					}
+					b := dAtA[iNdEx]
+					iNdEx++
+					wire |= uint64(b&0x7F) << shift
+					if b < 0x80 {
+						break
+					}
+				}
+				fieldNum := int32(wire >> 3)
+				if fieldNum == 1 {
+					var stringLenmapkey uint64
+					for shift := uint(0); ; shift += 7 {
+						if shift >= 64 {
+							return ErrIntOverflowProxy
+						}
+						if iNdEx >= l {
+							return io.ErrUnexpectedEOF
+						}
+						b := dAtA[iNdEx]
+						iNdEx++
+						stringLenmapkey |= uint64(b&0x7F) << shift
+						if b < 0x80 {
+							break
+						}
+					}
+					intStringLenmapkey := int(stringLenmapkey)
+					if intStringLenmapkey < 0 {
+						return ErrInvalidLengthProxy
+					}
+					postStringIndexmapkey := iNdEx + intStringLenmapkey
+					if postStringIndexmapkey < 0 {
+						return ErrInvalidLengthProxy
+					}
+					if postStringIndexmapkey > l {
+						return io.ErrUnexpectedEOF
+					}
+					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
+					iNdEx = postStringIndexmapkey
+				} else if fieldNum == 2 {
+					var stringLenmapvalue uint64
+					for shift := uint(0); ; shift += 7 {
+						if shift >= 64 {
+							return ErrIntOverflowProxy
+						}
+						if iNdEx >= l {
+							return io.ErrUnexpectedEOF
+						}
+						b := dAtA[iNdEx]
+						iNdEx++
+						stringLenmapvalue |= uint64(b&0x7F) << shift
+						if b < 0x80 {
+							break
+						}
+					}
+					intStringLenmapvalue := int(stringLenmapvalue)
+					if intStringLenmapvalue < 0 {
+						return ErrInvalidLengthProxy
+					}
+					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
+					if postStringIndexmapvalue < 0 {
+						return ErrInvalidLengthProxy
+					}
+					if postStringIndexmapvalue > l {
+						return io.ErrUnexpectedEOF
+					}
+					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
+					iNdEx = postStringIndexmapvalue
+				} else {
+					iNdEx = entryPreIndex
+					skippy, err := skipProxy(dAtA[iNdEx:])
+					if err != nil {
+						return err
+					}
+					if (skippy < 0) || (iNdEx+skippy) < 0 {
+						return ErrInvalidLengthProxy
+					}
+					if (iNdEx + skippy) > postIndex {
+						return io.ErrUnexpectedEOF
+					}
+					iNdEx += skippy
+				}
+			}
+			m.RuntimeValues[mapkey] = mapvalue
+			iNdEx = postIndex
+		case 100:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field LogPath", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowProxy
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthProxy
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthProxy
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.LogPath = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 101:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field XmoduleConfig", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowProxy
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthProxy
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthProxy
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.XmoduleConfig == nil {
+				m.XmoduleConfig = &XModuleBootstrapConfig{}
+			}
+			if err := m.XmoduleConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 110:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field DisableAlpnH2", wireType)
+			}
+			var v int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowProxy
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				v |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			m.DisableAlpnH2 = bool(v != 0)
 		default:
 			iNdEx = preIndex
 			skippy, err := skipProxy(dAtA[iNdEx:])
diff --git a/mesh/v1alpha1/proxy.proto b/mesh/v1alpha1/proxy.proto
index 09736435..1b1e00aa 100644
--- a/mesh/v1alpha1/proxy.proto
+++ b/mesh/v1alpha1/proxy.proto
@@ -127,6 +127,17 @@ message Tracing {
     repeated TraceContext context = 2;
   }
 
+  message EagleEye {
+    // The flag of open rpc logging. if not specified, the default is true.
+    bool turn_on_rpc_log = 1;
+    // The flag of open business logging. if not specified, the default is false.
+    bool turn_on_business_log = 2;
+    // Log sampling interval, value range [1, 9000].
+    uint32 sampling_interval = 3;
+    // The flag that passes user data to the other end. if not specified, the default is true.
+    bool pass_user_data = 4;
+  }
+
   // The tracer implementation to be used by Envoy.
   oneof tracer {
     // Use a Zipkin tracer.
@@ -139,6 +150,9 @@ message Tracing {
     Stackdriver stackdriver = 4;
     // Use an OpenCensus tracer exporting to an OpenCensus agent.
     OpenCensusAgent open_census_agent = 9;
+
+    // Use a EagleEye tracer.
+    EagleEye eagleeye = 10;
   }
 
   // Configure custom tags that will be added to any active span.
@@ -291,6 +305,50 @@ message Topology {
   ForwardClientCertDetails forward_client_cert_details = 2;
 }
 
+message XModuleBootstrapConfig {
+  // XAgent module.json path
+  string config_path = 1;
+
+  // check XAgent module.json update interval
+  uint32 config_check_rate = 2;
+
+  string agent_sock = 3;
+
+  string punish_cluster = 4;
+
+  // punish center host name
+  string punish_host = 5;
+
+  // punish center uri prefix
+  string x5_proxy = 6;
+
+  // log producer name
+  string flow_sls_producer = 7;
+
+  // local watch dog port
+  uint32 sls_port = 8;
+
+  // gzip decompress buffer size
+  uint32 decompress_buffer_size = 9;
+
+  // send buffer size
+  uint32 sndbuf_size = 10;
+
+  uint32 max_ipc_len = 11;
+
+  // enable abnormal req report
+  bool abnormal_report_enable = 12;
+
+  // enable cloud mode
+  bool cloud_mode = 13;
+
+  // cloud mode region
+  string region = 14;
+
+  // cloud mode cluster
+  string cluster = 15;
+}
+
 // ProxyConfig defines variables for individual Envoy instances. This can be configured on a per-workload basis
 // as well as by the mesh-wide defaults.
 // To set the mesh wide defaults, configure the `defaultConfig` section of `meshConfig`. For example:
@@ -437,6 +495,10 @@ message ProxyConfig {
   // Names starting with `ISTIO_META_` will be included in the generated bootstrap and sent to the XDS server.
   map<string,string> proxy_metadata = 24;
 
+  // Envoy [runtime configuration](https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/operations/runtime) to set during bootstrapping.
+  // This enables setting experimental, unsafe, unsupported, and deprecated features that should be used with extreme caution.
+  map<string,string>  runtime_values = 37;
+
   // Port on which the agent should listen for administrative commands such as readiness probe.
   // Default is set to port `15020`.
   int32 status_port = 26;
@@ -525,6 +587,17 @@ message ProxyConfig {
   // Specifies the details of the proxy image.
   // $hide_from_docs
   ProxyImage image = 35;
+
+  // Added by ingress
+  // Configure the log path for envoy proxy.
+  string log_path = 100;
+
+  // Startup configuration of XModule(Alibaba Waf) filters.
+  XModuleBootstrapConfig xmodule_config = 101;
+
+  // Disable apln h2 protocol for envoy proxy.
+  bool disable_alpn_h2 = 110;
+  // End added by ingress
 }
 
 message RemoteService {
diff --git a/networking/v1alpha3/destination_rule.gen.json b/networking/v1alpha3/destination_rule.gen.json
index 5aae480a..81049772 100644
--- a/networking/v1alpha3/destination_rule.gen.json
+++ b/networking/v1alpha3/destination_rule.gen.json
@@ -178,12 +178,297 @@
           }
         }
       },
+      "istio.networking.v1alpha3.HealthCheck": {
+        "description": "[#next-free-field: 25]",
+        "type": "object",
+        "properties": {
+          "timeout": {
+            "description": "The time to wait for a health check response. If the timeout is reached the health check attempt will be considered a failure.",
+            "type": "string"
+          },
+          "interval": {
+            "description": "The interval between health checks.",
+            "type": "string"
+          },
+          "initialJitter": {
+            "description": "An optional jitter amount in milliseconds. If specified, Envoy will start health checking after for a random time in ms between 0 and initial_jitter. This only applies to the first health check.",
+            "type": "string"
+          },
+          "intervalJitter": {
+            "description": "An optional jitter amount in milliseconds. If specified, during every interval Envoy will add interval_jitter to the wait time.",
+            "type": "string"
+          },
+          "intervalJitterPercent": {
+            "description": "An optional jitter amount as a percentage of interval_ms. If specified, during every interval Envoy will add interval_ms * interval_jitter_percent / 100 to the wait time.",
+            "type": "integer"
+          },
+          "unhealthyThreshold": {
+            "description": "The number of unhealthy health checks required before a host is marked unhealthy. Note that for *http* health checking if a host responds with a code not in",
+            "type": "integer",
+            "nullable": true
+          },
+          "healthyThreshold": {
+            "description": "The number of healthy health checks required before a host is marked healthy. Note that during startup, only a single successful health check is required to mark a host healthy.",
+            "type": "integer",
+            "nullable": true
+          },
+          "altPort": {
+            "type": "integer",
+            "nullable": true
+          },
+          "reuseConnection": {
+            "type": "boolean",
+            "nullable": true
+          },
+          "noTrafficInterval": {
+            "description": "The default value for \"no traffic interval\" is 60 seconds.",
+            "type": "string"
+          },
+          "noTrafficHealthyInterval": {
+            "description": "If no_traffic_healthy_interval is not set, it will default to the no traffic interval and send that interval regardless of health state.",
+            "type": "string"
+          },
+          "unhealthyInterval": {
+            "description": "The default value for \"unhealthy interval\" is the same as \"interval\".",
+            "type": "string"
+          },
+          "unhealthyEdgeInterval": {
+            "description": "The default value for \"unhealthy edge interval\" is the same as \"unhealthy interval\".",
+            "type": "string"
+          },
+          "healthyEdgeInterval": {
+            "description": "The default value for \"healthy edge interval\" is the same as the default interval.",
+            "type": "string"
+          },
+          "eventLogPath": {
+            "description": "Specifies the path to the :ref:`health check event log \u003carch_overview_health_check_logging\u003e`. If empty, no event log will be written.",
+            "type": "string"
+          },
+          "alwaysLogHealthCheckFailures": {
+            "type": "boolean"
+          },
+          "tlsOptions": {
+            "$ref": "#/components/schemas/istio.networking.v1alpha3.HealthCheck.TlsOptions"
+          }
+        },
+        "oneOf": [
+          {
+            "not": {
+              "anyOf": [
+                {
+                  "required": [
+                    "httpHealthCheck"
+                  ],
+                  "properties": {
+                    "httpHealthCheck": {
+                      "$ref": "#/components/schemas/istio.networking.v1alpha3.HealthCheck.HttpHealthCheck"
+                    }
+                  }
+                },
+                {
+                  "required": [
+                    "tcpHealthCheck"
+                  ],
+                  "properties": {
+                    "tcpHealthCheck": {
+                      "$ref": "#/components/schemas/istio.networking.v1alpha3.HealthCheck.TcpHealthCheck"
+                    }
+                  }
+                },
+                {
+                  "required": [
+                    "grpcHealthCheck"
+                  ],
+                  "properties": {
+                    "grpcHealthCheck": {
+                      "$ref": "#/components/schemas/istio.networking.v1alpha3.HealthCheck.GrpcHealthCheck"
+                    }
+                  }
+                },
+                {
+                  "required": [
+                    "customHealthCheck"
+                  ],
+                  "properties": {
+                    "customHealthCheck": {
+                      "$ref": "#/components/schemas/istio.networking.v1alpha3.HealthCheck.CustomHealthCheck"
+                    }
+                  }
+                }
+              ]
+            }
+          },
+          {
+            "required": [
+              "httpHealthCheck"
+            ],
+            "properties": {
+              "httpHealthCheck": {
+                "$ref": "#/components/schemas/istio.networking.v1alpha3.HealthCheck.HttpHealthCheck"
+              }
+            }
+          },
+          {
+            "required": [
+              "tcpHealthCheck"
+            ],
+            "properties": {
+              "tcpHealthCheck": {
+                "$ref": "#/components/schemas/istio.networking.v1alpha3.HealthCheck.TcpHealthCheck"
+              }
+            }
+          },
+          {
+            "required": [
+              "grpcHealthCheck"
+            ],
+            "properties": {
+              "grpcHealthCheck": {
+                "$ref": "#/components/schemas/istio.networking.v1alpha3.HealthCheck.GrpcHealthCheck"
+              }
+            }
+          },
+          {
+            "required": [
+              "customHealthCheck"
+            ],
+            "properties": {
+              "customHealthCheck": {
+                "$ref": "#/components/schemas/istio.networking.v1alpha3.HealthCheck.CustomHealthCheck"
+              }
+            }
+          }
+        ]
+      },
+      "istio.networking.v1alpha3.HealthCheck.CustomHealthCheck": {
+        "description": "Custom health check.",
+        "type": "object",
+        "properties": {
+          "name": {
+            "description": "The registered name of the custom health checker.",
+            "type": "string"
+          }
+        }
+      },
+      "istio.networking.v1alpha3.HealthCheck.GrpcHealthCheck": {
+        "type": "object",
+        "properties": {
+          "serviceName": {
+            "type": "string"
+          },
+          "authority": {
+            "type": "string"
+          }
+        }
+      },
+      "istio.networking.v1alpha3.HealthCheck.HttpHealthCheck": {
+        "description": "[#next-free-field: 13]",
+        "type": "object",
+        "properties": {
+          "host": {
+            "type": "string"
+          },
+          "path": {
+            "description": "Specifies the HTTP path that will be requested during health checking.",
+            "type": "string"
+          },
+          "send": {
+            "$ref": "#/components/schemas/istio.networking.v1alpha3.Payload"
+          },
+          "receive": {
+            "$ref": "#/components/schemas/istio.networking.v1alpha3.Payload"
+          },
+          "expectedStatuses": {
+            "description": "Specifies a list of HTTP response statuses considered healthy. If provided, replaces default 200-only policy - 200 must be included explicitly as needed. Ranges follow half-open semantics of :ref:`Int64Range \u003cenvoy_v3_api_msg_type.v3.Int64Range\u003e`. The start and end of each range are required. Only statuses in the range [100, 600) are allowed.",
+            "type": "array",
+            "items": {
+              "$ref": "#/components/schemas/istio.networking.v1alpha3.Int64Range"
+            }
+          },
+          "retriableStatuses": {
+            "type": "array",
+            "items": {
+              "$ref": "#/components/schemas/istio.networking.v1alpha3.Int64Range"
+            }
+          }
+        }
+      },
+      "istio.networking.v1alpha3.HealthCheck.TcpHealthCheck": {
+        "type": "object",
+        "properties": {
+          "send": {
+            "$ref": "#/components/schemas/istio.networking.v1alpha3.Payload"
+          },
+          "receive": {
+            "type": "array",
+            "items": {
+              "$ref": "#/components/schemas/istio.networking.v1alpha3.Payload"
+            }
+          }
+        }
+      },
+      "istio.networking.v1alpha3.HealthCheck.TlsOptions": {
+        "description": "Health checks occur over the transport socket specified for the cluster. This implies that if a cluster is using a TLS-enabled transport socket, the health check will also occur over TLS.",
+        "type": "object",
+        "properties": {
+          "alpnProtocols": {
+            "type": "array",
+            "items": {
+              "type": "string"
+            }
+          }
+        }
+      },
+      "istio.networking.v1alpha3.HealthStatus": {
+        "description": "Endpoint health status.",
+        "type": "string",
+        "enum": [
+          "UNKNOWN",
+          "HEALTHY",
+          "UNHEALTHY",
+          "DRAINING",
+          "TIMEOUT",
+          "DEGRADED"
+        ]
+      },
+      "istio.networking.v1alpha3.HealthStatusSet": {
+        "type": "object",
+        "properties": {
+          "statuses": {
+            "description": "An order-independent set of health status.",
+            "type": "array",
+            "items": {
+              "$ref": "#/components/schemas/istio.networking.v1alpha3.HealthStatus"
+            }
+          }
+        }
+      },
+      "istio.networking.v1alpha3.Int64Range": {
+        "description": "Added by Ingress",
+        "type": "object",
+        "properties": {
+          "start": {
+            "description": "start of the range (inclusive)",
+            "type": "integer",
+            "format": "int64"
+          },
+          "end": {
+            "description": "end of the range (exclusive)",
+            "type": "integer",
+            "format": "int64"
+          }
+        }
+      },
       "istio.networking.v1alpha3.LoadBalancerSettings": {
         "description": "Load balancing policies to apply for a specific destination. See Envoy's load balancing [documentation](https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/upstream/load_balancing/load_balancing) for more details.",
         "type": "object",
         "properties": {
           "localityLbSetting": {
             "$ref": "#/components/schemas/istio.networking.v1alpha3.LocalityLoadBalancerSetting"
+          },
+          "warmupDurationSecs": {
+            "description": "Represents the warmup duration of Service. If set, the newly created endpoint of service remains in warmup mode starting from its creation time for the duration of this window and Istio progressively increases amount of traffic for that endpoint instead of sending proportional amount of traffic. This should be enabled for services that require warm up time to serve full production load with reasonable latency. Currently this is only supported for ROUND_ROBIN and LEAST_CONN load balancers.",
+            "type": "string"
           }
         },
         "oneOf": [
@@ -479,6 +764,59 @@
           }
         }
       },
+      "istio.networking.v1alpha3.Payload": {
+        "type": "object",
+        "oneOf": [
+          {
+            "not": {
+              "anyOf": [
+                {
+                  "required": [
+                    "text"
+                  ],
+                  "properties": {
+                    "text": {
+                      "type": "string"
+                    }
+                  }
+                },
+                {
+                  "required": [
+                    "binary"
+                  ],
+                  "properties": {
+                    "binary": {
+                      "type": "string",
+                      "format": "binary"
+                    }
+                  }
+                }
+              ]
+            }
+          },
+          {
+            "required": [
+              "text"
+            ],
+            "properties": {
+              "text": {
+                "type": "string"
+              }
+            }
+          },
+          {
+            "required": [
+              "binary"
+            ],
+            "properties": {
+              "binary": {
+                "type": "string",
+                "format": "binary"
+              }
+            }
+          }
+        ]
+      },
       "istio.networking.v1alpha3.PortSelector": {
         "description": "PortSelector specifies the number of a port to be used for matching or selection for final routing.",
         "type": "object",
@@ -531,6 +869,12 @@
             "items": {
               "$ref": "#/components/schemas/istio.networking.v1alpha3.TrafficPolicy.PortTrafficPolicy"
             }
+          },
+          "healthChecks": {
+            "type": "array",
+            "items": {
+              "$ref": "#/components/schemas/istio.networking.v1alpha3.HealthCheck"
+            }
           }
         }
       },
@@ -552,6 +896,12 @@
           },
           "tls": {
             "$ref": "#/components/schemas/istio.networking.v1alpha3.ClientTLSSettings"
+          },
+          "healthChecks": {
+            "type": "array",
+            "items": {
+              "$ref": "#/components/schemas/istio.networking.v1alpha3.HealthCheck"
+            }
           }
         }
       }
diff --git a/networking/v1alpha3/destination_rule.pb.go b/networking/v1alpha3/destination_rule.pb.go
index 5b4ef102..e6c30a65 100644
--- a/networking/v1alpha3/destination_rule.pb.go
+++ b/networking/v1alpha3/destination_rule.pb.go
@@ -165,6 +165,47 @@ var _ = math.Inf
 // proto package needs to be updated.
 const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package
 
+// Endpoint health status.
+type HealthStatus int32
+
+const (
+	// The health status is not known. This is interpreted by Envoy as *HEALTHY*.
+	HealthStatus_UNKNOWN HealthStatus = 0
+	// Healthy.
+	HealthStatus_HEALTHY HealthStatus = 1
+	// Unhealthy.
+	HealthStatus_UNHEALTHY HealthStatus = 2
+	HealthStatus_DRAINING  HealthStatus = 3
+	HealthStatus_TIMEOUT   HealthStatus = 4
+	HealthStatus_DEGRADED  HealthStatus = 5
+)
+
+var HealthStatus_name = map[int32]string{
+	0: "UNKNOWN",
+	1: "HEALTHY",
+	2: "UNHEALTHY",
+	3: "DRAINING",
+	4: "TIMEOUT",
+	5: "DEGRADED",
+}
+
+var HealthStatus_value = map[string]int32{
+	"UNKNOWN":   0,
+	"HEALTHY":   1,
+	"UNHEALTHY": 2,
+	"DRAINING":  3,
+	"TIMEOUT":   4,
+	"DEGRADED":  5,
+}
+
+func (x HealthStatus) String() string {
+	return proto.EnumName(HealthStatus_name, int32(x))
+}
+
+func (HealthStatus) EnumDescriptor() ([]byte, []int) {
+	return fileDescriptor_12899beb695152c8, []int{0}
+}
+
 // Standard load balancing algorithms that require no tuning.
 type LoadBalancerSettings_SimpleLB int32
 
@@ -435,6 +476,7 @@ type TrafficPolicy struct {
 	// overridden by port-level settings, i.e. default values will be applied
 	// to fields omitted in port-level traffic policies.
 	PortLevelSettings    []*TrafficPolicy_PortTrafficPolicy `protobuf:"bytes,5,rep,name=port_level_settings,json=portLevelSettings,proto3" json:"port_level_settings,omitempty"`
+	HealthChecks         []*HealthCheck                     `protobuf:"bytes,101,rep,name=health_checks,json=healthChecks,proto3" json:"health_checks,omitempty"`
 	XXX_NoUnkeyedLiteral struct{}                           `json:"-"`
 	XXX_unrecognized     []byte                             `json:"-"`
 	XXX_sizecache        int32                              `json:"-"`
@@ -508,6 +550,13 @@ func (m *TrafficPolicy) GetPortLevelSettings() []*TrafficPolicy_PortTrafficPolic
 	return nil
 }
 
+func (m *TrafficPolicy) GetHealthChecks() []*HealthCheck {
+	if m != nil {
+		return m.HealthChecks
+	}
+	return nil
+}
+
 // Traffic policies that apply to specific ports of the service
 type TrafficPolicy_PortTrafficPolicy struct {
 	// Specifies the number of a port on the destination service
@@ -522,6 +571,7 @@ type TrafficPolicy_PortTrafficPolicy struct {
 	OutlierDetection *OutlierDetection `protobuf:"bytes,4,opt,name=outlier_detection,json=outlierDetection,proto3" json:"outlier_detection,omitempty"`
 	// TLS related settings for connections to the upstream service.
 	Tls                  *ClientTLSSettings `protobuf:"bytes,5,opt,name=tls,proto3" json:"tls,omitempty"`
+	HealthChecks         []*HealthCheck     `protobuf:"bytes,101,rep,name=health_checks,json=healthChecks,proto3" json:"health_checks,omitempty"`
 	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
 	XXX_unrecognized     []byte             `json:"-"`
 	XXX_sizecache        int32              `json:"-"`
@@ -595,6 +645,13 @@ func (m *TrafficPolicy_PortTrafficPolicy) GetTls() *ClientTLSSettings {
 	return nil
 }
 
+func (m *TrafficPolicy_PortTrafficPolicy) GetHealthChecks() []*HealthCheck {
+	if m != nil {
+		return m.HealthChecks
+	}
+	return nil
+}
+
 // A subset of endpoints of a service. Subsets can be used for scenarios
 // like A/B testing, or routing to a specific version of a service. Refer
 // to [VirtualService](https://istio.io/docs/reference/config/networking/virtual-service/#VirtualService) documentation for examples of using
@@ -814,10 +871,16 @@ type LoadBalancerSettings struct {
 	LbPolicy isLoadBalancerSettings_LbPolicy `protobuf_oneof:"lb_policy"`
 	// Locality load balancer settings, this will override mesh wide settings in entirety, meaning no merging would be performed
 	// between this object and the object one in MeshConfig
-	LocalityLbSetting    *LocalityLoadBalancerSetting `protobuf:"bytes,3,opt,name=locality_lb_setting,json=localityLbSetting,proto3" json:"locality_lb_setting,omitempty"`
-	XXX_NoUnkeyedLiteral struct{}                     `json:"-"`
-	XXX_unrecognized     []byte                       `json:"-"`
-	XXX_sizecache        int32                        `json:"-"`
+	LocalityLbSetting *LocalityLoadBalancerSetting `protobuf:"bytes,3,opt,name=locality_lb_setting,json=localityLbSetting,proto3" json:"locality_lb_setting,omitempty"`
+	// Represents the warmup duration of Service. If set, the newly created endpoint of service
+	// remains in warmup mode starting from its creation time for the duration of this window and
+	// Istio progressively increases amount of traffic for that endpoint instead of sending proportional amount of traffic.
+	// This should be enabled for services that require warm up time to serve full production load with reasonable latency.
+	// Currently this is only supported for ROUND_ROBIN and LEAST_CONN load balancers.
+	WarmupDurationSecs   *types.Duration `protobuf:"bytes,4,opt,name=warmup_duration_secs,json=warmupDurationSecs,proto3" json:"warmup_duration_secs,omitempty"`
+	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
+	XXX_unrecognized     []byte          `json:"-"`
+	XXX_sizecache        int32           `json:"-"`
 }
 
 func (m *LoadBalancerSettings) Reset()         { *m = LoadBalancerSettings{} }
@@ -897,6 +960,13 @@ func (m *LoadBalancerSettings) GetLocalityLbSetting() *LocalityLoadBalancerSetti
 	return nil
 }
 
+func (m *LoadBalancerSettings) GetWarmupDurationSecs() *types.Duration {
+	if m != nil {
+		return m.WarmupDurationSecs
+	}
+	return nil
+}
+
 // XXX_OneofWrappers is for the internal use of the proto package.
 func (*LoadBalancerSettings) XXX_OneofWrappers() []interface{} {
 	return []interface{}{
@@ -2271,763 +2341,1051 @@ func (m *LocalityLoadBalancerSetting_Failover) GetTo() string {
 	return ""
 }
 
-func init() {
-	proto.RegisterEnum("istio.networking.v1alpha3.LoadBalancerSettings_SimpleLB", LoadBalancerSettings_SimpleLB_name, LoadBalancerSettings_SimpleLB_value)
-	proto.RegisterEnum("istio.networking.v1alpha3.ConnectionPoolSettings_HTTPSettings_H2UpgradePolicy", ConnectionPoolSettings_HTTPSettings_H2UpgradePolicy_name, ConnectionPoolSettings_HTTPSettings_H2UpgradePolicy_value)
-	proto.RegisterEnum("istio.networking.v1alpha3.ClientTLSSettings_TLSmode", ClientTLSSettings_TLSmode_name, ClientTLSSettings_TLSmode_value)
-	proto.RegisterType((*DestinationRule)(nil), "istio.networking.v1alpha3.DestinationRule")
-	proto.RegisterType((*TrafficPolicy)(nil), "istio.networking.v1alpha3.TrafficPolicy")
-	proto.RegisterType((*TrafficPolicy_PortTrafficPolicy)(nil), "istio.networking.v1alpha3.TrafficPolicy.PortTrafficPolicy")
-	proto.RegisterType((*Subset)(nil), "istio.networking.v1alpha3.Subset")
-	proto.RegisterMapType((map[string]string)(nil), "istio.networking.v1alpha3.Subset.LabelsEntry")
-	proto.RegisterType((*LoadBalancerSettings)(nil), "istio.networking.v1alpha3.LoadBalancerSettings")
-	proto.RegisterType((*LoadBalancerSettings_ConsistentHashLB)(nil), "istio.networking.v1alpha3.LoadBalancerSettings.ConsistentHashLB")
-	proto.RegisterType((*LoadBalancerSettings_ConsistentHashLB_HTTPCookie)(nil), "istio.networking.v1alpha3.LoadBalancerSettings.ConsistentHashLB.HTTPCookie")
-	proto.RegisterType((*ConnectionPoolSettings)(nil), "istio.networking.v1alpha3.ConnectionPoolSettings")
-	proto.RegisterType((*ConnectionPoolSettings_TCPSettings)(nil), "istio.networking.v1alpha3.ConnectionPoolSettings.TCPSettings")
-	proto.RegisterType((*ConnectionPoolSettings_TCPSettings_TcpKeepalive)(nil), "istio.networking.v1alpha3.ConnectionPoolSettings.TCPSettings.TcpKeepalive")
-	proto.RegisterType((*ConnectionPoolSettings_HTTPSettings)(nil), "istio.networking.v1alpha3.ConnectionPoolSettings.HTTPSettings")
-	proto.RegisterType((*OutlierDetection)(nil), "istio.networking.v1alpha3.OutlierDetection")
-	proto.RegisterType((*ClientTLSSettings)(nil), "istio.networking.v1alpha3.ClientTLSSettings")
-	proto.RegisterType((*LocalityLoadBalancerSetting)(nil), "istio.networking.v1alpha3.LocalityLoadBalancerSetting")
-	proto.RegisterType((*LocalityLoadBalancerSetting_Distribute)(nil), "istio.networking.v1alpha3.LocalityLoadBalancerSetting.Distribute")
-	proto.RegisterMapType((map[string]uint32)(nil), "istio.networking.v1alpha3.LocalityLoadBalancerSetting.Distribute.ToEntry")
-	proto.RegisterType((*LocalityLoadBalancerSetting_Failover)(nil), "istio.networking.v1alpha3.LocalityLoadBalancerSetting.Failover")
+// Added by Ingress
+type Int64Range struct {
+	// start of the range (inclusive)
+	Start int64 `protobuf:"varint,1,opt,name=start,proto3" json:"start,omitempty"`
+	// end of the range (exclusive)
+	End                  int64    `protobuf:"varint,2,opt,name=end,proto3" json:"end,omitempty"`
+	XXX_NoUnkeyedLiteral struct{} `json:"-"`
+	XXX_unrecognized     []byte   `json:"-"`
+	XXX_sizecache        int32    `json:"-"`
 }
 
-func init() {
-	proto.RegisterFile("networking/v1alpha3/destination_rule.proto", fileDescriptor_12899beb695152c8)
+func (m *Int64Range) Reset()         { *m = Int64Range{} }
+func (m *Int64Range) String() string { return proto.CompactTextString(m) }
+func (*Int64Range) ProtoMessage()    {}
+func (*Int64Range) Descriptor() ([]byte, []int) {
+	return fileDescriptor_12899beb695152c8, []int{8}
+}
+func (m *Int64Range) XXX_Unmarshal(b []byte) error {
+	return m.Unmarshal(b)
+}
+func (m *Int64Range) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	if deterministic {
+		return xxx_messageInfo_Int64Range.Marshal(b, m, deterministic)
+	} else {
+		b = b[:cap(b)]
+		n, err := m.MarshalToSizedBuffer(b)
+		if err != nil {
+			return nil, err
+		}
+		return b[:n], nil
+	}
+}
+func (m *Int64Range) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_Int64Range.Merge(m, src)
+}
+func (m *Int64Range) XXX_Size() int {
+	return m.Size()
+}
+func (m *Int64Range) XXX_DiscardUnknown() {
+	xxx_messageInfo_Int64Range.DiscardUnknown(m)
 }
 
-var fileDescriptor_12899beb695152c8 = []byte{
-	// 1941 bytes of a gzipped FileDescriptorProto
-	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x58, 0x4b, 0x73, 0xdb, 0xc8,
-	0xf1, 0x17, 0x1f, 0x7a, 0xb0, 0xa9, 0x07, 0x39, 0x56, 0xf9, 0x4f, 0xd3, 0xff, 0xd2, 0x7a, 0x59,
-	0xa9, 0x5a, 0xc7, 0xbb, 0x86, 0x62, 0x7a, 0x9d, 0xda, 0xac, 0xb3, 0x0f, 0x52, 0xa2, 0x4d, 0xad,
-	0x69, 0x91, 0x19, 0x52, 0x5b, 0x89, 0x73, 0x40, 0x0d, 0xc1, 0x11, 0x39, 0x2b, 0x10, 0x83, 0x1d,
-	0x0c, 0x68, 0xd2, 0xe7, 0x9c, 0x52, 0xf9, 0x08, 0xb9, 0xe6, 0x0b, 0xe4, 0x94, 0x6b, 0x6e, 0x39,
-	0x26, 0x95, 0xaa, 0x9c, 0x53, 0x3e, 0xe4, 0x1b, 0xe4, 0x92, 0x53, 0x6a, 0x06, 0x03, 0x12, 0xb2,
-	0x65, 0xca, 0xb6, 0xb2, 0x37, 0xa0, 0xfb, 0xd7, 0xbf, 0x9e, 0xe9, 0xee, 0xe9, 0x69, 0x00, 0xee,
-	0x78, 0x54, 0x3e, 0xe7, 0xe2, 0x8c, 0x79, 0xc3, 0xfd, 0xc9, 0x3d, 0xe2, 0xfa, 0x23, 0x72, 0x7f,
-	0x7f, 0x40, 0x03, 0xc9, 0x3c, 0x22, 0x19, 0xf7, 0x6c, 0x11, 0xba, 0xd4, 0xf2, 0x05, 0x97, 0x1c,
-	0xdd, 0x60, 0x81, 0x64, 0xdc, 0x5a, 0x58, 0x58, 0xb1, 0x45, 0xf9, 0x83, 0x21, 0xe7, 0x43, 0x97,
-	0xee, 0x13, 0x9f, 0xed, 0x9f, 0x32, 0xea, 0x0e, 0xec, 0x3e, 0x1d, 0x91, 0x09, 0xe3, 0x22, 0xb2,
-	0x2d, 0xef, 0x19, 0x80, 0x7e, 0xeb, 0x87, 0xa7, 0xfb, 0x83, 0x50, 0x68, 0x07, 0x6f, 0xd2, 0x3f,
-	0x17, 0xc4, 0xf7, 0xa9, 0x08, 0x8c, 0xfe, 0xc7, 0x17, 0xad, 0x73, 0xc2, 0x84, 0x0c, 0x89, 0x6b,
-	0x07, 0x54, 0x4c, 0x98, 0x63, 0x96, 0x59, 0xde, 0x1d, 0xf2, 0x21, 0xd7, 0x8f, 0xfb, 0xea, 0x29,
-	0x92, 0x56, 0xfe, 0x91, 0x82, 0x9d, 0xc3, 0xc5, 0xbe, 0x70, 0xe8, 0x52, 0x54, 0x82, 0xec, 0x88,
-	0x07, 0xb2, 0x94, 0xba, 0x95, 0xba, 0x9d, 0xab, 0x67, 0x5f, 0xd6, 0x52, 0x69, 0xac, 0x25, 0xa8,
-	0x0d, 0xdb, 0x52, 0x90, 0xd3, 0x53, 0xe6, 0xd8, 0x3e, 0x77, 0x99, 0x33, 0x2b, 0xa5, 0x6f, 0xa5,
-	0x6e, 0xe7, 0xab, 0xb7, 0xad, 0x37, 0xc6, 0xc0, 0xea, 0x45, 0x06, 0x1d, 0x8d, 0xc7, 0x5b, 0x32,
-	0xf9, 0x8a, 0x1e, 0xc2, 0x7a, 0x10, 0xf6, 0x03, 0x2a, 0x83, 0x52, 0xe6, 0x56, 0xe6, 0x76, 0xbe,
-	0xfa, 0xe1, 0x12, 0xa6, 0xae, 0x46, 0xe2, 0xd8, 0x02, 0xdd, 0x84, 0x1c, 0x9d, 0xfa, 0x5c, 0x48,
-	0x5b, 0xf2, 0x52, 0xf6, 0x56, 0xe6, 0x76, 0x0e, 0x6f, 0x44, 0x82, 0x1e, 0xaf, 0xfc, 0x6b, 0x0d,
-	0xb6, 0xce, 0xb9, 0x46, 0x3d, 0xd8, 0x72, 0x39, 0x19, 0xd8, 0x7d, 0xe2, 0x12, 0xcf, 0xa1, 0x42,
-	0xef, 0x2f, 0x5f, 0xdd, 0x5f, 0xe2, 0xb1, 0xc5, 0xc9, 0xa0, 0x6e, 0xe0, 0x5d, 0x2a, 0x25, 0xf3,
-	0x86, 0x01, 0xde, 0x74, 0x13, 0x52, 0xf4, 0x0c, 0x76, 0x1c, 0xee, 0x79, 0xd4, 0xd1, 0x65, 0xe1,
-	0x73, 0xee, 0x9a, 0x98, 0xdc, 0x5b, 0xc2, 0x7b, 0x30, 0xb7, 0xe8, 0x70, 0xee, 0xce, 0x99, 0xb7,
-	0x9d, 0x73, 0x72, 0xf4, 0x4b, 0x28, 0xf2, 0x50, 0xba, 0x8c, 0x0a, 0x7b, 0x40, 0x65, 0xa4, 0x28,
-	0x65, 0x34, 0xfb, 0xc7, 0x4b, 0xd8, 0xdb, 0x91, 0xcd, 0x61, 0x6c, 0x82, 0x0b, 0xfc, 0x15, 0x09,
-	0xfa, 0x12, 0x32, 0xd2, 0x0d, 0x4a, 0x59, 0xcd, 0xf5, 0xc9, 0xb2, 0x95, 0xba, 0x8c, 0x7a, 0xb2,
-	0xd7, 0xea, 0xce, 0x17, 0xa9, 0x0c, 0xd1, 0x77, 0x70, 0x4d, 0x07, 0xde, 0xa5, 0x13, 0xaa, 0x0a,
-	0x2d, 0xd2, 0x95, 0x56, 0x75, 0x0e, 0x3f, 0x7f, 0xdb, 0x6a, 0xb0, 0x3a, 0x2a, 0x57, 0xe7, 0xea,
-	0xa3, 0xa8, 0x68, 0x5b, 0x8a, 0x35, 0x76, 0x58, 0xfe, 0x7d, 0x06, 0x8a, 0xaf, 0x01, 0xd1, 0x43,
-	0xc8, 0x2a, 0xa8, 0x49, 0xe2, 0x47, 0x4b, 0x5c, 0x2a, 0xdb, 0x2e, 0x75, 0xa9, 0x23, 0xb9, 0xc0,
-	0xda, 0xe8, 0xf5, 0x52, 0x48, 0xff, 0x40, 0xa5, 0x90, 0xf9, 0x41, 0x4b, 0x21, 0xfb, 0x3f, 0x2c,
-	0x85, 0xd5, 0xf7, 0x2c, 0x85, 0xca, 0xbf, 0x53, 0xb0, 0x16, 0x9d, 0x4c, 0xd5, 0x38, 0x3c, 0x32,
-	0xa6, 0xe7, 0x1b, 0x87, 0x92, 0xa0, 0x06, 0xac, 0xb9, 0xa4, 0x4f, 0xdd, 0xa0, 0x94, 0xd6, 0x25,
-	0x72, 0xf7, 0xd2, 0x63, 0x6e, 0xb5, 0x34, 0xbe, 0xe1, 0x49, 0x31, 0xc3, 0xc6, 0xf8, 0x82, 0xfe,
-	0x93, 0xb9, 0x52, 0xff, 0x29, 0xff, 0x0c, 0xf2, 0x09, 0x3f, 0xa8, 0x00, 0x99, 0x33, 0x3a, 0x8b,
-	0xd6, 0x8f, 0xd5, 0x23, 0xda, 0x85, 0xd5, 0x09, 0x71, 0x43, 0xaa, 0x2b, 0x24, 0x87, 0xa3, 0x97,
-	0xcf, 0xd3, 0x9f, 0xa5, 0x2a, 0x7f, 0x5b, 0x83, 0xdd, 0x8b, 0x8a, 0x02, 0x61, 0x58, 0x0b, 0xd8,
-	0xd8, 0x77, 0xa3, 0x38, 0x6c, 0x57, 0x3f, 0x7b, 0xc7, 0xaa, 0xb2, 0xba, 0xda, 0xba, 0x55, 0x6f,
-	0xae, 0x60, 0xc3, 0x84, 0xce, 0x74, 0x69, 0x05, 0x2c, 0x90, 0xd4, 0x93, 0xf6, 0x88, 0x04, 0x23,
-	0x53, 0xb2, 0x5f, 0xbf, 0x2b, 0xf9, 0xc1, 0x9c, 0xa6, 0x49, 0x82, 0x91, 0x76, 0xb2, 0xed, 0x9c,
-	0x93, 0xa1, 0x53, 0xb8, 0xe6, 0x72, 0x87, 0xb8, 0x4c, 0xce, 0x6c, 0xb7, 0x1f, 0x9f, 0x6e, 0x13,
-	0xea, 0x9f, 0x2e, 0x75, 0x18, 0x59, 0x5d, 0xe0, 0x18, 0x17, 0x63, 0xca, 0x56, 0xdf, 0x88, 0xca,
-	0x7f, 0xca, 0x40, 0xe1, 0xd5, 0xe5, 0xa0, 0x3b, 0x50, 0x18, 0x49, 0xe9, 0xdb, 0x23, 0x4a, 0x06,
-	0x54, 0xd8, 0x8b, 0x7a, 0x52, 0x0b, 0x55, 0x9a, 0xa6, 0x56, 0x1c, 0xab, 0xaa, 0xf2, 0x20, 0xaf,
-	0xb1, 0x0e, 0xe7, 0x67, 0x8c, 0x9a, 0x88, 0x3c, 0xb9, 0x6a, 0x44, 0xac, 0x66, 0xaf, 0xd7, 0x39,
-	0xd0, 0x94, 0xcd, 0x15, 0x0c, 0xca, 0x43, 0xf4, 0x86, 0x7e, 0x04, 0x5b, 0x61, 0x40, 0xed, 0x80,
-	0x87, 0xc2, 0xa1, 0x36, 0xf3, 0x75, 0x48, 0x36, 0x9a, 0x2b, 0x38, 0x1f, 0x06, 0xb4, 0xab, 0xa5,
-	0x47, 0x3e, 0x7a, 0x08, 0x37, 0xf4, 0xaa, 0xbe, 0x0f, 0xa9, 0x98, 0xd9, 0x3e, 0x11, 0x64, 0x4c,
-	0x65, 0xbc, 0x95, 0x55, 0xb3, 0x95, 0xeb, 0x0a, 0xf2, 0x0b, 0x85, 0xe8, 0xc4, 0x00, 0xbd, 0xa5,
-	0x3b, 0x50, 0x1c, 0x33, 0x8f, 0x8d, 0xc3, 0xb1, 0x2d, 0x98, 0x37, 0xb4, 0x03, 0xf6, 0x82, 0xea,
-	0x73, 0x9e, 0xc5, 0x3b, 0x46, 0x81, 0x99, 0x37, 0xec, 0xb2, 0x17, 0xb4, 0x3c, 0x06, 0x58, 0x2c,
-	0x75, 0xc9, 0xe1, 0x43, 0x90, 0xf5, 0x89, 0x1c, 0x99, 0x12, 0xd6, 0xcf, 0xe8, 0x1e, 0x64, 0xa4,
-	0x8c, 0xfb, 0xd3, 0x0d, 0x2b, 0x1a, 0x33, 0xac, 0x78, 0xcc, 0xb0, 0x0e, 0xcd, 0x18, 0x62, 0x78,
-	0x14, 0xb6, 0x0e, 0xb0, 0xa1, 0x0a, 0xcf, 0x3e, 0xa3, 0xb3, 0x4a, 0x13, 0x36, 0xe2, 0x2a, 0x45,
-	0x3b, 0x90, 0xc7, 0xed, 0x93, 0xe3, 0x43, 0x1b, 0xb7, 0xeb, 0x47, 0xc7, 0x85, 0x15, 0xb4, 0x0d,
-	0xd0, 0x6a, 0xd4, 0xba, 0x3d, 0xfb, 0xa0, 0x7d, 0x7c, 0x5c, 0x48, 0x21, 0x80, 0x35, 0x5c, 0x3b,
-	0x3e, 0x6c, 0x3f, 0x2d, 0xa4, 0x15, 0xb8, 0x53, 0xeb, 0x76, 0x7b, 0x4d, 0xdc, 0x3e, 0x79, 0xdc,
-	0x2c, 0x64, 0xea, 0x79, 0xc8, 0xb9, 0x7d, 0x73, 0x9a, 0x2b, 0x7f, 0xde, 0x80, 0xeb, 0x17, 0x37,
-	0x44, 0xd4, 0x86, 0x8c, 0x74, 0x7c, 0xd3, 0xee, 0xbf, 0x78, 0xe7, 0x86, 0x6a, 0xf5, 0x0e, 0x3a,
-	0x89, 0xbe, 0xe5, 0xf8, 0x08, 0x43, 0x56, 0xe5, 0xc0, 0x54, 0xcd, 0x97, 0xef, 0xce, 0xa8, 0x62,
-	0x3f, 0xa7, 0xd4, 0x5c, 0xe5, 0xff, 0xa4, 0x21, 0x9f, 0x70, 0x84, 0x3e, 0x82, 0x9d, 0x31, 0x99,
-	0xda, 0x8b, 0x5e, 0x1e, 0xe8, 0x0d, 0xac, 0xe2, 0xed, 0x31, 0x99, 0x2e, 0x68, 0x03, 0x54, 0x9f,
-	0x5f, 0x1d, 0xb6, 0x64, 0x63, 0xca, 0x43, 0x69, 0xd6, 0xf5, 0xe6, 0xd4, 0xcc, 0xaf, 0x88, 0x5e,
-	0x64, 0x80, 0x38, 0x6c, 0x49, 0xc7, 0xb7, 0xcf, 0x28, 0xf5, 0x89, 0xcb, 0x26, 0xd4, 0x24, 0xf7,
-	0x9b, 0x2b, 0xc5, 0xca, 0xea, 0x39, 0xfe, 0x93, 0x98, 0x11, 0x6f, 0xca, 0xc4, 0x5b, 0xf9, 0x77,
-	0x29, 0xd8, 0x4c, 0xaa, 0xd1, 0x75, 0x58, 0xf3, 0x05, 0xef, 0xd3, 0x68, 0x97, 0x5b, 0xd8, 0xbc,
-	0xa1, 0xbb, 0x90, 0x55, 0xbb, 0xba, 0x7c, 0x4b, 0x1a, 0x86, 0x1e, 0xc0, 0x06, 0xf3, 0x24, 0x15,
-	0x13, 0x72, 0x79, 0x81, 0xe2, 0x39, 0xb4, 0xfc, 0x9b, 0x2c, 0x6c, 0x26, 0x73, 0x82, 0x1e, 0x42,
-	0x59, 0x65, 0xe5, 0x9e, 0xad, 0x72, 0xe0, 0x53, 0x6f, 0xa0, 0x0e, 0x94, 0xa0, 0xdf, 0x87, 0x34,
-	0x90, 0x71, 0x22, 0xfe, 0x4f, 0x23, 0x9e, 0x92, 0x69, 0x27, 0xd2, 0x63, 0xa3, 0x46, 0x9f, 0x00,
-	0x52, 0xaa, 0xaa, 0x36, 0x9e, 0x1b, 0xa5, 0xb5, 0x91, 0xee, 0x50, 0xd5, 0xa7, 0x64, 0x3a, 0x47,
-	0x7f, 0x01, 0x37, 0x93, 0x38, 0xdb, 0xa7, 0x22, 0x91, 0x75, 0xbd, 0x8b, 0x55, 0x5c, 0x1a, 0x2f,
-	0x2c, 0x3a, 0x54, 0x2c, 0x82, 0x8f, 0x3e, 0x80, 0x7c, 0x64, 0x2e, 0x05, 0xa3, 0xd1, 0x58, 0xb6,
-	0x8a, 0x41, 0xc3, 0xb5, 0x04, 0xfd, 0x1c, 0x36, 0xd9, 0xc0, 0xa5, 0xf3, 0xe2, 0x58, 0xbd, 0x2c,
-	0x2c, 0x79, 0x05, 0x8f, 0x2b, 0xe3, 0x05, 0x14, 0x47, 0x55, 0x3b, 0xf4, 0x87, 0x82, 0x0c, 0x68,
-	0x7c, 0x73, 0xae, 0xe9, 0xcb, 0xe9, 0xf8, 0x6a, 0x75, 0x6f, 0x35, 0xab, 0x27, 0x11, 0xad, 0xb9,
-	0x5f, 0x77, 0x46, 0xe7, 0x05, 0xc8, 0x82, 0x6b, 0xaa, 0x67, 0x3a, 0x7a, 0x78, 0xb0, 0xf5, 0x42,
-	0x1d, 0xee, 0x96, 0xd6, 0x55, 0xe7, 0xc4, 0xc5, 0x30, 0xa0, 0xd1, 0x58, 0xd1, 0x31, 0x8a, 0xca,
-	0x57, 0xb0, 0xf3, 0x0a, 0x27, 0xca, 0xc3, 0xfa, 0x61, 0xe3, 0x51, 0xed, 0xa4, 0xd5, 0x2b, 0xac,
-	0x20, 0x04, 0xdb, 0x87, 0x6d, 0xfb, 0xb8, 0xdd, 0xb3, 0x4f, 0x3a, 0x8f, 0x71, 0xed, 0xb0, 0x51,
-	0x48, 0x29, 0x40, 0xfc, 0x92, 0xae, 0xfc, 0x76, 0x15, 0x0a, 0xaf, 0x8e, 0x3d, 0xe8, 0x1e, 0x20,
-	0x75, 0xc9, 0x51, 0x27, 0x94, 0x6c, 0x42, 0x6d, 0x2a, 0x04, 0x17, 0xa6, 0x04, 0xea, 0xe9, 0x52,
-	0x0a, 0x17, 0x13, 0xda, 0x86, 0x56, 0xa2, 0x6f, 0xa0, 0x12, 0xf8, 0x2e, 0x93, 0x36, 0x9d, 0x4a,
-	0x2a, 0x3c, 0xe2, 0xda, 0xfa, 0x06, 0xb3, 0xb9, 0x60, 0x43, 0xe6, 0xc5, 0x14, 0x1b, 0x7a, 0x1f,
-	0x7b, 0x1a, 0xd9, 0x30, 0x40, 0x7d, 0x0d, 0xb6, 0x35, 0xcc, 0x70, 0x0d, 0xe1, 0xc3, 0xa4, 0xfb,
-	0x73, 0x44, 0xa7, 0x84, 0xb9, 0xa1, 0xa0, 0x41, 0x29, 0xa7, 0x73, 0xfa, 0xff, 0xaf, 0xe5, 0xf4,
-	0xe4, 0xc8, 0x93, 0xf7, 0xab, 0xdf, 0xaa, 0xc1, 0x03, 0xef, 0x25, 0x68, 0x12, 0x6e, 0x1e, 0x19,
-	0x0e, 0xf4, 0x0c, 0xca, 0x49, 0x47, 0x43, 0x22, 0xe9, 0x73, 0x32, 0x8b, 0x17, 0xbb, 0xf6, 0x16,
-	0x1e, 0x4a, 0x09, 0xfb, 0xc7, 0x91, 0xb9, 0xd9, 0x04, 0x86, 0xeb, 0x49, 0xee, 0x07, 0xd3, 0x69,
-	0xcc, 0xbb, 0xfe, 0x16, 0xbc, 0xbb, 0x09, 0xdb, 0x07, 0xd3, 0xa9, 0xe1, 0x4c, 0x1e, 0xf5, 0xf4,
-	0x5b, 0x1f, 0x75, 0xf4, 0x18, 0x50, 0x9f, 0x04, 0xd4, 0xa6, 0xdf, 0x99, 0x61, 0x5b, 0xb7, 0x97,
-	0x4b, 0x7b, 0x45, 0x41, 0x19, 0x35, 0x8c, 0x8d, 0x3a, 0x1c, 0xe8, 0x27, 0xb0, 0xab, 0x0e, 0xde,
-	0x9c, 0xc7, 0xa7, 0xc2, 0xa1, 0x9e, 0x34, 0x27, 0x10, 0x8d, 0xc9, 0x34, 0x86, 0x77, 0x22, 0x8d,
-	0xea, 0x0b, 0x63, 0xe6, 0xa9, 0xf1, 0xc4, 0x95, 0xa3, 0x39, 0x7e, 0x35, 0xea, 0x0b, 0x63, 0xe6,
-	0x35, 0xb5, 0xc2, 0xa0, 0x2b, 0x7f, 0xcf, 0x40, 0xf1, 0xb5, 0xb9, 0x19, 0x1d, 0x43, 0x76, 0xcc,
-	0x07, 0xf1, 0x7c, 0xf8, 0xe9, 0xbb, 0xcc, 0xdc, 0x56, 0xaf, 0xd5, 0x55, 0xb6, 0xf1, 0x05, 0xaf,
-	0x9e, 0xd1, 0x5d, 0x40, 0xe6, 0x7c, 0x39, 0x54, 0x48, 0x76, 0xca, 0x1c, 0x22, 0xe3, 0x89, 0xb5,
-	0x18, 0x69, 0x0e, 0x16, 0x0a, 0xd5, 0x6d, 0x7c, 0xc1, 0x26, 0x44, 0x52, 0x75, 0x97, 0xeb, 0xb0,
-	0xe5, 0x30, 0x18, 0xd1, 0x13, 0x3a, 0x53, 0xd7, 0x96, 0x43, 0x92, 0x5c, 0x51, 0x4b, 0xca, 0xe1,
-	0x6d, 0x87, 0x24, 0x88, 0xf4, 0xfd, 0xe6, 0x08, 0x3a, 0xa0, 0x9e, 0x64, 0xc4, 0x8d, 0x06, 0x9c,
-	0x75, 0x03, 0x9c, 0x8b, 0xe3, 0xb1, 0x26, 0x08, 0xfb, 0x2a, 0x94, 0x36, 0x71, 0xa5, 0x46, 0x46,
-	0x5f, 0x8b, 0x39, 0xbc, 0x63, 0x14, 0x35, 0x57, 0x2a, 0x68, 0xa0, 0x86, 0xf0, 0xc0, 0x63, 0xba,
-	0x58, 0x73, 0x58, 0x3d, 0xa2, 0x16, 0xec, 0x32, 0x5d, 0x3c, 0x82, 0xda, 0xc1, 0x19, 0xf3, 0xed,
-	0x09, 0x15, 0xec, 0x74, 0xa6, 0x0f, 0x5f, 0xbe, 0x5a, 0x7e, 0x2d, 0xe1, 0x75, 0xce, 0xdd, 0xa8,
-	0xea, 0x50, 0x6c, 0xd7, 0x3d, 0x63, 0xfe, 0xb7, 0xda, 0xaa, 0xf2, 0x35, 0xac, 0x9b, 0x20, 0xea,
-	0xce, 0x72, 0xd4, 0xad, 0xd5, 0x5b, 0x8d, 0xc2, 0x8a, 0x1a, 0x53, 0xba, 0x47, 0x4f, 0x3b, 0xad,
-	0x46, 0x34, 0xb2, 0x3c, 0x3d, 0xe9, 0x9d, 0xd4, 0x5a, 0x85, 0x34, 0x2a, 0xc0, 0xe6, 0x51, 0xb7,
-	0x77, 0xd4, 0xb6, 0x8d, 0x24, 0x53, 0xf9, 0x43, 0x16, 0x6e, 0x2e, 0x99, 0x75, 0x11, 0x01, 0x18,
-	0xb0, 0x40, 0x0a, 0xd6, 0x0f, 0xa5, 0xca, 0xb2, 0xfa, 0xe2, 0xa9, 0xbd, 0xdf, 0xdc, 0x6c, 0x1d,
-	0xce, 0x89, 0x70, 0x82, 0x14, 0xfd, 0x1a, 0x36, 0x54, 0xe3, 0xe0, 0x13, 0xfd, 0xf1, 0xaa, 0x1c,
-	0x7c, 0xf5, 0x9e, 0x0e, 0x1e, 0x19, 0x1a, 0x3c, 0x27, 0x44, 0x1f, 0x43, 0x31, 0x7e, 0xb6, 0x7d,
-	0xc1, 0xb8, 0x60, 0x72, 0x66, 0x7e, 0xb0, 0x14, 0x62, 0x45, 0xc7, 0xc8, 0xd1, 0xa7, 0xb0, 0x4e,
-	0x3d, 0xd2, 0x77, 0xe9, 0xc0, 0x1c, 0xc0, 0x65, 0xf9, 0x88, 0xa1, 0xe5, 0x3f, 0xa6, 0x00, 0x16,
-	0x5b, 0x53, 0x23, 0xea, 0xa9, 0xe0, 0x63, 0xf3, 0xe5, 0xa5, 0x9f, 0xd1, 0xaf, 0x20, 0x2d, 0xb9,
-	0xd9, 0xdc, 0xd1, 0x95, 0xa3, 0x67, 0xf5, 0x78, 0xf4, 0x2d, 0x99, 0x96, 0xbc, 0xfc, 0x00, 0xd6,
-	0xcd, 0xeb, 0x65, 0x9f, 0x7c, 0x5b, 0x89, 0x4f, 0xbe, 0xb2, 0x05, 0x1b, 0x71, 0xb4, 0x2e, 0x5c,
-	0xf1, 0xb6, 0x59, 0xb1, 0x92, 0xa4, 0x25, 0xaf, 0x5b, 0x7f, 0x79, 0xb9, 0x97, 0xfa, 0xeb, 0xcb,
-	0xbd, 0xd4, 0x3f, 0x5f, 0xee, 0xa5, 0x9e, 0xdd, 0x8a, 0xb6, 0xc0, 0xb8, 0xfe, 0x1d, 0x78, 0xc1,
-	0x8f, 0xbb, 0xfe, 0x9a, 0x8e, 0xd8, 0xfd, 0xff, 0x06, 0x00, 0x00, 0xff, 0xff, 0x84, 0x57, 0x3b,
-	0x12, 0x7e, 0x14, 0x00, 0x00,
+var xxx_messageInfo_Int64Range proto.InternalMessageInfo
+
+func (m *Int64Range) GetStart() int64 {
+	if m != nil {
+		return m.Start
+	}
+	return 0
 }
 
-func (m *DestinationRule) Marshal() (dAtA []byte, err error) {
-	size := m.Size()
-	dAtA = make([]byte, size)
-	n, err := m.MarshalToSizedBuffer(dAtA[:size])
-	if err != nil {
-		return nil, err
+func (m *Int64Range) GetEnd() int64 {
+	if m != nil {
+		return m.End
 	}
-	return dAtA[:n], nil
+	return 0
 }
 
-func (m *DestinationRule) MarshalTo(dAtA []byte) (int, error) {
-	size := m.Size()
-	return m.MarshalToSizedBuffer(dAtA[:size])
+type HealthStatusSet struct {
+	// An order-independent set of health status.
+	Statuses             []HealthStatus `protobuf:"varint,1,rep,packed,name=statuses,proto3,enum=istio.networking.v1alpha3.HealthStatus" json:"statuses,omitempty"`
+	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
+	XXX_unrecognized     []byte         `json:"-"`
+	XXX_sizecache        int32          `json:"-"`
 }
 
-func (m *DestinationRule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
-	i := len(dAtA)
-	_ = i
-	var l int
-	_ = l
-	if m.XXX_unrecognized != nil {
-		i -= len(m.XXX_unrecognized)
-		copy(dAtA[i:], m.XXX_unrecognized)
-	}
-	if len(m.ExportTo) > 0 {
-		for iNdEx := len(m.ExportTo) - 1; iNdEx >= 0; iNdEx-- {
-			i -= len(m.ExportTo[iNdEx])
-			copy(dAtA[i:], m.ExportTo[iNdEx])
-			i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.ExportTo[iNdEx])))
-			i--
-			dAtA[i] = 0x22
+func (m *HealthStatusSet) Reset()         { *m = HealthStatusSet{} }
+func (m *HealthStatusSet) String() string { return proto.CompactTextString(m) }
+func (*HealthStatusSet) ProtoMessage()    {}
+func (*HealthStatusSet) Descriptor() ([]byte, []int) {
+	return fileDescriptor_12899beb695152c8, []int{9}
+}
+func (m *HealthStatusSet) XXX_Unmarshal(b []byte) error {
+	return m.Unmarshal(b)
+}
+func (m *HealthStatusSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	if deterministic {
+		return xxx_messageInfo_HealthStatusSet.Marshal(b, m, deterministic)
+	} else {
+		b = b[:cap(b)]
+		n, err := m.MarshalToSizedBuffer(b)
+		if err != nil {
+			return nil, err
 		}
+		return b[:n], nil
 	}
-	if len(m.Subsets) > 0 {
-		for iNdEx := len(m.Subsets) - 1; iNdEx >= 0; iNdEx-- {
-			{
-				size, err := m.Subsets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
-				if err != nil {
-					return 0, err
-				}
-				i -= size
-				i = encodeVarintDestinationRule(dAtA, i, uint64(size))
-			}
-			i--
-			dAtA[i] = 0x1a
-		}
+}
+func (m *HealthStatusSet) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_HealthStatusSet.Merge(m, src)
+}
+func (m *HealthStatusSet) XXX_Size() int {
+	return m.Size()
+}
+func (m *HealthStatusSet) XXX_DiscardUnknown() {
+	xxx_messageInfo_HealthStatusSet.DiscardUnknown(m)
+}
+
+var xxx_messageInfo_HealthStatusSet proto.InternalMessageInfo
+
+func (m *HealthStatusSet) GetStatuses() []HealthStatus {
+	if m != nil {
+		return m.Statuses
 	}
-	if m.TrafficPolicy != nil {
-		{
-			size, err := m.TrafficPolicy.MarshalToSizedBuffer(dAtA[:i])
-			if err != nil {
-				return 0, err
-			}
-			i -= size
-			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+	return nil
+}
+
+type Payload struct {
+	// Types that are valid to be assigned to Payload:
+	//	*Payload_Text
+	//	*Payload_Binary
+	Payload              isPayload_Payload `protobuf_oneof:"payload"`
+	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
+	XXX_unrecognized     []byte            `json:"-"`
+	XXX_sizecache        int32             `json:"-"`
+}
+
+func (m *Payload) Reset()         { *m = Payload{} }
+func (m *Payload) String() string { return proto.CompactTextString(m) }
+func (*Payload) ProtoMessage()    {}
+func (*Payload) Descriptor() ([]byte, []int) {
+	return fileDescriptor_12899beb695152c8, []int{10}
+}
+func (m *Payload) XXX_Unmarshal(b []byte) error {
+	return m.Unmarshal(b)
+}
+func (m *Payload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	if deterministic {
+		return xxx_messageInfo_Payload.Marshal(b, m, deterministic)
+	} else {
+		b = b[:cap(b)]
+		n, err := m.MarshalToSizedBuffer(b)
+		if err != nil {
+			return nil, err
 		}
-		i--
-		dAtA[i] = 0x12
-	}
-	if len(m.Host) > 0 {
-		i -= len(m.Host)
-		copy(dAtA[i:], m.Host)
-		i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.Host)))
-		i--
-		dAtA[i] = 0xa
+		return b[:n], nil
 	}
-	return len(dAtA) - i, nil
+}
+func (m *Payload) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_Payload.Merge(m, src)
+}
+func (m *Payload) XXX_Size() int {
+	return m.Size()
+}
+func (m *Payload) XXX_DiscardUnknown() {
+	xxx_messageInfo_Payload.DiscardUnknown(m)
 }
 
-func (m *TrafficPolicy) Marshal() (dAtA []byte, err error) {
-	size := m.Size()
-	dAtA = make([]byte, size)
-	n, err := m.MarshalToSizedBuffer(dAtA[:size])
-	if err != nil {
-		return nil, err
+var xxx_messageInfo_Payload proto.InternalMessageInfo
+
+type isPayload_Payload interface {
+	isPayload_Payload()
+	MarshalTo([]byte) (int, error)
+	Size() int
+}
+
+type Payload_Text struct {
+	Text string `protobuf:"bytes,1,opt,name=text,proto3,oneof" json:"text,omitempty"`
+}
+type Payload_Binary struct {
+	Binary []byte `protobuf:"bytes,2,opt,name=binary,proto3,oneof" json:"binary,omitempty"`
+}
+
+func (*Payload_Text) isPayload_Payload()   {}
+func (*Payload_Binary) isPayload_Payload() {}
+
+func (m *Payload) GetPayload() isPayload_Payload {
+	if m != nil {
+		return m.Payload
 	}
-	return dAtA[:n], nil
+	return nil
 }
 
-func (m *TrafficPolicy) MarshalTo(dAtA []byte) (int, error) {
-	size := m.Size()
-	return m.MarshalToSizedBuffer(dAtA[:size])
+func (m *Payload) GetText() string {
+	if x, ok := m.GetPayload().(*Payload_Text); ok {
+		return x.Text
+	}
+	return ""
 }
 
-func (m *TrafficPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
-	i := len(dAtA)
-	_ = i
-	var l int
-	_ = l
-	if m.XXX_unrecognized != nil {
-		i -= len(m.XXX_unrecognized)
-		copy(dAtA[i:], m.XXX_unrecognized)
+func (m *Payload) GetBinary() []byte {
+	if x, ok := m.GetPayload().(*Payload_Binary); ok {
+		return x.Binary
 	}
-	if len(m.PortLevelSettings) > 0 {
-		for iNdEx := len(m.PortLevelSettings) - 1; iNdEx >= 0; iNdEx-- {
-			{
-				size, err := m.PortLevelSettings[iNdEx].MarshalToSizedBuffer(dAtA[:i])
-				if err != nil {
-					return 0, err
-				}
-				i -= size
-				i = encodeVarintDestinationRule(dAtA, i, uint64(size))
-			}
-			i--
-			dAtA[i] = 0x2a
-		}
+	return nil
+}
+
+// XXX_OneofWrappers is for the internal use of the proto package.
+func (*Payload) XXX_OneofWrappers() []interface{} {
+	return []interface{}{
+		(*Payload_Text)(nil),
+		(*Payload_Binary)(nil),
 	}
-	if m.Tls != nil {
-		{
-			size, err := m.Tls.MarshalToSizedBuffer(dAtA[:i])
-			if err != nil {
-				return 0, err
-			}
-			i -= size
-			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+}
+
+// [#next-free-field: 25]
+type HealthCheck struct {
+	// The time to wait for a health check response. If the timeout is reached the
+	// health check attempt will be considered a failure.
+	Timeout *types.Duration `protobuf:"bytes,1,opt,name=timeout,proto3" json:"timeout,omitempty"`
+	// The interval between health checks.
+	Interval *types.Duration `protobuf:"bytes,2,opt,name=interval,proto3" json:"interval,omitempty"`
+	// An optional jitter amount in milliseconds. If specified, Envoy will start health
+	// checking after for a random time in ms between 0 and initial_jitter. This only
+	// applies to the first health check.
+	InitialJitter *types.Duration `protobuf:"bytes,20,opt,name=initial_jitter,json=initialJitter,proto3" json:"initial_jitter,omitempty"`
+	// An optional jitter amount in milliseconds. If specified, during every
+	// interval Envoy will add interval_jitter to the wait time.
+	IntervalJitter *types.Duration `protobuf:"bytes,3,opt,name=interval_jitter,json=intervalJitter,proto3" json:"interval_jitter,omitempty"`
+	// An optional jitter amount as a percentage of interval_ms. If specified,
+	// during every interval Envoy will add interval_ms *
+	// interval_jitter_percent / 100 to the wait time.
+	//
+	// If interval_jitter_ms and interval_jitter_percent are both set, both of
+	// them will be used to increase the wait time.
+	IntervalJitterPercent uint32 `protobuf:"varint,18,opt,name=interval_jitter_percent,json=intervalJitterPercent,proto3" json:"interval_jitter_percent,omitempty"`
+	// The number of unhealthy health checks required before a host is marked
+	// unhealthy. Note that for *http* health checking if a host responds with a code not in
+	UnhealthyThreshold *types.UInt32Value `protobuf:"bytes,4,opt,name=unhealthy_threshold,json=unhealthyThreshold,proto3" json:"unhealthy_threshold,omitempty"`
+	// The number of healthy health checks required before a host is marked
+	// healthy. Note that during startup, only a single successful health check is
+	// required to mark a host healthy.
+	HealthyThreshold *types.UInt32Value `protobuf:"bytes,5,opt,name=healthy_threshold,json=healthyThreshold,proto3" json:"healthy_threshold,omitempty"`
+	AltPort          *types.UInt32Value `protobuf:"bytes,6,opt,name=alt_port,json=altPort,proto3" json:"alt_port,omitempty"`
+	ReuseConnection  *types.BoolValue   `protobuf:"bytes,7,opt,name=reuse_connection,json=reuseConnection,proto3" json:"reuse_connection,omitempty"`
+	// Types that are valid to be assigned to HealthChecker:
+	//	*HealthCheck_HttpHealthCheck_
+	//	*HealthCheck_TcpHealthCheck_
+	//	*HealthCheck_GrpcHealthCheck_
+	//	*HealthCheck_CustomHealthCheck_
+	HealthChecker isHealthCheck_HealthChecker `protobuf_oneof:"health_checker"`
+	// The default value for "no traffic interval" is 60 seconds.
+	NoTrafficInterval *types.Duration `protobuf:"bytes,12,opt,name=no_traffic_interval,json=noTrafficInterval,proto3" json:"no_traffic_interval,omitempty"`
+	// If no_traffic_healthy_interval is not set, it will default to the
+	// no traffic interval and send that interval regardless of health state.
+	NoTrafficHealthyInterval *types.Duration `protobuf:"bytes,24,opt,name=no_traffic_healthy_interval,json=noTrafficHealthyInterval,proto3" json:"no_traffic_healthy_interval,omitempty"`
+	// The default value for "unhealthy interval" is the same as "interval".
+	UnhealthyInterval *types.Duration `protobuf:"bytes,14,opt,name=unhealthy_interval,json=unhealthyInterval,proto3" json:"unhealthy_interval,omitempty"`
+	// The default value for "unhealthy edge interval" is the same as "unhealthy interval".
+	UnhealthyEdgeInterval *types.Duration `protobuf:"bytes,15,opt,name=unhealthy_edge_interval,json=unhealthyEdgeInterval,proto3" json:"unhealthy_edge_interval,omitempty"`
+	// The default value for "healthy edge interval" is the same as the default interval.
+	HealthyEdgeInterval *types.Duration `protobuf:"bytes,16,opt,name=healthy_edge_interval,json=healthyEdgeInterval,proto3" json:"healthy_edge_interval,omitempty"`
+	// Specifies the path to the :ref:`health check event log <arch_overview_health_check_logging>`.
+	// If empty, no event log will be written.
+	EventLogPath                 string `protobuf:"bytes,17,opt,name=event_log_path,json=eventLogPath,proto3" json:"event_log_path,omitempty"`
+	AlwaysLogHealthCheckFailures bool   `protobuf:"varint,19,opt,name=always_log_health_check_failures,json=alwaysLogHealthCheckFailures,proto3" json:"always_log_health_check_failures,omitempty"`
+	// This allows overriding the cluster TLS settings, just for health check connections.
+	TlsOptions           *HealthCheck_TlsOptions `protobuf:"bytes,21,opt,name=tls_options,json=tlsOptions,proto3" json:"tls_options,omitempty"`
+	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
+	XXX_unrecognized     []byte                  `json:"-"`
+	XXX_sizecache        int32                   `json:"-"`
+}
+
+func (m *HealthCheck) Reset()         { *m = HealthCheck{} }
+func (m *HealthCheck) String() string { return proto.CompactTextString(m) }
+func (*HealthCheck) ProtoMessage()    {}
+func (*HealthCheck) Descriptor() ([]byte, []int) {
+	return fileDescriptor_12899beb695152c8, []int{11}
+}
+func (m *HealthCheck) XXX_Unmarshal(b []byte) error {
+	return m.Unmarshal(b)
+}
+func (m *HealthCheck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	if deterministic {
+		return xxx_messageInfo_HealthCheck.Marshal(b, m, deterministic)
+	} else {
+		b = b[:cap(b)]
+		n, err := m.MarshalToSizedBuffer(b)
+		if err != nil {
+			return nil, err
 		}
-		i--
-		dAtA[i] = 0x22
+		return b[:n], nil
 	}
-	if m.OutlierDetection != nil {
-		{
-			size, err := m.OutlierDetection.MarshalToSizedBuffer(dAtA[:i])
-			if err != nil {
-				return 0, err
-			}
-			i -= size
-			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
-		}
-		i--
-		dAtA[i] = 0x1a
+}
+func (m *HealthCheck) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_HealthCheck.Merge(m, src)
+}
+func (m *HealthCheck) XXX_Size() int {
+	return m.Size()
+}
+func (m *HealthCheck) XXX_DiscardUnknown() {
+	xxx_messageInfo_HealthCheck.DiscardUnknown(m)
+}
+
+var xxx_messageInfo_HealthCheck proto.InternalMessageInfo
+
+type isHealthCheck_HealthChecker interface {
+	isHealthCheck_HealthChecker()
+	MarshalTo([]byte) (int, error)
+	Size() int
+}
+
+type HealthCheck_HttpHealthCheck_ struct {
+	HttpHealthCheck *HealthCheck_HttpHealthCheck `protobuf:"bytes,8,opt,name=http_health_check,json=httpHealthCheck,proto3,oneof" json:"http_health_check,omitempty"`
+}
+type HealthCheck_TcpHealthCheck_ struct {
+	TcpHealthCheck *HealthCheck_TcpHealthCheck `protobuf:"bytes,9,opt,name=tcp_health_check,json=tcpHealthCheck,proto3,oneof" json:"tcp_health_check,omitempty"`
+}
+type HealthCheck_GrpcHealthCheck_ struct {
+	GrpcHealthCheck *HealthCheck_GrpcHealthCheck `protobuf:"bytes,11,opt,name=grpc_health_check,json=grpcHealthCheck,proto3,oneof" json:"grpc_health_check,omitempty"`
+}
+type HealthCheck_CustomHealthCheck_ struct {
+	CustomHealthCheck *HealthCheck_CustomHealthCheck `protobuf:"bytes,13,opt,name=custom_health_check,json=customHealthCheck,proto3,oneof" json:"custom_health_check,omitempty"`
+}
+
+func (*HealthCheck_HttpHealthCheck_) isHealthCheck_HealthChecker()   {}
+func (*HealthCheck_TcpHealthCheck_) isHealthCheck_HealthChecker()    {}
+func (*HealthCheck_GrpcHealthCheck_) isHealthCheck_HealthChecker()   {}
+func (*HealthCheck_CustomHealthCheck_) isHealthCheck_HealthChecker() {}
+
+func (m *HealthCheck) GetHealthChecker() isHealthCheck_HealthChecker {
+	if m != nil {
+		return m.HealthChecker
 	}
-	if m.ConnectionPool != nil {
-		{
-			size, err := m.ConnectionPool.MarshalToSizedBuffer(dAtA[:i])
-			if err != nil {
-				return 0, err
-			}
-			i -= size
-			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
-		}
-		i--
-		dAtA[i] = 0x12
+	return nil
+}
+
+func (m *HealthCheck) GetTimeout() *types.Duration {
+	if m != nil {
+		return m.Timeout
 	}
-	if m.LoadBalancer != nil {
-		{
-			size, err := m.LoadBalancer.MarshalToSizedBuffer(dAtA[:i])
-			if err != nil {
-				return 0, err
-			}
-			i -= size
-			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
-		}
-		i--
-		dAtA[i] = 0xa
+	return nil
+}
+
+func (m *HealthCheck) GetInterval() *types.Duration {
+	if m != nil {
+		return m.Interval
 	}
-	return len(dAtA) - i, nil
+	return nil
 }
 
-func (m *TrafficPolicy_PortTrafficPolicy) Marshal() (dAtA []byte, err error) {
-	size := m.Size()
-	dAtA = make([]byte, size)
-	n, err := m.MarshalToSizedBuffer(dAtA[:size])
-	if err != nil {
-		return nil, err
+func (m *HealthCheck) GetInitialJitter() *types.Duration {
+	if m != nil {
+		return m.InitialJitter
 	}
-	return dAtA[:n], nil
+	return nil
 }
 
-func (m *TrafficPolicy_PortTrafficPolicy) MarshalTo(dAtA []byte) (int, error) {
-	size := m.Size()
-	return m.MarshalToSizedBuffer(dAtA[:size])
+func (m *HealthCheck) GetIntervalJitter() *types.Duration {
+	if m != nil {
+		return m.IntervalJitter
+	}
+	return nil
 }
 
-func (m *TrafficPolicy_PortTrafficPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
-	i := len(dAtA)
-	_ = i
-	var l int
-	_ = l
-	if m.XXX_unrecognized != nil {
-		i -= len(m.XXX_unrecognized)
-		copy(dAtA[i:], m.XXX_unrecognized)
+func (m *HealthCheck) GetIntervalJitterPercent() uint32 {
+	if m != nil {
+		return m.IntervalJitterPercent
 	}
-	if m.Tls != nil {
-		{
-			size, err := m.Tls.MarshalToSizedBuffer(dAtA[:i])
-			if err != nil {
-				return 0, err
-			}
-			i -= size
-			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
-		}
-		i--
-		dAtA[i] = 0x2a
+	return 0
+}
+
+func (m *HealthCheck) GetUnhealthyThreshold() *types.UInt32Value {
+	if m != nil {
+		return m.UnhealthyThreshold
 	}
-	if m.OutlierDetection != nil {
-		{
-			size, err := m.OutlierDetection.MarshalToSizedBuffer(dAtA[:i])
-			if err != nil {
-				return 0, err
-			}
-			i -= size
-			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
-		}
-		i--
-		dAtA[i] = 0x22
+	return nil
+}
+
+func (m *HealthCheck) GetHealthyThreshold() *types.UInt32Value {
+	if m != nil {
+		return m.HealthyThreshold
 	}
-	if m.ConnectionPool != nil {
-		{
-			size, err := m.ConnectionPool.MarshalToSizedBuffer(dAtA[:i])
-			if err != nil {
-				return 0, err
-			}
-			i -= size
-			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
-		}
-		i--
-		dAtA[i] = 0x1a
+	return nil
+}
+
+func (m *HealthCheck) GetAltPort() *types.UInt32Value {
+	if m != nil {
+		return m.AltPort
 	}
-	if m.LoadBalancer != nil {
-		{
-			size, err := m.LoadBalancer.MarshalToSizedBuffer(dAtA[:i])
-			if err != nil {
-				return 0, err
-			}
-			i -= size
-			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
-		}
-		i--
-		dAtA[i] = 0x12
+	return nil
+}
+
+func (m *HealthCheck) GetReuseConnection() *types.BoolValue {
+	if m != nil {
+		return m.ReuseConnection
 	}
-	if m.Port != nil {
-		{
-			size, err := m.Port.MarshalToSizedBuffer(dAtA[:i])
-			if err != nil {
-				return 0, err
-			}
-			i -= size
-			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
-		}
-		i--
-		dAtA[i] = 0xa
+	return nil
+}
+
+func (m *HealthCheck) GetHttpHealthCheck() *HealthCheck_HttpHealthCheck {
+	if x, ok := m.GetHealthChecker().(*HealthCheck_HttpHealthCheck_); ok {
+		return x.HttpHealthCheck
 	}
-	return len(dAtA) - i, nil
+	return nil
 }
 
-func (m *Subset) Marshal() (dAtA []byte, err error) {
-	size := m.Size()
-	dAtA = make([]byte, size)
-	n, err := m.MarshalToSizedBuffer(dAtA[:size])
-	if err != nil {
-		return nil, err
+func (m *HealthCheck) GetTcpHealthCheck() *HealthCheck_TcpHealthCheck {
+	if x, ok := m.GetHealthChecker().(*HealthCheck_TcpHealthCheck_); ok {
+		return x.TcpHealthCheck
 	}
-	return dAtA[:n], nil
+	return nil
 }
 
-func (m *Subset) MarshalTo(dAtA []byte) (int, error) {
-	size := m.Size()
-	return m.MarshalToSizedBuffer(dAtA[:size])
+func (m *HealthCheck) GetGrpcHealthCheck() *HealthCheck_GrpcHealthCheck {
+	if x, ok := m.GetHealthChecker().(*HealthCheck_GrpcHealthCheck_); ok {
+		return x.GrpcHealthCheck
+	}
+	return nil
 }
 
-func (m *Subset) MarshalToSizedBuffer(dAtA []byte) (int, error) {
-	i := len(dAtA)
-	_ = i
-	var l int
-	_ = l
-	if m.XXX_unrecognized != nil {
-		i -= len(m.XXX_unrecognized)
-		copy(dAtA[i:], m.XXX_unrecognized)
+func (m *HealthCheck) GetCustomHealthCheck() *HealthCheck_CustomHealthCheck {
+	if x, ok := m.GetHealthChecker().(*HealthCheck_CustomHealthCheck_); ok {
+		return x.CustomHealthCheck
 	}
-	if m.TrafficPolicy != nil {
-		{
-			size, err := m.TrafficPolicy.MarshalToSizedBuffer(dAtA[:i])
-			if err != nil {
-				return 0, err
-			}
-			i -= size
-			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
-		}
-		i--
-		dAtA[i] = 0x1a
+	return nil
+}
+
+func (m *HealthCheck) GetNoTrafficInterval() *types.Duration {
+	if m != nil {
+		return m.NoTrafficInterval
 	}
-	if len(m.Labels) > 0 {
-		for k := range m.Labels {
-			v := m.Labels[k]
-			baseI := i
-			i -= len(v)
-			copy(dAtA[i:], v)
-			i = encodeVarintDestinationRule(dAtA, i, uint64(len(v)))
-			i--
-			dAtA[i] = 0x12
-			i -= len(k)
-			copy(dAtA[i:], k)
-			i = encodeVarintDestinationRule(dAtA, i, uint64(len(k)))
-			i--
-			dAtA[i] = 0xa
-			i = encodeVarintDestinationRule(dAtA, i, uint64(baseI-i))
-			i--
-			dAtA[i] = 0x12
-		}
+	return nil
+}
+
+func (m *HealthCheck) GetNoTrafficHealthyInterval() *types.Duration {
+	if m != nil {
+		return m.NoTrafficHealthyInterval
 	}
-	if len(m.Name) > 0 {
-		i -= len(m.Name)
-		copy(dAtA[i:], m.Name)
-		i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.Name)))
-		i--
-		dAtA[i] = 0xa
+	return nil
+}
+
+func (m *HealthCheck) GetUnhealthyInterval() *types.Duration {
+	if m != nil {
+		return m.UnhealthyInterval
 	}
-	return len(dAtA) - i, nil
+	return nil
 }
 
-func (m *LoadBalancerSettings) Marshal() (dAtA []byte, err error) {
-	size := m.Size()
-	dAtA = make([]byte, size)
-	n, err := m.MarshalToSizedBuffer(dAtA[:size])
-	if err != nil {
-		return nil, err
+func (m *HealthCheck) GetUnhealthyEdgeInterval() *types.Duration {
+	if m != nil {
+		return m.UnhealthyEdgeInterval
 	}
-	return dAtA[:n], nil
+	return nil
 }
 
-func (m *LoadBalancerSettings) MarshalTo(dAtA []byte) (int, error) {
-	size := m.Size()
-	return m.MarshalToSizedBuffer(dAtA[:size])
+func (m *HealthCheck) GetHealthyEdgeInterval() *types.Duration {
+	if m != nil {
+		return m.HealthyEdgeInterval
+	}
+	return nil
 }
 
-func (m *LoadBalancerSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
-	i := len(dAtA)
-	_ = i
-	var l int
-	_ = l
-	if m.XXX_unrecognized != nil {
-		i -= len(m.XXX_unrecognized)
-		copy(dAtA[i:], m.XXX_unrecognized)
+func (m *HealthCheck) GetEventLogPath() string {
+	if m != nil {
+		return m.EventLogPath
 	}
-	if m.LocalityLbSetting != nil {
-		{
-			size, err := m.LocalityLbSetting.MarshalToSizedBuffer(dAtA[:i])
-			if err != nil {
-				return 0, err
-			}
-			i -= size
-			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
-		}
-		i--
-		dAtA[i] = 0x1a
-	}
-	if m.LbPolicy != nil {
-		{
-			size := m.LbPolicy.Size()
-			i -= size
-			if _, err := m.LbPolicy.MarshalTo(dAtA[i:]); err != nil {
-				return 0, err
-			}
-		}
-	}
-	return len(dAtA) - i, nil
+	return ""
 }
 
-func (m *LoadBalancerSettings_Simple) MarshalTo(dAtA []byte) (int, error) {
-	size := m.Size()
-	return m.MarshalToSizedBuffer(dAtA[:size])
+func (m *HealthCheck) GetAlwaysLogHealthCheckFailures() bool {
+	if m != nil {
+		return m.AlwaysLogHealthCheckFailures
+	}
+	return false
 }
 
-func (m *LoadBalancerSettings_Simple) MarshalToSizedBuffer(dAtA []byte) (int, error) {
-	i := len(dAtA)
-	i = encodeVarintDestinationRule(dAtA, i, uint64(m.Simple))
-	i--
-	dAtA[i] = 0x8
-	return len(dAtA) - i, nil
+func (m *HealthCheck) GetTlsOptions() *HealthCheck_TlsOptions {
+	if m != nil {
+		return m.TlsOptions
+	}
+	return nil
 }
-func (m *LoadBalancerSettings_ConsistentHash) MarshalTo(dAtA []byte) (int, error) {
-	size := m.Size()
-	return m.MarshalToSizedBuffer(dAtA[:size])
+
+// XXX_OneofWrappers is for the internal use of the proto package.
+func (*HealthCheck) XXX_OneofWrappers() []interface{} {
+	return []interface{}{
+		(*HealthCheck_HttpHealthCheck_)(nil),
+		(*HealthCheck_TcpHealthCheck_)(nil),
+		(*HealthCheck_GrpcHealthCheck_)(nil),
+		(*HealthCheck_CustomHealthCheck_)(nil),
+	}
 }
 
-func (m *LoadBalancerSettings_ConsistentHash) MarshalToSizedBuffer(dAtA []byte) (int, error) {
-	i := len(dAtA)
-	if m.ConsistentHash != nil {
-		{
-			size, err := m.ConsistentHash.MarshalToSizedBuffer(dAtA[:i])
-			if err != nil {
-				return 0, err
-			}
-			i -= size
-			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+// [#next-free-field: 13]
+type HealthCheck_HttpHealthCheck struct {
+	Host string `protobuf:"bytes,1,opt,name=host,proto3" json:"host,omitempty"`
+	// Specifies the HTTP path that will be requested during health checking.
+	Path    string   `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
+	Send    *Payload `protobuf:"bytes,3,opt,name=send,proto3" json:"send,omitempty"`
+	Receive *Payload `protobuf:"bytes,4,opt,name=receive,proto3" json:"receive,omitempty"`
+	// Specifies a list of HTTP response statuses considered healthy. If provided, replaces default
+	// 200-only policy - 200 must be included explicitly as needed. Ranges follow half-open
+	// semantics of :ref:`Int64Range <envoy_v3_api_msg_type.v3.Int64Range>`. The start and end of each
+	// range are required. Only statuses in the range [100, 600) are allowed.
+	ExpectedStatuses     []*Int64Range `protobuf:"bytes,9,rep,name=expected_statuses,json=expectedStatuses,proto3" json:"expected_statuses,omitempty"`
+	RetriableStatuses    []*Int64Range `protobuf:"bytes,12,rep,name=retriable_statuses,json=retriableStatuses,proto3" json:"retriable_statuses,omitempty"`
+	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
+	XXX_unrecognized     []byte        `json:"-"`
+	XXX_sizecache        int32         `json:"-"`
+}
+
+func (m *HealthCheck_HttpHealthCheck) Reset()         { *m = HealthCheck_HttpHealthCheck{} }
+func (m *HealthCheck_HttpHealthCheck) String() string { return proto.CompactTextString(m) }
+func (*HealthCheck_HttpHealthCheck) ProtoMessage()    {}
+func (*HealthCheck_HttpHealthCheck) Descriptor() ([]byte, []int) {
+	return fileDescriptor_12899beb695152c8, []int{11, 0}
+}
+func (m *HealthCheck_HttpHealthCheck) XXX_Unmarshal(b []byte) error {
+	return m.Unmarshal(b)
+}
+func (m *HealthCheck_HttpHealthCheck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	if deterministic {
+		return xxx_messageInfo_HealthCheck_HttpHealthCheck.Marshal(b, m, deterministic)
+	} else {
+		b = b[:cap(b)]
+		n, err := m.MarshalToSizedBuffer(b)
+		if err != nil {
+			return nil, err
 		}
-		i--
-		dAtA[i] = 0x12
+		return b[:n], nil
 	}
-	return len(dAtA) - i, nil
 }
-func (m *LoadBalancerSettings_ConsistentHashLB) Marshal() (dAtA []byte, err error) {
-	size := m.Size()
-	dAtA = make([]byte, size)
-	n, err := m.MarshalToSizedBuffer(dAtA[:size])
-	if err != nil {
-		return nil, err
-	}
-	return dAtA[:n], nil
+func (m *HealthCheck_HttpHealthCheck) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_HealthCheck_HttpHealthCheck.Merge(m, src)
 }
-
-func (m *LoadBalancerSettings_ConsistentHashLB) MarshalTo(dAtA []byte) (int, error) {
-	size := m.Size()
-	return m.MarshalToSizedBuffer(dAtA[:size])
+func (m *HealthCheck_HttpHealthCheck) XXX_Size() int {
+	return m.Size()
+}
+func (m *HealthCheck_HttpHealthCheck) XXX_DiscardUnknown() {
+	xxx_messageInfo_HealthCheck_HttpHealthCheck.DiscardUnknown(m)
 }
 
-func (m *LoadBalancerSettings_ConsistentHashLB) MarshalToSizedBuffer(dAtA []byte) (int, error) {
-	i := len(dAtA)
-	_ = i
-	var l int
-	_ = l
-	if m.XXX_unrecognized != nil {
-		i -= len(m.XXX_unrecognized)
-		copy(dAtA[i:], m.XXX_unrecognized)
-	}
-	if m.HashKey != nil {
-		{
-			size := m.HashKey.Size()
-			i -= size
-			if _, err := m.HashKey.MarshalTo(dAtA[i:]); err != nil {
-				return 0, err
-			}
-		}
+var xxx_messageInfo_HealthCheck_HttpHealthCheck proto.InternalMessageInfo
+
+func (m *HealthCheck_HttpHealthCheck) GetHost() string {
+	if m != nil {
+		return m.Host
 	}
-	if m.MinimumRingSize != 0 {
-		i = encodeVarintDestinationRule(dAtA, i, uint64(m.MinimumRingSize))
-		i--
-		dAtA[i] = 0x20
+	return ""
+}
+
+func (m *HealthCheck_HttpHealthCheck) GetPath() string {
+	if m != nil {
+		return m.Path
 	}
-	return len(dAtA) - i, nil
+	return ""
 }
 
-func (m *LoadBalancerSettings_ConsistentHashLB_HttpHeaderName) MarshalTo(dAtA []byte) (int, error) {
-	size := m.Size()
-	return m.MarshalToSizedBuffer(dAtA[:size])
+func (m *HealthCheck_HttpHealthCheck) GetSend() *Payload {
+	if m != nil {
+		return m.Send
+	}
+	return nil
 }
 
-func (m *LoadBalancerSettings_ConsistentHashLB_HttpHeaderName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
-	i := len(dAtA)
-	i -= len(m.HttpHeaderName)
-	copy(dAtA[i:], m.HttpHeaderName)
-	i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.HttpHeaderName)))
-	i--
-	dAtA[i] = 0xa
-	return len(dAtA) - i, nil
+func (m *HealthCheck_HttpHealthCheck) GetReceive() *Payload {
+	if m != nil {
+		return m.Receive
+	}
+	return nil
 }
-func (m *LoadBalancerSettings_ConsistentHashLB_HttpCookie) MarshalTo(dAtA []byte) (int, error) {
-	size := m.Size()
-	return m.MarshalToSizedBuffer(dAtA[:size])
+
+func (m *HealthCheck_HttpHealthCheck) GetExpectedStatuses() []*Int64Range {
+	if m != nil {
+		return m.ExpectedStatuses
+	}
+	return nil
 }
 
-func (m *LoadBalancerSettings_ConsistentHashLB_HttpCookie) MarshalToSizedBuffer(dAtA []byte) (int, error) {
-	i := len(dAtA)
-	if m.HttpCookie != nil {
-		{
-			size, err := m.HttpCookie.MarshalToSizedBuffer(dAtA[:i])
-			if err != nil {
-				return 0, err
-			}
-			i -= size
-			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
-		}
-		i--
-		dAtA[i] = 0x12
+func (m *HealthCheck_HttpHealthCheck) GetRetriableStatuses() []*Int64Range {
+	if m != nil {
+		return m.RetriableStatuses
 	}
-	return len(dAtA) - i, nil
+	return nil
 }
-func (m *LoadBalancerSettings_ConsistentHashLB_UseSourceIp) MarshalTo(dAtA []byte) (int, error) {
-	size := m.Size()
-	return m.MarshalToSizedBuffer(dAtA[:size])
+
+type HealthCheck_TcpHealthCheck struct {
+	// Empty payloads imply a connect-only health check.
+	Send                 *Payload   `protobuf:"bytes,1,opt,name=send,proto3" json:"send,omitempty"`
+	Receive              []*Payload `protobuf:"bytes,2,rep,name=receive,proto3" json:"receive,omitempty"`
+	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
+	XXX_unrecognized     []byte     `json:"-"`
+	XXX_sizecache        int32      `json:"-"`
 }
 
-func (m *LoadBalancerSettings_ConsistentHashLB_UseSourceIp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
-	i := len(dAtA)
-	i--
-	if m.UseSourceIp {
-		dAtA[i] = 1
+func (m *HealthCheck_TcpHealthCheck) Reset()         { *m = HealthCheck_TcpHealthCheck{} }
+func (m *HealthCheck_TcpHealthCheck) String() string { return proto.CompactTextString(m) }
+func (*HealthCheck_TcpHealthCheck) ProtoMessage()    {}
+func (*HealthCheck_TcpHealthCheck) Descriptor() ([]byte, []int) {
+	return fileDescriptor_12899beb695152c8, []int{11, 1}
+}
+func (m *HealthCheck_TcpHealthCheck) XXX_Unmarshal(b []byte) error {
+	return m.Unmarshal(b)
+}
+func (m *HealthCheck_TcpHealthCheck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	if deterministic {
+		return xxx_messageInfo_HealthCheck_TcpHealthCheck.Marshal(b, m, deterministic)
 	} else {
-		dAtA[i] = 0
+		b = b[:cap(b)]
+		n, err := m.MarshalToSizedBuffer(b)
+		if err != nil {
+			return nil, err
+		}
+		return b[:n], nil
 	}
-	i--
-	dAtA[i] = 0x18
-	return len(dAtA) - i, nil
 }
-func (m *LoadBalancerSettings_ConsistentHashLB_HttpQueryParameterName) MarshalTo(dAtA []byte) (int, error) {
-	size := m.Size()
-	return m.MarshalToSizedBuffer(dAtA[:size])
+func (m *HealthCheck_TcpHealthCheck) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_HealthCheck_TcpHealthCheck.Merge(m, src)
 }
-
-func (m *LoadBalancerSettings_ConsistentHashLB_HttpQueryParameterName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
-	i := len(dAtA)
-	i -= len(m.HttpQueryParameterName)
-	copy(dAtA[i:], m.HttpQueryParameterName)
-	i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.HttpQueryParameterName)))
-	i--
-	dAtA[i] = 0x2a
-	return len(dAtA) - i, nil
+func (m *HealthCheck_TcpHealthCheck) XXX_Size() int {
+	return m.Size()
 }
-func (m *LoadBalancerSettings_ConsistentHashLB_HTTPCookie) Marshal() (dAtA []byte, err error) {
-	size := m.Size()
-	dAtA = make([]byte, size)
-	n, err := m.MarshalToSizedBuffer(dAtA[:size])
-	if err != nil {
-		return nil, err
-	}
-	return dAtA[:n], nil
+func (m *HealthCheck_TcpHealthCheck) XXX_DiscardUnknown() {
+	xxx_messageInfo_HealthCheck_TcpHealthCheck.DiscardUnknown(m)
 }
 
-func (m *LoadBalancerSettings_ConsistentHashLB_HTTPCookie) MarshalTo(dAtA []byte) (int, error) {
-	size := m.Size()
-	return m.MarshalToSizedBuffer(dAtA[:size])
-}
+var xxx_messageInfo_HealthCheck_TcpHealthCheck proto.InternalMessageInfo
 
-func (m *LoadBalancerSettings_ConsistentHashLB_HTTPCookie) MarshalToSizedBuffer(dAtA []byte) (int, error) {
-	i := len(dAtA)
-	_ = i
-	var l int
-	_ = l
-	if m.XXX_unrecognized != nil {
-		i -= len(m.XXX_unrecognized)
-		copy(dAtA[i:], m.XXX_unrecognized)
-	}
-	if m.Ttl != nil {
-		{
-			size, err := m.Ttl.MarshalToSizedBuffer(dAtA[:i])
-			if err != nil {
-				return 0, err
-			}
-			i -= size
-			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
-		}
-		i--
-		dAtA[i] = 0x1a
-	}
-	if len(m.Path) > 0 {
-		i -= len(m.Path)
-		copy(dAtA[i:], m.Path)
-		i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.Path)))
-		i--
-		dAtA[i] = 0x12
-	}
-	if len(m.Name) > 0 {
-		i -= len(m.Name)
-		copy(dAtA[i:], m.Name)
-		i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.Name)))
-		i--
-		dAtA[i] = 0xa
+func (m *HealthCheck_TcpHealthCheck) GetSend() *Payload {
+	if m != nil {
+		return m.Send
 	}
-	return len(dAtA) - i, nil
+	return nil
 }
 
-func (m *ConnectionPoolSettings) Marshal() (dAtA []byte, err error) {
-	size := m.Size()
-	dAtA = make([]byte, size)
-	n, err := m.MarshalToSizedBuffer(dAtA[:size])
-	if err != nil {
-		return nil, err
+func (m *HealthCheck_TcpHealthCheck) GetReceive() []*Payload {
+	if m != nil {
+		return m.Receive
 	}
-	return dAtA[:n], nil
+	return nil
 }
 
-func (m *ConnectionPoolSettings) MarshalTo(dAtA []byte) (int, error) {
-	size := m.Size()
-	return m.MarshalToSizedBuffer(dAtA[:size])
+type HealthCheck_RedisHealthCheck struct {
+	Key                  string   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
+	XXX_NoUnkeyedLiteral struct{} `json:"-"`
+	XXX_unrecognized     []byte   `json:"-"`
+	XXX_sizecache        int32    `json:"-"`
 }
 
-func (m *ConnectionPoolSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
-	i := len(dAtA)
-	_ = i
-	var l int
-	_ = l
-	if m.XXX_unrecognized != nil {
-		i -= len(m.XXX_unrecognized)
-		copy(dAtA[i:], m.XXX_unrecognized)
+func (m *HealthCheck_RedisHealthCheck) Reset()         { *m = HealthCheck_RedisHealthCheck{} }
+func (m *HealthCheck_RedisHealthCheck) String() string { return proto.CompactTextString(m) }
+func (*HealthCheck_RedisHealthCheck) ProtoMessage()    {}
+func (*HealthCheck_RedisHealthCheck) Descriptor() ([]byte, []int) {
+	return fileDescriptor_12899beb695152c8, []int{11, 2}
+}
+func (m *HealthCheck_RedisHealthCheck) XXX_Unmarshal(b []byte) error {
+	return m.Unmarshal(b)
+}
+func (m *HealthCheck_RedisHealthCheck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	if deterministic {
+		return xxx_messageInfo_HealthCheck_RedisHealthCheck.Marshal(b, m, deterministic)
+	} else {
+		b = b[:cap(b)]
+		n, err := m.MarshalToSizedBuffer(b)
+		if err != nil {
+			return nil, err
+		}
+		return b[:n], nil
 	}
-	if m.Http != nil {
-		{
-			size, err := m.Http.MarshalToSizedBuffer(dAtA[:i])
-			if err != nil {
-				return 0, err
-			}
-			i -= size
-			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+}
+func (m *HealthCheck_RedisHealthCheck) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_HealthCheck_RedisHealthCheck.Merge(m, src)
+}
+func (m *HealthCheck_RedisHealthCheck) XXX_Size() int {
+	return m.Size()
+}
+func (m *HealthCheck_RedisHealthCheck) XXX_DiscardUnknown() {
+	xxx_messageInfo_HealthCheck_RedisHealthCheck.DiscardUnknown(m)
+}
+
+var xxx_messageInfo_HealthCheck_RedisHealthCheck proto.InternalMessageInfo
+
+func (m *HealthCheck_RedisHealthCheck) GetKey() string {
+	if m != nil {
+		return m.Key
+	}
+	return ""
+}
+
+type HealthCheck_GrpcHealthCheck struct {
+	ServiceName          string   `protobuf:"bytes,1,opt,name=service_name,json=serviceName,proto3" json:"service_name,omitempty"`
+	Authority            string   `protobuf:"bytes,2,opt,name=authority,proto3" json:"authority,omitempty"`
+	XXX_NoUnkeyedLiteral struct{} `json:"-"`
+	XXX_unrecognized     []byte   `json:"-"`
+	XXX_sizecache        int32    `json:"-"`
+}
+
+func (m *HealthCheck_GrpcHealthCheck) Reset()         { *m = HealthCheck_GrpcHealthCheck{} }
+func (m *HealthCheck_GrpcHealthCheck) String() string { return proto.CompactTextString(m) }
+func (*HealthCheck_GrpcHealthCheck) ProtoMessage()    {}
+func (*HealthCheck_GrpcHealthCheck) Descriptor() ([]byte, []int) {
+	return fileDescriptor_12899beb695152c8, []int{11, 3}
+}
+func (m *HealthCheck_GrpcHealthCheck) XXX_Unmarshal(b []byte) error {
+	return m.Unmarshal(b)
+}
+func (m *HealthCheck_GrpcHealthCheck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	if deterministic {
+		return xxx_messageInfo_HealthCheck_GrpcHealthCheck.Marshal(b, m, deterministic)
+	} else {
+		b = b[:cap(b)]
+		n, err := m.MarshalToSizedBuffer(b)
+		if err != nil {
+			return nil, err
 		}
-		i--
-		dAtA[i] = 0x12
+		return b[:n], nil
 	}
-	if m.Tcp != nil {
-		{
-			size, err := m.Tcp.MarshalToSizedBuffer(dAtA[:i])
-			if err != nil {
-				return 0, err
-			}
-			i -= size
-			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+}
+func (m *HealthCheck_GrpcHealthCheck) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_HealthCheck_GrpcHealthCheck.Merge(m, src)
+}
+func (m *HealthCheck_GrpcHealthCheck) XXX_Size() int {
+	return m.Size()
+}
+func (m *HealthCheck_GrpcHealthCheck) XXX_DiscardUnknown() {
+	xxx_messageInfo_HealthCheck_GrpcHealthCheck.DiscardUnknown(m)
+}
+
+var xxx_messageInfo_HealthCheck_GrpcHealthCheck proto.InternalMessageInfo
+
+func (m *HealthCheck_GrpcHealthCheck) GetServiceName() string {
+	if m != nil {
+		return m.ServiceName
+	}
+	return ""
+}
+
+func (m *HealthCheck_GrpcHealthCheck) GetAuthority() string {
+	if m != nil {
+		return m.Authority
+	}
+	return ""
+}
+
+// Custom health check.
+type HealthCheck_CustomHealthCheck struct {
+	// The registered name of the custom health checker.
+	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
+	XXX_NoUnkeyedLiteral struct{} `json:"-"`
+	XXX_unrecognized     []byte   `json:"-"`
+	XXX_sizecache        int32    `json:"-"`
+}
+
+func (m *HealthCheck_CustomHealthCheck) Reset()         { *m = HealthCheck_CustomHealthCheck{} }
+func (m *HealthCheck_CustomHealthCheck) String() string { return proto.CompactTextString(m) }
+func (*HealthCheck_CustomHealthCheck) ProtoMessage()    {}
+func (*HealthCheck_CustomHealthCheck) Descriptor() ([]byte, []int) {
+	return fileDescriptor_12899beb695152c8, []int{11, 4}
+}
+func (m *HealthCheck_CustomHealthCheck) XXX_Unmarshal(b []byte) error {
+	return m.Unmarshal(b)
+}
+func (m *HealthCheck_CustomHealthCheck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	if deterministic {
+		return xxx_messageInfo_HealthCheck_CustomHealthCheck.Marshal(b, m, deterministic)
+	} else {
+		b = b[:cap(b)]
+		n, err := m.MarshalToSizedBuffer(b)
+		if err != nil {
+			return nil, err
 		}
-		i--
-		dAtA[i] = 0xa
+		return b[:n], nil
 	}
-	return len(dAtA) - i, nil
+}
+func (m *HealthCheck_CustomHealthCheck) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_HealthCheck_CustomHealthCheck.Merge(m, src)
+}
+func (m *HealthCheck_CustomHealthCheck) XXX_Size() int {
+	return m.Size()
+}
+func (m *HealthCheck_CustomHealthCheck) XXX_DiscardUnknown() {
+	xxx_messageInfo_HealthCheck_CustomHealthCheck.DiscardUnknown(m)
 }
 
-func (m *ConnectionPoolSettings_TCPSettings) Marshal() (dAtA []byte, err error) {
+var xxx_messageInfo_HealthCheck_CustomHealthCheck proto.InternalMessageInfo
+
+func (m *HealthCheck_CustomHealthCheck) GetName() string {
+	if m != nil {
+		return m.Name
+	}
+	return ""
+}
+
+// Health checks occur over the transport socket specified for the cluster. This implies that if a
+// cluster is using a TLS-enabled transport socket, the health check will also occur over TLS.
+//
+// This allows overriding the cluster TLS settings, just for health check connections.
+type HealthCheck_TlsOptions struct {
+	AlpnProtocols        []string `protobuf:"bytes,1,rep,name=alpn_protocols,json=alpnProtocols,proto3" json:"alpn_protocols,omitempty"`
+	XXX_NoUnkeyedLiteral struct{} `json:"-"`
+	XXX_unrecognized     []byte   `json:"-"`
+	XXX_sizecache        int32    `json:"-"`
+}
+
+func (m *HealthCheck_TlsOptions) Reset()         { *m = HealthCheck_TlsOptions{} }
+func (m *HealthCheck_TlsOptions) String() string { return proto.CompactTextString(m) }
+func (*HealthCheck_TlsOptions) ProtoMessage()    {}
+func (*HealthCheck_TlsOptions) Descriptor() ([]byte, []int) {
+	return fileDescriptor_12899beb695152c8, []int{11, 5}
+}
+func (m *HealthCheck_TlsOptions) XXX_Unmarshal(b []byte) error {
+	return m.Unmarshal(b)
+}
+func (m *HealthCheck_TlsOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	if deterministic {
+		return xxx_messageInfo_HealthCheck_TlsOptions.Marshal(b, m, deterministic)
+	} else {
+		b = b[:cap(b)]
+		n, err := m.MarshalToSizedBuffer(b)
+		if err != nil {
+			return nil, err
+		}
+		return b[:n], nil
+	}
+}
+func (m *HealthCheck_TlsOptions) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_HealthCheck_TlsOptions.Merge(m, src)
+}
+func (m *HealthCheck_TlsOptions) XXX_Size() int {
+	return m.Size()
+}
+func (m *HealthCheck_TlsOptions) XXX_DiscardUnknown() {
+	xxx_messageInfo_HealthCheck_TlsOptions.DiscardUnknown(m)
+}
+
+var xxx_messageInfo_HealthCheck_TlsOptions proto.InternalMessageInfo
+
+func (m *HealthCheck_TlsOptions) GetAlpnProtocols() []string {
+	if m != nil {
+		return m.AlpnProtocols
+	}
+	return nil
+}
+
+func init() {
+	proto.RegisterEnum("istio.networking.v1alpha3.HealthStatus", HealthStatus_name, HealthStatus_value)
+	proto.RegisterEnum("istio.networking.v1alpha3.LoadBalancerSettings_SimpleLB", LoadBalancerSettings_SimpleLB_name, LoadBalancerSettings_SimpleLB_value)
+	proto.RegisterEnum("istio.networking.v1alpha3.ConnectionPoolSettings_HTTPSettings_H2UpgradePolicy", ConnectionPoolSettings_HTTPSettings_H2UpgradePolicy_name, ConnectionPoolSettings_HTTPSettings_H2UpgradePolicy_value)
+	proto.RegisterEnum("istio.networking.v1alpha3.ClientTLSSettings_TLSmode", ClientTLSSettings_TLSmode_name, ClientTLSSettings_TLSmode_value)
+	proto.RegisterType((*DestinationRule)(nil), "istio.networking.v1alpha3.DestinationRule")
+	proto.RegisterType((*TrafficPolicy)(nil), "istio.networking.v1alpha3.TrafficPolicy")
+	proto.RegisterType((*TrafficPolicy_PortTrafficPolicy)(nil), "istio.networking.v1alpha3.TrafficPolicy.PortTrafficPolicy")
+	proto.RegisterType((*Subset)(nil), "istio.networking.v1alpha3.Subset")
+	proto.RegisterMapType((map[string]string)(nil), "istio.networking.v1alpha3.Subset.LabelsEntry")
+	proto.RegisterType((*LoadBalancerSettings)(nil), "istio.networking.v1alpha3.LoadBalancerSettings")
+	proto.RegisterType((*LoadBalancerSettings_ConsistentHashLB)(nil), "istio.networking.v1alpha3.LoadBalancerSettings.ConsistentHashLB")
+	proto.RegisterType((*LoadBalancerSettings_ConsistentHashLB_HTTPCookie)(nil), "istio.networking.v1alpha3.LoadBalancerSettings.ConsistentHashLB.HTTPCookie")
+	proto.RegisterType((*ConnectionPoolSettings)(nil), "istio.networking.v1alpha3.ConnectionPoolSettings")
+	proto.RegisterType((*ConnectionPoolSettings_TCPSettings)(nil), "istio.networking.v1alpha3.ConnectionPoolSettings.TCPSettings")
+	proto.RegisterType((*ConnectionPoolSettings_TCPSettings_TcpKeepalive)(nil), "istio.networking.v1alpha3.ConnectionPoolSettings.TCPSettings.TcpKeepalive")
+	proto.RegisterType((*ConnectionPoolSettings_HTTPSettings)(nil), "istio.networking.v1alpha3.ConnectionPoolSettings.HTTPSettings")
+	proto.RegisterType((*OutlierDetection)(nil), "istio.networking.v1alpha3.OutlierDetection")
+	proto.RegisterType((*ClientTLSSettings)(nil), "istio.networking.v1alpha3.ClientTLSSettings")
+	proto.RegisterType((*LocalityLoadBalancerSetting)(nil), "istio.networking.v1alpha3.LocalityLoadBalancerSetting")
+	proto.RegisterType((*LocalityLoadBalancerSetting_Distribute)(nil), "istio.networking.v1alpha3.LocalityLoadBalancerSetting.Distribute")
+	proto.RegisterMapType((map[string]uint32)(nil), "istio.networking.v1alpha3.LocalityLoadBalancerSetting.Distribute.ToEntry")
+	proto.RegisterType((*LocalityLoadBalancerSetting_Failover)(nil), "istio.networking.v1alpha3.LocalityLoadBalancerSetting.Failover")
+	proto.RegisterType((*Int64Range)(nil), "istio.networking.v1alpha3.Int64Range")
+	proto.RegisterType((*HealthStatusSet)(nil), "istio.networking.v1alpha3.HealthStatusSet")
+	proto.RegisterType((*Payload)(nil), "istio.networking.v1alpha3.Payload")
+	proto.RegisterType((*HealthCheck)(nil), "istio.networking.v1alpha3.HealthCheck")
+	proto.RegisterType((*HealthCheck_HttpHealthCheck)(nil), "istio.networking.v1alpha3.HealthCheck.HttpHealthCheck")
+	proto.RegisterType((*HealthCheck_TcpHealthCheck)(nil), "istio.networking.v1alpha3.HealthCheck.TcpHealthCheck")
+	proto.RegisterType((*HealthCheck_RedisHealthCheck)(nil), "istio.networking.v1alpha3.HealthCheck.RedisHealthCheck")
+	proto.RegisterType((*HealthCheck_GrpcHealthCheck)(nil), "istio.networking.v1alpha3.HealthCheck.GrpcHealthCheck")
+	proto.RegisterType((*HealthCheck_CustomHealthCheck)(nil), "istio.networking.v1alpha3.HealthCheck.CustomHealthCheck")
+	proto.RegisterType((*HealthCheck_TlsOptions)(nil), "istio.networking.v1alpha3.HealthCheck.TlsOptions")
+}
+
+func init() {
+	proto.RegisterFile("networking/v1alpha3/destination_rule.proto", fileDescriptor_12899beb695152c8)
+}
+
+var fileDescriptor_12899beb695152c8 = []byte{
+	// 2826 bytes of a gzipped FileDescriptorProto
+	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x59, 0x4b, 0x73, 0x1b, 0xc7,
+	0xb5, 0x26, 0x1e, 0x24, 0x80, 0x03, 0x12, 0x1c, 0x34, 0x29, 0x09, 0x86, 0x5c, 0xb2, 0x8c, 0xb2,
+	0xaf, 0x75, 0x65, 0x1b, 0xbc, 0xa2, 0x1e, 0xd7, 0xd7, 0xf2, 0x8b, 0x0f, 0x48, 0x00, 0x05, 0x02,
+	0x70, 0x03, 0xf4, 0xb5, 0x9d, 0xc5, 0xa4, 0x31, 0x68, 0x02, 0x2d, 0x0e, 0x66, 0xc6, 0x33, 0x0d,
+	0x88, 0xf0, 0x2a, 0x8b, 0x54, 0x16, 0xae, 0xfc, 0x86, 0xec, 0xf2, 0x07, 0xb2, 0xca, 0x36, 0xbb,
+	0x2c, 0x53, 0x95, 0xaa, 0x6c, 0x93, 0xd2, 0x2e, 0x3f, 0x20, 0x9b, 0xac, 0x52, 0xdd, 0xd3, 0x33,
+	0x18, 0x90, 0x34, 0x40, 0x4a, 0xf6, 0x6e, 0xfa, 0xf4, 0xf9, 0xbe, 0xd3, 0x8f, 0xd3, 0xe7, 0x9c,
+	0xee, 0x81, 0xbb, 0x16, 0xe5, 0x2f, 0x6c, 0xf7, 0x84, 0x59, 0xfd, 0xad, 0xf1, 0x3d, 0x62, 0x3a,
+	0x03, 0x72, 0x7f, 0xab, 0x47, 0x3d, 0xce, 0x2c, 0xc2, 0x99, 0x6d, 0xe9, 0xee, 0xc8, 0xa4, 0x65,
+	0xc7, 0xb5, 0xb9, 0x8d, 0xde, 0x60, 0x1e, 0x67, 0x76, 0x79, 0x8a, 0x28, 0x07, 0x88, 0xe2, 0x5b,
+	0x7d, 0xdb, 0xee, 0x9b, 0x74, 0x8b, 0x38, 0x6c, 0xeb, 0x98, 0x51, 0xb3, 0xa7, 0x77, 0xe9, 0x80,
+	0x8c, 0x99, 0xed, 0xfa, 0xd8, 0xe2, 0x2d, 0xa5, 0x20, 0x5b, 0xdd, 0xd1, 0xf1, 0x56, 0x6f, 0xe4,
+	0x4a, 0x03, 0x3f, 0xd6, 0xff, 0xc2, 0x25, 0x8e, 0x43, 0x5d, 0x4f, 0xf5, 0xff, 0xf7, 0x45, 0xe3,
+	0x1c, 0x33, 0x97, 0x8f, 0x88, 0xa9, 0x7b, 0xd4, 0x1d, 0x33, 0x43, 0x0d, 0xb3, 0xb8, 0xd9, 0xb7,
+	0xfb, 0xb6, 0xfc, 0xdc, 0x12, 0x5f, 0xbe, 0xb4, 0xf4, 0xb7, 0x18, 0xac, 0xef, 0x4f, 0xe7, 0x85,
+	0x47, 0x26, 0x45, 0x05, 0x48, 0x0e, 0x6c, 0x8f, 0x17, 0x62, 0xb7, 0x63, 0x77, 0x32, 0xbb, 0xc9,
+	0x97, 0x3b, 0xb1, 0x38, 0x96, 0x12, 0xd4, 0x84, 0x1c, 0x77, 0xc9, 0xf1, 0x31, 0x33, 0x74, 0xc7,
+	0x36, 0x99, 0x31, 0x29, 0xc4, 0x6f, 0xc7, 0xee, 0x64, 0xb7, 0xef, 0x94, 0x7f, 0x74, 0x0d, 0xca,
+	0x1d, 0x1f, 0xd0, 0x92, 0xfa, 0x78, 0x8d, 0x47, 0x9b, 0xe8, 0x31, 0xa4, 0xbc, 0x51, 0xd7, 0xa3,
+	0xdc, 0x2b, 0x24, 0x6e, 0x27, 0xee, 0x64, 0xb7, 0xdf, 0x9e, 0xc3, 0xd4, 0x96, 0x9a, 0x38, 0x40,
+	0xa0, 0x9b, 0x90, 0xa1, 0xa7, 0x8e, 0xed, 0x72, 0x9d, 0xdb, 0x85, 0xe4, 0xed, 0xc4, 0x9d, 0x0c,
+	0x4e, 0xfb, 0x82, 0x8e, 0x5d, 0xfa, 0x55, 0x1a, 0xd6, 0x66, 0x4c, 0xa3, 0x0e, 0xac, 0x99, 0x36,
+	0xe9, 0xe9, 0x5d, 0x62, 0x12, 0xcb, 0xa0, 0xae, 0x9c, 0x5f, 0x76, 0x7b, 0x6b, 0x8e, 0xc5, 0xba,
+	0x4d, 0x7a, 0xbb, 0x4a, 0xbd, 0x4d, 0x39, 0x67, 0x56, 0xdf, 0xc3, 0xab, 0x66, 0x44, 0x8a, 0xbe,
+	0x85, 0x75, 0xc3, 0xb6, 0x2c, 0x6a, 0x48, 0xb7, 0x70, 0x6c, 0xdb, 0x54, 0x6b, 0x72, 0x6f, 0x0e,
+	0xef, 0x5e, 0x88, 0x68, 0xd9, 0xb6, 0x19, 0x32, 0xe7, 0x8c, 0x19, 0x39, 0xfa, 0x1a, 0xf2, 0xf6,
+	0x88, 0x9b, 0x8c, 0xba, 0x7a, 0x8f, 0x72, 0xbf, 0xa3, 0x90, 0x90, 0xec, 0xef, 0xcf, 0x61, 0x6f,
+	0xfa, 0x98, 0xfd, 0x00, 0x82, 0x35, 0xfb, 0x8c, 0x04, 0x7d, 0x06, 0x09, 0x6e, 0x7a, 0x85, 0xa4,
+	0xe4, 0xfa, 0x60, 0xde, 0x48, 0x4d, 0x46, 0x2d, 0xde, 0xa9, 0xb7, 0xc3, 0x41, 0x0a, 0x20, 0x7a,
+	0x0e, 0x1b, 0x72, 0xe1, 0x4d, 0x3a, 0xa6, 0xc2, 0xd1, 0xfc, 0xbe, 0xc2, 0xb2, 0xdc, 0xc3, 0x8f,
+	0x2f, 0xeb, 0x0d, 0xe5, 0x96, 0xd8, 0xab, 0x19, 0xff, 0xc8, 0x0b, 0xda, 0xba, 0x60, 0x0d, 0x0c,
+	0xa2, 0x67, 0xb0, 0x36, 0xa0, 0xc4, 0xe4, 0x03, 0xdd, 0x18, 0x50, 0xe3, 0xc4, 0x2b, 0x50, 0x69,
+	0xe5, 0xbf, 0xe6, 0x58, 0xa9, 0x4a, 0xfd, 0x3d, 0xa1, 0x8e, 0x57, 0x07, 0xd3, 0x86, 0x57, 0xfc,
+	0x67, 0x02, 0xf2, 0xe7, 0xac, 0xa2, 0xc7, 0x90, 0x14, 0x76, 0x95, 0x47, 0xbc, 0x37, 0x87, 0x59,
+	0x60, 0xdb, 0xd4, 0xa4, 0x06, 0xb7, 0x5d, 0x2c, 0x41, 0xe7, 0xfd, 0x2a, 0xfe, 0x33, 0xf9, 0x55,
+	0xe2, 0x67, 0xf5, 0xab, 0xe4, 0x4f, 0xe8, 0x57, 0xcb, 0xaf, 0xea, 0x57, 0x3f, 0xe5, 0x5e, 0x97,
+	0xfe, 0x15, 0x83, 0x15, 0x3f, 0x66, 0x88, 0x90, 0x66, 0x91, 0x21, 0x9d, 0x0d, 0x69, 0x42, 0x82,
+	0x2a, 0xb0, 0x62, 0x92, 0x2e, 0x35, 0xbd, 0x42, 0x5c, 0x9a, 0xfa, 0x70, 0x61, 0x00, 0x2a, 0xd7,
+	0xa5, 0x7e, 0xc5, 0xe2, 0xee, 0x04, 0x2b, 0xf0, 0x05, 0x91, 0x31, 0xf1, 0x5a, 0x91, 0xb1, 0xf8,
+	0x7f, 0x90, 0x8d, 0xd8, 0x41, 0x1a, 0x24, 0x4e, 0xe8, 0xc4, 0x1f, 0x3f, 0x16, 0x9f, 0x68, 0x13,
+	0x96, 0xc7, 0xc4, 0x1c, 0x51, 0xe9, 0x6e, 0x19, 0xec, 0x37, 0x3e, 0x8e, 0x7f, 0x14, 0x2b, 0xfd,
+	0x2e, 0x05, 0x9b, 0x17, 0x79, 0x18, 0xc2, 0xb0, 0xe2, 0xb1, 0xa1, 0x63, 0xfa, 0xeb, 0x90, 0xdb,
+	0xfe, 0xe8, 0x8a, 0x2e, 0x5a, 0x6e, 0x4b, 0x74, 0x7d, 0xb7, 0xba, 0x84, 0x15, 0x13, 0x3a, 0x91,
+	0x7e, 0xea, 0x31, 0x8f, 0x53, 0x8b, 0xeb, 0x03, 0xe2, 0x0d, 0x94, 0xff, 0x7f, 0x71, 0x55, 0xf2,
+	0xbd, 0x90, 0xa6, 0x4a, 0xbc, 0x81, 0x34, 0x92, 0x33, 0x66, 0x64, 0xe8, 0x18, 0x36, 0x4c, 0xdb,
+	0x20, 0x26, 0xe3, 0x13, 0xdd, 0xec, 0x06, 0x71, 0x47, 0x2d, 0xf5, 0xa3, 0xb9, 0x06, 0x7d, 0xd4,
+	0x05, 0x86, 0x71, 0x3e, 0xa0, 0xac, 0x77, 0x95, 0x08, 0x3d, 0x83, 0xcd, 0x17, 0xc4, 0x1d, 0x8e,
+	0x1c, 0x3d, 0xc8, 0xc7, 0xba, 0x47, 0x8d, 0x20, 0x5e, 0xbe, 0x51, 0xf6, 0xb3, 0x72, 0x39, 0xc8,
+	0xca, 0xe5, 0x7d, 0xa5, 0x85, 0x91, 0x0f, 0x0b, 0xda, 0x6d, 0x6a, 0x78, 0xc5, 0x3f, 0x26, 0x40,
+	0x3b, 0x3b, 0x37, 0x74, 0x17, 0xb4, 0x01, 0xe7, 0x8e, 0x3e, 0xa0, 0xa4, 0x47, 0x5d, 0x7d, 0xea,
+	0x9c, 0x62, 0xd6, 0xa2, 0xa7, 0x2a, 0x3b, 0x1a, 0xc2, 0x45, 0x2d, 0xc8, 0x4a, 0x5d, 0xc3, 0xb6,
+	0x4f, 0x18, 0x55, 0xcb, 0xfb, 0xec, 0x75, 0x97, 0xb7, 0x5c, 0xed, 0x74, 0x5a, 0x7b, 0x92, 0xb2,
+	0xba, 0x84, 0x41, 0x58, 0xf0, 0x5b, 0xe8, 0x1d, 0x58, 0x1b, 0x79, 0x54, 0xf7, 0xec, 0x91, 0x6b,
+	0x50, 0x9d, 0x39, 0x72, 0x7d, 0xd3, 0xd5, 0x25, 0x9c, 0x1d, 0x79, 0xb4, 0x2d, 0xa5, 0x35, 0x07,
+	0x3d, 0x86, 0x37, 0xe4, 0xa8, 0xbe, 0x1b, 0x51, 0x77, 0xa2, 0x3b, 0xc4, 0x25, 0x43, 0xca, 0x83,
+	0xa9, 0x2c, 0xab, 0xa9, 0x5c, 0x17, 0x2a, 0x5f, 0x0a, 0x8d, 0x56, 0xa0, 0x20, 0xa7, 0x74, 0x17,
+	0xf2, 0x43, 0x66, 0xb1, 0xe1, 0x68, 0xa8, 0xbb, 0xcc, 0xea, 0xeb, 0x1e, 0xfb, 0x9e, 0xca, 0xd5,
+	0x4d, 0xe2, 0x75, 0xd5, 0x81, 0x99, 0xd5, 0x6f, 0xb3, 0xef, 0x69, 0x71, 0x08, 0x30, 0x1d, 0xea,
+	0x9c, 0x93, 0x8c, 0x20, 0xe9, 0x10, 0x3e, 0x50, 0xe7, 0x41, 0x7e, 0xa3, 0x7b, 0x90, 0xe0, 0x3c,
+	0x88, 0x9c, 0x3f, 0xbe, 0x6f, 0x8a, 0x47, 0xe8, 0xee, 0x02, 0xa4, 0x85, 0x17, 0xeb, 0x27, 0x74,
+	0x52, 0xaa, 0x42, 0x3a, 0x70, 0x79, 0xb4, 0x0e, 0x59, 0xdc, 0x3c, 0x6a, 0xec, 0xeb, 0xb8, 0xb9,
+	0x5b, 0x6b, 0x68, 0x4b, 0x28, 0x07, 0x50, 0xaf, 0xec, 0xb4, 0x3b, 0xfa, 0x5e, 0xb3, 0xd1, 0xd0,
+	0x62, 0x08, 0x60, 0x05, 0xef, 0x34, 0xf6, 0x9b, 0x87, 0x5a, 0x5c, 0x28, 0xb7, 0x76, 0xda, 0xed,
+	0x4e, 0x15, 0x37, 0x8f, 0x9e, 0x56, 0xb5, 0xc4, 0x6e, 0x16, 0x32, 0x66, 0x57, 0x85, 0x86, 0xd2,
+	0x9f, 0xd2, 0x70, 0xfd, 0xe2, 0x50, 0x8d, 0x9a, 0x90, 0xe0, 0x86, 0xa3, 0x12, 0xd1, 0xa7, 0x57,
+	0x0e, 0xf5, 0xe5, 0xce, 0x5e, 0x2b, 0x12, 0x51, 0x0d, 0x07, 0x61, 0x48, 0x8a, 0x3d, 0x50, 0x5e,
+	0xf3, 0xd9, 0xd5, 0x19, 0xc5, 0xda, 0x87, 0x94, 0x92, 0xab, 0xf8, 0xef, 0x38, 0x64, 0x23, 0x86,
+	0xd0, 0x7b, 0xb0, 0x3e, 0x24, 0xa7, 0xfa, 0x34, 0xcb, 0x78, 0x72, 0x02, 0xcb, 0x38, 0x37, 0x24,
+	0xa7, 0x53, 0x5a, 0x0f, 0xed, 0x86, 0x49, 0x4d, 0xe7, 0x6c, 0x48, 0xed, 0x11, 0x57, 0xe3, 0x9a,
+	0x73, 0xa4, 0x82, 0xe4, 0xd5, 0xf1, 0x01, 0xc8, 0x86, 0x35, 0x6e, 0x38, 0xfa, 0x09, 0xa5, 0x0e,
+	0x31, 0xd9, 0x98, 0xaa, 0xcd, 0x3d, 0x78, 0xad, 0xb5, 0x2a, 0x77, 0x0c, 0xe7, 0x59, 0xc0, 0x88,
+	0x57, 0x79, 0xa4, 0x55, 0xfc, 0x6d, 0x0c, 0x56, 0xa3, 0xdd, 0xe8, 0x3a, 0xac, 0x38, 0xae, 0xdd,
+	0xa5, 0xfe, 0x2c, 0xd7, 0xb0, 0x6a, 0xa1, 0x0f, 0x21, 0x29, 0x66, 0xb5, 0x78, 0x4a, 0x52, 0x0d,
+	0x3d, 0x84, 0x34, 0xb3, 0x38, 0x75, 0xc7, 0x64, 0xb1, 0x83, 0xe2, 0x50, 0xb5, 0xf8, 0xeb, 0x24,
+	0xac, 0x46, 0xf7, 0x04, 0x3d, 0x86, 0xa2, 0xd8, 0x95, 0x7b, 0xba, 0xd8, 0x03, 0x87, 0x5a, 0x3d,
+	0x71, 0xa0, 0x5c, 0xfa, 0xdd, 0x88, 0x7a, 0x3c, 0xd8, 0x88, 0x1b, 0x52, 0xe3, 0x90, 0x9c, 0xb6,
+	0xfc, 0x7e, 0xac, 0xba, 0xd1, 0x07, 0x80, 0x44, 0xd7, 0xb6, 0x04, 0x87, 0xa0, 0xb8, 0x04, 0xc9,
+	0x08, 0xb5, 0x7d, 0x48, 0x4e, 0x43, 0xed, 0x4f, 0xe1, 0x66, 0x54, 0x4f, 0x77, 0xa8, 0x1b, 0xd9,
+	0x75, 0x39, 0x8b, 0x65, 0x5c, 0x18, 0x4e, 0x11, 0x2d, 0xea, 0x4e, 0x17, 0x1f, 0xbd, 0x05, 0x59,
+	0x1f, 0xce, 0x5d, 0x46, 0xfd, 0x68, 0xba, 0x8c, 0x41, 0xaa, 0x4b, 0x09, 0xfa, 0x04, 0x56, 0x59,
+	0xcf, 0xa4, 0xa1, 0x73, 0x2c, 0x2f, 0x5a, 0x96, 0xac, 0x50, 0x0f, 0x3c, 0xe3, 0x7b, 0xc8, 0x0f,
+	0xb6, 0xf5, 0x91, 0xd3, 0x77, 0x49, 0x8f, 0x06, 0x69, 0x78, 0x45, 0x66, 0xba, 0xc6, 0xeb, 0xf9,
+	0x7d, 0xb9, 0xba, 0x7d, 0xe4, 0xd3, 0xaa, 0x64, 0xbd, 0x3e, 0x98, 0x15, 0xa0, 0x32, 0x6c, 0x88,
+	0x98, 0x69, 0xc8, 0xb2, 0x46, 0x97, 0x03, 0x35, 0x6c, 0xb3, 0x90, 0x12, 0x91, 0x13, 0xe7, 0x47,
+	0x1e, 0xf5, 0x0b, 0x9e, 0x96, 0xea, 0x28, 0x7d, 0x0e, 0xeb, 0x67, 0x38, 0x51, 0x16, 0x52, 0xfb,
+	0x95, 0x27, 0x3b, 0x47, 0xf5, 0x8e, 0xb6, 0x84, 0x10, 0xe4, 0xf6, 0x9b, 0x7a, 0xa3, 0xd9, 0xd1,
+	0x8f, 0x5a, 0x4f, 0xf1, 0xce, 0x7e, 0x45, 0x8b, 0x09, 0x85, 0xa0, 0x11, 0x2f, 0xfd, 0xb0, 0x0c,
+	0xda, 0xd9, 0x82, 0x0c, 0xdd, 0x03, 0x24, 0x32, 0x26, 0x35, 0x46, 0x9c, 0x8d, 0xa9, 0x4e, 0x5d,
+	0xd7, 0x76, 0x95, 0x0b, 0xec, 0xc6, 0x0b, 0x31, 0x9c, 0x8f, 0xf4, 0x56, 0x64, 0x27, 0x3a, 0x80,
+	0x92, 0xe7, 0x98, 0x8c, 0xeb, 0xf4, 0x94, 0x53, 0xd7, 0x22, 0xa6, 0x2e, 0xd3, 0xa1, 0x6e, 0xbb,
+	0xac, 0xcf, 0xac, 0x80, 0x22, 0x2d, 0xe7, 0x71, 0x4b, 0x6a, 0x56, 0x94, 0xa2, 0xcc, 0xa9, 0x4d,
+	0xa9, 0xa6, 0xb8, 0xfa, 0xf0, 0x76, 0xd4, 0xfc, 0x0c, 0xd1, 0x31, 0x61, 0xe6, 0xc8, 0xa5, 0x5e,
+	0x21, 0x23, 0xf7, 0xf4, 0xcd, 0x73, 0x7b, 0x7a, 0x54, 0xb3, 0xf8, 0xfd, 0xed, 0xaf, 0x44, 0x15,
+	0x83, 0x6f, 0x45, 0x68, 0x22, 0x66, 0x9e, 0x28, 0x0e, 0xf4, 0x2d, 0x14, 0xa3, 0x86, 0xfa, 0x84,
+	0xd3, 0x17, 0x64, 0x12, 0x0c, 0x76, 0xe5, 0x12, 0x16, 0x0a, 0x11, 0xfc, 0x53, 0x1f, 0xae, 0x26,
+	0x81, 0xe1, 0x7a, 0x94, 0xfb, 0xe1, 0xe9, 0x69, 0xc0, 0x9b, 0xba, 0x04, 0xef, 0x66, 0x04, 0xfb,
+	0xf0, 0xf4, 0x54, 0x71, 0x46, 0x8f, 0x7a, 0xfc, 0xd2, 0x47, 0x1d, 0x3d, 0x05, 0xd4, 0x25, 0x1e,
+	0xd5, 0xe9, 0x73, 0x75, 0x0d, 0x90, 0xe1, 0x65, 0x61, 0xac, 0xd0, 0x04, 0xa8, 0xa2, 0x30, 0xe2,
+	0x70, 0xa0, 0xff, 0x81, 0x4d, 0x71, 0xf0, 0x42, 0x1e, 0x87, 0xba, 0x06, 0xb5, 0xb8, 0x3a, 0x81,
+	0x68, 0x48, 0x4e, 0x03, 0xf5, 0x96, 0xdf, 0x23, 0xe2, 0xc2, 0x90, 0x59, 0xba, 0x2a, 0xc6, 0x03,
+	0xfd, 0x65, 0x3f, 0x2e, 0x0c, 0x99, 0xe5, 0x57, 0xdd, 0x4a, 0xbb, 0xf4, 0xd7, 0x04, 0xe4, 0xcf,
+	0x55, 0xf4, 0xa8, 0x01, 0xc9, 0xa1, 0xdd, 0x0b, 0x8a, 0xcd, 0x07, 0x57, 0xb9, 0x0d, 0x94, 0x3b,
+	0xf5, 0xb6, 0xc0, 0x06, 0x09, 0x5e, 0x7c, 0xa3, 0x0f, 0x01, 0xa9, 0xf3, 0x65, 0x50, 0x97, 0xb3,
+	0x63, 0x66, 0x10, 0x1e, 0x94, 0xbf, 0x79, 0xbf, 0x67, 0x6f, 0xda, 0x21, 0xa2, 0x8d, 0xe3, 0xb2,
+	0x31, 0xe1, 0x54, 0xe4, 0x72, 0xb9, 0x6c, 0x19, 0x0c, 0x4a, 0xf4, 0x8c, 0x4e, 0x44, 0xda, 0x32,
+	0x48, 0x94, 0xcb, 0x0f, 0x49, 0x19, 0x9c, 0x33, 0x48, 0x84, 0x48, 0xe6, 0x37, 0xc3, 0xa5, 0x3d,
+	0x6a, 0x71, 0x46, 0x4c, 0xbf, 0xc0, 0x49, 0x29, 0xc5, 0x50, 0x1c, 0x94, 0x35, 0xde, 0xa8, 0x2b,
+	0x96, 0x52, 0x27, 0x26, 0x97, 0x9a, 0xfe, 0xa5, 0x38, 0x83, 0xd7, 0x55, 0xc7, 0x8e, 0xc9, 0x85,
+	0xaa, 0x27, 0x2a, 0x7a, 0xcf, 0x62, 0xd2, 0x59, 0x33, 0x58, 0x7c, 0xa2, 0x3a, 0x6c, 0x32, 0xe9,
+	0x3c, 0x2e, 0xd5, 0xbd, 0x13, 0xe6, 0xe8, 0x63, 0xea, 0xb2, 0xe3, 0x89, 0x3c, 0x7c, 0xd9, 0xed,
+	0xe2, 0xb9, 0x0d, 0xdf, 0xb5, 0x6d, 0xd3, 0xf7, 0x3a, 0x14, 0xe0, 0xda, 0x27, 0xcc, 0xf9, 0x4a,
+	0xa2, 0x4a, 0x5f, 0x40, 0x4a, 0x2d, 0xa2, 0x8c, 0x2c, 0xb5, 0xf6, 0xce, 0x6e, 0xbd, 0xa2, 0x2d,
+	0x89, 0x32, 0xa5, 0x5d, 0x3b, 0x6c, 0xd5, 0x2b, 0x7e, 0xc9, 0x72, 0x78, 0xd4, 0x39, 0xda, 0xa9,
+	0x6b, 0x71, 0xa4, 0xc1, 0x6a, 0xad, 0xdd, 0xa9, 0x35, 0x75, 0x25, 0x49, 0x94, 0x7e, 0x9f, 0x84,
+	0x9b, 0x73, 0x0a, 0x67, 0x44, 0x00, 0x7a, 0xcc, 0xe3, 0x2e, 0xeb, 0x8e, 0xb8, 0xd8, 0x65, 0x71,
+	0x7d, 0xda, 0x79, 0xb5, 0x22, 0xbc, 0xbc, 0x1f, 0x12, 0xe1, 0x08, 0x29, 0xfa, 0x05, 0xa4, 0x45,
+	0xe0, 0xb0, 0xc7, 0xf2, 0x5a, 0x2d, 0x0c, 0x7c, 0xfe, 0x8a, 0x06, 0x9e, 0x28, 0x1a, 0x1c, 0x12,
+	0xa2, 0xf7, 0x21, 0x1f, 0x7c, 0xeb, 0x8e, 0xcb, 0x6c, 0x97, 0xf1, 0x89, 0x7a, 0x47, 0xd2, 0x82,
+	0x8e, 0x96, 0x92, 0xa3, 0x07, 0x90, 0xa2, 0x16, 0xe9, 0x9a, 0xb4, 0xa7, 0x0e, 0xe0, 0xbc, 0xfd,
+	0x08, 0x54, 0x8b, 0x7f, 0x88, 0x01, 0x4c, 0xa7, 0x26, 0x4a, 0xd4, 0x63, 0xd7, 0x1e, 0xaa, 0x6b,
+	0x9c, 0xfc, 0x46, 0xdf, 0x40, 0x9c, 0xdb, 0x6a, 0x72, 0xb5, 0xd7, 0x5e, 0xbd, 0x72, 0xc7, 0xf6,
+	0x2f, 0xa6, 0x71, 0x6e, 0x17, 0x1f, 0x42, 0x4a, 0x35, 0x17, 0xdd, 0x1f, 0xd7, 0x22, 0xf7, 0xc7,
+	0x62, 0x19, 0xd2, 0xc1, 0x6a, 0x5d, 0x38, 0xe2, 0x9c, 0x1a, 0xb1, 0x90, 0xc4, 0xb9, 0x5d, 0x7a,
+	0x00, 0x50, 0xb3, 0xf8, 0xa3, 0x07, 0x98, 0x58, 0x7d, 0x2a, 0x78, 0x3d, 0x4e, 0xd4, 0x63, 0x4a,
+	0x02, 0xfb, 0x0d, 0x61, 0x9f, 0x5a, 0x3d, 0x09, 0x4a, 0x60, 0xf1, 0x59, 0xfa, 0x0a, 0xd6, 0xfd,
+	0x20, 0xd2, 0xe6, 0x84, 0x8f, 0xbc, 0x36, 0xe5, 0x68, 0x0f, 0xd2, 0x9e, 0x6c, 0xc8, 0xd2, 0x2a,
+	0x71, 0x27, 0x37, 0xf7, 0x29, 0x26, 0x8a, 0xc6, 0x21, 0xb0, 0xb4, 0x0f, 0xa9, 0x16, 0x99, 0x98,
+	0x36, 0xe9, 0xa1, 0x4d, 0x48, 0x72, 0x7a, 0xca, 0xc3, 0x8b, 0x95, 0x6c, 0xa1, 0x02, 0xac, 0x74,
+	0x99, 0x45, 0x5c, 0xff, 0xf1, 0x72, 0x55, 0xdc, 0x65, 0xfd, 0xf6, 0x6e, 0x06, 0x52, 0x8e, 0x0f,
+	0x2d, 0xfd, 0x1d, 0x41, 0x36, 0xf2, 0xb2, 0x80, 0xee, 0x43, 0x2a, 0x28, 0x4a, 0x62, 0x8b, 0xe2,
+	0x6f, 0xa0, 0xf9, 0xaa, 0x61, 0xff, 0x0b, 0xc8, 0x31, 0x8b, 0xc9, 0x58, 0xf3, 0x9c, 0x71, 0x4e,
+	0xdd, 0xc2, 0xe6, 0x22, 0xf0, 0x9a, 0x02, 0x1c, 0x48, 0x7d, 0x51, 0x67, 0x07, 0x6c, 0x01, 0xc5,
+	0xc2, 0xac, 0x91, 0x0b, 0x10, 0x8a, 0xe3, 0x11, 0xdc, 0x38, 0xc3, 0x11, 0xa6, 0x01, 0x24, 0x3d,
+	0xe6, 0xda, 0x2c, 0x20, 0xc8, 0x1c, 0x87, 0xb0, 0x31, 0xb2, 0xfc, 0xbc, 0x31, 0xd1, 0xf9, 0xc0,
+	0xa5, 0xde, 0xc0, 0x36, 0x7b, 0xea, 0xea, 0x3c, 0x3f, 0x79, 0xa2, 0x10, 0xd8, 0x09, 0x70, 0xa8,
+	0x06, 0xf9, 0xf3, 0x64, 0xcb, 0x97, 0x20, 0xd3, 0xce, 0x51, 0xfd, 0x2f, 0xa4, 0x45, 0x54, 0x96,
+	0x2f, 0x7d, 0x97, 0xa9, 0x11, 0x52, 0xc4, 0xe4, 0x2d, 0xdb, 0xe5, 0xa8, 0x02, 0x9a, 0x4b, 0x65,
+	0x79, 0x37, 0xad, 0x75, 0x53, 0x0b, 0x83, 0xc0, 0xba, 0xc4, 0x44, 0xca, 0xdf, 0x1e, 0xe4, 0x83,
+	0x3b, 0x7f, 0xf8, 0xc2, 0xa5, 0x82, 0xfb, 0xa3, 0xcb, 0x3d, 0x70, 0x95, 0xab, 0xfe, 0xcb, 0x40,
+	0xd0, 0xae, 0x2e, 0xe1, 0xf5, 0xc1, 0xac, 0x08, 0x11, 0xd0, 0xc4, 0xfd, 0x68, 0xc6, 0x88, 0x5f,
+	0x73, 0x3d, 0xbc, 0xa4, 0x91, 0x8e, 0x71, 0xc6, 0x46, 0x8e, 0xcf, 0x48, 0xc4, 0x44, 0xfa, 0xae,
+	0x63, 0xcc, 0xda, 0xc8, 0x5e, 0x69, 0x22, 0x4f, 0x5d, 0xc7, 0x38, 0x33, 0x91, 0xfe, 0xac, 0x08,
+	0x3d, 0x87, 0x0d, 0x63, 0xe4, 0x71, 0x7b, 0x38, 0x6b, 0x67, 0x4d, 0xda, 0xf9, 0xe8, 0x92, 0x76,
+	0xf6, 0x24, 0xc3, 0xac, 0xa5, 0xbc, 0x71, 0x56, 0x88, 0x6a, 0xb0, 0x61, 0xd9, 0x7a, 0xf0, 0x82,
+	0x17, 0x1e, 0xda, 0xd5, 0x45, 0x87, 0x26, 0x6f, 0xd9, 0xea, 0x15, 0xaf, 0x16, 0x9c, 0xde, 0xaf,
+	0xe1, 0x66, 0x84, 0x2a, 0xf0, 0xdd, 0x90, 0xb2, 0xb0, 0x88, 0xb2, 0x10, 0x52, 0xfa, 0x03, 0x9c,
+	0x84, 0xcc, 0x55, 0x98, 0x1e, 0x90, 0x29, 0x61, 0x6e, 0xe1, 0x18, 0x43, 0x50, 0xc8, 0xf4, 0x25,
+	0xdc, 0x98, 0x32, 0xd1, 0x5e, 0x9f, 0x4e, 0xe9, 0xd6, 0x17, 0xd1, 0x5d, 0x0b, 0x91, 0x95, 0x5e,
+	0x9f, 0x86, 0x94, 0x87, 0x70, 0xed, 0x62, 0x42, 0x6d, 0x11, 0xe1, 0xc6, 0x45, 0x74, 0xef, 0x40,
+	0x8e, 0x8e, 0x45, 0xa9, 0x67, 0xda, 0x7d, 0x5d, 0x3e, 0xeb, 0xe4, 0x65, 0xbe, 0x59, 0x95, 0xd2,
+	0xba, 0xdd, 0x6f, 0x11, 0x3e, 0x40, 0x4f, 0xe0, 0x36, 0x31, 0x5f, 0x90, 0x89, 0x27, 0xd5, 0xa2,
+	0x6e, 0x32, 0xbd, 0x6f, 0x6c, 0xc8, 0xab, 0xcb, 0x9b, 0xbe, 0x5e, 0xdd, 0xee, 0x47, 0xb6, 0x3d,
+	0xbc, 0x4f, 0x60, 0xc8, 0x72, 0xd3, 0xd3, 0x6d, 0xc7, 0x7f, 0xbc, 0xb8, 0xb6, 0xf0, 0xa1, 0x7d,
+	0xe6, 0xb8, 0x98, 0x5e, 0xd3, 0x07, 0x62, 0xe0, 0xe1, 0x77, 0xf1, 0x87, 0x04, 0xac, 0x9f, 0x39,
+	0xae, 0x22, 0x9b, 0x4e, 0xff, 0xac, 0xa9, 0x7f, 0x6a, 0x17, 0x3d, 0x5b, 0x3d, 0x82, 0xa4, 0x27,
+	0xd2, 0xa5, 0x1f, 0xb4, 0x4b, 0xf3, 0xfe, 0x47, 0xf8, 0xf9, 0x0a, 0x4b, 0x7d, 0xf4, 0x09, 0xa4,
+	0x5c, 0x6a, 0x50, 0x36, 0xa6, 0x2a, 0xde, 0x5e, 0x06, 0x1a, 0x40, 0x10, 0x86, 0x3c, 0x3d, 0x75,
+	0xa8, 0xc1, 0x69, 0x4f, 0x0f, 0xf3, 0x70, 0x46, 0x16, 0x26, 0xef, 0xce, 0xe1, 0x99, 0xe6, 0x7e,
+	0xac, 0x05, 0xf8, 0xb6, 0x82, 0xa3, 0x0e, 0x20, 0x79, 0xdd, 0x17, 0xe5, 0xd0, 0x94, 0x74, 0xf5,
+	0x2a, 0xa4, 0xf9, 0x90, 0x20, 0x60, 0x3d, 0x48, 0xa6, 0x97, 0xb5, 0x95, 0x83, 0x64, 0x3a, 0xa5,
+	0xa5, 0x0f, 0x92, 0xe9, 0x15, 0x2d, 0x75, 0x90, 0x4c, 0xa7, 0xb5, 0x0c, 0x5e, 0x55, 0xbf, 0x3c,
+	0x65, 0xe5, 0x8d, 0x33, 0x22, 0x64, 0xcb, 0x37, 0x8c, 0xe2, 0x6f, 0x62, 0x90, 0x9b, 0x0d, 0x6b,
+	0xe1, 0x1a, 0xc7, 0x5e, 0x7d, 0x8d, 0xfd, 0xa2, 0xed, 0x2a, 0x6b, 0x5c, 0x7c, 0x07, 0x34, 0x4c,
+	0x7b, 0xcc, 0x8b, 0x8e, 0xe4, 0x5c, 0x6d, 0x56, 0xfc, 0x1a, 0xd6, 0xcf, 0x04, 0x48, 0xf4, 0x36,
+	0xcc, 0x4c, 0x4e, 0x69, 0x67, 0x95, 0x4c, 0xde, 0x3e, 0xde, 0x84, 0x0c, 0x19, 0xf1, 0x81, 0x5f,
+	0xc7, 0xfa, 0xee, 0x34, 0x15, 0x1c, 0x24, 0xd3, 0x09, 0x2d, 0x59, 0x7c, 0x08, 0xf9, 0x73, 0x21,
+	0x51, 0xb8, 0x60, 0x84, 0x53, 0x7e, 0x1f, 0x24, 0xd3, 0x71, 0x2d, 0x81, 0x57, 0x0c, 0xdb, 0x3a,
+	0x66, 0xfd, 0xe2, 0x7d, 0x80, 0xa9, 0x9b, 0xa3, 0x77, 0x21, 0x47, 0x4c, 0xc7, 0x0a, 0x9f, 0x39,
+	0xfc, 0x6a, 0x2d, 0x83, 0xd7, 0x84, 0x34, 0x78, 0xe2, 0xf0, 0x76, 0x35, 0xc8, 0x45, 0x8f, 0x24,
+	0x75, 0x0f, 0x92, 0x69, 0xd0, 0xb2, 0x07, 0xc9, 0xf4, 0x75, 0xed, 0xc6, 0xdd, 0x5f, 0xc2, 0x6a,
+	0xb4, 0x82, 0x93, 0xaf, 0x1b, 0x8d, 0x67, 0x8d, 0xe6, 0xff, 0x37, 0xb4, 0x25, 0xd1, 0xa8, 0x56,
+	0x76, 0xea, 0x9d, 0xea, 0x37, 0x5a, 0x0c, 0xad, 0x41, 0xe6, 0xa8, 0x11, 0x34, 0xe3, 0x68, 0x15,
+	0xd2, 0xfb, 0x78, 0xa7, 0xd6, 0xa8, 0x35, 0x9e, 0x6a, 0x09, 0xa1, 0xd9, 0xa9, 0x1d, 0x56, 0x9a,
+	0x47, 0x1d, 0x2d, 0x29, 0xbb, 0x2a, 0xf2, 0x85, 0x64, 0x5f, 0x5b, 0xde, 0x2d, 0xff, 0xf9, 0xe5,
+	0xad, 0xd8, 0x5f, 0x5e, 0xde, 0x8a, 0xfd, 0xe3, 0xe5, 0xad, 0xd8, 0xb7, 0xb7, 0xfd, 0x5d, 0x62,
+	0xb6, 0xfc, 0x1b, 0x7f, 0xc1, 0x7f, 0xf3, 0xee, 0x8a, 0x9c, 0xcf, 0xfd, 0xff, 0x04, 0x00, 0x00,
+	0xff, 0xff, 0x3a, 0x38, 0x86, 0x40, 0xfd, 0x1f, 0x00, 0x00,
+}
+
+func (m *DestinationRule) Marshal() (dAtA []byte, err error) {
 	size := m.Size()
 	dAtA = make([]byte, size)
 	n, err := m.MarshalToSizedBuffer(dAtA[:size])
@@ -3037,12 +3395,12 @@ func (m *ConnectionPoolSettings_TCPSettings) Marshal() (dAtA []byte, err error)
 	return dAtA[:n], nil
 }
 
-func (m *ConnectionPoolSettings_TCPSettings) MarshalTo(dAtA []byte) (int, error) {
+func (m *DestinationRule) MarshalTo(dAtA []byte) (int, error) {
 	size := m.Size()
 	return m.MarshalToSizedBuffer(dAtA[:size])
 }
 
-func (m *ConnectionPoolSettings_TCPSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+func (m *DestinationRule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 	i := len(dAtA)
 	_ = i
 	var l int
@@ -3051,21 +3409,32 @@ func (m *ConnectionPoolSettings_TCPSettings) MarshalToSizedBuffer(dAtA []byte) (
 		i -= len(m.XXX_unrecognized)
 		copy(dAtA[i:], m.XXX_unrecognized)
 	}
-	if m.TcpKeepalive != nil {
-		{
-			size, err := m.TcpKeepalive.MarshalToSizedBuffer(dAtA[:i])
-			if err != nil {
-				return 0, err
+	if len(m.ExportTo) > 0 {
+		for iNdEx := len(m.ExportTo) - 1; iNdEx >= 0; iNdEx-- {
+			i -= len(m.ExportTo[iNdEx])
+			copy(dAtA[i:], m.ExportTo[iNdEx])
+			i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.ExportTo[iNdEx])))
+			i--
+			dAtA[i] = 0x22
+		}
+	}
+	if len(m.Subsets) > 0 {
+		for iNdEx := len(m.Subsets) - 1; iNdEx >= 0; iNdEx-- {
+			{
+				size, err := m.Subsets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
+				if err != nil {
+					return 0, err
+				}
+				i -= size
+				i = encodeVarintDestinationRule(dAtA, i, uint64(size))
 			}
-			i -= size
-			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+			i--
+			dAtA[i] = 0x1a
 		}
-		i--
-		dAtA[i] = 0x1a
 	}
-	if m.ConnectTimeout != nil {
+	if m.TrafficPolicy != nil {
 		{
-			size, err := m.ConnectTimeout.MarshalToSizedBuffer(dAtA[:i])
+			size, err := m.TrafficPolicy.MarshalToSizedBuffer(dAtA[:i])
 			if err != nil {
 				return 0, err
 			}
@@ -3075,15 +3444,17 @@ func (m *ConnectionPoolSettings_TCPSettings) MarshalToSizedBuffer(dAtA []byte) (
 		i--
 		dAtA[i] = 0x12
 	}
-	if m.MaxConnections != 0 {
-		i = encodeVarintDestinationRule(dAtA, i, uint64(m.MaxConnections))
+	if len(m.Host) > 0 {
+		i -= len(m.Host)
+		copy(dAtA[i:], m.Host)
+		i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.Host)))
 		i--
-		dAtA[i] = 0x8
+		dAtA[i] = 0xa
 	}
 	return len(dAtA) - i, nil
 }
 
-func (m *ConnectionPoolSettings_TCPSettings_TcpKeepalive) Marshal() (dAtA []byte, err error) {
+func (m *TrafficPolicy) Marshal() (dAtA []byte, err error) {
 	size := m.Size()
 	dAtA = make([]byte, size)
 	n, err := m.MarshalToSizedBuffer(dAtA[:size])
@@ -3093,12 +3464,12 @@ func (m *ConnectionPoolSettings_TCPSettings_TcpKeepalive) Marshal() (dAtA []byte
 	return dAtA[:n], nil
 }
 
-func (m *ConnectionPoolSettings_TCPSettings_TcpKeepalive) MarshalTo(dAtA []byte) (int, error) {
+func (m *TrafficPolicy) MarshalTo(dAtA []byte) (int, error) {
 	size := m.Size()
 	return m.MarshalToSizedBuffer(dAtA[:size])
 }
 
-func (m *ConnectionPoolSettings_TCPSettings_TcpKeepalive) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+func (m *TrafficPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 	i := len(dAtA)
 	_ = i
 	var l int
@@ -3107,9 +3478,39 @@ func (m *ConnectionPoolSettings_TCPSettings_TcpKeepalive) MarshalToSizedBuffer(d
 		i -= len(m.XXX_unrecognized)
 		copy(dAtA[i:], m.XXX_unrecognized)
 	}
-	if m.Interval != nil {
+	if len(m.HealthChecks) > 0 {
+		for iNdEx := len(m.HealthChecks) - 1; iNdEx >= 0; iNdEx-- {
+			{
+				size, err := m.HealthChecks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
+				if err != nil {
+					return 0, err
+				}
+				i -= size
+				i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+			}
+			i--
+			dAtA[i] = 0x6
+			i--
+			dAtA[i] = 0xaa
+		}
+	}
+	if len(m.PortLevelSettings) > 0 {
+		for iNdEx := len(m.PortLevelSettings) - 1; iNdEx >= 0; iNdEx-- {
+			{
+				size, err := m.PortLevelSettings[iNdEx].MarshalToSizedBuffer(dAtA[:i])
+				if err != nil {
+					return 0, err
+				}
+				i -= size
+				i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+			}
+			i--
+			dAtA[i] = 0x2a
+		}
+	}
+	if m.Tls != nil {
 		{
-			size, err := m.Interval.MarshalToSizedBuffer(dAtA[:i])
+			size, err := m.Tls.MarshalToSizedBuffer(dAtA[:i])
 			if err != nil {
 				return 0, err
 			}
@@ -3117,11 +3518,11 @@ func (m *ConnectionPoolSettings_TCPSettings_TcpKeepalive) MarshalToSizedBuffer(d
 			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
 		}
 		i--
-		dAtA[i] = 0x1a
+		dAtA[i] = 0x22
 	}
-	if m.Time != nil {
+	if m.OutlierDetection != nil {
 		{
-			size, err := m.Time.MarshalToSizedBuffer(dAtA[:i])
+			size, err := m.OutlierDetection.MarshalToSizedBuffer(dAtA[:i])
 			if err != nil {
 				return 0, err
 			}
@@ -3129,58 +3530,23 @@ func (m *ConnectionPoolSettings_TCPSettings_TcpKeepalive) MarshalToSizedBuffer(d
 			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
 		}
 		i--
-		dAtA[i] = 0x12
+		dAtA[i] = 0x1a
 	}
-	if m.Probes != 0 {
-		i = encodeVarintDestinationRule(dAtA, i, uint64(m.Probes))
-		i--
-		dAtA[i] = 0x8
-	}
-	return len(dAtA) - i, nil
-}
-
-func (m *ConnectionPoolSettings_HTTPSettings) Marshal() (dAtA []byte, err error) {
-	size := m.Size()
-	dAtA = make([]byte, size)
-	n, err := m.MarshalToSizedBuffer(dAtA[:size])
-	if err != nil {
-		return nil, err
-	}
-	return dAtA[:n], nil
-}
-
-func (m *ConnectionPoolSettings_HTTPSettings) MarshalTo(dAtA []byte) (int, error) {
-	size := m.Size()
-	return m.MarshalToSizedBuffer(dAtA[:size])
-}
-
-func (m *ConnectionPoolSettings_HTTPSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
-	i := len(dAtA)
-	_ = i
-	var l int
-	_ = l
-	if m.XXX_unrecognized != nil {
-		i -= len(m.XXX_unrecognized)
-		copy(dAtA[i:], m.XXX_unrecognized)
-	}
-	if m.UseClientProtocol {
-		i--
-		if m.UseClientProtocol {
-			dAtA[i] = 1
-		} else {
-			dAtA[i] = 0
+	if m.ConnectionPool != nil {
+		{
+			size, err := m.ConnectionPool.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
 		}
 		i--
-		dAtA[i] = 0x38
-	}
-	if m.H2UpgradePolicy != 0 {
-		i = encodeVarintDestinationRule(dAtA, i, uint64(m.H2UpgradePolicy))
-		i--
-		dAtA[i] = 0x30
+		dAtA[i] = 0x12
 	}
-	if m.IdleTimeout != nil {
+	if m.LoadBalancer != nil {
 		{
-			size, err := m.IdleTimeout.MarshalToSizedBuffer(dAtA[:i])
+			size, err := m.LoadBalancer.MarshalToSizedBuffer(dAtA[:i])
 			if err != nil {
 				return 0, err
 			}
@@ -3188,32 +3554,12 @@ func (m *ConnectionPoolSettings_HTTPSettings) MarshalToSizedBuffer(dAtA []byte)
 			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
 		}
 		i--
-		dAtA[i] = 0x2a
-	}
-	if m.MaxRetries != 0 {
-		i = encodeVarintDestinationRule(dAtA, i, uint64(m.MaxRetries))
-		i--
-		dAtA[i] = 0x20
-	}
-	if m.MaxRequestsPerConnection != 0 {
-		i = encodeVarintDestinationRule(dAtA, i, uint64(m.MaxRequestsPerConnection))
-		i--
-		dAtA[i] = 0x18
-	}
-	if m.Http2MaxRequests != 0 {
-		i = encodeVarintDestinationRule(dAtA, i, uint64(m.Http2MaxRequests))
-		i--
-		dAtA[i] = 0x10
-	}
-	if m.Http1MaxPendingRequests != 0 {
-		i = encodeVarintDestinationRule(dAtA, i, uint64(m.Http1MaxPendingRequests))
-		i--
-		dAtA[i] = 0x8
+		dAtA[i] = 0xa
 	}
 	return len(dAtA) - i, nil
 }
 
-func (m *OutlierDetection) Marshal() (dAtA []byte, err error) {
+func (m *TrafficPolicy_PortTrafficPolicy) Marshal() (dAtA []byte, err error) {
 	size := m.Size()
 	dAtA = make([]byte, size)
 	n, err := m.MarshalToSizedBuffer(dAtA[:size])
@@ -3223,12 +3569,12 @@ func (m *OutlierDetection) Marshal() (dAtA []byte, err error) {
 	return dAtA[:n], nil
 }
 
-func (m *OutlierDetection) MarshalTo(dAtA []byte) (int, error) {
+func (m *TrafficPolicy_PortTrafficPolicy) MarshalTo(dAtA []byte) (int, error) {
 	size := m.Size()
 	return m.MarshalToSizedBuffer(dAtA[:size])
 }
 
-func (m *OutlierDetection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+func (m *TrafficPolicy_PortTrafficPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 	i := len(dAtA)
 	_ = i
 	var l int
@@ -3237,9 +3583,25 @@ func (m *OutlierDetection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 		i -= len(m.XXX_unrecognized)
 		copy(dAtA[i:], m.XXX_unrecognized)
 	}
-	if m.ConsecutiveLocalOriginFailures != nil {
+	if len(m.HealthChecks) > 0 {
+		for iNdEx := len(m.HealthChecks) - 1; iNdEx >= 0; iNdEx-- {
+			{
+				size, err := m.HealthChecks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
+				if err != nil {
+					return 0, err
+				}
+				i -= size
+				i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+			}
+			i--
+			dAtA[i] = 0x6
+			i--
+			dAtA[i] = 0xaa
+		}
+	}
+	if m.Tls != nil {
 		{
-			size, err := m.ConsecutiveLocalOriginFailures.MarshalToSizedBuffer(dAtA[:i])
+			size, err := m.Tls.MarshalToSizedBuffer(dAtA[:i])
 			if err != nil {
 				return 0, err
 			}
@@ -3247,21 +3609,11 @@ func (m *OutlierDetection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
 		}
 		i--
-		dAtA[i] = 0x4a
-	}
-	if m.SplitExternalLocalOriginErrors {
-		i--
-		if m.SplitExternalLocalOriginErrors {
-			dAtA[i] = 1
-		} else {
-			dAtA[i] = 0
-		}
-		i--
-		dAtA[i] = 0x40
+		dAtA[i] = 0x2a
 	}
-	if m.Consecutive_5XxErrors != nil {
+	if m.OutlierDetection != nil {
 		{
-			size, err := m.Consecutive_5XxErrors.MarshalToSizedBuffer(dAtA[:i])
+			size, err := m.OutlierDetection.MarshalToSizedBuffer(dAtA[:i])
 			if err != nil {
 				return 0, err
 			}
@@ -3269,11 +3621,11 @@ func (m *OutlierDetection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
 		}
 		i--
-		dAtA[i] = 0x3a
+		dAtA[i] = 0x22
 	}
-	if m.ConsecutiveGatewayErrors != nil {
+	if m.ConnectionPool != nil {
 		{
-			size, err := m.ConsecutiveGatewayErrors.MarshalToSizedBuffer(dAtA[:i])
+			size, err := m.ConnectionPool.MarshalToSizedBuffer(dAtA[:i])
 			if err != nil {
 				return 0, err
 			}
@@ -3281,21 +3633,11 @@ func (m *OutlierDetection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
 		}
 		i--
-		dAtA[i] = 0x32
-	}
-	if m.MinHealthPercent != 0 {
-		i = encodeVarintDestinationRule(dAtA, i, uint64(m.MinHealthPercent))
-		i--
-		dAtA[i] = 0x28
-	}
-	if m.MaxEjectionPercent != 0 {
-		i = encodeVarintDestinationRule(dAtA, i, uint64(m.MaxEjectionPercent))
-		i--
-		dAtA[i] = 0x20
+		dAtA[i] = 0x1a
 	}
-	if m.BaseEjectionTime != nil {
+	if m.LoadBalancer != nil {
 		{
-			size, err := m.BaseEjectionTime.MarshalToSizedBuffer(dAtA[:i])
+			size, err := m.LoadBalancer.MarshalToSizedBuffer(dAtA[:i])
 			if err != nil {
 				return 0, err
 			}
@@ -3303,11 +3645,11 @@ func (m *OutlierDetection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
 		}
 		i--
-		dAtA[i] = 0x1a
+		dAtA[i] = 0x12
 	}
-	if m.Interval != nil {
+	if m.Port != nil {
 		{
-			size, err := m.Interval.MarshalToSizedBuffer(dAtA[:i])
+			size, err := m.Port.MarshalToSizedBuffer(dAtA[:i])
 			if err != nil {
 				return 0, err
 			}
@@ -3315,17 +3657,12 @@ func (m *OutlierDetection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
 		}
 		i--
-		dAtA[i] = 0x12
-	}
-	if m.ConsecutiveErrors != 0 {
-		i = encodeVarintDestinationRule(dAtA, i, uint64(m.ConsecutiveErrors))
-		i--
-		dAtA[i] = 0x8
+		dAtA[i] = 0xa
 	}
 	return len(dAtA) - i, nil
 }
 
-func (m *ClientTLSSettings) Marshal() (dAtA []byte, err error) {
+func (m *Subset) Marshal() (dAtA []byte, err error) {
 	size := m.Size()
 	dAtA = make([]byte, size)
 	n, err := m.MarshalToSizedBuffer(dAtA[:size])
@@ -3335,12 +3672,12 @@ func (m *ClientTLSSettings) Marshal() (dAtA []byte, err error) {
 	return dAtA[:n], nil
 }
 
-func (m *ClientTLSSettings) MarshalTo(dAtA []byte) (int, error) {
+func (m *Subset) MarshalTo(dAtA []byte) (int, error) {
 	size := m.Size()
 	return m.MarshalToSizedBuffer(dAtA[:size])
 }
 
-func (m *ClientTLSSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+func (m *Subset) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 	i := len(dAtA)
 	_ = i
 	var l int
@@ -3349,9 +3686,9 @@ func (m *ClientTLSSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 		i -= len(m.XXX_unrecognized)
 		copy(dAtA[i:], m.XXX_unrecognized)
 	}
-	if m.InsecureSkipVerify != nil {
+	if m.TrafficPolicy != nil {
 		{
-			size, err := m.InsecureSkipVerify.MarshalToSizedBuffer(dAtA[:i])
+			size, err := m.TrafficPolicy.MarshalToSizedBuffer(dAtA[:i])
 			if err != nil {
 				return 0, err
 			}
@@ -3359,61 +3696,38 @@ func (m *ClientTLSSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
 		}
 		i--
-		dAtA[i] = 0x42
-	}
-	if len(m.CredentialName) > 0 {
-		i -= len(m.CredentialName)
-		copy(dAtA[i:], m.CredentialName)
-		i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.CredentialName)))
-		i--
-		dAtA[i] = 0x3a
-	}
-	if len(m.Sni) > 0 {
-		i -= len(m.Sni)
-		copy(dAtA[i:], m.Sni)
-		i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.Sni)))
-		i--
-		dAtA[i] = 0x32
+		dAtA[i] = 0x1a
 	}
-	if len(m.SubjectAltNames) > 0 {
-		for iNdEx := len(m.SubjectAltNames) - 1; iNdEx >= 0; iNdEx-- {
-			i -= len(m.SubjectAltNames[iNdEx])
-			copy(dAtA[i:], m.SubjectAltNames[iNdEx])
-			i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.SubjectAltNames[iNdEx])))
+	if len(m.Labels) > 0 {
+		for k := range m.Labels {
+			v := m.Labels[k]
+			baseI := i
+			i -= len(v)
+			copy(dAtA[i:], v)
+			i = encodeVarintDestinationRule(dAtA, i, uint64(len(v)))
 			i--
-			dAtA[i] = 0x2a
+			dAtA[i] = 0x12
+			i -= len(k)
+			copy(dAtA[i:], k)
+			i = encodeVarintDestinationRule(dAtA, i, uint64(len(k)))
+			i--
+			dAtA[i] = 0xa
+			i = encodeVarintDestinationRule(dAtA, i, uint64(baseI-i))
+			i--
+			dAtA[i] = 0x12
 		}
 	}
-	if len(m.CaCertificates) > 0 {
-		i -= len(m.CaCertificates)
-		copy(dAtA[i:], m.CaCertificates)
-		i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.CaCertificates)))
-		i--
-		dAtA[i] = 0x22
-	}
-	if len(m.PrivateKey) > 0 {
-		i -= len(m.PrivateKey)
-		copy(dAtA[i:], m.PrivateKey)
-		i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.PrivateKey)))
-		i--
-		dAtA[i] = 0x1a
-	}
-	if len(m.ClientCertificate) > 0 {
-		i -= len(m.ClientCertificate)
-		copy(dAtA[i:], m.ClientCertificate)
-		i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.ClientCertificate)))
-		i--
-		dAtA[i] = 0x12
-	}
-	if m.Mode != 0 {
-		i = encodeVarintDestinationRule(dAtA, i, uint64(m.Mode))
+	if len(m.Name) > 0 {
+		i -= len(m.Name)
+		copy(dAtA[i:], m.Name)
+		i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.Name)))
 		i--
-		dAtA[i] = 0x8
+		dAtA[i] = 0xa
 	}
 	return len(dAtA) - i, nil
 }
 
-func (m *LocalityLoadBalancerSetting) Marshal() (dAtA []byte, err error) {
+func (m *LoadBalancerSettings) Marshal() (dAtA []byte, err error) {
 	size := m.Size()
 	dAtA = make([]byte, size)
 	n, err := m.MarshalToSizedBuffer(dAtA[:size])
@@ -3423,12 +3737,12 @@ func (m *LocalityLoadBalancerSetting) Marshal() (dAtA []byte, err error) {
 	return dAtA[:n], nil
 }
 
-func (m *LocalityLoadBalancerSetting) MarshalTo(dAtA []byte) (int, error) {
+func (m *LoadBalancerSettings) MarshalTo(dAtA []byte) (int, error) {
 	size := m.Size()
 	return m.MarshalToSizedBuffer(dAtA[:size])
 }
 
-func (m *LocalityLoadBalancerSetting) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+func (m *LoadBalancerSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 	i := len(dAtA)
 	_ = i
 	var l int
@@ -3437,18 +3751,21 @@ func (m *LocalityLoadBalancerSetting) MarshalToSizedBuffer(dAtA []byte) (int, er
 		i -= len(m.XXX_unrecognized)
 		copy(dAtA[i:], m.XXX_unrecognized)
 	}
-	if len(m.FailoverPriority) > 0 {
-		for iNdEx := len(m.FailoverPriority) - 1; iNdEx >= 0; iNdEx-- {
-			i -= len(m.FailoverPriority[iNdEx])
-			copy(dAtA[i:], m.FailoverPriority[iNdEx])
-			i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.FailoverPriority[iNdEx])))
-			i--
-			dAtA[i] = 0x22
+	if m.WarmupDurationSecs != nil {
+		{
+			size, err := m.WarmupDurationSecs.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
 		}
+		i--
+		dAtA[i] = 0x22
 	}
-	if m.Enabled != nil {
+	if m.LocalityLbSetting != nil {
 		{
-			size, err := m.Enabled.MarshalToSizedBuffer(dAtA[:i])
+			size, err := m.LocalityLbSetting.MarshalToSizedBuffer(dAtA[:i])
 			if err != nil {
 				return 0, err
 			}
@@ -3458,38 +3775,52 @@ func (m *LocalityLoadBalancerSetting) MarshalToSizedBuffer(dAtA []byte) (int, er
 		i--
 		dAtA[i] = 0x1a
 	}
-	if len(m.Failover) > 0 {
-		for iNdEx := len(m.Failover) - 1; iNdEx >= 0; iNdEx-- {
-			{
-				size, err := m.Failover[iNdEx].MarshalToSizedBuffer(dAtA[:i])
-				if err != nil {
-					return 0, err
-				}
-				i -= size
-				i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+	if m.LbPolicy != nil {
+		{
+			size := m.LbPolicy.Size()
+			i -= size
+			if _, err := m.LbPolicy.MarshalTo(dAtA[i:]); err != nil {
+				return 0, err
 			}
-			i--
-			dAtA[i] = 0x12
 		}
 	}
-	if len(m.Distribute) > 0 {
-		for iNdEx := len(m.Distribute) - 1; iNdEx >= 0; iNdEx-- {
-			{
-				size, err := m.Distribute[iNdEx].MarshalToSizedBuffer(dAtA[:i])
-				if err != nil {
-					return 0, err
-				}
-				i -= size
-				i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+	return len(dAtA) - i, nil
+}
+
+func (m *LoadBalancerSettings_Simple) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *LoadBalancerSettings_Simple) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	i = encodeVarintDestinationRule(dAtA, i, uint64(m.Simple))
+	i--
+	dAtA[i] = 0x8
+	return len(dAtA) - i, nil
+}
+func (m *LoadBalancerSettings_ConsistentHash) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *LoadBalancerSettings_ConsistentHash) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	if m.ConsistentHash != nil {
+		{
+			size, err := m.ConsistentHash.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
 			}
-			i--
-			dAtA[i] = 0xa
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
 		}
+		i--
+		dAtA[i] = 0x12
 	}
 	return len(dAtA) - i, nil
 }
-
-func (m *LocalityLoadBalancerSetting_Distribute) Marshal() (dAtA []byte, err error) {
+func (m *LoadBalancerSettings_ConsistentHashLB) Marshal() (dAtA []byte, err error) {
 	size := m.Size()
 	dAtA = make([]byte, size)
 	n, err := m.MarshalToSizedBuffer(dAtA[:size])
@@ -3499,12 +3830,12 @@ func (m *LocalityLoadBalancerSetting_Distribute) Marshal() (dAtA []byte, err err
 	return dAtA[:n], nil
 }
 
-func (m *LocalityLoadBalancerSetting_Distribute) MarshalTo(dAtA []byte) (int, error) {
+func (m *LoadBalancerSettings_ConsistentHashLB) MarshalTo(dAtA []byte) (int, error) {
 	size := m.Size()
 	return m.MarshalToSizedBuffer(dAtA[:size])
 }
 
-func (m *LocalityLoadBalancerSetting_Distribute) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+func (m *LoadBalancerSettings_ConsistentHashLB) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 	i := len(dAtA)
 	_ = i
 	var l int
@@ -3513,34 +3844,90 @@ func (m *LocalityLoadBalancerSetting_Distribute) MarshalToSizedBuffer(dAtA []byt
 		i -= len(m.XXX_unrecognized)
 		copy(dAtA[i:], m.XXX_unrecognized)
 	}
-	if len(m.To) > 0 {
-		for k := range m.To {
-			v := m.To[k]
-			baseI := i
-			i = encodeVarintDestinationRule(dAtA, i, uint64(v))
-			i--
-			dAtA[i] = 0x10
-			i -= len(k)
-			copy(dAtA[i:], k)
-			i = encodeVarintDestinationRule(dAtA, i, uint64(len(k)))
-			i--
-			dAtA[i] = 0xa
-			i = encodeVarintDestinationRule(dAtA, i, uint64(baseI-i))
-			i--
-			dAtA[i] = 0x12
+	if m.HashKey != nil {
+		{
+			size := m.HashKey.Size()
+			i -= size
+			if _, err := m.HashKey.MarshalTo(dAtA[i:]); err != nil {
+				return 0, err
+			}
 		}
 	}
-	if len(m.From) > 0 {
-		i -= len(m.From)
-		copy(dAtA[i:], m.From)
-		i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.From)))
+	if m.MinimumRingSize != 0 {
+		i = encodeVarintDestinationRule(dAtA, i, uint64(m.MinimumRingSize))
 		i--
-		dAtA[i] = 0xa
+		dAtA[i] = 0x20
 	}
 	return len(dAtA) - i, nil
 }
 
-func (m *LocalityLoadBalancerSetting_Failover) Marshal() (dAtA []byte, err error) {
+func (m *LoadBalancerSettings_ConsistentHashLB_HttpHeaderName) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *LoadBalancerSettings_ConsistentHashLB_HttpHeaderName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	i -= len(m.HttpHeaderName)
+	copy(dAtA[i:], m.HttpHeaderName)
+	i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.HttpHeaderName)))
+	i--
+	dAtA[i] = 0xa
+	return len(dAtA) - i, nil
+}
+func (m *LoadBalancerSettings_ConsistentHashLB_HttpCookie) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *LoadBalancerSettings_ConsistentHashLB_HttpCookie) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	if m.HttpCookie != nil {
+		{
+			size, err := m.HttpCookie.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x12
+	}
+	return len(dAtA) - i, nil
+}
+func (m *LoadBalancerSettings_ConsistentHashLB_UseSourceIp) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *LoadBalancerSettings_ConsistentHashLB_UseSourceIp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	i--
+	if m.UseSourceIp {
+		dAtA[i] = 1
+	} else {
+		dAtA[i] = 0
+	}
+	i--
+	dAtA[i] = 0x18
+	return len(dAtA) - i, nil
+}
+func (m *LoadBalancerSettings_ConsistentHashLB_HttpQueryParameterName) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *LoadBalancerSettings_ConsistentHashLB_HttpQueryParameterName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	i -= len(m.HttpQueryParameterName)
+	copy(dAtA[i:], m.HttpQueryParameterName)
+	i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.HttpQueryParameterName)))
+	i--
+	dAtA[i] = 0x2a
+	return len(dAtA) - i, nil
+}
+func (m *LoadBalancerSettings_ConsistentHashLB_HTTPCookie) Marshal() (dAtA []byte, err error) {
 	size := m.Size()
 	dAtA = make([]byte, size)
 	n, err := m.MarshalToSizedBuffer(dAtA[:size])
@@ -3550,12 +3937,12 @@ func (m *LocalityLoadBalancerSetting_Failover) Marshal() (dAtA []byte, err error
 	return dAtA[:n], nil
 }
 
-func (m *LocalityLoadBalancerSetting_Failover) MarshalTo(dAtA []byte) (int, error) {
+func (m *LoadBalancerSettings_ConsistentHashLB_HTTPCookie) MarshalTo(dAtA []byte) (int, error) {
 	size := m.Size()
 	return m.MarshalToSizedBuffer(dAtA[:size])
 }
 
-func (m *LocalityLoadBalancerSetting_Failover) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+func (m *LoadBalancerSettings_ConsistentHashLB_HTTPCookie) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 	i := len(dAtA)
 	_ = i
 	var l int
@@ -3564,493 +3951,1889 @@ func (m *LocalityLoadBalancerSetting_Failover) MarshalToSizedBuffer(dAtA []byte)
 		i -= len(m.XXX_unrecognized)
 		copy(dAtA[i:], m.XXX_unrecognized)
 	}
-	if len(m.To) > 0 {
-		i -= len(m.To)
-		copy(dAtA[i:], m.To)
-		i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.To)))
+	if m.Ttl != nil {
+		{
+			size, err := m.Ttl.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x1a
+	}
+	if len(m.Path) > 0 {
+		i -= len(m.Path)
+		copy(dAtA[i:], m.Path)
+		i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.Path)))
 		i--
 		dAtA[i] = 0x12
 	}
-	if len(m.From) > 0 {
-		i -= len(m.From)
-		copy(dAtA[i:], m.From)
-		i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.From)))
+	if len(m.Name) > 0 {
+		i -= len(m.Name)
+		copy(dAtA[i:], m.Name)
+		i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.Name)))
 		i--
 		dAtA[i] = 0xa
 	}
 	return len(dAtA) - i, nil
 }
 
-func encodeVarintDestinationRule(dAtA []byte, offset int, v uint64) int {
-	offset -= sovDestinationRule(v)
-	base := offset
-	for v >= 1<<7 {
-		dAtA[offset] = uint8(v&0x7f | 0x80)
-		v >>= 7
-		offset++
+func (m *ConnectionPoolSettings) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
 	}
-	dAtA[offset] = uint8(v)
-	return base
+	return dAtA[:n], nil
 }
-func (m *DestinationRule) Size() (n int) {
-	if m == nil {
-		return 0
-	}
+
+func (m *ConnectionPoolSettings) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *ConnectionPoolSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
 	var l int
 	_ = l
-	l = len(m.Host)
-	if l > 0 {
-		n += 1 + l + sovDestinationRule(uint64(l))
+	if m.XXX_unrecognized != nil {
+		i -= len(m.XXX_unrecognized)
+		copy(dAtA[i:], m.XXX_unrecognized)
 	}
-	if m.TrafficPolicy != nil {
-		l = m.TrafficPolicy.Size()
-		n += 1 + l + sovDestinationRule(uint64(l))
+	if m.Http != nil {
+		{
+			size, err := m.Http.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x12
 	}
-	if len(m.Subsets) > 0 {
-		for _, e := range m.Subsets {
-			l = e.Size()
-			n += 1 + l + sovDestinationRule(uint64(l))
+	if m.Tcp != nil {
+		{
+			size, err := m.Tcp.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
 		}
+		i--
+		dAtA[i] = 0xa
 	}
-	if len(m.ExportTo) > 0 {
-		for _, s := range m.ExportTo {
-			l = len(s)
-			n += 1 + l + sovDestinationRule(uint64(l))
-		}
-	}
-	if m.XXX_unrecognized != nil {
-		n += len(m.XXX_unrecognized)
-	}
-	return n
+	return len(dAtA) - i, nil
 }
 
-func (m *TrafficPolicy) Size() (n int) {
-	if m == nil {
-		return 0
+func (m *ConnectionPoolSettings_TCPSettings) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
 	}
+	return dAtA[:n], nil
+}
+
+func (m *ConnectionPoolSettings_TCPSettings) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *ConnectionPoolSettings_TCPSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
 	var l int
 	_ = l
-	if m.LoadBalancer != nil {
-		l = m.LoadBalancer.Size()
-		n += 1 + l + sovDestinationRule(uint64(l))
-	}
-	if m.ConnectionPool != nil {
-		l = m.ConnectionPool.Size()
-		n += 1 + l + sovDestinationRule(uint64(l))
-	}
-	if m.OutlierDetection != nil {
-		l = m.OutlierDetection.Size()
-		n += 1 + l + sovDestinationRule(uint64(l))
+	if m.XXX_unrecognized != nil {
+		i -= len(m.XXX_unrecognized)
+		copy(dAtA[i:], m.XXX_unrecognized)
 	}
-	if m.Tls != nil {
-		l = m.Tls.Size()
-		n += 1 + l + sovDestinationRule(uint64(l))
+	if m.TcpKeepalive != nil {
+		{
+			size, err := m.TcpKeepalive.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x1a
 	}
-	if len(m.PortLevelSettings) > 0 {
-		for _, e := range m.PortLevelSettings {
-			l = e.Size()
-			n += 1 + l + sovDestinationRule(uint64(l))
+	if m.ConnectTimeout != nil {
+		{
+			size, err := m.ConnectTimeout.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
 		}
+		i--
+		dAtA[i] = 0x12
 	}
-	if m.XXX_unrecognized != nil {
-		n += len(m.XXX_unrecognized)
+	if m.MaxConnections != 0 {
+		i = encodeVarintDestinationRule(dAtA, i, uint64(m.MaxConnections))
+		i--
+		dAtA[i] = 0x8
 	}
-	return n
+	return len(dAtA) - i, nil
 }
 
-func (m *TrafficPolicy_PortTrafficPolicy) Size() (n int) {
-	if m == nil {
-		return 0
+func (m *ConnectionPoolSettings_TCPSettings_TcpKeepalive) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
 	}
+	return dAtA[:n], nil
+}
+
+func (m *ConnectionPoolSettings_TCPSettings_TcpKeepalive) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *ConnectionPoolSettings_TCPSettings_TcpKeepalive) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
 	var l int
 	_ = l
-	if m.Port != nil {
-		l = m.Port.Size()
-		n += 1 + l + sovDestinationRule(uint64(l))
-	}
-	if m.LoadBalancer != nil {
-		l = m.LoadBalancer.Size()
-		n += 1 + l + sovDestinationRule(uint64(l))
-	}
-	if m.ConnectionPool != nil {
-		l = m.ConnectionPool.Size()
-		n += 1 + l + sovDestinationRule(uint64(l))
+	if m.XXX_unrecognized != nil {
+		i -= len(m.XXX_unrecognized)
+		copy(dAtA[i:], m.XXX_unrecognized)
 	}
-	if m.OutlierDetection != nil {
-		l = m.OutlierDetection.Size()
-		n += 1 + l + sovDestinationRule(uint64(l))
+	if m.Interval != nil {
+		{
+			size, err := m.Interval.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x1a
 	}
-	if m.Tls != nil {
-		l = m.Tls.Size()
-		n += 1 + l + sovDestinationRule(uint64(l))
+	if m.Time != nil {
+		{
+			size, err := m.Time.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x12
 	}
-	if m.XXX_unrecognized != nil {
-		n += len(m.XXX_unrecognized)
+	if m.Probes != 0 {
+		i = encodeVarintDestinationRule(dAtA, i, uint64(m.Probes))
+		i--
+		dAtA[i] = 0x8
 	}
-	return n
+	return len(dAtA) - i, nil
 }
 
-func (m *Subset) Size() (n int) {
-	if m == nil {
-		return 0
+func (m *ConnectionPoolSettings_HTTPSettings) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
 	}
+	return dAtA[:n], nil
+}
+
+func (m *ConnectionPoolSettings_HTTPSettings) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *ConnectionPoolSettings_HTTPSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
 	var l int
 	_ = l
-	l = len(m.Name)
-	if l > 0 {
-		n += 1 + l + sovDestinationRule(uint64(l))
+	if m.XXX_unrecognized != nil {
+		i -= len(m.XXX_unrecognized)
+		copy(dAtA[i:], m.XXX_unrecognized)
 	}
-	if len(m.Labels) > 0 {
-		for k, v := range m.Labels {
-			_ = k
-			_ = v
-			mapEntrySize := 1 + len(k) + sovDestinationRule(uint64(len(k))) + 1 + len(v) + sovDestinationRule(uint64(len(v)))
-			n += mapEntrySize + 1 + sovDestinationRule(uint64(mapEntrySize))
+	if m.UseClientProtocol {
+		i--
+		if m.UseClientProtocol {
+			dAtA[i] = 1
+		} else {
+			dAtA[i] = 0
 		}
+		i--
+		dAtA[i] = 0x38
 	}
-	if m.TrafficPolicy != nil {
-		l = m.TrafficPolicy.Size()
-		n += 1 + l + sovDestinationRule(uint64(l))
+	if m.H2UpgradePolicy != 0 {
+		i = encodeVarintDestinationRule(dAtA, i, uint64(m.H2UpgradePolicy))
+		i--
+		dAtA[i] = 0x30
 	}
-	if m.XXX_unrecognized != nil {
-		n += len(m.XXX_unrecognized)
+	if m.IdleTimeout != nil {
+		{
+			size, err := m.IdleTimeout.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x2a
 	}
-	return n
-}
-
-func (m *LoadBalancerSettings) Size() (n int) {
-	if m == nil {
-		return 0
+	if m.MaxRetries != 0 {
+		i = encodeVarintDestinationRule(dAtA, i, uint64(m.MaxRetries))
+		i--
+		dAtA[i] = 0x20
 	}
-	var l int
-	_ = l
-	if m.LbPolicy != nil {
-		n += m.LbPolicy.Size()
+	if m.MaxRequestsPerConnection != 0 {
+		i = encodeVarintDestinationRule(dAtA, i, uint64(m.MaxRequestsPerConnection))
+		i--
+		dAtA[i] = 0x18
 	}
-	if m.LocalityLbSetting != nil {
-		l = m.LocalityLbSetting.Size()
-		n += 1 + l + sovDestinationRule(uint64(l))
+	if m.Http2MaxRequests != 0 {
+		i = encodeVarintDestinationRule(dAtA, i, uint64(m.Http2MaxRequests))
+		i--
+		dAtA[i] = 0x10
 	}
-	if m.XXX_unrecognized != nil {
-		n += len(m.XXX_unrecognized)
+	if m.Http1MaxPendingRequests != 0 {
+		i = encodeVarintDestinationRule(dAtA, i, uint64(m.Http1MaxPendingRequests))
+		i--
+		dAtA[i] = 0x8
 	}
-	return n
+	return len(dAtA) - i, nil
 }
 
-func (m *LoadBalancerSettings_Simple) Size() (n int) {
-	if m == nil {
-		return 0
+func (m *OutlierDetection) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
 	}
-	var l int
-	_ = l
-	n += 1 + sovDestinationRule(uint64(m.Simple))
-	return n
+	return dAtA[:n], nil
 }
-func (m *LoadBalancerSettings_ConsistentHash) Size() (n int) {
-	if m == nil {
-		return 0
-	}
-	var l int
-	_ = l
-	if m.ConsistentHash != nil {
-		l = m.ConsistentHash.Size()
-		n += 1 + l + sovDestinationRule(uint64(l))
-	}
-	return n
+
+func (m *OutlierDetection) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
 }
-func (m *LoadBalancerSettings_ConsistentHashLB) Size() (n int) {
-	if m == nil {
-		return 0
-	}
+
+func (m *OutlierDetection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
 	var l int
 	_ = l
-	if m.HashKey != nil {
-		n += m.HashKey.Size()
-	}
-	if m.MinimumRingSize != 0 {
-		n += 1 + sovDestinationRule(uint64(m.MinimumRingSize))
-	}
 	if m.XXX_unrecognized != nil {
-		n += len(m.XXX_unrecognized)
-	}
-	return n
-}
-
-func (m *LoadBalancerSettings_ConsistentHashLB_HttpHeaderName) Size() (n int) {
-	if m == nil {
-		return 0
+		i -= len(m.XXX_unrecognized)
+		copy(dAtA[i:], m.XXX_unrecognized)
 	}
-	var l int
-	_ = l
-	l = len(m.HttpHeaderName)
-	n += 1 + l + sovDestinationRule(uint64(l))
-	return n
-}
-func (m *LoadBalancerSettings_ConsistentHashLB_HttpCookie) Size() (n int) {
-	if m == nil {
-		return 0
+	if m.ConsecutiveLocalOriginFailures != nil {
+		{
+			size, err := m.ConsecutiveLocalOriginFailures.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x4a
 	}
-	var l int
-	_ = l
-	if m.HttpCookie != nil {
-		l = m.HttpCookie.Size()
-		n += 1 + l + sovDestinationRule(uint64(l))
+	if m.SplitExternalLocalOriginErrors {
+		i--
+		if m.SplitExternalLocalOriginErrors {
+			dAtA[i] = 1
+		} else {
+			dAtA[i] = 0
+		}
+		i--
+		dAtA[i] = 0x40
 	}
-	return n
-}
-func (m *LoadBalancerSettings_ConsistentHashLB_UseSourceIp) Size() (n int) {
-	if m == nil {
-		return 0
+	if m.Consecutive_5XxErrors != nil {
+		{
+			size, err := m.Consecutive_5XxErrors.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x3a
 	}
-	var l int
-	_ = l
-	n += 2
-	return n
-}
-func (m *LoadBalancerSettings_ConsistentHashLB_HttpQueryParameterName) Size() (n int) {
-	if m == nil {
-		return 0
+	if m.ConsecutiveGatewayErrors != nil {
+		{
+			size, err := m.ConsecutiveGatewayErrors.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x32
 	}
-	var l int
-	_ = l
-	l = len(m.HttpQueryParameterName)
-	n += 1 + l + sovDestinationRule(uint64(l))
-	return n
-}
-func (m *LoadBalancerSettings_ConsistentHashLB_HTTPCookie) Size() (n int) {
-	if m == nil {
-		return 0
+	if m.MinHealthPercent != 0 {
+		i = encodeVarintDestinationRule(dAtA, i, uint64(m.MinHealthPercent))
+		i--
+		dAtA[i] = 0x28
 	}
-	var l int
-	_ = l
-	l = len(m.Name)
-	if l > 0 {
-		n += 1 + l + sovDestinationRule(uint64(l))
+	if m.MaxEjectionPercent != 0 {
+		i = encodeVarintDestinationRule(dAtA, i, uint64(m.MaxEjectionPercent))
+		i--
+		dAtA[i] = 0x20
 	}
-	l = len(m.Path)
-	if l > 0 {
-		n += 1 + l + sovDestinationRule(uint64(l))
+	if m.BaseEjectionTime != nil {
+		{
+			size, err := m.BaseEjectionTime.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x1a
 	}
-	if m.Ttl != nil {
-		l = m.Ttl.Size()
-		n += 1 + l + sovDestinationRule(uint64(l))
+	if m.Interval != nil {
+		{
+			size, err := m.Interval.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x12
 	}
-	if m.XXX_unrecognized != nil {
-		n += len(m.XXX_unrecognized)
+	if m.ConsecutiveErrors != 0 {
+		i = encodeVarintDestinationRule(dAtA, i, uint64(m.ConsecutiveErrors))
+		i--
+		dAtA[i] = 0x8
 	}
-	return n
+	return len(dAtA) - i, nil
 }
 
-func (m *ConnectionPoolSettings) Size() (n int) {
-	if m == nil {
-		return 0
-	}
-	var l int
-	_ = l
-	if m.Tcp != nil {
-		l = m.Tcp.Size()
-		n += 1 + l + sovDestinationRule(uint64(l))
-	}
-	if m.Http != nil {
-		l = m.Http.Size()
-		n += 1 + l + sovDestinationRule(uint64(l))
-	}
-	if m.XXX_unrecognized != nil {
-		n += len(m.XXX_unrecognized)
+func (m *ClientTLSSettings) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
 	}
-	return n
+	return dAtA[:n], nil
 }
 
-func (m *ConnectionPoolSettings_TCPSettings) Size() (n int) {
-	if m == nil {
-		return 0
-	}
-	var l int
-	_ = l
-	if m.MaxConnections != 0 {
-		n += 1 + sovDestinationRule(uint64(m.MaxConnections))
-	}
-	if m.ConnectTimeout != nil {
-		l = m.ConnectTimeout.Size()
-		n += 1 + l + sovDestinationRule(uint64(l))
-	}
-	if m.TcpKeepalive != nil {
-		l = m.TcpKeepalive.Size()
-		n += 1 + l + sovDestinationRule(uint64(l))
-	}
-	if m.XXX_unrecognized != nil {
-		n += len(m.XXX_unrecognized)
-	}
-	return n
+func (m *ClientTLSSettings) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
 }
 
-func (m *ConnectionPoolSettings_TCPSettings_TcpKeepalive) Size() (n int) {
-	if m == nil {
-		return 0
-	}
+func (m *ClientTLSSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
 	var l int
 	_ = l
-	if m.Probes != 0 {
-		n += 1 + sovDestinationRule(uint64(m.Probes))
-	}
-	if m.Time != nil {
-		l = m.Time.Size()
-		n += 1 + l + sovDestinationRule(uint64(l))
-	}
-	if m.Interval != nil {
-		l = m.Interval.Size()
-		n += 1 + l + sovDestinationRule(uint64(l))
-	}
 	if m.XXX_unrecognized != nil {
-		n += len(m.XXX_unrecognized)
+		i -= len(m.XXX_unrecognized)
+		copy(dAtA[i:], m.XXX_unrecognized)
 	}
-	return n
-}
-
-func (m *ConnectionPoolSettings_HTTPSettings) Size() (n int) {
-	if m == nil {
-		return 0
+	if m.InsecureSkipVerify != nil {
+		{
+			size, err := m.InsecureSkipVerify.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x42
 	}
-	var l int
-	_ = l
-	if m.Http1MaxPendingRequests != 0 {
-		n += 1 + sovDestinationRule(uint64(m.Http1MaxPendingRequests))
-	}
-	if m.Http2MaxRequests != 0 {
-		n += 1 + sovDestinationRule(uint64(m.Http2MaxRequests))
+	if len(m.CredentialName) > 0 {
+		i -= len(m.CredentialName)
+		copy(dAtA[i:], m.CredentialName)
+		i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.CredentialName)))
+		i--
+		dAtA[i] = 0x3a
 	}
-	if m.MaxRequestsPerConnection != 0 {
-		n += 1 + sovDestinationRule(uint64(m.MaxRequestsPerConnection))
+	if len(m.Sni) > 0 {
+		i -= len(m.Sni)
+		copy(dAtA[i:], m.Sni)
+		i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.Sni)))
+		i--
+		dAtA[i] = 0x32
 	}
-	if m.MaxRetries != 0 {
-		n += 1 + sovDestinationRule(uint64(m.MaxRetries))
+	if len(m.SubjectAltNames) > 0 {
+		for iNdEx := len(m.SubjectAltNames) - 1; iNdEx >= 0; iNdEx-- {
+			i -= len(m.SubjectAltNames[iNdEx])
+			copy(dAtA[i:], m.SubjectAltNames[iNdEx])
+			i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.SubjectAltNames[iNdEx])))
+			i--
+			dAtA[i] = 0x2a
+		}
 	}
-	if m.IdleTimeout != nil {
-		l = m.IdleTimeout.Size()
-		n += 1 + l + sovDestinationRule(uint64(l))
+	if len(m.CaCertificates) > 0 {
+		i -= len(m.CaCertificates)
+		copy(dAtA[i:], m.CaCertificates)
+		i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.CaCertificates)))
+		i--
+		dAtA[i] = 0x22
 	}
-	if m.H2UpgradePolicy != 0 {
-		n += 1 + sovDestinationRule(uint64(m.H2UpgradePolicy))
+	if len(m.PrivateKey) > 0 {
+		i -= len(m.PrivateKey)
+		copy(dAtA[i:], m.PrivateKey)
+		i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.PrivateKey)))
+		i--
+		dAtA[i] = 0x1a
 	}
-	if m.UseClientProtocol {
-		n += 2
+	if len(m.ClientCertificate) > 0 {
+		i -= len(m.ClientCertificate)
+		copy(dAtA[i:], m.ClientCertificate)
+		i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.ClientCertificate)))
+		i--
+		dAtA[i] = 0x12
 	}
-	if m.XXX_unrecognized != nil {
-		n += len(m.XXX_unrecognized)
+	if m.Mode != 0 {
+		i = encodeVarintDestinationRule(dAtA, i, uint64(m.Mode))
+		i--
+		dAtA[i] = 0x8
 	}
-	return n
+	return len(dAtA) - i, nil
 }
 
-func (m *OutlierDetection) Size() (n int) {
-	if m == nil {
-		return 0
-	}
-	var l int
-	_ = l
-	if m.ConsecutiveErrors != 0 {
-		n += 1 + sovDestinationRule(uint64(m.ConsecutiveErrors))
-	}
-	if m.Interval != nil {
-		l = m.Interval.Size()
-		n += 1 + l + sovDestinationRule(uint64(l))
-	}
-	if m.BaseEjectionTime != nil {
-		l = m.BaseEjectionTime.Size()
-		n += 1 + l + sovDestinationRule(uint64(l))
-	}
-	if m.MaxEjectionPercent != 0 {
-		n += 1 + sovDestinationRule(uint64(m.MaxEjectionPercent))
-	}
-	if m.MinHealthPercent != 0 {
-		n += 1 + sovDestinationRule(uint64(m.MinHealthPercent))
-	}
-	if m.ConsecutiveGatewayErrors != nil {
-		l = m.ConsecutiveGatewayErrors.Size()
-		n += 1 + l + sovDestinationRule(uint64(l))
-	}
-	if m.Consecutive_5XxErrors != nil {
-		l = m.Consecutive_5XxErrors.Size()
-		n += 1 + l + sovDestinationRule(uint64(l))
-	}
-	if m.SplitExternalLocalOriginErrors {
-		n += 2
-	}
-	if m.ConsecutiveLocalOriginFailures != nil {
-		l = m.ConsecutiveLocalOriginFailures.Size()
-		n += 1 + l + sovDestinationRule(uint64(l))
-	}
-	if m.XXX_unrecognized != nil {
-		n += len(m.XXX_unrecognized)
+func (m *LocalityLoadBalancerSetting) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
 	}
-	return n
+	return dAtA[:n], nil
 }
 
-func (m *ClientTLSSettings) Size() (n int) {
-	if m == nil {
-		return 0
-	}
+func (m *LocalityLoadBalancerSetting) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *LocalityLoadBalancerSetting) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
 	var l int
 	_ = l
-	if m.Mode != 0 {
-		n += 1 + sovDestinationRule(uint64(m.Mode))
-	}
-	l = len(m.ClientCertificate)
-	if l > 0 {
-		n += 1 + l + sovDestinationRule(uint64(l))
-	}
-	l = len(m.PrivateKey)
-	if l > 0 {
-		n += 1 + l + sovDestinationRule(uint64(l))
-	}
-	l = len(m.CaCertificates)
-	if l > 0 {
-		n += 1 + l + sovDestinationRule(uint64(l))
+	if m.XXX_unrecognized != nil {
+		i -= len(m.XXX_unrecognized)
+		copy(dAtA[i:], m.XXX_unrecognized)
 	}
-	if len(m.SubjectAltNames) > 0 {
-		for _, s := range m.SubjectAltNames {
-			l = len(s)
-			n += 1 + l + sovDestinationRule(uint64(l))
+	if len(m.FailoverPriority) > 0 {
+		for iNdEx := len(m.FailoverPriority) - 1; iNdEx >= 0; iNdEx-- {
+			i -= len(m.FailoverPriority[iNdEx])
+			copy(dAtA[i:], m.FailoverPriority[iNdEx])
+			i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.FailoverPriority[iNdEx])))
+			i--
+			dAtA[i] = 0x22
 		}
 	}
-	l = len(m.Sni)
-	if l > 0 {
-		n += 1 + l + sovDestinationRule(uint64(l))
-	}
-	l = len(m.CredentialName)
-	if l > 0 {
-		n += 1 + l + sovDestinationRule(uint64(l))
+	if m.Enabled != nil {
+		{
+			size, err := m.Enabled.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x1a
 	}
-	if m.InsecureSkipVerify != nil {
-		l = m.InsecureSkipVerify.Size()
-		n += 1 + l + sovDestinationRule(uint64(l))
+	if len(m.Failover) > 0 {
+		for iNdEx := len(m.Failover) - 1; iNdEx >= 0; iNdEx-- {
+			{
+				size, err := m.Failover[iNdEx].MarshalToSizedBuffer(dAtA[:i])
+				if err != nil {
+					return 0, err
+				}
+				i -= size
+				i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+			}
+			i--
+			dAtA[i] = 0x12
+		}
 	}
-	if m.XXX_unrecognized != nil {
-		n += len(m.XXX_unrecognized)
+	if len(m.Distribute) > 0 {
+		for iNdEx := len(m.Distribute) - 1; iNdEx >= 0; iNdEx-- {
+			{
+				size, err := m.Distribute[iNdEx].MarshalToSizedBuffer(dAtA[:i])
+				if err != nil {
+					return 0, err
+				}
+				i -= size
+				i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+			}
+			i--
+			dAtA[i] = 0xa
+		}
 	}
-	return n
+	return len(dAtA) - i, nil
 }
 
-func (m *LocalityLoadBalancerSetting) Size() (n int) {
-	if m == nil {
-		return 0
+func (m *LocalityLoadBalancerSetting_Distribute) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
 	}
+	return dAtA[:n], nil
+}
+
+func (m *LocalityLoadBalancerSetting_Distribute) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *LocalityLoadBalancerSetting_Distribute) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
 	var l int
 	_ = l
-	if len(m.Distribute) > 0 {
-		for _, e := range m.Distribute {
-			l = e.Size()
-			n += 1 + l + sovDestinationRule(uint64(l))
-		}
+	if m.XXX_unrecognized != nil {
+		i -= len(m.XXX_unrecognized)
+		copy(dAtA[i:], m.XXX_unrecognized)
 	}
-	if len(m.Failover) > 0 {
-		for _, e := range m.Failover {
-			l = e.Size()
-			n += 1 + l + sovDestinationRule(uint64(l))
+	if len(m.To) > 0 {
+		for k := range m.To {
+			v := m.To[k]
+			baseI := i
+			i = encodeVarintDestinationRule(dAtA, i, uint64(v))
+			i--
+			dAtA[i] = 0x10
+			i -= len(k)
+			copy(dAtA[i:], k)
+			i = encodeVarintDestinationRule(dAtA, i, uint64(len(k)))
+			i--
+			dAtA[i] = 0xa
+			i = encodeVarintDestinationRule(dAtA, i, uint64(baseI-i))
+			i--
+			dAtA[i] = 0x12
 		}
 	}
-	if m.Enabled != nil {
-		l = m.Enabled.Size()
-		n += 1 + l + sovDestinationRule(uint64(l))
+	if len(m.From) > 0 {
+		i -= len(m.From)
+		copy(dAtA[i:], m.From)
+		i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.From)))
+		i--
+		dAtA[i] = 0xa
+	}
+	return len(dAtA) - i, nil
+}
+
+func (m *LocalityLoadBalancerSetting_Failover) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *LocalityLoadBalancerSetting_Failover) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *LocalityLoadBalancerSetting_Failover) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
+	var l int
+	_ = l
+	if m.XXX_unrecognized != nil {
+		i -= len(m.XXX_unrecognized)
+		copy(dAtA[i:], m.XXX_unrecognized)
+	}
+	if len(m.To) > 0 {
+		i -= len(m.To)
+		copy(dAtA[i:], m.To)
+		i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.To)))
+		i--
+		dAtA[i] = 0x12
+	}
+	if len(m.From) > 0 {
+		i -= len(m.From)
+		copy(dAtA[i:], m.From)
+		i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.From)))
+		i--
+		dAtA[i] = 0xa
+	}
+	return len(dAtA) - i, nil
+}
+
+func (m *Int64Range) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *Int64Range) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *Int64Range) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
+	var l int
+	_ = l
+	if m.XXX_unrecognized != nil {
+		i -= len(m.XXX_unrecognized)
+		copy(dAtA[i:], m.XXX_unrecognized)
+	}
+	if m.End != 0 {
+		i = encodeVarintDestinationRule(dAtA, i, uint64(m.End))
+		i--
+		dAtA[i] = 0x10
+	}
+	if m.Start != 0 {
+		i = encodeVarintDestinationRule(dAtA, i, uint64(m.Start))
+		i--
+		dAtA[i] = 0x8
+	}
+	return len(dAtA) - i, nil
+}
+
+func (m *HealthStatusSet) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *HealthStatusSet) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *HealthStatusSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
+	var l int
+	_ = l
+	if m.XXX_unrecognized != nil {
+		i -= len(m.XXX_unrecognized)
+		copy(dAtA[i:], m.XXX_unrecognized)
+	}
+	if len(m.Statuses) > 0 {
+		dAtA32 := make([]byte, len(m.Statuses)*10)
+		var j31 int
+		for _, num := range m.Statuses {
+			for num >= 1<<7 {
+				dAtA32[j31] = uint8(uint64(num)&0x7f | 0x80)
+				num >>= 7
+				j31++
+			}
+			dAtA32[j31] = uint8(num)
+			j31++
+		}
+		i -= j31
+		copy(dAtA[i:], dAtA32[:j31])
+		i = encodeVarintDestinationRule(dAtA, i, uint64(j31))
+		i--
+		dAtA[i] = 0xa
+	}
+	return len(dAtA) - i, nil
+}
+
+func (m *Payload) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *Payload) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *Payload) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
+	var l int
+	_ = l
+	if m.XXX_unrecognized != nil {
+		i -= len(m.XXX_unrecognized)
+		copy(dAtA[i:], m.XXX_unrecognized)
+	}
+	if m.Payload != nil {
+		{
+			size := m.Payload.Size()
+			i -= size
+			if _, err := m.Payload.MarshalTo(dAtA[i:]); err != nil {
+				return 0, err
+			}
+		}
+	}
+	return len(dAtA) - i, nil
+}
+
+func (m *Payload_Text) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *Payload_Text) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	i -= len(m.Text)
+	copy(dAtA[i:], m.Text)
+	i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.Text)))
+	i--
+	dAtA[i] = 0xa
+	return len(dAtA) - i, nil
+}
+func (m *Payload_Binary) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *Payload_Binary) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	if m.Binary != nil {
+		i -= len(m.Binary)
+		copy(dAtA[i:], m.Binary)
+		i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.Binary)))
+		i--
+		dAtA[i] = 0x12
+	}
+	return len(dAtA) - i, nil
+}
+func (m *HealthCheck) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *HealthCheck) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *HealthCheck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
+	var l int
+	_ = l
+	if m.XXX_unrecognized != nil {
+		i -= len(m.XXX_unrecognized)
+		copy(dAtA[i:], m.XXX_unrecognized)
+	}
+	if m.NoTrafficHealthyInterval != nil {
+		{
+			size, err := m.NoTrafficHealthyInterval.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x1
+		i--
+		dAtA[i] = 0xc2
+	}
+	if m.TlsOptions != nil {
+		{
+			size, err := m.TlsOptions.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x1
+		i--
+		dAtA[i] = 0xaa
+	}
+	if m.InitialJitter != nil {
+		{
+			size, err := m.InitialJitter.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x1
+		i--
+		dAtA[i] = 0xa2
+	}
+	if m.AlwaysLogHealthCheckFailures {
+		i--
+		if m.AlwaysLogHealthCheckFailures {
+			dAtA[i] = 1
+		} else {
+			dAtA[i] = 0
+		}
+		i--
+		dAtA[i] = 0x1
+		i--
+		dAtA[i] = 0x98
+	}
+	if m.IntervalJitterPercent != 0 {
+		i = encodeVarintDestinationRule(dAtA, i, uint64(m.IntervalJitterPercent))
+		i--
+		dAtA[i] = 0x1
+		i--
+		dAtA[i] = 0x90
+	}
+	if len(m.EventLogPath) > 0 {
+		i -= len(m.EventLogPath)
+		copy(dAtA[i:], m.EventLogPath)
+		i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.EventLogPath)))
+		i--
+		dAtA[i] = 0x1
+		i--
+		dAtA[i] = 0x8a
+	}
+	if m.HealthyEdgeInterval != nil {
+		{
+			size, err := m.HealthyEdgeInterval.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x1
+		i--
+		dAtA[i] = 0x82
+	}
+	if m.UnhealthyEdgeInterval != nil {
+		{
+			size, err := m.UnhealthyEdgeInterval.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x7a
+	}
+	if m.UnhealthyInterval != nil {
+		{
+			size, err := m.UnhealthyInterval.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x72
+	}
+	if m.HealthChecker != nil {
+		{
+			size := m.HealthChecker.Size()
+			i -= size
+			if _, err := m.HealthChecker.MarshalTo(dAtA[i:]); err != nil {
+				return 0, err
+			}
+		}
+	}
+	if m.NoTrafficInterval != nil {
+		{
+			size, err := m.NoTrafficInterval.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x62
+	}
+	if m.ReuseConnection != nil {
+		{
+			size, err := m.ReuseConnection.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x3a
+	}
+	if m.AltPort != nil {
+		{
+			size, err := m.AltPort.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x32
+	}
+	if m.HealthyThreshold != nil {
+		{
+			size, err := m.HealthyThreshold.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x2a
+	}
+	if m.UnhealthyThreshold != nil {
+		{
+			size, err := m.UnhealthyThreshold.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x22
+	}
+	if m.IntervalJitter != nil {
+		{
+			size, err := m.IntervalJitter.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x1a
+	}
+	if m.Interval != nil {
+		{
+			size, err := m.Interval.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x12
+	}
+	if m.Timeout != nil {
+		{
+			size, err := m.Timeout.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0xa
+	}
+	return len(dAtA) - i, nil
+}
+
+func (m *HealthCheck_HttpHealthCheck_) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *HealthCheck_HttpHealthCheck_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	if m.HttpHealthCheck != nil {
+		{
+			size, err := m.HttpHealthCheck.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x42
+	}
+	return len(dAtA) - i, nil
+}
+func (m *HealthCheck_TcpHealthCheck_) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *HealthCheck_TcpHealthCheck_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	if m.TcpHealthCheck != nil {
+		{
+			size, err := m.TcpHealthCheck.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x4a
+	}
+	return len(dAtA) - i, nil
+}
+func (m *HealthCheck_GrpcHealthCheck_) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *HealthCheck_GrpcHealthCheck_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	if m.GrpcHealthCheck != nil {
+		{
+			size, err := m.GrpcHealthCheck.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x5a
+	}
+	return len(dAtA) - i, nil
+}
+func (m *HealthCheck_CustomHealthCheck_) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *HealthCheck_CustomHealthCheck_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	if m.CustomHealthCheck != nil {
+		{
+			size, err := m.CustomHealthCheck.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x6a
+	}
+	return len(dAtA) - i, nil
+}
+func (m *HealthCheck_HttpHealthCheck) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *HealthCheck_HttpHealthCheck) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *HealthCheck_HttpHealthCheck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
+	var l int
+	_ = l
+	if m.XXX_unrecognized != nil {
+		i -= len(m.XXX_unrecognized)
+		copy(dAtA[i:], m.XXX_unrecognized)
+	}
+	if len(m.RetriableStatuses) > 0 {
+		for iNdEx := len(m.RetriableStatuses) - 1; iNdEx >= 0; iNdEx-- {
+			{
+				size, err := m.RetriableStatuses[iNdEx].MarshalToSizedBuffer(dAtA[:i])
+				if err != nil {
+					return 0, err
+				}
+				i -= size
+				i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+			}
+			i--
+			dAtA[i] = 0x62
+		}
+	}
+	if len(m.ExpectedStatuses) > 0 {
+		for iNdEx := len(m.ExpectedStatuses) - 1; iNdEx >= 0; iNdEx-- {
+			{
+				size, err := m.ExpectedStatuses[iNdEx].MarshalToSizedBuffer(dAtA[:i])
+				if err != nil {
+					return 0, err
+				}
+				i -= size
+				i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+			}
+			i--
+			dAtA[i] = 0x4a
+		}
+	}
+	if m.Receive != nil {
+		{
+			size, err := m.Receive.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x22
+	}
+	if m.Send != nil {
+		{
+			size, err := m.Send.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x1a
+	}
+	if len(m.Path) > 0 {
+		i -= len(m.Path)
+		copy(dAtA[i:], m.Path)
+		i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.Path)))
+		i--
+		dAtA[i] = 0x12
+	}
+	if len(m.Host) > 0 {
+		i -= len(m.Host)
+		copy(dAtA[i:], m.Host)
+		i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.Host)))
+		i--
+		dAtA[i] = 0xa
+	}
+	return len(dAtA) - i, nil
+}
+
+func (m *HealthCheck_TcpHealthCheck) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *HealthCheck_TcpHealthCheck) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *HealthCheck_TcpHealthCheck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
+	var l int
+	_ = l
+	if m.XXX_unrecognized != nil {
+		i -= len(m.XXX_unrecognized)
+		copy(dAtA[i:], m.XXX_unrecognized)
+	}
+	if len(m.Receive) > 0 {
+		for iNdEx := len(m.Receive) - 1; iNdEx >= 0; iNdEx-- {
+			{
+				size, err := m.Receive[iNdEx].MarshalToSizedBuffer(dAtA[:i])
+				if err != nil {
+					return 0, err
+				}
+				i -= size
+				i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+			}
+			i--
+			dAtA[i] = 0x12
+		}
+	}
+	if m.Send != nil {
+		{
+			size, err := m.Send.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0xa
+	}
+	return len(dAtA) - i, nil
+}
+
+func (m *HealthCheck_RedisHealthCheck) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *HealthCheck_RedisHealthCheck) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *HealthCheck_RedisHealthCheck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
+	var l int
+	_ = l
+	if m.XXX_unrecognized != nil {
+		i -= len(m.XXX_unrecognized)
+		copy(dAtA[i:], m.XXX_unrecognized)
+	}
+	if len(m.Key) > 0 {
+		i -= len(m.Key)
+		copy(dAtA[i:], m.Key)
+		i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.Key)))
+		i--
+		dAtA[i] = 0xa
+	}
+	return len(dAtA) - i, nil
+}
+
+func (m *HealthCheck_GrpcHealthCheck) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *HealthCheck_GrpcHealthCheck) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *HealthCheck_GrpcHealthCheck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
+	var l int
+	_ = l
+	if m.XXX_unrecognized != nil {
+		i -= len(m.XXX_unrecognized)
+		copy(dAtA[i:], m.XXX_unrecognized)
+	}
+	if len(m.Authority) > 0 {
+		i -= len(m.Authority)
+		copy(dAtA[i:], m.Authority)
+		i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.Authority)))
+		i--
+		dAtA[i] = 0x12
+	}
+	if len(m.ServiceName) > 0 {
+		i -= len(m.ServiceName)
+		copy(dAtA[i:], m.ServiceName)
+		i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.ServiceName)))
+		i--
+		dAtA[i] = 0xa
+	}
+	return len(dAtA) - i, nil
+}
+
+func (m *HealthCheck_CustomHealthCheck) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *HealthCheck_CustomHealthCheck) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *HealthCheck_CustomHealthCheck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
+	var l int
+	_ = l
+	if m.XXX_unrecognized != nil {
+		i -= len(m.XXX_unrecognized)
+		copy(dAtA[i:], m.XXX_unrecognized)
+	}
+	if len(m.Name) > 0 {
+		i -= len(m.Name)
+		copy(dAtA[i:], m.Name)
+		i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.Name)))
+		i--
+		dAtA[i] = 0xa
+	}
+	return len(dAtA) - i, nil
+}
+
+func (m *HealthCheck_TlsOptions) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *HealthCheck_TlsOptions) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *HealthCheck_TlsOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
+	var l int
+	_ = l
+	if m.XXX_unrecognized != nil {
+		i -= len(m.XXX_unrecognized)
+		copy(dAtA[i:], m.XXX_unrecognized)
+	}
+	if len(m.AlpnProtocols) > 0 {
+		for iNdEx := len(m.AlpnProtocols) - 1; iNdEx >= 0; iNdEx-- {
+			i -= len(m.AlpnProtocols[iNdEx])
+			copy(dAtA[i:], m.AlpnProtocols[iNdEx])
+			i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.AlpnProtocols[iNdEx])))
+			i--
+			dAtA[i] = 0xa
+		}
+	}
+	return len(dAtA) - i, nil
+}
+
+func encodeVarintDestinationRule(dAtA []byte, offset int, v uint64) int {
+	offset -= sovDestinationRule(v)
+	base := offset
+	for v >= 1<<7 {
+		dAtA[offset] = uint8(v&0x7f | 0x80)
+		v >>= 7
+		offset++
+	}
+	dAtA[offset] = uint8(v)
+	return base
+}
+func (m *DestinationRule) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	l = len(m.Host)
+	if l > 0 {
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.TrafficPolicy != nil {
+		l = m.TrafficPolicy.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if len(m.Subsets) > 0 {
+		for _, e := range m.Subsets {
+			l = e.Size()
+			n += 1 + l + sovDestinationRule(uint64(l))
+		}
+	}
+	if len(m.ExportTo) > 0 {
+		for _, s := range m.ExportTo {
+			l = len(s)
+			n += 1 + l + sovDestinationRule(uint64(l))
+		}
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *TrafficPolicy) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if m.LoadBalancer != nil {
+		l = m.LoadBalancer.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.ConnectionPool != nil {
+		l = m.ConnectionPool.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.OutlierDetection != nil {
+		l = m.OutlierDetection.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.Tls != nil {
+		l = m.Tls.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if len(m.PortLevelSettings) > 0 {
+		for _, e := range m.PortLevelSettings {
+			l = e.Size()
+			n += 1 + l + sovDestinationRule(uint64(l))
+		}
+	}
+	if len(m.HealthChecks) > 0 {
+		for _, e := range m.HealthChecks {
+			l = e.Size()
+			n += 2 + l + sovDestinationRule(uint64(l))
+		}
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *TrafficPolicy_PortTrafficPolicy) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if m.Port != nil {
+		l = m.Port.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.LoadBalancer != nil {
+		l = m.LoadBalancer.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.ConnectionPool != nil {
+		l = m.ConnectionPool.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.OutlierDetection != nil {
+		l = m.OutlierDetection.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.Tls != nil {
+		l = m.Tls.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if len(m.HealthChecks) > 0 {
+		for _, e := range m.HealthChecks {
+			l = e.Size()
+			n += 2 + l + sovDestinationRule(uint64(l))
+		}
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *Subset) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	l = len(m.Name)
+	if l > 0 {
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if len(m.Labels) > 0 {
+		for k, v := range m.Labels {
+			_ = k
+			_ = v
+			mapEntrySize := 1 + len(k) + sovDestinationRule(uint64(len(k))) + 1 + len(v) + sovDestinationRule(uint64(len(v)))
+			n += mapEntrySize + 1 + sovDestinationRule(uint64(mapEntrySize))
+		}
+	}
+	if m.TrafficPolicy != nil {
+		l = m.TrafficPolicy.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *LoadBalancerSettings) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if m.LbPolicy != nil {
+		n += m.LbPolicy.Size()
+	}
+	if m.LocalityLbSetting != nil {
+		l = m.LocalityLbSetting.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.WarmupDurationSecs != nil {
+		l = m.WarmupDurationSecs.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *LoadBalancerSettings_Simple) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	n += 1 + sovDestinationRule(uint64(m.Simple))
+	return n
+}
+func (m *LoadBalancerSettings_ConsistentHash) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if m.ConsistentHash != nil {
+		l = m.ConsistentHash.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	return n
+}
+func (m *LoadBalancerSettings_ConsistentHashLB) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if m.HashKey != nil {
+		n += m.HashKey.Size()
+	}
+	if m.MinimumRingSize != 0 {
+		n += 1 + sovDestinationRule(uint64(m.MinimumRingSize))
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *LoadBalancerSettings_ConsistentHashLB_HttpHeaderName) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	l = len(m.HttpHeaderName)
+	n += 1 + l + sovDestinationRule(uint64(l))
+	return n
+}
+func (m *LoadBalancerSettings_ConsistentHashLB_HttpCookie) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if m.HttpCookie != nil {
+		l = m.HttpCookie.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	return n
+}
+func (m *LoadBalancerSettings_ConsistentHashLB_UseSourceIp) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	n += 2
+	return n
+}
+func (m *LoadBalancerSettings_ConsistentHashLB_HttpQueryParameterName) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	l = len(m.HttpQueryParameterName)
+	n += 1 + l + sovDestinationRule(uint64(l))
+	return n
+}
+func (m *LoadBalancerSettings_ConsistentHashLB_HTTPCookie) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	l = len(m.Name)
+	if l > 0 {
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	l = len(m.Path)
+	if l > 0 {
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.Ttl != nil {
+		l = m.Ttl.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *ConnectionPoolSettings) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if m.Tcp != nil {
+		l = m.Tcp.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.Http != nil {
+		l = m.Http.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *ConnectionPoolSettings_TCPSettings) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if m.MaxConnections != 0 {
+		n += 1 + sovDestinationRule(uint64(m.MaxConnections))
+	}
+	if m.ConnectTimeout != nil {
+		l = m.ConnectTimeout.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.TcpKeepalive != nil {
+		l = m.TcpKeepalive.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *ConnectionPoolSettings_TCPSettings_TcpKeepalive) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if m.Probes != 0 {
+		n += 1 + sovDestinationRule(uint64(m.Probes))
+	}
+	if m.Time != nil {
+		l = m.Time.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.Interval != nil {
+		l = m.Interval.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *ConnectionPoolSettings_HTTPSettings) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if m.Http1MaxPendingRequests != 0 {
+		n += 1 + sovDestinationRule(uint64(m.Http1MaxPendingRequests))
+	}
+	if m.Http2MaxRequests != 0 {
+		n += 1 + sovDestinationRule(uint64(m.Http2MaxRequests))
+	}
+	if m.MaxRequestsPerConnection != 0 {
+		n += 1 + sovDestinationRule(uint64(m.MaxRequestsPerConnection))
+	}
+	if m.MaxRetries != 0 {
+		n += 1 + sovDestinationRule(uint64(m.MaxRetries))
+	}
+	if m.IdleTimeout != nil {
+		l = m.IdleTimeout.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.H2UpgradePolicy != 0 {
+		n += 1 + sovDestinationRule(uint64(m.H2UpgradePolicy))
+	}
+	if m.UseClientProtocol {
+		n += 2
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *OutlierDetection) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if m.ConsecutiveErrors != 0 {
+		n += 1 + sovDestinationRule(uint64(m.ConsecutiveErrors))
+	}
+	if m.Interval != nil {
+		l = m.Interval.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.BaseEjectionTime != nil {
+		l = m.BaseEjectionTime.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.MaxEjectionPercent != 0 {
+		n += 1 + sovDestinationRule(uint64(m.MaxEjectionPercent))
+	}
+	if m.MinHealthPercent != 0 {
+		n += 1 + sovDestinationRule(uint64(m.MinHealthPercent))
+	}
+	if m.ConsecutiveGatewayErrors != nil {
+		l = m.ConsecutiveGatewayErrors.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.Consecutive_5XxErrors != nil {
+		l = m.Consecutive_5XxErrors.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.SplitExternalLocalOriginErrors {
+		n += 2
+	}
+	if m.ConsecutiveLocalOriginFailures != nil {
+		l = m.ConsecutiveLocalOriginFailures.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *ClientTLSSettings) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if m.Mode != 0 {
+		n += 1 + sovDestinationRule(uint64(m.Mode))
+	}
+	l = len(m.ClientCertificate)
+	if l > 0 {
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	l = len(m.PrivateKey)
+	if l > 0 {
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	l = len(m.CaCertificates)
+	if l > 0 {
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if len(m.SubjectAltNames) > 0 {
+		for _, s := range m.SubjectAltNames {
+			l = len(s)
+			n += 1 + l + sovDestinationRule(uint64(l))
+		}
+	}
+	l = len(m.Sni)
+	if l > 0 {
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	l = len(m.CredentialName)
+	if l > 0 {
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.InsecureSkipVerify != nil {
+		l = m.InsecureSkipVerify.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *LocalityLoadBalancerSetting) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if len(m.Distribute) > 0 {
+		for _, e := range m.Distribute {
+			l = e.Size()
+			n += 1 + l + sovDestinationRule(uint64(l))
+		}
+	}
+	if len(m.Failover) > 0 {
+		for _, e := range m.Failover {
+			l = e.Size()
+			n += 1 + l + sovDestinationRule(uint64(l))
+		}
+	}
+	if m.Enabled != nil {
+		l = m.Enabled.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
 	}
 	if len(m.FailoverPriority) > 0 {
 		for _, s := range m.FailoverPriority {
@@ -4058,63 +5841,2283 @@ func (m *LocalityLoadBalancerSetting) Size() (n int) {
 			n += 1 + l + sovDestinationRule(uint64(l))
 		}
 	}
-	if m.XXX_unrecognized != nil {
-		n += len(m.XXX_unrecognized)
-	}
-	return n
-}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *LocalityLoadBalancerSetting_Distribute) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	l = len(m.From)
+	if l > 0 {
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if len(m.To) > 0 {
+		for k, v := range m.To {
+			_ = k
+			_ = v
+			mapEntrySize := 1 + len(k) + sovDestinationRule(uint64(len(k))) + 1 + sovDestinationRule(uint64(v))
+			n += mapEntrySize + 1 + sovDestinationRule(uint64(mapEntrySize))
+		}
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *LocalityLoadBalancerSetting_Failover) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	l = len(m.From)
+	if l > 0 {
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	l = len(m.To)
+	if l > 0 {
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *Int64Range) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if m.Start != 0 {
+		n += 1 + sovDestinationRule(uint64(m.Start))
+	}
+	if m.End != 0 {
+		n += 1 + sovDestinationRule(uint64(m.End))
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *HealthStatusSet) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if len(m.Statuses) > 0 {
+		l = 0
+		for _, e := range m.Statuses {
+			l += sovDestinationRule(uint64(e))
+		}
+		n += 1 + sovDestinationRule(uint64(l)) + l
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *Payload) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if m.Payload != nil {
+		n += m.Payload.Size()
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *Payload_Text) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	l = len(m.Text)
+	n += 1 + l + sovDestinationRule(uint64(l))
+	return n
+}
+func (m *Payload_Binary) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if m.Binary != nil {
+		l = len(m.Binary)
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	return n
+}
+func (m *HealthCheck) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if m.Timeout != nil {
+		l = m.Timeout.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.Interval != nil {
+		l = m.Interval.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.IntervalJitter != nil {
+		l = m.IntervalJitter.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.UnhealthyThreshold != nil {
+		l = m.UnhealthyThreshold.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.HealthyThreshold != nil {
+		l = m.HealthyThreshold.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.AltPort != nil {
+		l = m.AltPort.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.ReuseConnection != nil {
+		l = m.ReuseConnection.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.HealthChecker != nil {
+		n += m.HealthChecker.Size()
+	}
+	if m.NoTrafficInterval != nil {
+		l = m.NoTrafficInterval.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.UnhealthyInterval != nil {
+		l = m.UnhealthyInterval.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.UnhealthyEdgeInterval != nil {
+		l = m.UnhealthyEdgeInterval.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.HealthyEdgeInterval != nil {
+		l = m.HealthyEdgeInterval.Size()
+		n += 2 + l + sovDestinationRule(uint64(l))
+	}
+	l = len(m.EventLogPath)
+	if l > 0 {
+		n += 2 + l + sovDestinationRule(uint64(l))
+	}
+	if m.IntervalJitterPercent != 0 {
+		n += 2 + sovDestinationRule(uint64(m.IntervalJitterPercent))
+	}
+	if m.AlwaysLogHealthCheckFailures {
+		n += 3
+	}
+	if m.InitialJitter != nil {
+		l = m.InitialJitter.Size()
+		n += 2 + l + sovDestinationRule(uint64(l))
+	}
+	if m.TlsOptions != nil {
+		l = m.TlsOptions.Size()
+		n += 2 + l + sovDestinationRule(uint64(l))
+	}
+	if m.NoTrafficHealthyInterval != nil {
+		l = m.NoTrafficHealthyInterval.Size()
+		n += 2 + l + sovDestinationRule(uint64(l))
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *HealthCheck_HttpHealthCheck_) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if m.HttpHealthCheck != nil {
+		l = m.HttpHealthCheck.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	return n
+}
+func (m *HealthCheck_TcpHealthCheck_) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if m.TcpHealthCheck != nil {
+		l = m.TcpHealthCheck.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	return n
+}
+func (m *HealthCheck_GrpcHealthCheck_) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if m.GrpcHealthCheck != nil {
+		l = m.GrpcHealthCheck.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	return n
+}
+func (m *HealthCheck_CustomHealthCheck_) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if m.CustomHealthCheck != nil {
+		l = m.CustomHealthCheck.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	return n
+}
+func (m *HealthCheck_HttpHealthCheck) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	l = len(m.Host)
+	if l > 0 {
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	l = len(m.Path)
+	if l > 0 {
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.Send != nil {
+		l = m.Send.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.Receive != nil {
+		l = m.Receive.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if len(m.ExpectedStatuses) > 0 {
+		for _, e := range m.ExpectedStatuses {
+			l = e.Size()
+			n += 1 + l + sovDestinationRule(uint64(l))
+		}
+	}
+	if len(m.RetriableStatuses) > 0 {
+		for _, e := range m.RetriableStatuses {
+			l = e.Size()
+			n += 1 + l + sovDestinationRule(uint64(l))
+		}
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *HealthCheck_TcpHealthCheck) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if m.Send != nil {
+		l = m.Send.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if len(m.Receive) > 0 {
+		for _, e := range m.Receive {
+			l = e.Size()
+			n += 1 + l + sovDestinationRule(uint64(l))
+		}
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *HealthCheck_RedisHealthCheck) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	l = len(m.Key)
+	if l > 0 {
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *HealthCheck_GrpcHealthCheck) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	l = len(m.ServiceName)
+	if l > 0 {
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	l = len(m.Authority)
+	if l > 0 {
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *HealthCheck_CustomHealthCheck) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	l = len(m.Name)
+	if l > 0 {
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *HealthCheck_TlsOptions) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if len(m.AlpnProtocols) > 0 {
+		for _, s := range m.AlpnProtocols {
+			l = len(s)
+			n += 1 + l + sovDestinationRule(uint64(l))
+		}
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func sovDestinationRule(x uint64) (n int) {
+	return (math_bits.Len64(x|1) + 6) / 7
+}
+func sozDestinationRule(x uint64) (n int) {
+	return sovDestinationRule(uint64((x << 1) ^ uint64((int64(x) >> 63))))
+}
+func (m *DestinationRule) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowDestinationRule
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: DestinationRule: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: DestinationRule: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Host = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field TrafficPolicy", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.TrafficPolicy == nil {
+				m.TrafficPolicy = &TrafficPolicy{}
+			}
+			if err := m.TrafficPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 3:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Subsets", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Subsets = append(m.Subsets, &Subset{})
+			if err := m.Subsets[len(m.Subsets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 4:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field ExportTo", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.ExportTo = append(m.ExportTo, string(dAtA[iNdEx:postIndex]))
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipDestinationRule(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *TrafficPolicy) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowDestinationRule
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: TrafficPolicy: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: TrafficPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field LoadBalancer", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.LoadBalancer == nil {
+				m.LoadBalancer = &LoadBalancerSettings{}
+			}
+			if err := m.LoadBalancer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionPool", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.ConnectionPool == nil {
+				m.ConnectionPool = &ConnectionPoolSettings{}
+			}
+			if err := m.ConnectionPool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 3:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field OutlierDetection", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.OutlierDetection == nil {
+				m.OutlierDetection = &OutlierDetection{}
+			}
+			if err := m.OutlierDetection.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 4:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Tls", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.Tls == nil {
+				m.Tls = &ClientTLSSettings{}
+			}
+			if err := m.Tls.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 5:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field PortLevelSettings", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.PortLevelSettings = append(m.PortLevelSettings, &TrafficPolicy_PortTrafficPolicy{})
+			if err := m.PortLevelSettings[len(m.PortLevelSettings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 101:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field HealthChecks", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.HealthChecks = append(m.HealthChecks, &HealthCheck{})
+			if err := m.HealthChecks[len(m.HealthChecks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipDestinationRule(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *TrafficPolicy_PortTrafficPolicy) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowDestinationRule
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: PortTrafficPolicy: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: PortTrafficPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.Port == nil {
+				m.Port = &PortSelector{}
+			}
+			if err := m.Port.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field LoadBalancer", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.LoadBalancer == nil {
+				m.LoadBalancer = &LoadBalancerSettings{}
+			}
+			if err := m.LoadBalancer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 3:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionPool", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.ConnectionPool == nil {
+				m.ConnectionPool = &ConnectionPoolSettings{}
+			}
+			if err := m.ConnectionPool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 4:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field OutlierDetection", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.OutlierDetection == nil {
+				m.OutlierDetection = &OutlierDetection{}
+			}
+			if err := m.OutlierDetection.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 5:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Tls", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.Tls == nil {
+				m.Tls = &ClientTLSSettings{}
+			}
+			if err := m.Tls.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 101:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field HealthChecks", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.HealthChecks = append(m.HealthChecks, &HealthCheck{})
+			if err := m.HealthChecks[len(m.HealthChecks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipDestinationRule(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *Subset) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowDestinationRule
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: Subset: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: Subset: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Name = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.Labels == nil {
+				m.Labels = make(map[string]string)
+			}
+			var mapkey string
+			var mapvalue string
+			for iNdEx < postIndex {
+				entryPreIndex := iNdEx
+				var wire uint64
+				for shift := uint(0); ; shift += 7 {
+					if shift >= 64 {
+						return ErrIntOverflowDestinationRule
+					}
+					if iNdEx >= l {
+						return io.ErrUnexpectedEOF
+					}
+					b := dAtA[iNdEx]
+					iNdEx++
+					wire |= uint64(b&0x7F) << shift
+					if b < 0x80 {
+						break
+					}
+				}
+				fieldNum := int32(wire >> 3)
+				if fieldNum == 1 {
+					var stringLenmapkey uint64
+					for shift := uint(0); ; shift += 7 {
+						if shift >= 64 {
+							return ErrIntOverflowDestinationRule
+						}
+						if iNdEx >= l {
+							return io.ErrUnexpectedEOF
+						}
+						b := dAtA[iNdEx]
+						iNdEx++
+						stringLenmapkey |= uint64(b&0x7F) << shift
+						if b < 0x80 {
+							break
+						}
+					}
+					intStringLenmapkey := int(stringLenmapkey)
+					if intStringLenmapkey < 0 {
+						return ErrInvalidLengthDestinationRule
+					}
+					postStringIndexmapkey := iNdEx + intStringLenmapkey
+					if postStringIndexmapkey < 0 {
+						return ErrInvalidLengthDestinationRule
+					}
+					if postStringIndexmapkey > l {
+						return io.ErrUnexpectedEOF
+					}
+					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
+					iNdEx = postStringIndexmapkey
+				} else if fieldNum == 2 {
+					var stringLenmapvalue uint64
+					for shift := uint(0); ; shift += 7 {
+						if shift >= 64 {
+							return ErrIntOverflowDestinationRule
+						}
+						if iNdEx >= l {
+							return io.ErrUnexpectedEOF
+						}
+						b := dAtA[iNdEx]
+						iNdEx++
+						stringLenmapvalue |= uint64(b&0x7F) << shift
+						if b < 0x80 {
+							break
+						}
+					}
+					intStringLenmapvalue := int(stringLenmapvalue)
+					if intStringLenmapvalue < 0 {
+						return ErrInvalidLengthDestinationRule
+					}
+					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
+					if postStringIndexmapvalue < 0 {
+						return ErrInvalidLengthDestinationRule
+					}
+					if postStringIndexmapvalue > l {
+						return io.ErrUnexpectedEOF
+					}
+					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
+					iNdEx = postStringIndexmapvalue
+				} else {
+					iNdEx = entryPreIndex
+					skippy, err := skipDestinationRule(dAtA[iNdEx:])
+					if err != nil {
+						return err
+					}
+					if (skippy < 0) || (iNdEx+skippy) < 0 {
+						return ErrInvalidLengthDestinationRule
+					}
+					if (iNdEx + skippy) > postIndex {
+						return io.ErrUnexpectedEOF
+					}
+					iNdEx += skippy
+				}
+			}
+			m.Labels[mapkey] = mapvalue
+			iNdEx = postIndex
+		case 3:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field TrafficPolicy", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.TrafficPolicy == nil {
+				m.TrafficPolicy = &TrafficPolicy{}
+			}
+			if err := m.TrafficPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipDestinationRule(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *LoadBalancerSettings) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowDestinationRule
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: LoadBalancerSettings: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: LoadBalancerSettings: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Simple", wireType)
+			}
+			var v LoadBalancerSettings_SimpleLB
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				v |= LoadBalancerSettings_SimpleLB(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			m.LbPolicy = &LoadBalancerSettings_Simple{v}
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field ConsistentHash", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			v := &LoadBalancerSettings_ConsistentHashLB{}
+			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			m.LbPolicy = &LoadBalancerSettings_ConsistentHash{v}
+			iNdEx = postIndex
+		case 3:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field LocalityLbSetting", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.LocalityLbSetting == nil {
+				m.LocalityLbSetting = &LocalityLoadBalancerSetting{}
+			}
+			if err := m.LocalityLbSetting.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 4:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field WarmupDurationSecs", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.WarmupDurationSecs == nil {
+				m.WarmupDurationSecs = &types.Duration{}
+			}
+			if err := m.WarmupDurationSecs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipDestinationRule(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *LoadBalancerSettings_ConsistentHashLB) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowDestinationRule
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: ConsistentHashLB: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: ConsistentHashLB: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field HttpHeaderName", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.HashKey = &LoadBalancerSettings_ConsistentHashLB_HttpHeaderName{string(dAtA[iNdEx:postIndex])}
+			iNdEx = postIndex
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field HttpCookie", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			v := &LoadBalancerSettings_ConsistentHashLB_HTTPCookie{}
+			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			m.HashKey = &LoadBalancerSettings_ConsistentHashLB_HttpCookie{v}
+			iNdEx = postIndex
+		case 3:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field UseSourceIp", wireType)
+			}
+			var v int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				v |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			b := bool(v != 0)
+			m.HashKey = &LoadBalancerSettings_ConsistentHashLB_UseSourceIp{b}
+		case 4:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field MinimumRingSize", wireType)
+			}
+			m.MinimumRingSize = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.MinimumRingSize |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		case 5:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field HttpQueryParameterName", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.HashKey = &LoadBalancerSettings_ConsistentHashLB_HttpQueryParameterName{string(dAtA[iNdEx:postIndex])}
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipDestinationRule(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *LoadBalancerSettings_ConsistentHashLB_HTTPCookie) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowDestinationRule
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: HTTPCookie: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: HTTPCookie: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Name = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Path = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 3:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Ttl", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.Ttl == nil {
+				m.Ttl = &types.Duration{}
+			}
+			if err := m.Ttl.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipDestinationRule(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *ConnectionPoolSettings) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowDestinationRule
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: ConnectionPoolSettings: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: ConnectionPoolSettings: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Tcp", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.Tcp == nil {
+				m.Tcp = &ConnectionPoolSettings_TCPSettings{}
+			}
+			if err := m.Tcp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Http", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.Http == nil {
+				m.Http = &ConnectionPoolSettings_HTTPSettings{}
+			}
+			if err := m.Http.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipDestinationRule(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *ConnectionPoolSettings_TCPSettings) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowDestinationRule
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: TCPSettings: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: TCPSettings: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field MaxConnections", wireType)
+			}
+			m.MaxConnections = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.MaxConnections |= int32(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field ConnectTimeout", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.ConnectTimeout == nil {
+				m.ConnectTimeout = &types.Duration{}
+			}
+			if err := m.ConnectTimeout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 3:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field TcpKeepalive", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.TcpKeepalive == nil {
+				m.TcpKeepalive = &ConnectionPoolSettings_TCPSettings_TcpKeepalive{}
+			}
+			if err := m.TcpKeepalive.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipDestinationRule(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
+			iNdEx += skippy
+		}
+	}
 
-func (m *LocalityLoadBalancerSetting_Distribute) Size() (n int) {
-	if m == nil {
-		return 0
-	}
-	var l int
-	_ = l
-	l = len(m.From)
-	if l > 0 {
-		n += 1 + l + sovDestinationRule(uint64(l))
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
 	}
-	if len(m.To) > 0 {
-		for k, v := range m.To {
-			_ = k
-			_ = v
-			mapEntrySize := 1 + len(k) + sovDestinationRule(uint64(len(k))) + 1 + sovDestinationRule(uint64(v))
-			n += mapEntrySize + 1 + sovDestinationRule(uint64(mapEntrySize))
+	return nil
+}
+func (m *ConnectionPoolSettings_TCPSettings_TcpKeepalive) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowDestinationRule
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: TcpKeepalive: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: TcpKeepalive: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Probes", wireType)
+			}
+			m.Probes = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.Probes |= uint32(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.Time == nil {
+				m.Time = &types.Duration{}
+			}
+			if err := m.Time.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 3:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.Interval == nil {
+				m.Interval = &types.Duration{}
+			}
+			if err := m.Interval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipDestinationRule(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
+			iNdEx += skippy
 		}
 	}
-	if m.XXX_unrecognized != nil {
-		n += len(m.XXX_unrecognized)
-	}
-	return n
-}
 
-func (m *LocalityLoadBalancerSetting_Failover) Size() (n int) {
-	if m == nil {
-		return 0
-	}
-	var l int
-	_ = l
-	l = len(m.From)
-	if l > 0 {
-		n += 1 + l + sovDestinationRule(uint64(l))
-	}
-	l = len(m.To)
-	if l > 0 {
-		n += 1 + l + sovDestinationRule(uint64(l))
-	}
-	if m.XXX_unrecognized != nil {
-		n += len(m.XXX_unrecognized)
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
 	}
-	return n
-}
-
-func sovDestinationRule(x uint64) (n int) {
-	return (math_bits.Len64(x|1) + 6) / 7
-}
-func sozDestinationRule(x uint64) (n int) {
-	return sovDestinationRule(uint64((x << 1) ^ uint64((int64(x) >> 63))))
+	return nil
 }
-func (m *DestinationRule) Unmarshal(dAtA []byte) error {
+func (m *ConnectionPoolSettings_HTTPSettings) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
 	for iNdEx < l {
@@ -4137,17 +8140,74 @@ func (m *DestinationRule) Unmarshal(dAtA []byte) error {
 		fieldNum := int32(wire >> 3)
 		wireType := int(wire & 0x7)
 		if wireType == 4 {
-			return fmt.Errorf("proto: DestinationRule: wiretype end group for non-group")
+			return fmt.Errorf("proto: HTTPSettings: wiretype end group for non-group")
 		}
 		if fieldNum <= 0 {
-			return fmt.Errorf("proto: DestinationRule: illegal tag %d (wire type %d)", fieldNum, wire)
+			return fmt.Errorf("proto: HTTPSettings: illegal tag %d (wire type %d)", fieldNum, wire)
 		}
 		switch fieldNum {
 		case 1:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Http1MaxPendingRequests", wireType)
+			}
+			m.Http1MaxPendingRequests = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.Http1MaxPendingRequests |= int32(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		case 2:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Http2MaxRequests", wireType)
+			}
+			m.Http2MaxRequests = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.Http2MaxRequests |= int32(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		case 3:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field MaxRequestsPerConnection", wireType)
+			}
+			m.MaxRequestsPerConnection = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.MaxRequestsPerConnection |= int32(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		case 4:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field MaxRetries", wireType)
 			}
-			var stringLen uint64
+			m.MaxRetries = 0
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowDestinationRule
@@ -4157,27 +8217,14 @@ func (m *DestinationRule) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				stringLen |= uint64(b&0x7F) << shift
+				m.MaxRetries |= int32(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			intStringLen := int(stringLen)
-			if intStringLen < 0 {
-				return ErrInvalidLengthDestinationRule
-			}
-			postIndex := iNdEx + intStringLen
-			if postIndex < 0 {
-				return ErrInvalidLengthDestinationRule
-			}
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			m.Host = string(dAtA[iNdEx:postIndex])
-			iNdEx = postIndex
-		case 2:
+		case 5:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field TrafficPolicy", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field IdleTimeout", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -4204,18 +8251,18 @@ func (m *DestinationRule) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.TrafficPolicy == nil {
-				m.TrafficPolicy = &TrafficPolicy{}
+			if m.IdleTimeout == nil {
+				m.IdleTimeout = &types.Duration{}
 			}
-			if err := m.TrafficPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+			if err := m.IdleTimeout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
 			iNdEx = postIndex
-		case 3:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Subsets", wireType)
+		case 6:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field H2UpgradePolicy", wireType)
 			}
-			var msglen int
+			m.H2UpgradePolicy = 0
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowDestinationRule
@@ -4225,31 +8272,16 @@ func (m *DestinationRule) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				msglen |= int(b&0x7F) << shift
+				m.H2UpgradePolicy |= ConnectionPoolSettings_HTTPSettings_H2UpgradePolicy(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			if msglen < 0 {
-				return ErrInvalidLengthDestinationRule
-			}
-			postIndex := iNdEx + msglen
-			if postIndex < 0 {
-				return ErrInvalidLengthDestinationRule
-			}
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			m.Subsets = append(m.Subsets, &Subset{})
-			if err := m.Subsets[len(m.Subsets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
-			iNdEx = postIndex
-		case 4:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field ExportTo", wireType)
+		case 7:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field UseClientProtocol", wireType)
 			}
-			var stringLen uint64
+			var v int
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowDestinationRule
@@ -4259,24 +8291,12 @@ func (m *DestinationRule) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				stringLen |= uint64(b&0x7F) << shift
+				v |= int(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			intStringLen := int(stringLen)
-			if intStringLen < 0 {
-				return ErrInvalidLengthDestinationRule
-			}
-			postIndex := iNdEx + intStringLen
-			if postIndex < 0 {
-				return ErrInvalidLengthDestinationRule
-			}
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			m.ExportTo = append(m.ExportTo, string(dAtA[iNdEx:postIndex]))
-			iNdEx = postIndex
+			m.UseClientProtocol = bool(v != 0)
 		default:
 			iNdEx = preIndex
 			skippy, err := skipDestinationRule(dAtA[iNdEx:])
@@ -4299,7 +8319,7 @@ func (m *DestinationRule) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
-func (m *TrafficPolicy) Unmarshal(dAtA []byte) error {
+func (m *OutlierDetection) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
 	for iNdEx < l {
@@ -4322,15 +8342,34 @@ func (m *TrafficPolicy) Unmarshal(dAtA []byte) error {
 		fieldNum := int32(wire >> 3)
 		wireType := int(wire & 0x7)
 		if wireType == 4 {
-			return fmt.Errorf("proto: TrafficPolicy: wiretype end group for non-group")
+			return fmt.Errorf("proto: OutlierDetection: wiretype end group for non-group")
 		}
 		if fieldNum <= 0 {
-			return fmt.Errorf("proto: TrafficPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
+			return fmt.Errorf("proto: OutlierDetection: illegal tag %d (wire type %d)", fieldNum, wire)
 		}
 		switch fieldNum {
 		case 1:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field ConsecutiveErrors", wireType)
+			}
+			m.ConsecutiveErrors = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.ConsecutiveErrors |= int32(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		case 2:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field LoadBalancer", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -4357,16 +8396,16 @@ func (m *TrafficPolicy) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.LoadBalancer == nil {
-				m.LoadBalancer = &LoadBalancerSettings{}
+			if m.Interval == nil {
+				m.Interval = &types.Duration{}
 			}
-			if err := m.LoadBalancer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+			if err := m.Interval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
 			iNdEx = postIndex
-		case 2:
+		case 3:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionPool", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field BaseEjectionTime", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -4393,16 +8432,54 @@ func (m *TrafficPolicy) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.ConnectionPool == nil {
-				m.ConnectionPool = &ConnectionPoolSettings{}
+			if m.BaseEjectionTime == nil {
+				m.BaseEjectionTime = &types.Duration{}
 			}
-			if err := m.ConnectionPool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+			if err := m.BaseEjectionTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
 			iNdEx = postIndex
-		case 3:
+		case 4:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field MaxEjectionPercent", wireType)
+			}
+			m.MaxEjectionPercent = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.MaxEjectionPercent |= int32(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		case 5:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field MinHealthPercent", wireType)
+			}
+			m.MinHealthPercent = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.MinHealthPercent |= int32(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		case 6:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field OutlierDetection", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field ConsecutiveGatewayErrors", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -4429,16 +8506,16 @@ func (m *TrafficPolicy) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.OutlierDetection == nil {
-				m.OutlierDetection = &OutlierDetection{}
+			if m.ConsecutiveGatewayErrors == nil {
+				m.ConsecutiveGatewayErrors = &types.UInt32Value{}
 			}
-			if err := m.OutlierDetection.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+			if err := m.ConsecutiveGatewayErrors.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
 			iNdEx = postIndex
-		case 4:
+		case 7:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Tls", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Consecutive_5XxErrors", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -4465,16 +8542,36 @@ func (m *TrafficPolicy) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.Tls == nil {
-				m.Tls = &ClientTLSSettings{}
+			if m.Consecutive_5XxErrors == nil {
+				m.Consecutive_5XxErrors = &types.UInt32Value{}
 			}
-			if err := m.Tls.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+			if err := m.Consecutive_5XxErrors.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
 			iNdEx = postIndex
-		case 5:
+		case 8:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field SplitExternalLocalOriginErrors", wireType)
+			}
+			var v int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				v |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			m.SplitExternalLocalOriginErrors = bool(v != 0)
+		case 9:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field PortLevelSettings", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field ConsecutiveLocalOriginFailures", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -4501,8 +8598,10 @@ func (m *TrafficPolicy) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.PortLevelSettings = append(m.PortLevelSettings, &TrafficPolicy_PortTrafficPolicy{})
-			if err := m.PortLevelSettings[len(m.PortLevelSettings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+			if m.ConsecutiveLocalOriginFailures == nil {
+				m.ConsecutiveLocalOriginFailures = &types.UInt32Value{}
+			}
+			if err := m.ConsecutiveLocalOriginFailures.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
 			iNdEx = postIndex
@@ -4528,7 +8627,7 @@ func (m *TrafficPolicy) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
-func (m *TrafficPolicy_PortTrafficPolicy) Unmarshal(dAtA []byte) error {
+func (m *ClientTLSSettings) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
 	for iNdEx < l {
@@ -4551,53 +8650,17 @@ func (m *TrafficPolicy_PortTrafficPolicy) Unmarshal(dAtA []byte) error {
 		fieldNum := int32(wire >> 3)
 		wireType := int(wire & 0x7)
 		if wireType == 4 {
-			return fmt.Errorf("proto: PortTrafficPolicy: wiretype end group for non-group")
-		}
-		if fieldNum <= 0 {
-			return fmt.Errorf("proto: PortTrafficPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
+			return fmt.Errorf("proto: ClientTLSSettings: wiretype end group for non-group")
 		}
-		switch fieldNum {
-		case 1:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
-			}
-			var msglen int
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowDestinationRule
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				msglen |= int(b&0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-			if msglen < 0 {
-				return ErrInvalidLengthDestinationRule
-			}
-			postIndex := iNdEx + msglen
-			if postIndex < 0 {
-				return ErrInvalidLengthDestinationRule
-			}
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			if m.Port == nil {
-				m.Port = &PortSelector{}
-			}
-			if err := m.Port.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
-			iNdEx = postIndex
-		case 2:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field LoadBalancer", wireType)
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: ClientTLSSettings: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
 			}
-			var msglen int
+			m.Mode = 0
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowDestinationRule
@@ -4607,33 +8670,16 @@ func (m *TrafficPolicy_PortTrafficPolicy) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				msglen |= int(b&0x7F) << shift
+				m.Mode |= ClientTLSSettings_TLSmode(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			if msglen < 0 {
-				return ErrInvalidLengthDestinationRule
-			}
-			postIndex := iNdEx + msglen
-			if postIndex < 0 {
-				return ErrInvalidLengthDestinationRule
-			}
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			if m.LoadBalancer == nil {
-				m.LoadBalancer = &LoadBalancerSettings{}
-			}
-			if err := m.LoadBalancer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
-			iNdEx = postIndex
-		case 3:
+		case 2:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionPool", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field ClientCertificate", wireType)
 			}
-			var msglen int
+			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowDestinationRule
@@ -4643,33 +8689,29 @@ func (m *TrafficPolicy_PortTrafficPolicy) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				msglen |= int(b&0x7F) << shift
+				stringLen |= uint64(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			if msglen < 0 {
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
 				return ErrInvalidLengthDestinationRule
 			}
-			postIndex := iNdEx + msglen
+			postIndex := iNdEx + intStringLen
 			if postIndex < 0 {
 				return ErrInvalidLengthDestinationRule
 			}
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.ConnectionPool == nil {
-				m.ConnectionPool = &ConnectionPoolSettings{}
-			}
-			if err := m.ConnectionPool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
+			m.ClientCertificate = string(dAtA[iNdEx:postIndex])
 			iNdEx = postIndex
-		case 4:
+		case 3:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field OutlierDetection", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field PrivateKey", wireType)
 			}
-			var msglen int
+			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowDestinationRule
@@ -4679,33 +8721,29 @@ func (m *TrafficPolicy_PortTrafficPolicy) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				msglen |= int(b&0x7F) << shift
+				stringLen |= uint64(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			if msglen < 0 {
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
 				return ErrInvalidLengthDestinationRule
 			}
-			postIndex := iNdEx + msglen
+			postIndex := iNdEx + intStringLen
 			if postIndex < 0 {
 				return ErrInvalidLengthDestinationRule
 			}
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.OutlierDetection == nil {
-				m.OutlierDetection = &OutlierDetection{}
-			}
-			if err := m.OutlierDetection.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
+			m.PrivateKey = string(dAtA[iNdEx:postIndex])
 			iNdEx = postIndex
-		case 5:
+		case 4:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Tls", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field CaCertificates", wireType)
 			}
-			var msglen int
+			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowDestinationRule
@@ -4715,82 +8753,27 @@ func (m *TrafficPolicy_PortTrafficPolicy) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				msglen |= int(b&0x7F) << shift
+				stringLen |= uint64(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			if msglen < 0 {
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
 				return ErrInvalidLengthDestinationRule
 			}
-			postIndex := iNdEx + msglen
+			postIndex := iNdEx + intStringLen
 			if postIndex < 0 {
 				return ErrInvalidLengthDestinationRule
 			}
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.Tls == nil {
-				m.Tls = &ClientTLSSettings{}
-			}
-			if err := m.Tls.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
+			m.CaCertificates = string(dAtA[iNdEx:postIndex])
 			iNdEx = postIndex
-		default:
-			iNdEx = preIndex
-			skippy, err := skipDestinationRule(dAtA[iNdEx:])
-			if err != nil {
-				return err
-			}
-			if (skippy < 0) || (iNdEx+skippy) < 0 {
-				return ErrInvalidLengthDestinationRule
-			}
-			if (iNdEx + skippy) > l {
-				return io.ErrUnexpectedEOF
-			}
-			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
-			iNdEx += skippy
-		}
-	}
-
-	if iNdEx > l {
-		return io.ErrUnexpectedEOF
-	}
-	return nil
-}
-func (m *Subset) Unmarshal(dAtA []byte) error {
-	l := len(dAtA)
-	iNdEx := 0
-	for iNdEx < l {
-		preIndex := iNdEx
-		var wire uint64
-		for shift := uint(0); ; shift += 7 {
-			if shift >= 64 {
-				return ErrIntOverflowDestinationRule
-			}
-			if iNdEx >= l {
-				return io.ErrUnexpectedEOF
-			}
-			b := dAtA[iNdEx]
-			iNdEx++
-			wire |= uint64(b&0x7F) << shift
-			if b < 0x80 {
-				break
-			}
-		}
-		fieldNum := int32(wire >> 3)
-		wireType := int(wire & 0x7)
-		if wireType == 4 {
-			return fmt.Errorf("proto: Subset: wiretype end group for non-group")
-		}
-		if fieldNum <= 0 {
-			return fmt.Errorf("proto: Subset: illegal tag %d (wire type %d)", fieldNum, wire)
-		}
-		switch fieldNum {
-		case 1:
+		case 5:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field SubjectAltNames", wireType)
 			}
 			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
@@ -4818,13 +8801,13 @@ func (m *Subset) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.Name = string(dAtA[iNdEx:postIndex])
+			m.SubjectAltNames = append(m.SubjectAltNames, string(dAtA[iNdEx:postIndex]))
 			iNdEx = postIndex
-		case 2:
+		case 6:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Sni", wireType)
 			}
-			var msglen int
+			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowDestinationRule
@@ -4834,122 +8817,59 @@ func (m *Subset) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				msglen |= int(b&0x7F) << shift
+				stringLen |= uint64(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			if msglen < 0 {
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
 				return ErrInvalidLengthDestinationRule
 			}
-			postIndex := iNdEx + msglen
+			postIndex := iNdEx + intStringLen
 			if postIndex < 0 {
 				return ErrInvalidLengthDestinationRule
 			}
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.Labels == nil {
-				m.Labels = make(map[string]string)
+			m.Sni = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 7:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field CredentialName", wireType)
 			}
-			var mapkey string
-			var mapvalue string
-			for iNdEx < postIndex {
-				entryPreIndex := iNdEx
-				var wire uint64
-				for shift := uint(0); ; shift += 7 {
-					if shift >= 64 {
-						return ErrIntOverflowDestinationRule
-					}
-					if iNdEx >= l {
-						return io.ErrUnexpectedEOF
-					}
-					b := dAtA[iNdEx]
-					iNdEx++
-					wire |= uint64(b&0x7F) << shift
-					if b < 0x80 {
-						break
-					}
-				}
-				fieldNum := int32(wire >> 3)
-				if fieldNum == 1 {
-					var stringLenmapkey uint64
-					for shift := uint(0); ; shift += 7 {
-						if shift >= 64 {
-							return ErrIntOverflowDestinationRule
-						}
-						if iNdEx >= l {
-							return io.ErrUnexpectedEOF
-						}
-						b := dAtA[iNdEx]
-						iNdEx++
-						stringLenmapkey |= uint64(b&0x7F) << shift
-						if b < 0x80 {
-							break
-						}
-					}
-					intStringLenmapkey := int(stringLenmapkey)
-					if intStringLenmapkey < 0 {
-						return ErrInvalidLengthDestinationRule
-					}
-					postStringIndexmapkey := iNdEx + intStringLenmapkey
-					if postStringIndexmapkey < 0 {
-						return ErrInvalidLengthDestinationRule
-					}
-					if postStringIndexmapkey > l {
-						return io.ErrUnexpectedEOF
-					}
-					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
-					iNdEx = postStringIndexmapkey
-				} else if fieldNum == 2 {
-					var stringLenmapvalue uint64
-					for shift := uint(0); ; shift += 7 {
-						if shift >= 64 {
-							return ErrIntOverflowDestinationRule
-						}
-						if iNdEx >= l {
-							return io.ErrUnexpectedEOF
-						}
-						b := dAtA[iNdEx]
-						iNdEx++
-						stringLenmapvalue |= uint64(b&0x7F) << shift
-						if b < 0x80 {
-							break
-						}
-					}
-					intStringLenmapvalue := int(stringLenmapvalue)
-					if intStringLenmapvalue < 0 {
-						return ErrInvalidLengthDestinationRule
-					}
-					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
-					if postStringIndexmapvalue < 0 {
-						return ErrInvalidLengthDestinationRule
-					}
-					if postStringIndexmapvalue > l {
-						return io.ErrUnexpectedEOF
-					}
-					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
-					iNdEx = postStringIndexmapvalue
-				} else {
-					iNdEx = entryPreIndex
-					skippy, err := skipDestinationRule(dAtA[iNdEx:])
-					if err != nil {
-						return err
-					}
-					if (skippy < 0) || (iNdEx+skippy) < 0 {
-						return ErrInvalidLengthDestinationRule
-					}
-					if (iNdEx + skippy) > postIndex {
-						return io.ErrUnexpectedEOF
-					}
-					iNdEx += skippy
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
 				}
 			}
-			m.Labels[mapkey] = mapvalue
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.CredentialName = string(dAtA[iNdEx:postIndex])
 			iNdEx = postIndex
-		case 3:
+		case 8:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field TrafficPolicy", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field InsecureSkipVerify", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -4976,10 +8896,10 @@ func (m *Subset) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.TrafficPolicy == nil {
-				m.TrafficPolicy = &TrafficPolicy{}
+			if m.InsecureSkipVerify == nil {
+				m.InsecureSkipVerify = &types.BoolValue{}
 			}
-			if err := m.TrafficPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+			if err := m.InsecureSkipVerify.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
 			iNdEx = postIndex
@@ -5005,7 +8925,7 @@ func (m *Subset) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
-func (m *LoadBalancerSettings) Unmarshal(dAtA []byte) error {
+func (m *LocalityLoadBalancerSetting) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
 	for iNdEx < l {
@@ -5028,17 +8948,17 @@ func (m *LoadBalancerSettings) Unmarshal(dAtA []byte) error {
 		fieldNum := int32(wire >> 3)
 		wireType := int(wire & 0x7)
 		if wireType == 4 {
-			return fmt.Errorf("proto: LoadBalancerSettings: wiretype end group for non-group")
+			return fmt.Errorf("proto: LocalityLoadBalancerSetting: wiretype end group for non-group")
 		}
 		if fieldNum <= 0 {
-			return fmt.Errorf("proto: LoadBalancerSettings: illegal tag %d (wire type %d)", fieldNum, wire)
+			return fmt.Errorf("proto: LocalityLoadBalancerSetting: illegal tag %d (wire type %d)", fieldNum, wire)
 		}
 		switch fieldNum {
 		case 1:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Simple", wireType)
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Distribute", wireType)
 			}
-			var v LoadBalancerSettings_SimpleLB
+			var msglen int
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowDestinationRule
@@ -5048,15 +8968,29 @@ func (m *LoadBalancerSettings) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				v |= LoadBalancerSettings_SimpleLB(b&0x7F) << shift
+				msglen |= int(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			m.LbPolicy = &LoadBalancerSettings_Simple{v}
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Distribute = append(m.Distribute, &LocalityLoadBalancerSetting_Distribute{})
+			if err := m.Distribute[len(m.Distribute)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
 		case 2:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field ConsistentHash", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Failover", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -5083,15 +9017,14 @@ func (m *LoadBalancerSettings) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			v := &LoadBalancerSettings_ConsistentHashLB{}
-			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+			m.Failover = append(m.Failover, &LocalityLoadBalancerSetting_Failover{})
+			if err := m.Failover[len(m.Failover)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
-			m.LbPolicy = &LoadBalancerSettings_ConsistentHash{v}
 			iNdEx = postIndex
 		case 3:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field LocalityLbSetting", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -5118,13 +9051,45 @@ func (m *LoadBalancerSettings) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.LocalityLbSetting == nil {
-				m.LocalityLbSetting = &LocalityLoadBalancerSetting{}
+			if m.Enabled == nil {
+				m.Enabled = &types.BoolValue{}
 			}
-			if err := m.LocalityLbSetting.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+			if err := m.Enabled.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
 			iNdEx = postIndex
+		case 4:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field FailoverPriority", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.FailoverPriority = append(m.FailoverPriority, string(dAtA[iNdEx:postIndex]))
+			iNdEx = postIndex
 		default:
 			iNdEx = preIndex
 			skippy, err := skipDestinationRule(dAtA[iNdEx:])
@@ -5147,7 +9112,7 @@ func (m *LoadBalancerSettings) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
-func (m *LoadBalancerSettings_ConsistentHashLB) Unmarshal(dAtA []byte) error {
+func (m *LocalityLoadBalancerSetting_Distribute) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
 	for iNdEx < l {
@@ -5170,15 +9135,15 @@ func (m *LoadBalancerSettings_ConsistentHashLB) Unmarshal(dAtA []byte) error {
 		fieldNum := int32(wire >> 3)
 		wireType := int(wire & 0x7)
 		if wireType == 4 {
-			return fmt.Errorf("proto: ConsistentHashLB: wiretype end group for non-group")
+			return fmt.Errorf("proto: Distribute: wiretype end group for non-group")
 		}
 		if fieldNum <= 0 {
-			return fmt.Errorf("proto: ConsistentHashLB: illegal tag %d (wire type %d)", fieldNum, wire)
+			return fmt.Errorf("proto: Distribute: illegal tag %d (wire type %d)", fieldNum, wire)
 		}
 		switch fieldNum {
 		case 1:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field HttpHeaderName", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
 			}
 			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
@@ -5206,11 +9171,11 @@ func (m *LoadBalancerSettings_ConsistentHashLB) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.HashKey = &LoadBalancerSettings_ConsistentHashLB_HttpHeaderName{string(dAtA[iNdEx:postIndex])}
+			m.From = string(dAtA[iNdEx:postIndex])
 			iNdEx = postIndex
 		case 2:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field HttpCookie", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -5237,17 +9202,146 @@ func (m *LoadBalancerSettings_ConsistentHashLB) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			v := &LoadBalancerSettings_ConsistentHashLB_HTTPCookie{}
-			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
+			if m.To == nil {
+				m.To = make(map[string]uint32)
 			}
-			m.HashKey = &LoadBalancerSettings_ConsistentHashLB_HttpCookie{v}
+			var mapkey string
+			var mapvalue uint32
+			for iNdEx < postIndex {
+				entryPreIndex := iNdEx
+				var wire uint64
+				for shift := uint(0); ; shift += 7 {
+					if shift >= 64 {
+						return ErrIntOverflowDestinationRule
+					}
+					if iNdEx >= l {
+						return io.ErrUnexpectedEOF
+					}
+					b := dAtA[iNdEx]
+					iNdEx++
+					wire |= uint64(b&0x7F) << shift
+					if b < 0x80 {
+						break
+					}
+				}
+				fieldNum := int32(wire >> 3)
+				if fieldNum == 1 {
+					var stringLenmapkey uint64
+					for shift := uint(0); ; shift += 7 {
+						if shift >= 64 {
+							return ErrIntOverflowDestinationRule
+						}
+						if iNdEx >= l {
+							return io.ErrUnexpectedEOF
+						}
+						b := dAtA[iNdEx]
+						iNdEx++
+						stringLenmapkey |= uint64(b&0x7F) << shift
+						if b < 0x80 {
+							break
+						}
+					}
+					intStringLenmapkey := int(stringLenmapkey)
+					if intStringLenmapkey < 0 {
+						return ErrInvalidLengthDestinationRule
+					}
+					postStringIndexmapkey := iNdEx + intStringLenmapkey
+					if postStringIndexmapkey < 0 {
+						return ErrInvalidLengthDestinationRule
+					}
+					if postStringIndexmapkey > l {
+						return io.ErrUnexpectedEOF
+					}
+					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
+					iNdEx = postStringIndexmapkey
+				} else if fieldNum == 2 {
+					for shift := uint(0); ; shift += 7 {
+						if shift >= 64 {
+							return ErrIntOverflowDestinationRule
+						}
+						if iNdEx >= l {
+							return io.ErrUnexpectedEOF
+						}
+						b := dAtA[iNdEx]
+						iNdEx++
+						mapvalue |= uint32(b&0x7F) << shift
+						if b < 0x80 {
+							break
+						}
+					}
+				} else {
+					iNdEx = entryPreIndex
+					skippy, err := skipDestinationRule(dAtA[iNdEx:])
+					if err != nil {
+						return err
+					}
+					if (skippy < 0) || (iNdEx+skippy) < 0 {
+						return ErrInvalidLengthDestinationRule
+					}
+					if (iNdEx + skippy) > postIndex {
+						return io.ErrUnexpectedEOF
+					}
+					iNdEx += skippy
+				}
+			}
+			m.To[mapkey] = mapvalue
 			iNdEx = postIndex
-		case 3:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field UseSourceIp", wireType)
+		default:
+			iNdEx = preIndex
+			skippy, err := skipDestinationRule(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *LocalityLoadBalancerSetting_Failover) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowDestinationRule
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: Failover: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: Failover: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
 			}
-			var v int
+			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowDestinationRule
@@ -5257,35 +9351,27 @@ func (m *LoadBalancerSettings_ConsistentHashLB) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				v |= int(b&0x7F) << shift
+				stringLen |= uint64(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			b := bool(v != 0)
-			m.HashKey = &LoadBalancerSettings_ConsistentHashLB_UseSourceIp{b}
-		case 4:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field MinimumRingSize", wireType)
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthDestinationRule
 			}
-			m.MinimumRingSize = 0
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowDestinationRule
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				m.MinimumRingSize |= uint64(b&0x7F) << shift
-				if b < 0x80 {
-					break
-				}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
 			}
-		case 5:
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.From = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 2:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field HttpQueryParameterName", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
 			}
 			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
@@ -5313,7 +9399,7 @@ func (m *LoadBalancerSettings_ConsistentHashLB) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.HashKey = &LoadBalancerSettings_ConsistentHashLB_HttpQueryParameterName{string(dAtA[iNdEx:postIndex])}
+			m.To = string(dAtA[iNdEx:postIndex])
 			iNdEx = postIndex
 		default:
 			iNdEx = preIndex
@@ -5337,7 +9423,7 @@ func (m *LoadBalancerSettings_ConsistentHashLB) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
-func (m *LoadBalancerSettings_ConsistentHashLB_HTTPCookie) Unmarshal(dAtA []byte) error {
+func (m *Int64Range) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
 	for iNdEx < l {
@@ -5360,17 +9446,17 @@ func (m *LoadBalancerSettings_ConsistentHashLB_HTTPCookie) Unmarshal(dAtA []byte
 		fieldNum := int32(wire >> 3)
 		wireType := int(wire & 0x7)
 		if wireType == 4 {
-			return fmt.Errorf("proto: HTTPCookie: wiretype end group for non-group")
+			return fmt.Errorf("proto: Int64Range: wiretype end group for non-group")
 		}
 		if fieldNum <= 0 {
-			return fmt.Errorf("proto: HTTPCookie: illegal tag %d (wire type %d)", fieldNum, wire)
+			return fmt.Errorf("proto: Int64Range: illegal tag %d (wire type %d)", fieldNum, wire)
 		}
 		switch fieldNum {
 		case 1:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
 			}
-			var stringLen uint64
+			m.Start = 0
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowDestinationRule
@@ -5380,29 +9466,16 @@ func (m *LoadBalancerSettings_ConsistentHashLB_HTTPCookie) Unmarshal(dAtA []byte
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				stringLen |= uint64(b&0x7F) << shift
+				m.Start |= int64(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			intStringLen := int(stringLen)
-			if intStringLen < 0 {
-				return ErrInvalidLengthDestinationRule
-			}
-			postIndex := iNdEx + intStringLen
-			if postIndex < 0 {
-				return ErrInvalidLengthDestinationRule
-			}
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			m.Name = string(dAtA[iNdEx:postIndex])
-			iNdEx = postIndex
 		case 2:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
 			}
-			var stringLen uint64
+			m.End = 0
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowDestinationRule
@@ -5412,60 +9485,131 @@ func (m *LoadBalancerSettings_ConsistentHashLB_HTTPCookie) Unmarshal(dAtA []byte
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				stringLen |= uint64(b&0x7F) << shift
+				m.End |= int64(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			intStringLen := int(stringLen)
-			if intStringLen < 0 {
-				return ErrInvalidLengthDestinationRule
+		default:
+			iNdEx = preIndex
+			skippy, err := skipDestinationRule(dAtA[iNdEx:])
+			if err != nil {
+				return err
 			}
-			postIndex := iNdEx + intStringLen
-			if postIndex < 0 {
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
 				return ErrInvalidLengthDestinationRule
 			}
-			if postIndex > l {
+			if (iNdEx + skippy) > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.Path = string(dAtA[iNdEx:postIndex])
-			iNdEx = postIndex
-		case 3:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Ttl", wireType)
+			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *HealthStatusSet) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowDestinationRule
 			}
-			var msglen int
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowDestinationRule
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: HealthStatusSet: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: HealthStatusSet: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType == 0 {
+				var v HealthStatus
+				for shift := uint(0); ; shift += 7 {
+					if shift >= 64 {
+						return ErrIntOverflowDestinationRule
+					}
+					if iNdEx >= l {
+						return io.ErrUnexpectedEOF
+					}
+					b := dAtA[iNdEx]
+					iNdEx++
+					v |= HealthStatus(b&0x7F) << shift
+					if b < 0x80 {
+						break
+					}
 				}
-				if iNdEx >= l {
+				m.Statuses = append(m.Statuses, v)
+			} else if wireType == 2 {
+				var packedLen int
+				for shift := uint(0); ; shift += 7 {
+					if shift >= 64 {
+						return ErrIntOverflowDestinationRule
+					}
+					if iNdEx >= l {
+						return io.ErrUnexpectedEOF
+					}
+					b := dAtA[iNdEx]
+					iNdEx++
+					packedLen |= int(b&0x7F) << shift
+					if b < 0x80 {
+						break
+					}
+				}
+				if packedLen < 0 {
+					return ErrInvalidLengthDestinationRule
+				}
+				postIndex := iNdEx + packedLen
+				if postIndex < 0 {
+					return ErrInvalidLengthDestinationRule
+				}
+				if postIndex > l {
 					return io.ErrUnexpectedEOF
 				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				msglen |= int(b&0x7F) << shift
-				if b < 0x80 {
-					break
+				var elementCount int
+				if elementCount != 0 && len(m.Statuses) == 0 {
+					m.Statuses = make([]HealthStatus, 0, elementCount)
 				}
+				for iNdEx < postIndex {
+					var v HealthStatus
+					for shift := uint(0); ; shift += 7 {
+						if shift >= 64 {
+							return ErrIntOverflowDestinationRule
+						}
+						if iNdEx >= l {
+							return io.ErrUnexpectedEOF
+						}
+						b := dAtA[iNdEx]
+						iNdEx++
+						v |= HealthStatus(b&0x7F) << shift
+						if b < 0x80 {
+							break
+						}
+					}
+					m.Statuses = append(m.Statuses, v)
+				}
+			} else {
+				return fmt.Errorf("proto: wrong wireType = %d for field Statuses", wireType)
 			}
-			if msglen < 0 {
-				return ErrInvalidLengthDestinationRule
-			}
-			postIndex := iNdEx + msglen
-			if postIndex < 0 {
-				return ErrInvalidLengthDestinationRule
-			}
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			if m.Ttl == nil {
-				m.Ttl = &types.Duration{}
-			}
-			if err := m.Ttl.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
-			iNdEx = postIndex
 		default:
 			iNdEx = preIndex
 			skippy, err := skipDestinationRule(dAtA[iNdEx:])
@@ -5488,7 +9632,7 @@ func (m *LoadBalancerSettings_ConsistentHashLB_HTTPCookie) Unmarshal(dAtA []byte
 	}
 	return nil
 }
-func (m *ConnectionPoolSettings) Unmarshal(dAtA []byte) error {
+func (m *Payload) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
 	for iNdEx < l {
@@ -5511,17 +9655,17 @@ func (m *ConnectionPoolSettings) Unmarshal(dAtA []byte) error {
 		fieldNum := int32(wire >> 3)
 		wireType := int(wire & 0x7)
 		if wireType == 4 {
-			return fmt.Errorf("proto: ConnectionPoolSettings: wiretype end group for non-group")
+			return fmt.Errorf("proto: Payload: wiretype end group for non-group")
 		}
 		if fieldNum <= 0 {
-			return fmt.Errorf("proto: ConnectionPoolSettings: illegal tag %d (wire type %d)", fieldNum, wire)
+			return fmt.Errorf("proto: Payload: illegal tag %d (wire type %d)", fieldNum, wire)
 		}
 		switch fieldNum {
 		case 1:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Tcp", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
 			}
-			var msglen int
+			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowDestinationRule
@@ -5531,33 +9675,29 @@ func (m *ConnectionPoolSettings) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				msglen |= int(b&0x7F) << shift
+				stringLen |= uint64(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			if msglen < 0 {
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
 				return ErrInvalidLengthDestinationRule
 			}
-			postIndex := iNdEx + msglen
+			postIndex := iNdEx + intStringLen
 			if postIndex < 0 {
 				return ErrInvalidLengthDestinationRule
 			}
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.Tcp == nil {
-				m.Tcp = &ConnectionPoolSettings_TCPSettings{}
-			}
-			if err := m.Tcp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
+			m.Payload = &Payload_Text{string(dAtA[iNdEx:postIndex])}
 			iNdEx = postIndex
 		case 2:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Http", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Binary", wireType)
 			}
-			var msglen int
+			var byteLen int
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowDestinationRule
@@ -5567,27 +9707,24 @@ func (m *ConnectionPoolSettings) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				msglen |= int(b&0x7F) << shift
+				byteLen |= int(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			if msglen < 0 {
+			if byteLen < 0 {
 				return ErrInvalidLengthDestinationRule
 			}
-			postIndex := iNdEx + msglen
+			postIndex := iNdEx + byteLen
 			if postIndex < 0 {
 				return ErrInvalidLengthDestinationRule
 			}
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.Http == nil {
-				m.Http = &ConnectionPoolSettings_HTTPSettings{}
-			}
-			if err := m.Http.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
+			v := make([]byte, postIndex-iNdEx)
+			copy(v, dAtA[iNdEx:postIndex])
+			m.Payload = &Payload_Binary{v}
 			iNdEx = postIndex
 		default:
 			iNdEx = preIndex
@@ -5611,7 +9748,7 @@ func (m *ConnectionPoolSettings) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
-func (m *ConnectionPoolSettings_TCPSettings) Unmarshal(dAtA []byte) error {
+func (m *HealthCheck) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
 	for iNdEx < l {
@@ -5634,17 +9771,17 @@ func (m *ConnectionPoolSettings_TCPSettings) Unmarshal(dAtA []byte) error {
 		fieldNum := int32(wire >> 3)
 		wireType := int(wire & 0x7)
 		if wireType == 4 {
-			return fmt.Errorf("proto: TCPSettings: wiretype end group for non-group")
+			return fmt.Errorf("proto: HealthCheck: wiretype end group for non-group")
 		}
 		if fieldNum <= 0 {
-			return fmt.Errorf("proto: TCPSettings: illegal tag %d (wire type %d)", fieldNum, wire)
+			return fmt.Errorf("proto: HealthCheck: illegal tag %d (wire type %d)", fieldNum, wire)
 		}
 		switch fieldNum {
 		case 1:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field MaxConnections", wireType)
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
 			}
-			m.MaxConnections = 0
+			var msglen int
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowDestinationRule
@@ -5654,14 +9791,31 @@ func (m *ConnectionPoolSettings_TCPSettings) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				m.MaxConnections |= int32(b&0x7F) << shift
+				msglen |= int(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.Timeout == nil {
+				m.Timeout = &types.Duration{}
+			}
+			if err := m.Timeout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
 		case 2:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field ConnectTimeout", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -5688,16 +9842,16 @@ func (m *ConnectionPoolSettings_TCPSettings) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.ConnectTimeout == nil {
-				m.ConnectTimeout = &types.Duration{}
+			if m.Interval == nil {
+				m.Interval = &types.Duration{}
 			}
-			if err := m.ConnectTimeout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+			if err := m.Interval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
 			iNdEx = postIndex
 		case 3:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field TcpKeepalive", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field IntervalJitter", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -5724,69 +9878,18 @@ func (m *ConnectionPoolSettings_TCPSettings) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.TcpKeepalive == nil {
-				m.TcpKeepalive = &ConnectionPoolSettings_TCPSettings_TcpKeepalive{}
+			if m.IntervalJitter == nil {
+				m.IntervalJitter = &types.Duration{}
 			}
-			if err := m.TcpKeepalive.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+			if err := m.IntervalJitter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
 			iNdEx = postIndex
-		default:
-			iNdEx = preIndex
-			skippy, err := skipDestinationRule(dAtA[iNdEx:])
-			if err != nil {
-				return err
-			}
-			if (skippy < 0) || (iNdEx+skippy) < 0 {
-				return ErrInvalidLengthDestinationRule
-			}
-			if (iNdEx + skippy) > l {
-				return io.ErrUnexpectedEOF
-			}
-			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
-			iNdEx += skippy
-		}
-	}
-
-	if iNdEx > l {
-		return io.ErrUnexpectedEOF
-	}
-	return nil
-}
-func (m *ConnectionPoolSettings_TCPSettings_TcpKeepalive) Unmarshal(dAtA []byte) error {
-	l := len(dAtA)
-	iNdEx := 0
-	for iNdEx < l {
-		preIndex := iNdEx
-		var wire uint64
-		for shift := uint(0); ; shift += 7 {
-			if shift >= 64 {
-				return ErrIntOverflowDestinationRule
-			}
-			if iNdEx >= l {
-				return io.ErrUnexpectedEOF
-			}
-			b := dAtA[iNdEx]
-			iNdEx++
-			wire |= uint64(b&0x7F) << shift
-			if b < 0x80 {
-				break
-			}
-		}
-		fieldNum := int32(wire >> 3)
-		wireType := int(wire & 0x7)
-		if wireType == 4 {
-			return fmt.Errorf("proto: TcpKeepalive: wiretype end group for non-group")
-		}
-		if fieldNum <= 0 {
-			return fmt.Errorf("proto: TcpKeepalive: illegal tag %d (wire type %d)", fieldNum, wire)
-		}
-		switch fieldNum {
-		case 1:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Probes", wireType)
+		case 4:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field UnhealthyThreshold", wireType)
 			}
-			m.Probes = 0
+			var msglen int
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowDestinationRule
@@ -5796,14 +9899,31 @@ func (m *ConnectionPoolSettings_TCPSettings_TcpKeepalive) Unmarshal(dAtA []byte)
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				m.Probes |= uint32(b&0x7F) << shift
+				msglen |= int(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-		case 2:
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.UnhealthyThreshold == nil {
+				m.UnhealthyThreshold = &types.UInt32Value{}
+			}
+			if err := m.UnhealthyThreshold.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 5:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field HealthyThreshold", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -5830,16 +9950,16 @@ func (m *ConnectionPoolSettings_TCPSettings_TcpKeepalive) Unmarshal(dAtA []byte)
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.Time == nil {
-				m.Time = &types.Duration{}
+			if m.HealthyThreshold == nil {
+				m.HealthyThreshold = &types.UInt32Value{}
 			}
-			if err := m.Time.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+			if err := m.HealthyThreshold.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
 			iNdEx = postIndex
-		case 3:
+		case 6:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field AltPort", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -5866,69 +9986,18 @@ func (m *ConnectionPoolSettings_TCPSettings_TcpKeepalive) Unmarshal(dAtA []byte)
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.Interval == nil {
-				m.Interval = &types.Duration{}
+			if m.AltPort == nil {
+				m.AltPort = &types.UInt32Value{}
 			}
-			if err := m.Interval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+			if err := m.AltPort.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
 			iNdEx = postIndex
-		default:
-			iNdEx = preIndex
-			skippy, err := skipDestinationRule(dAtA[iNdEx:])
-			if err != nil {
-				return err
-			}
-			if (skippy < 0) || (iNdEx+skippy) < 0 {
-				return ErrInvalidLengthDestinationRule
-			}
-			if (iNdEx + skippy) > l {
-				return io.ErrUnexpectedEOF
-			}
-			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
-			iNdEx += skippy
-		}
-	}
-
-	if iNdEx > l {
-		return io.ErrUnexpectedEOF
-	}
-	return nil
-}
-func (m *ConnectionPoolSettings_HTTPSettings) Unmarshal(dAtA []byte) error {
-	l := len(dAtA)
-	iNdEx := 0
-	for iNdEx < l {
-		preIndex := iNdEx
-		var wire uint64
-		for shift := uint(0); ; shift += 7 {
-			if shift >= 64 {
-				return ErrIntOverflowDestinationRule
-			}
-			if iNdEx >= l {
-				return io.ErrUnexpectedEOF
-			}
-			b := dAtA[iNdEx]
-			iNdEx++
-			wire |= uint64(b&0x7F) << shift
-			if b < 0x80 {
-				break
-			}
-		}
-		fieldNum := int32(wire >> 3)
-		wireType := int(wire & 0x7)
-		if wireType == 4 {
-			return fmt.Errorf("proto: HTTPSettings: wiretype end group for non-group")
-		}
-		if fieldNum <= 0 {
-			return fmt.Errorf("proto: HTTPSettings: illegal tag %d (wire type %d)", fieldNum, wire)
-		}
-		switch fieldNum {
-		case 1:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Http1MaxPendingRequests", wireType)
+		case 7:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field ReuseConnection", wireType)
 			}
-			m.Http1MaxPendingRequests = 0
+			var msglen int
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowDestinationRule
@@ -5938,16 +10007,33 @@ func (m *ConnectionPoolSettings_HTTPSettings) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				m.Http1MaxPendingRequests |= int32(b&0x7F) << shift
+				msglen |= int(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-		case 2:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Http2MaxRequests", wireType)
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
 			}
-			m.Http2MaxRequests = 0
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.ReuseConnection == nil {
+				m.ReuseConnection = &types.BoolValue{}
+			}
+			if err := m.ReuseConnection.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 8:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field HttpHealthCheck", wireType)
+			}
+			var msglen int
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowDestinationRule
@@ -5957,16 +10043,32 @@ func (m *ConnectionPoolSettings_HTTPSettings) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				m.Http2MaxRequests |= int32(b&0x7F) << shift
+				msglen |= int(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-		case 3:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field MaxRequestsPerConnection", wireType)
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
 			}
-			m.MaxRequestsPerConnection = 0
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			v := &HealthCheck_HttpHealthCheck{}
+			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			m.HealthChecker = &HealthCheck_HttpHealthCheck_{v}
+			iNdEx = postIndex
+		case 9:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field TcpHealthCheck", wireType)
+			}
+			var msglen int
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowDestinationRule
@@ -5976,16 +10078,32 @@ func (m *ConnectionPoolSettings_HTTPSettings) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				m.MaxRequestsPerConnection |= int32(b&0x7F) << shift
+				msglen |= int(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-		case 4:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field MaxRetries", wireType)
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
 			}
-			m.MaxRetries = 0
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			v := &HealthCheck_TcpHealthCheck{}
+			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			m.HealthChecker = &HealthCheck_TcpHealthCheck_{v}
+			iNdEx = postIndex
+		case 11:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field GrpcHealthCheck", wireType)
+			}
+			var msglen int
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowDestinationRule
@@ -5995,14 +10113,30 @@ func (m *ConnectionPoolSettings_HTTPSettings) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				m.MaxRetries |= int32(b&0x7F) << shift
+				msglen |= int(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-		case 5:
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			v := &HealthCheck_GrpcHealthCheck{}
+			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			m.HealthChecker = &HealthCheck_GrpcHealthCheck_{v}
+			iNdEx = postIndex
+		case 12:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field IdleTimeout", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field NoTrafficInterval", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -6029,18 +10163,18 @@ func (m *ConnectionPoolSettings_HTTPSettings) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.IdleTimeout == nil {
-				m.IdleTimeout = &types.Duration{}
+			if m.NoTrafficInterval == nil {
+				m.NoTrafficInterval = &types.Duration{}
 			}
-			if err := m.IdleTimeout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+			if err := m.NoTrafficInterval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
 			iNdEx = postIndex
-		case 6:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field H2UpgradePolicy", wireType)
+		case 13:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field CustomHealthCheck", wireType)
 			}
-			m.H2UpgradePolicy = 0
+			var msglen int
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowDestinationRule
@@ -6050,16 +10184,32 @@ func (m *ConnectionPoolSettings_HTTPSettings) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				m.H2UpgradePolicy |= ConnectionPoolSettings_HTTPSettings_H2UpgradePolicy(b&0x7F) << shift
+				msglen |= int(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-		case 7:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field UseClientProtocol", wireType)
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
 			}
-			var v int
+			v := &HealthCheck_CustomHealthCheck{}
+			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			m.HealthChecker = &HealthCheck_CustomHealthCheck_{v}
+			iNdEx = postIndex
+		case 14:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field UnhealthyInterval", wireType)
+			}
+			var msglen int
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowDestinationRule
@@ -6069,68 +10219,33 @@ func (m *ConnectionPoolSettings_HTTPSettings) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				v |= int(b&0x7F) << shift
+				msglen |= int(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			m.UseClientProtocol = bool(v != 0)
-		default:
-			iNdEx = preIndex
-			skippy, err := skipDestinationRule(dAtA[iNdEx:])
-			if err != nil {
-				return err
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
 			}
-			if (skippy < 0) || (iNdEx+skippy) < 0 {
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
 				return ErrInvalidLengthDestinationRule
 			}
-			if (iNdEx + skippy) > l {
+			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
-			iNdEx += skippy
-		}
-	}
-
-	if iNdEx > l {
-		return io.ErrUnexpectedEOF
-	}
-	return nil
-}
-func (m *OutlierDetection) Unmarshal(dAtA []byte) error {
-	l := len(dAtA)
-	iNdEx := 0
-	for iNdEx < l {
-		preIndex := iNdEx
-		var wire uint64
-		for shift := uint(0); ; shift += 7 {
-			if shift >= 64 {
-				return ErrIntOverflowDestinationRule
-			}
-			if iNdEx >= l {
-				return io.ErrUnexpectedEOF
+			if m.UnhealthyInterval == nil {
+				m.UnhealthyInterval = &types.Duration{}
 			}
-			b := dAtA[iNdEx]
-			iNdEx++
-			wire |= uint64(b&0x7F) << shift
-			if b < 0x80 {
-				break
+			if err := m.UnhealthyInterval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
 			}
-		}
-		fieldNum := int32(wire >> 3)
-		wireType := int(wire & 0x7)
-		if wireType == 4 {
-			return fmt.Errorf("proto: OutlierDetection: wiretype end group for non-group")
-		}
-		if fieldNum <= 0 {
-			return fmt.Errorf("proto: OutlierDetection: illegal tag %d (wire type %d)", fieldNum, wire)
-		}
-		switch fieldNum {
-		case 1:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field ConsecutiveErrors", wireType)
+			iNdEx = postIndex
+		case 15:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field UnhealthyEdgeInterval", wireType)
 			}
-			m.ConsecutiveErrors = 0
+			var msglen int
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowDestinationRule
@@ -6140,14 +10255,31 @@ func (m *OutlierDetection) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				m.ConsecutiveErrors |= int32(b&0x7F) << shift
+				msglen |= int(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-		case 2:
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.UnhealthyEdgeInterval == nil {
+				m.UnhealthyEdgeInterval = &types.Duration{}
+			}
+			if err := m.UnhealthyEdgeInterval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 16:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field HealthyEdgeInterval", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -6174,18 +10306,18 @@ func (m *OutlierDetection) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.Interval == nil {
-				m.Interval = &types.Duration{}
+			if m.HealthyEdgeInterval == nil {
+				m.HealthyEdgeInterval = &types.Duration{}
 			}
-			if err := m.Interval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+			if err := m.HealthyEdgeInterval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
 			iNdEx = postIndex
-		case 3:
+		case 17:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field BaseEjectionTime", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field EventLogPath", wireType)
 			}
-			var msglen int
+			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowDestinationRule
@@ -6195,33 +10327,29 @@ func (m *OutlierDetection) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				msglen |= int(b&0x7F) << shift
+				stringLen |= uint64(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			if msglen < 0 {
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
 				return ErrInvalidLengthDestinationRule
 			}
-			postIndex := iNdEx + msglen
+			postIndex := iNdEx + intStringLen
 			if postIndex < 0 {
 				return ErrInvalidLengthDestinationRule
 			}
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.BaseEjectionTime == nil {
-				m.BaseEjectionTime = &types.Duration{}
-			}
-			if err := m.BaseEjectionTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
+			m.EventLogPath = string(dAtA[iNdEx:postIndex])
 			iNdEx = postIndex
-		case 4:
+		case 18:
 			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field MaxEjectionPercent", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field IntervalJitterPercent", wireType)
 			}
-			m.MaxEjectionPercent = 0
+			m.IntervalJitterPercent = 0
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowDestinationRule
@@ -6231,16 +10359,16 @@ func (m *OutlierDetection) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				m.MaxEjectionPercent |= int32(b&0x7F) << shift
+				m.IntervalJitterPercent |= uint32(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-		case 5:
+		case 19:
 			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field MinHealthPercent", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field AlwaysLogHealthCheckFailures", wireType)
 			}
-			m.MinHealthPercent = 0
+			var v int
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowDestinationRule
@@ -6250,14 +10378,15 @@ func (m *OutlierDetection) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				m.MinHealthPercent |= int32(b&0x7F) << shift
+				v |= int(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-		case 6:
+			m.AlwaysLogHealthCheckFailures = bool(v != 0)
+		case 20:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field ConsecutiveGatewayErrors", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field InitialJitter", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -6284,16 +10413,16 @@ func (m *OutlierDetection) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.ConsecutiveGatewayErrors == nil {
-				m.ConsecutiveGatewayErrors = &types.UInt32Value{}
+			if m.InitialJitter == nil {
+				m.InitialJitter = &types.Duration{}
 			}
-			if err := m.ConsecutiveGatewayErrors.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+			if err := m.InitialJitter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
 			iNdEx = postIndex
-		case 7:
+		case 21:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Consecutive_5XxErrors", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field TlsOptions", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -6320,36 +10449,16 @@ func (m *OutlierDetection) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.Consecutive_5XxErrors == nil {
-				m.Consecutive_5XxErrors = &types.UInt32Value{}
+			if m.TlsOptions == nil {
+				m.TlsOptions = &HealthCheck_TlsOptions{}
 			}
-			if err := m.Consecutive_5XxErrors.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+			if err := m.TlsOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
 			iNdEx = postIndex
-		case 8:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field SplitExternalLocalOriginErrors", wireType)
-			}
-			var v int
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowDestinationRule
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				v |= int(b&0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-			m.SplitExternalLocalOriginErrors = bool(v != 0)
-		case 9:
+		case 24:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field ConsecutiveLocalOriginFailures", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field NoTrafficHealthyInterval", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -6376,10 +10485,10 @@ func (m *OutlierDetection) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.ConsecutiveLocalOriginFailures == nil {
-				m.ConsecutiveLocalOriginFailures = &types.UInt32Value{}
+			if m.NoTrafficHealthyInterval == nil {
+				m.NoTrafficHealthyInterval = &types.Duration{}
 			}
-			if err := m.ConsecutiveLocalOriginFailures.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+			if err := m.NoTrafficHealthyInterval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
 			iNdEx = postIndex
@@ -6405,7 +10514,7 @@ func (m *OutlierDetection) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
-func (m *ClientTLSSettings) Unmarshal(dAtA []byte) error {
+func (m *HealthCheck_HttpHealthCheck) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
 	for iNdEx < l {
@@ -6428,34 +10537,15 @@ func (m *ClientTLSSettings) Unmarshal(dAtA []byte) error {
 		fieldNum := int32(wire >> 3)
 		wireType := int(wire & 0x7)
 		if wireType == 4 {
-			return fmt.Errorf("proto: ClientTLSSettings: wiretype end group for non-group")
+			return fmt.Errorf("proto: HttpHealthCheck: wiretype end group for non-group")
 		}
 		if fieldNum <= 0 {
-			return fmt.Errorf("proto: ClientTLSSettings: illegal tag %d (wire type %d)", fieldNum, wire)
+			return fmt.Errorf("proto: HttpHealthCheck: illegal tag %d (wire type %d)", fieldNum, wire)
 		}
 		switch fieldNum {
 		case 1:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
-			}
-			m.Mode = 0
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowDestinationRule
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				m.Mode |= ClientTLSSettings_TLSmode(b&0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		case 2:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field ClientCertificate", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
 			}
 			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
@@ -6483,11 +10573,11 @@ func (m *ClientTLSSettings) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.ClientCertificate = string(dAtA[iNdEx:postIndex])
+			m.Host = string(dAtA[iNdEx:postIndex])
 			iNdEx = postIndex
-		case 3:
+		case 2:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field PrivateKey", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
 			}
 			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
@@ -6515,13 +10605,13 @@ func (m *ClientTLSSettings) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.PrivateKey = string(dAtA[iNdEx:postIndex])
+			m.Path = string(dAtA[iNdEx:postIndex])
 			iNdEx = postIndex
-		case 4:
+		case 3:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field CaCertificates", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Send", wireType)
 			}
-			var stringLen uint64
+			var msglen int
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowDestinationRule
@@ -6531,61 +10621,33 @@ func (m *ClientTLSSettings) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				stringLen |= uint64(b&0x7F) << shift
+				msglen |= int(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			intStringLen := int(stringLen)
-			if intStringLen < 0 {
+			if msglen < 0 {
 				return ErrInvalidLengthDestinationRule
 			}
-			postIndex := iNdEx + intStringLen
+			postIndex := iNdEx + msglen
 			if postIndex < 0 {
 				return ErrInvalidLengthDestinationRule
 			}
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.CaCertificates = string(dAtA[iNdEx:postIndex])
-			iNdEx = postIndex
-		case 5:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field SubjectAltNames", wireType)
-			}
-			var stringLen uint64
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowDestinationRule
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				stringLen |= uint64(b&0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-			intStringLen := int(stringLen)
-			if intStringLen < 0 {
-				return ErrInvalidLengthDestinationRule
-			}
-			postIndex := iNdEx + intStringLen
-			if postIndex < 0 {
-				return ErrInvalidLengthDestinationRule
+			if m.Send == nil {
+				m.Send = &Payload{}
 			}
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
+			if err := m.Send.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
 			}
-			m.SubjectAltNames = append(m.SubjectAltNames, string(dAtA[iNdEx:postIndex]))
 			iNdEx = postIndex
-		case 6:
+		case 4:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Sni", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Receive", wireType)
 			}
-			var stringLen uint64
+			var msglen int
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowDestinationRule
@@ -6595,29 +10657,33 @@ func (m *ClientTLSSettings) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				stringLen |= uint64(b&0x7F) << shift
+				msglen |= int(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			intStringLen := int(stringLen)
-			if intStringLen < 0 {
+			if msglen < 0 {
 				return ErrInvalidLengthDestinationRule
 			}
-			postIndex := iNdEx + intStringLen
+			postIndex := iNdEx + msglen
 			if postIndex < 0 {
 				return ErrInvalidLengthDestinationRule
 			}
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.Sni = string(dAtA[iNdEx:postIndex])
+			if m.Receive == nil {
+				m.Receive = &Payload{}
+			}
+			if err := m.Receive.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
 			iNdEx = postIndex
-		case 7:
+		case 9:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field CredentialName", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field ExpectedStatuses", wireType)
 			}
-			var stringLen uint64
+			var msglen int
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowDestinationRule
@@ -6627,27 +10693,29 @@ func (m *ClientTLSSettings) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				stringLen |= uint64(b&0x7F) << shift
+				msglen |= int(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			intStringLen := int(stringLen)
-			if intStringLen < 0 {
+			if msglen < 0 {
 				return ErrInvalidLengthDestinationRule
 			}
-			postIndex := iNdEx + intStringLen
+			postIndex := iNdEx + msglen
 			if postIndex < 0 {
 				return ErrInvalidLengthDestinationRule
 			}
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.CredentialName = string(dAtA[iNdEx:postIndex])
+			m.ExpectedStatuses = append(m.ExpectedStatuses, &Int64Range{})
+			if err := m.ExpectedStatuses[len(m.ExpectedStatuses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
 			iNdEx = postIndex
-		case 8:
+		case 12:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field InsecureSkipVerify", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field RetriableStatuses", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -6674,10 +10742,8 @@ func (m *ClientTLSSettings) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.InsecureSkipVerify == nil {
-				m.InsecureSkipVerify = &types.BoolValue{}
-			}
-			if err := m.InsecureSkipVerify.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+			m.RetriableStatuses = append(m.RetriableStatuses, &Int64Range{})
+			if err := m.RetriableStatuses[len(m.RetriableStatuses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
 			iNdEx = postIndex
@@ -6703,7 +10769,7 @@ func (m *ClientTLSSettings) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
-func (m *LocalityLoadBalancerSetting) Unmarshal(dAtA []byte) error {
+func (m *HealthCheck_TcpHealthCheck) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
 	for iNdEx < l {
@@ -6726,15 +10792,15 @@ func (m *LocalityLoadBalancerSetting) Unmarshal(dAtA []byte) error {
 		fieldNum := int32(wire >> 3)
 		wireType := int(wire & 0x7)
 		if wireType == 4 {
-			return fmt.Errorf("proto: LocalityLoadBalancerSetting: wiretype end group for non-group")
+			return fmt.Errorf("proto: TcpHealthCheck: wiretype end group for non-group")
 		}
 		if fieldNum <= 0 {
-			return fmt.Errorf("proto: LocalityLoadBalancerSetting: illegal tag %d (wire type %d)", fieldNum, wire)
+			return fmt.Errorf("proto: TcpHealthCheck: illegal tag %d (wire type %d)", fieldNum, wire)
 		}
 		switch fieldNum {
 		case 1:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Distribute", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Send", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -6761,14 +10827,16 @@ func (m *LocalityLoadBalancerSetting) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.Distribute = append(m.Distribute, &LocalityLoadBalancerSetting_Distribute{})
-			if err := m.Distribute[len(m.Distribute)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+			if m.Send == nil {
+				m.Send = &Payload{}
+			}
+			if err := m.Send.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
 			iNdEx = postIndex
 		case 2:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Failover", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Receive", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -6795,50 +10863,65 @@ func (m *LocalityLoadBalancerSetting) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.Failover = append(m.Failover, &LocalityLoadBalancerSetting_Failover{})
-			if err := m.Failover[len(m.Failover)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+			m.Receive = append(m.Receive, &Payload{})
+			if err := m.Receive[len(m.Receive)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
 			iNdEx = postIndex
-		case 3:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
-			}
-			var msglen int
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowDestinationRule
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				msglen |= int(b&0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-			if msglen < 0 {
-				return ErrInvalidLengthDestinationRule
+		default:
+			iNdEx = preIndex
+			skippy, err := skipDestinationRule(dAtA[iNdEx:])
+			if err != nil {
+				return err
 			}
-			postIndex := iNdEx + msglen
-			if postIndex < 0 {
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
 				return ErrInvalidLengthDestinationRule
 			}
-			if postIndex > l {
+			if (iNdEx + skippy) > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.Enabled == nil {
-				m.Enabled = &types.BoolValue{}
+			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *HealthCheck_RedisHealthCheck) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowDestinationRule
 			}
-			if err := m.Enabled.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
 			}
-			iNdEx = postIndex
-		case 4:
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: RedisHealthCheck: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: RedisHealthCheck: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field FailoverPriority", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
 			}
 			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
@@ -6866,7 +10949,7 @@ func (m *LocalityLoadBalancerSetting) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.FailoverPriority = append(m.FailoverPriority, string(dAtA[iNdEx:postIndex]))
+			m.Key = string(dAtA[iNdEx:postIndex])
 			iNdEx = postIndex
 		default:
 			iNdEx = preIndex
@@ -6890,7 +10973,7 @@ func (m *LocalityLoadBalancerSetting) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
-func (m *LocalityLoadBalancerSetting_Distribute) Unmarshal(dAtA []byte) error {
+func (m *HealthCheck_GrpcHealthCheck) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
 	for iNdEx < l {
@@ -6913,15 +10996,15 @@ func (m *LocalityLoadBalancerSetting_Distribute) Unmarshal(dAtA []byte) error {
 		fieldNum := int32(wire >> 3)
 		wireType := int(wire & 0x7)
 		if wireType == 4 {
-			return fmt.Errorf("proto: Distribute: wiretype end group for non-group")
+			return fmt.Errorf("proto: GrpcHealthCheck: wiretype end group for non-group")
 		}
 		if fieldNum <= 0 {
-			return fmt.Errorf("proto: Distribute: illegal tag %d (wire type %d)", fieldNum, wire)
+			return fmt.Errorf("proto: GrpcHealthCheck: illegal tag %d (wire type %d)", fieldNum, wire)
 		}
 		switch fieldNum {
 		case 1:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field ServiceName", wireType)
 			}
 			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
@@ -6949,13 +11032,13 @@ func (m *LocalityLoadBalancerSetting_Distribute) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.From = string(dAtA[iNdEx:postIndex])
+			m.ServiceName = string(dAtA[iNdEx:postIndex])
 			iNdEx = postIndex
 		case 2:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
 			}
-			var msglen int
+			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowDestinationRule
@@ -6965,104 +11048,23 @@ func (m *LocalityLoadBalancerSetting_Distribute) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				msglen |= int(b&0x7F) << shift
+				stringLen |= uint64(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			if msglen < 0 {
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
 				return ErrInvalidLengthDestinationRule
 			}
-			postIndex := iNdEx + msglen
+			postIndex := iNdEx + intStringLen
 			if postIndex < 0 {
 				return ErrInvalidLengthDestinationRule
 			}
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.To == nil {
-				m.To = make(map[string]uint32)
-			}
-			var mapkey string
-			var mapvalue uint32
-			for iNdEx < postIndex {
-				entryPreIndex := iNdEx
-				var wire uint64
-				for shift := uint(0); ; shift += 7 {
-					if shift >= 64 {
-						return ErrIntOverflowDestinationRule
-					}
-					if iNdEx >= l {
-						return io.ErrUnexpectedEOF
-					}
-					b := dAtA[iNdEx]
-					iNdEx++
-					wire |= uint64(b&0x7F) << shift
-					if b < 0x80 {
-						break
-					}
-				}
-				fieldNum := int32(wire >> 3)
-				if fieldNum == 1 {
-					var stringLenmapkey uint64
-					for shift := uint(0); ; shift += 7 {
-						if shift >= 64 {
-							return ErrIntOverflowDestinationRule
-						}
-						if iNdEx >= l {
-							return io.ErrUnexpectedEOF
-						}
-						b := dAtA[iNdEx]
-						iNdEx++
-						stringLenmapkey |= uint64(b&0x7F) << shift
-						if b < 0x80 {
-							break
-						}
-					}
-					intStringLenmapkey := int(stringLenmapkey)
-					if intStringLenmapkey < 0 {
-						return ErrInvalidLengthDestinationRule
-					}
-					postStringIndexmapkey := iNdEx + intStringLenmapkey
-					if postStringIndexmapkey < 0 {
-						return ErrInvalidLengthDestinationRule
-					}
-					if postStringIndexmapkey > l {
-						return io.ErrUnexpectedEOF
-					}
-					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
-					iNdEx = postStringIndexmapkey
-				} else if fieldNum == 2 {
-					for shift := uint(0); ; shift += 7 {
-						if shift >= 64 {
-							return ErrIntOverflowDestinationRule
-						}
-						if iNdEx >= l {
-							return io.ErrUnexpectedEOF
-						}
-						b := dAtA[iNdEx]
-						iNdEx++
-						mapvalue |= uint32(b&0x7F) << shift
-						if b < 0x80 {
-							break
-						}
-					}
-				} else {
-					iNdEx = entryPreIndex
-					skippy, err := skipDestinationRule(dAtA[iNdEx:])
-					if err != nil {
-						return err
-					}
-					if (skippy < 0) || (iNdEx+skippy) < 0 {
-						return ErrInvalidLengthDestinationRule
-					}
-					if (iNdEx + skippy) > postIndex {
-						return io.ErrUnexpectedEOF
-					}
-					iNdEx += skippy
-				}
-			}
-			m.To[mapkey] = mapvalue
+			m.Authority = string(dAtA[iNdEx:postIndex])
 			iNdEx = postIndex
 		default:
 			iNdEx = preIndex
@@ -7086,7 +11088,7 @@ func (m *LocalityLoadBalancerSetting_Distribute) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
-func (m *LocalityLoadBalancerSetting_Failover) Unmarshal(dAtA []byte) error {
+func (m *HealthCheck_CustomHealthCheck) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
 	for iNdEx < l {
@@ -7109,15 +11111,15 @@ func (m *LocalityLoadBalancerSetting_Failover) Unmarshal(dAtA []byte) error {
 		fieldNum := int32(wire >> 3)
 		wireType := int(wire & 0x7)
 		if wireType == 4 {
-			return fmt.Errorf("proto: Failover: wiretype end group for non-group")
+			return fmt.Errorf("proto: CustomHealthCheck: wiretype end group for non-group")
 		}
 		if fieldNum <= 0 {
-			return fmt.Errorf("proto: Failover: illegal tag %d (wire type %d)", fieldNum, wire)
+			return fmt.Errorf("proto: CustomHealthCheck: illegal tag %d (wire type %d)", fieldNum, wire)
 		}
 		switch fieldNum {
 		case 1:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
 			}
 			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
@@ -7145,11 +11147,62 @@ func (m *LocalityLoadBalancerSetting_Failover) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.From = string(dAtA[iNdEx:postIndex])
+			m.Name = string(dAtA[iNdEx:postIndex])
 			iNdEx = postIndex
-		case 2:
+		default:
+			iNdEx = preIndex
+			skippy, err := skipDestinationRule(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *HealthCheck_TlsOptions) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowDestinationRule
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: TlsOptions: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: TlsOptions: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field AlpnProtocols", wireType)
 			}
 			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
@@ -7177,7 +11230,7 @@ func (m *LocalityLoadBalancerSetting_Failover) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.To = string(dAtA[iNdEx:postIndex])
+			m.AlpnProtocols = append(m.AlpnProtocols, string(dAtA[iNdEx:postIndex]))
 			iNdEx = postIndex
 		default:
 			iNdEx = preIndex
diff --git a/networking/v1alpha3/destination_rule.pb.html b/networking/v1alpha3/destination_rule.pb.html
index aad04c85..2fcff11a 100644
--- a/networking/v1alpha3/destination_rule.pb.html
+++ b/networking/v1alpha3/destination_rule.pb.html
@@ -6,7 +6,7 @@ layout: protoc-gen-docs
 generator: protoc-gen-docs
 schema: istio.networking.v1alpha3.DestinationRule
 aliases: [/docs/reference/config/networking/v1alpha3/destination-rule]
-number_of_entries: 20
+number_of_entries: 31
 ---
 <p><code>DestinationRule</code> defines policies that apply to traffic intended for a
 service after routing has occurred. These rules specify configuration
@@ -314,6 +314,15 @@ settings specified at the destination-level will not be inherited when
 overridden by port-level settings, i.e. default values will be applied
 to fields omitted in port-level traffic policies.</p>
 
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="TrafficPolicy-health_checks">
+<td><code>healthChecks</code></td>
+<td><code><a href="#HealthCheck">HealthCheck[]</a></code></td>
+<td>
 </td>
 <td>
 No
@@ -558,6 +567,21 @@ No
 <p>Locality load balancer settings, this will override mesh wide settings in entirety, meaning no merging would be performed
 between this object and the object one in MeshConfig</p>
 
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="LoadBalancerSettings-warmup_duration_secs">
+<td><code>warmupDurationSecs</code></td>
+<td><code><a href="https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#duration">Duration</a></code></td>
+<td>
+<p>Represents the warmup duration of Service. If set, the newly created endpoint of service
+remains in warmup mode starting from its creation time for the duration of this window and
+Istio progressively increases amount of traffic for that endpoint instead of sending proportional amount of traffic.
+This should be enabled for services that require warm up time to serve full production load with reasonable latency.
+Currently this is only supported for ROUND<em>ROBIN and LEAST</em>CONN load balancers.</p>
+
 </td>
 <td>
 No
@@ -1266,6 +1290,360 @@ No
 <p>enable locality load balancing, this is DestinationRule-level and will override mesh wide settings in entirety.
 e.g. true means that turn on locality load balancing for this DestinationRule no matter what mesh wide settings is.</p>
 
+</td>
+<td>
+No
+</td>
+</tr>
+</tbody>
+</table>
+</section>
+<h2 id="Int64Range">Int64Range</h2>
+<section>
+<p>Added by Ingress</p>
+
+<table class="message-fields">
+<thead>
+<tr>
+<th>Field</th>
+<th>Type</th>
+<th>Description</th>
+<th>Required</th>
+</tr>
+</thead>
+<tbody>
+<tr id="Int64Range-start">
+<td><code>start</code></td>
+<td><code>int64</code></td>
+<td>
+<p>start of the range (inclusive)</p>
+
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="Int64Range-end">
+<td><code>end</code></td>
+<td><code>int64</code></td>
+<td>
+<p>end of the range (exclusive)</p>
+
+</td>
+<td>
+No
+</td>
+</tr>
+</tbody>
+</table>
+</section>
+<h2 id="HealthStatusSet">HealthStatusSet</h2>
+<section>
+<table class="message-fields">
+<thead>
+<tr>
+<th>Field</th>
+<th>Type</th>
+<th>Description</th>
+<th>Required</th>
+</tr>
+</thead>
+<tbody>
+<tr id="HealthStatusSet-statuses">
+<td><code>statuses</code></td>
+<td><code><a href="#HealthStatus">HealthStatus[]</a></code></td>
+<td>
+<p>An order-independent set of health status.</p>
+
+</td>
+<td>
+No
+</td>
+</tr>
+</tbody>
+</table>
+</section>
+<h2 id="Payload">Payload</h2>
+<section>
+<table class="message-fields">
+<thead>
+<tr>
+<th>Field</th>
+<th>Type</th>
+<th>Description</th>
+<th>Required</th>
+</tr>
+</thead>
+<tbody>
+<tr id="Payload-text" class="oneof oneof-start">
+<td><code>text</code></td>
+<td><code>string (oneof)</code></td>
+<td>
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="Payload-binary" class="oneof">
+<td><code>binary</code></td>
+<td><code>bytes (oneof)</code></td>
+<td>
+</td>
+<td>
+No
+</td>
+</tr>
+</tbody>
+</table>
+</section>
+<h2 id="HealthCheck">HealthCheck</h2>
+<section>
+<p>[#next-free-field: 25]</p>
+
+<table class="message-fields">
+<thead>
+<tr>
+<th>Field</th>
+<th>Type</th>
+<th>Description</th>
+<th>Required</th>
+</tr>
+</thead>
+<tbody>
+<tr id="HealthCheck-timeout">
+<td><code>timeout</code></td>
+<td><code><a href="https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#duration">Duration</a></code></td>
+<td>
+<p>The time to wait for a health check response. If the timeout is reached the
+health check attempt will be considered a failure.</p>
+
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="HealthCheck-interval">
+<td><code>interval</code></td>
+<td><code><a href="https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#duration">Duration</a></code></td>
+<td>
+<p>The interval between health checks.</p>
+
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="HealthCheck-initial_jitter">
+<td><code>initialJitter</code></td>
+<td><code><a href="https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#duration">Duration</a></code></td>
+<td>
+<p>An optional jitter amount in milliseconds. If specified, Envoy will start health
+checking after for a random time in ms between 0 and initial_jitter. This only
+applies to the first health check.</p>
+
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="HealthCheck-interval_jitter">
+<td><code>intervalJitter</code></td>
+<td><code><a href="https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#duration">Duration</a></code></td>
+<td>
+<p>An optional jitter amount in milliseconds. If specified, during every
+interval Envoy will add interval_jitter to the wait time.</p>
+
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="HealthCheck-interval_jitter_percent">
+<td><code>intervalJitterPercent</code></td>
+<td><code>uint32</code></td>
+<td>
+<p>An optional jitter amount as a percentage of interval<em>ms. If specified,
+during every interval Envoy will add interval</em>ms *
+interval<em>jitter</em>percent / 100 to the wait time.</p>
+
+<p>If interval<em>jitter</em>ms and interval<em>jitter</em>percent are both set, both of
+them will be used to increase the wait time.</p>
+
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="HealthCheck-unhealthy_threshold">
+<td><code>unhealthyThreshold</code></td>
+<td><code><a href="#google-protobuf-UInt32Value">UInt32Value</a></code></td>
+<td>
+<p>The number of unhealthy health checks required before a host is marked
+unhealthy. Note that for <em>http</em> health checking if a host responds with a code not in</p>
+
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="HealthCheck-healthy_threshold">
+<td><code>healthyThreshold</code></td>
+<td><code><a href="#google-protobuf-UInt32Value">UInt32Value</a></code></td>
+<td>
+<p>The number of healthy health checks required before a host is marked
+healthy. Note that during startup, only a single successful health check is
+required to mark a host healthy.</p>
+
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="HealthCheck-alt_port">
+<td><code>altPort</code></td>
+<td><code><a href="#google-protobuf-UInt32Value">UInt32Value</a></code></td>
+<td>
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="HealthCheck-reuse_connection">
+<td><code>reuseConnection</code></td>
+<td><code><a href="https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#boolvalue">BoolValue</a></code></td>
+<td>
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="HealthCheck-http_health_check" class="oneof oneof-start">
+<td><code>httpHealthCheck</code></td>
+<td><code><a href="#HealthCheck-HttpHealthCheck">HttpHealthCheck (oneof)</a></code></td>
+<td>
+<p>HTTP health check.</p>
+
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="HealthCheck-tcp_health_check" class="oneof">
+<td><code>tcpHealthCheck</code></td>
+<td><code><a href="#HealthCheck-TcpHealthCheck">TcpHealthCheck (oneof)</a></code></td>
+<td>
+<p>TCP health check.</p>
+
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="HealthCheck-grpc_health_check" class="oneof">
+<td><code>grpcHealthCheck</code></td>
+<td><code><a href="#HealthCheck-GrpcHealthCheck">GrpcHealthCheck (oneof)</a></code></td>
+<td>
+<p>gRPC health check.</p>
+
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="HealthCheck-custom_health_check" class="oneof">
+<td><code>customHealthCheck</code></td>
+<td><code><a href="#HealthCheck-CustomHealthCheck">CustomHealthCheck (oneof)</a></code></td>
+<td>
+<p>Custom health check.</p>
+
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="HealthCheck-no_traffic_interval">
+<td><code>noTrafficInterval</code></td>
+<td><code><a href="https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#duration">Duration</a></code></td>
+<td>
+<p>The default value for &ldquo;no traffic interval&rdquo; is 60 seconds.</p>
+
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="HealthCheck-no_traffic_healthy_interval">
+<td><code>noTrafficHealthyInterval</code></td>
+<td><code><a href="https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#duration">Duration</a></code></td>
+<td>
+<p>If no<em>traffic</em>healthy_interval is not set, it will default to the
+no traffic interval and send that interval regardless of health state.</p>
+
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="HealthCheck-unhealthy_interval">
+<td><code>unhealthyInterval</code></td>
+<td><code><a href="https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#duration">Duration</a></code></td>
+<td>
+<p>The default value for &ldquo;unhealthy interval&rdquo; is the same as &ldquo;interval&rdquo;.</p>
+
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="HealthCheck-unhealthy_edge_interval">
+<td><code>unhealthyEdgeInterval</code></td>
+<td><code><a href="https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#duration">Duration</a></code></td>
+<td>
+<p>The default value for &ldquo;unhealthy edge interval&rdquo; is the same as &ldquo;unhealthy interval&rdquo;.</p>
+
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="HealthCheck-healthy_edge_interval">
+<td><code>healthyEdgeInterval</code></td>
+<td><code><a href="https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#duration">Duration</a></code></td>
+<td>
+<p>The default value for &ldquo;healthy edge interval&rdquo; is the same as the default interval.</p>
+
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="HealthCheck-event_log_path">
+<td><code>eventLogPath</code></td>
+<td><code>string</code></td>
+<td>
+<p>Specifies the path to the :ref:<code>health check event log &lt;arch_overview_health_check_logging&gt;</code>.
+If empty, no event log will be written.</p>
+
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="HealthCheck-always_log_health_check_failures">
+<td><code>alwaysLogHealthCheckFailures</code></td>
+<td><code>bool</code></td>
+<td>
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="HealthCheck-tls_options">
+<td><code>tlsOptions</code></td>
+<td><code><a href="#HealthCheck-TlsOptions">TlsOptions</a></code></td>
+<td>
+<p>This allows overriding the cluster TLS settings, just for health check connections.</p>
+
 </td>
 <td>
 No
@@ -1339,6 +1717,15 @@ No
 <td>
 <p>TLS related settings for connections to the upstream service.</p>
 
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="TrafficPolicy-PortTrafficPolicy-health_checks">
+<td><code>healthChecks</code></td>
+<td><code><a href="#HealthCheck">HealthCheck[]</a></code></td>
+<td>
 </td>
 <td>
 No
@@ -1780,6 +2167,233 @@ No
 <p>Destination region the traffic will fail over to when endpoints in
 the &lsquo;from&rsquo; region becomes unhealthy.</p>
 
+</td>
+<td>
+No
+</td>
+</tr>
+</tbody>
+</table>
+</section>
+<h2 id="HealthCheck-HttpHealthCheck">HealthCheck.HttpHealthCheck</h2>
+<section>
+<p>[#next-free-field: 13]</p>
+
+<table class="message-fields">
+<thead>
+<tr>
+<th>Field</th>
+<th>Type</th>
+<th>Description</th>
+<th>Required</th>
+</tr>
+</thead>
+<tbody>
+<tr id="HealthCheck-HttpHealthCheck-host">
+<td><code>host</code></td>
+<td><code>string</code></td>
+<td>
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="HealthCheck-HttpHealthCheck-path">
+<td><code>path</code></td>
+<td><code>string</code></td>
+<td>
+<p>Specifies the HTTP path that will be requested during health checking.</p>
+
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="HealthCheck-HttpHealthCheck-send">
+<td><code>send</code></td>
+<td><code><a href="#Payload">Payload</a></code></td>
+<td>
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="HealthCheck-HttpHealthCheck-receive">
+<td><code>receive</code></td>
+<td><code><a href="#Payload">Payload</a></code></td>
+<td>
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="HealthCheck-HttpHealthCheck-expected_statuses">
+<td><code>expectedStatuses</code></td>
+<td><code><a href="#Int64Range">Int64Range[]</a></code></td>
+<td>
+<p>Specifies a list of HTTP response statuses considered healthy. If provided, replaces default
+200-only policy - 200 must be included explicitly as needed. Ranges follow half-open
+semantics of :ref:<code>Int64Range &lt;envoy_v3_api_msg_type.v3.Int64Range&gt;</code>. The start and end of each
+range are required. Only statuses in the range [100, 600) are allowed.</p>
+
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="HealthCheck-HttpHealthCheck-retriable_statuses">
+<td><code>retriableStatuses</code></td>
+<td><code><a href="#Int64Range">Int64Range[]</a></code></td>
+<td>
+</td>
+<td>
+No
+</td>
+</tr>
+</tbody>
+</table>
+</section>
+<h2 id="HealthCheck-TcpHealthCheck">HealthCheck.TcpHealthCheck</h2>
+<section>
+<table class="message-fields">
+<thead>
+<tr>
+<th>Field</th>
+<th>Type</th>
+<th>Description</th>
+<th>Required</th>
+</tr>
+</thead>
+<tbody>
+<tr id="HealthCheck-TcpHealthCheck-send">
+<td><code>send</code></td>
+<td><code><a href="#Payload">Payload</a></code></td>
+<td>
+<p>Empty payloads imply a connect-only health check.</p>
+
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="HealthCheck-TcpHealthCheck-receive">
+<td><code>receive</code></td>
+<td><code><a href="#Payload">Payload[]</a></code></td>
+<td>
+</td>
+<td>
+No
+</td>
+</tr>
+</tbody>
+</table>
+</section>
+<h2 id="HealthCheck-RedisHealthCheck">HealthCheck.RedisHealthCheck</h2>
+<section>
+<table class="message-fields">
+<thead>
+<tr>
+<th>Field</th>
+<th>Type</th>
+<th>Description</th>
+<th>Required</th>
+</tr>
+</thead>
+<tbody>
+<tr id="HealthCheck-RedisHealthCheck-key">
+<td><code>key</code></td>
+<td><code>string</code></td>
+<td>
+</td>
+<td>
+No
+</td>
+</tr>
+</tbody>
+</table>
+</section>
+<h2 id="HealthCheck-GrpcHealthCheck">HealthCheck.GrpcHealthCheck</h2>
+<section>
+<table class="message-fields">
+<thead>
+<tr>
+<th>Field</th>
+<th>Type</th>
+<th>Description</th>
+<th>Required</th>
+</tr>
+</thead>
+<tbody>
+<tr id="HealthCheck-GrpcHealthCheck-service_name">
+<td><code>serviceName</code></td>
+<td><code>string</code></td>
+<td>
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="HealthCheck-GrpcHealthCheck-authority">
+<td><code>authority</code></td>
+<td><code>string</code></td>
+<td>
+</td>
+<td>
+No
+</td>
+</tr>
+</tbody>
+</table>
+</section>
+<h2 id="HealthCheck-CustomHealthCheck">HealthCheck.CustomHealthCheck</h2>
+<section>
+<p>Custom health check.</p>
+
+<table class="message-fields">
+<thead>
+<tr>
+<th>Field</th>
+<th>Type</th>
+<th>Description</th>
+<th>Required</th>
+</tr>
+</thead>
+<tbody>
+<tr id="HealthCheck-CustomHealthCheck-name">
+<td><code>name</code></td>
+<td><code>string</code></td>
+<td>
+<p>The registered name of the custom health checker.</p>
+
+</td>
+<td>
+No
+</td>
+</tr>
+</tbody>
+</table>
+</section>
+<h2 id="HealthCheck-TlsOptions">HealthCheck.TlsOptions</h2>
+<section>
+<p>Health checks occur over the transport socket specified for the cluster. This implies that if a
+cluster is using a TLS-enabled transport socket, the health check will also occur over TLS.</p>
+
+<p>This allows overriding the cluster TLS settings, just for health check connections.</p>
+
+<table class="message-fields">
+<thead>
+<tr>
+<th>Field</th>
+<th>Type</th>
+<th>Description</th>
+<th>Required</th>
+</tr>
+</thead>
+<tbody>
+<tr id="HealthCheck-TlsOptions-alpn_protocols">
+<td><code>alpnProtocols</code></td>
+<td><code>string[]</code></td>
+<td>
 </td>
 <td>
 No
@@ -1955,3 +2569,54 @@ used, all other fields in <code>ClientTLSSettings</code> should be empty.</p>
 </tbody>
 </table>
 </section>
+<h2 id="HealthStatus">HealthStatus</h2>
+<section>
+<p>Endpoint health status.</p>
+
+<table class="enum-values">
+<thead>
+<tr>
+<th>Name</th>
+<th>Description</th>
+</tr>
+</thead>
+<tbody>
+<tr id="HealthStatus-UNKNOWN">
+<td><code>UNKNOWN</code></td>
+<td>
+<p>The health status is not known. This is interpreted by Envoy as <em>HEALTHY</em>.</p>
+
+</td>
+</tr>
+<tr id="HealthStatus-HEALTHY">
+<td><code>HEALTHY</code></td>
+<td>
+<p>Healthy.</p>
+
+</td>
+</tr>
+<tr id="HealthStatus-UNHEALTHY">
+<td><code>UNHEALTHY</code></td>
+<td>
+<p>Unhealthy.</p>
+
+</td>
+</tr>
+<tr id="HealthStatus-DRAINING">
+<td><code>DRAINING</code></td>
+<td>
+</td>
+</tr>
+<tr id="HealthStatus-TIMEOUT">
+<td><code>TIMEOUT</code></td>
+<td>
+</td>
+</tr>
+<tr id="HealthStatus-DEGRADED">
+<td><code>DEGRADED</code></td>
+<td>
+</td>
+</tr>
+</tbody>
+</table>
+</section>
diff --git a/networking/v1alpha3/destination_rule.proto b/networking/v1alpha3/destination_rule.proto
index 57e72c32..05e5ebc9 100644
--- a/networking/v1alpha3/destination_rule.proto
+++ b/networking/v1alpha3/destination_rule.proto
@@ -274,6 +274,8 @@ message TrafficPolicy {
 
     // TLS related settings for connections to the upstream service.
     ClientTLSSettings tls = 5;
+
+    repeated HealthCheck health_checks = 101;
   }
 
   // Traffic policies specific to individual ports. Note that port level
@@ -282,6 +284,8 @@ message TrafficPolicy {
   // overridden by port-level settings, i.e. default values will be applied
   // to fields omitted in port-level traffic policies.
   repeated PortTrafficPolicy port_level_settings = 5;
+
+  repeated HealthCheck health_checks = 101;
 }
 
 // A subset of endpoints of a service. Subsets can be used for scenarios
@@ -518,6 +522,13 @@ message LoadBalancerSettings {
   // Locality load balancer settings, this will override mesh wide settings in entirety, meaning no merging would be performed
   // between this object and the object one in MeshConfig
   LocalityLoadBalancerSetting locality_lb_setting = 3;
+
+  // Represents the warmup duration of Service. If set, the newly created endpoint of service
+  // remains in warmup mode starting from its creation time for the duration of this window and
+  // Istio progressively increases amount of traffic for that endpoint instead of sending proportional amount of traffic.
+  // This should be enabled for services that require warm up time to serve full production load with reasonable latency.
+  // Currently this is only supported for ROUND_ROBIN and LEAST_CONN load balancers.
+  google.protobuf.Duration warmup_duration_secs = 4;
 }
 
 // Connection pool settings for an upstream host. The settings apply to
@@ -1124,3 +1135,194 @@ message LocalityLoadBalancerSetting{
     // e.g. true means that turn on locality load balancing for this DestinationRule no matter what mesh wide settings is.
     google.protobuf.BoolValue enabled = 3;
 }
+
+
+// Added by Ingress
+message Int64Range {
+    // start of the range (inclusive)
+    int64 start = 1;
+  
+    // end of the range (exclusive)
+    int64 end = 2;
+}
+
+// Endpoint health status.
+enum HealthStatus {
+  // The health status is not known. This is interpreted by Envoy as *HEALTHY*.
+  UNKNOWN = 0;
+
+  // Healthy.
+  HEALTHY = 1;
+
+  // Unhealthy.
+  UNHEALTHY = 2;
+
+  DRAINING = 3;
+
+  TIMEOUT = 4;
+
+  DEGRADED = 5;
+}
+
+message HealthStatusSet {
+  // An order-independent set of health status.
+  repeated HealthStatus statuses = 1;
+}
+
+message Payload {
+  oneof payload {
+    string text = 1;
+
+    bytes binary = 2;
+  }
+}
+
+// [#next-free-field: 25]
+message HealthCheck {
+  // Describes the encoding of the payload bytes in the payload.
+
+  // [#next-free-field: 13]
+  message HttpHealthCheck {
+    reserved 5, 7;
+
+    reserved "service_name", "use_http2";
+
+    string host = 1;
+
+    // Specifies the HTTP path that will be requested during health checking.
+    string path = 2;
+
+    Payload send = 3;
+
+    Payload receive = 4;
+
+    reserved 6, 8;
+
+    // Specifies a list of HTTP response statuses considered healthy. If provided, replaces default
+    // 200-only policy - 200 must be included explicitly as needed. Ranges follow half-open
+    // semantics of :ref:`Int64Range <envoy_v3_api_msg_type.v3.Int64Range>`. The start and end of each
+    // range are required. Only statuses in the range [100, 600) are allowed.
+    repeated Int64Range expected_statuses = 9;
+
+    repeated Int64Range retriable_statuses = 12;
+  }
+
+  message TcpHealthCheck {
+    // Empty payloads imply a connect-only health check.
+    Payload send = 1;
+
+    repeated Payload receive = 2;
+  }
+
+  message RedisHealthCheck {
+    string key = 1;
+  }
+
+  message GrpcHealthCheck {
+    string service_name = 1;
+
+    string authority = 2;
+    
+
+    reserved 3;
+  }
+
+  // Custom health check.
+  message CustomHealthCheck {
+    reserved 2;
+
+    reserved "config";
+
+    // The registered name of the custom health checker.
+    string name = 1 ;
+  }
+
+  // Health checks occur over the transport socket specified for the cluster. This implies that if a
+  // cluster is using a TLS-enabled transport socket, the health check will also occur over TLS.
+  //
+  // This allows overriding the cluster TLS settings, just for health check connections.
+  message TlsOptions {
+    repeated string alpn_protocols = 1;
+  }
+
+  reserved 10;
+
+  // The time to wait for a health check response. If the timeout is reached the
+  // health check attempt will be considered a failure.
+  google.protobuf.Duration timeout = 1;
+
+  // The interval between health checks.
+  google.protobuf.Duration interval = 2;
+
+  // An optional jitter amount in milliseconds. If specified, Envoy will start health
+  // checking after for a random time in ms between 0 and initial_jitter. This only
+  // applies to the first health check.
+  google.protobuf.Duration initial_jitter = 20;
+
+  // An optional jitter amount in milliseconds. If specified, during every
+  // interval Envoy will add interval_jitter to the wait time.
+  google.protobuf.Duration interval_jitter = 3;
+
+  // An optional jitter amount as a percentage of interval_ms. If specified,
+  // during every interval Envoy will add interval_ms *
+  // interval_jitter_percent / 100 to the wait time.
+  //
+  // If interval_jitter_ms and interval_jitter_percent are both set, both of
+  // them will be used to increase the wait time.
+  uint32 interval_jitter_percent = 18;
+
+  // The number of unhealthy health checks required before a host is marked
+  // unhealthy. Note that for *http* health checking if a host responds with a code not in
+  google.protobuf.UInt32Value unhealthy_threshold = 4;
+
+  // The number of healthy health checks required before a host is marked
+  // healthy. Note that during startup, only a single successful health check is
+  // required to mark a host healthy.
+  google.protobuf.UInt32Value healthy_threshold = 5;
+
+  google.protobuf.UInt32Value alt_port = 6;
+
+  google.protobuf.BoolValue reuse_connection = 7;
+
+  oneof health_checker {
+    // HTTP health check.
+    HttpHealthCheck http_health_check = 8;
+
+    // TCP health check.
+    TcpHealthCheck tcp_health_check = 9;
+
+    // gRPC health check.
+    GrpcHealthCheck grpc_health_check = 11;
+
+    // Custom health check.
+    CustomHealthCheck custom_health_check = 13;
+  }
+
+  // The default value for "no traffic interval" is 60 seconds.
+  google.protobuf.Duration no_traffic_interval = 12;
+
+  // If no_traffic_healthy_interval is not set, it will default to the
+  // no traffic interval and send that interval regardless of health state.
+  google.protobuf.Duration no_traffic_healthy_interval = 24;
+
+  // The default value for "unhealthy interval" is the same as "interval".
+  google.protobuf.Duration unhealthy_interval = 14;
+
+  // The default value for "unhealthy edge interval" is the same as "unhealthy interval".
+  google.protobuf.Duration unhealthy_edge_interval = 15;
+
+  // The default value for "healthy edge interval" is the same as the default interval.
+  google.protobuf.Duration healthy_edge_interval = 16;
+
+  // Specifies the path to the :ref:`health check event log <arch_overview_health_check_logging>`.
+  // If empty, no event log will be written.
+  string event_log_path = 17;
+
+  reserved 22;
+
+  bool always_log_health_check_failures = 19;
+
+  // This allows overriding the cluster TLS settings, just for health check connections.
+  TlsOptions tls_options = 21;
+}
+// End Added
\ No newline at end of file
diff --git a/networking/v1alpha3/destination_rule_deepcopy.gen.go b/networking/v1alpha3/destination_rule_deepcopy.gen.go
index f3fa5ccd..bf8ea4d1 100644
--- a/networking/v1alpha3/destination_rule_deepcopy.gen.go
+++ b/networking/v1alpha3/destination_rule_deepcopy.gen.go
@@ -492,3 +492,213 @@ func (in *LocalityLoadBalancerSetting_Failover) DeepCopy() *LocalityLoadBalancer
 func (in *LocalityLoadBalancerSetting_Failover) DeepCopyInterface() interface{} {
 	return in.DeepCopy()
 }
+
+// DeepCopyInto supports using Int64Range within kubernetes types, where deepcopy-gen is used.
+func (in *Int64Range) DeepCopyInto(out *Int64Range) {
+	p := proto.Clone(in).(*Int64Range)
+	*out = *p
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Int64Range. Required by controller-gen.
+func (in *Int64Range) DeepCopy() *Int64Range {
+	if in == nil {
+		return nil
+	}
+	out := new(Int64Range)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInterface is an autogenerated deepcopy function, copying the receiver, creating a new Int64Range. Required by controller-gen.
+func (in *Int64Range) DeepCopyInterface() interface{} {
+	return in.DeepCopy()
+}
+
+// DeepCopyInto supports using HealthStatusSet within kubernetes types, where deepcopy-gen is used.
+func (in *HealthStatusSet) DeepCopyInto(out *HealthStatusSet) {
+	p := proto.Clone(in).(*HealthStatusSet)
+	*out = *p
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new HealthStatusSet. Required by controller-gen.
+func (in *HealthStatusSet) DeepCopy() *HealthStatusSet {
+	if in == nil {
+		return nil
+	}
+	out := new(HealthStatusSet)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInterface is an autogenerated deepcopy function, copying the receiver, creating a new HealthStatusSet. Required by controller-gen.
+func (in *HealthStatusSet) DeepCopyInterface() interface{} {
+	return in.DeepCopy()
+}
+
+// DeepCopyInto supports using Payload within kubernetes types, where deepcopy-gen is used.
+func (in *Payload) DeepCopyInto(out *Payload) {
+	p := proto.Clone(in).(*Payload)
+	*out = *p
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Payload. Required by controller-gen.
+func (in *Payload) DeepCopy() *Payload {
+	if in == nil {
+		return nil
+	}
+	out := new(Payload)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInterface is an autogenerated deepcopy function, copying the receiver, creating a new Payload. Required by controller-gen.
+func (in *Payload) DeepCopyInterface() interface{} {
+	return in.DeepCopy()
+}
+
+// DeepCopyInto supports using HealthCheck within kubernetes types, where deepcopy-gen is used.
+func (in *HealthCheck) DeepCopyInto(out *HealthCheck) {
+	p := proto.Clone(in).(*HealthCheck)
+	*out = *p
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new HealthCheck. Required by controller-gen.
+func (in *HealthCheck) DeepCopy() *HealthCheck {
+	if in == nil {
+		return nil
+	}
+	out := new(HealthCheck)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInterface is an autogenerated deepcopy function, copying the receiver, creating a new HealthCheck. Required by controller-gen.
+func (in *HealthCheck) DeepCopyInterface() interface{} {
+	return in.DeepCopy()
+}
+
+// DeepCopyInto supports using HealthCheck_HttpHealthCheck within kubernetes types, where deepcopy-gen is used.
+func (in *HealthCheck_HttpHealthCheck) DeepCopyInto(out *HealthCheck_HttpHealthCheck) {
+	p := proto.Clone(in).(*HealthCheck_HttpHealthCheck)
+	*out = *p
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new HealthCheck_HttpHealthCheck. Required by controller-gen.
+func (in *HealthCheck_HttpHealthCheck) DeepCopy() *HealthCheck_HttpHealthCheck {
+	if in == nil {
+		return nil
+	}
+	out := new(HealthCheck_HttpHealthCheck)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInterface is an autogenerated deepcopy function, copying the receiver, creating a new HealthCheck_HttpHealthCheck. Required by controller-gen.
+func (in *HealthCheck_HttpHealthCheck) DeepCopyInterface() interface{} {
+	return in.DeepCopy()
+}
+
+// DeepCopyInto supports using HealthCheck_TcpHealthCheck within kubernetes types, where deepcopy-gen is used.
+func (in *HealthCheck_TcpHealthCheck) DeepCopyInto(out *HealthCheck_TcpHealthCheck) {
+	p := proto.Clone(in).(*HealthCheck_TcpHealthCheck)
+	*out = *p
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new HealthCheck_TcpHealthCheck. Required by controller-gen.
+func (in *HealthCheck_TcpHealthCheck) DeepCopy() *HealthCheck_TcpHealthCheck {
+	if in == nil {
+		return nil
+	}
+	out := new(HealthCheck_TcpHealthCheck)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInterface is an autogenerated deepcopy function, copying the receiver, creating a new HealthCheck_TcpHealthCheck. Required by controller-gen.
+func (in *HealthCheck_TcpHealthCheck) DeepCopyInterface() interface{} {
+	return in.DeepCopy()
+}
+
+// DeepCopyInto supports using HealthCheck_RedisHealthCheck within kubernetes types, where deepcopy-gen is used.
+func (in *HealthCheck_RedisHealthCheck) DeepCopyInto(out *HealthCheck_RedisHealthCheck) {
+	p := proto.Clone(in).(*HealthCheck_RedisHealthCheck)
+	*out = *p
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new HealthCheck_RedisHealthCheck. Required by controller-gen.
+func (in *HealthCheck_RedisHealthCheck) DeepCopy() *HealthCheck_RedisHealthCheck {
+	if in == nil {
+		return nil
+	}
+	out := new(HealthCheck_RedisHealthCheck)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInterface is an autogenerated deepcopy function, copying the receiver, creating a new HealthCheck_RedisHealthCheck. Required by controller-gen.
+func (in *HealthCheck_RedisHealthCheck) DeepCopyInterface() interface{} {
+	return in.DeepCopy()
+}
+
+// DeepCopyInto supports using HealthCheck_GrpcHealthCheck within kubernetes types, where deepcopy-gen is used.
+func (in *HealthCheck_GrpcHealthCheck) DeepCopyInto(out *HealthCheck_GrpcHealthCheck) {
+	p := proto.Clone(in).(*HealthCheck_GrpcHealthCheck)
+	*out = *p
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new HealthCheck_GrpcHealthCheck. Required by controller-gen.
+func (in *HealthCheck_GrpcHealthCheck) DeepCopy() *HealthCheck_GrpcHealthCheck {
+	if in == nil {
+		return nil
+	}
+	out := new(HealthCheck_GrpcHealthCheck)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInterface is an autogenerated deepcopy function, copying the receiver, creating a new HealthCheck_GrpcHealthCheck. Required by controller-gen.
+func (in *HealthCheck_GrpcHealthCheck) DeepCopyInterface() interface{} {
+	return in.DeepCopy()
+}
+
+// DeepCopyInto supports using HealthCheck_CustomHealthCheck within kubernetes types, where deepcopy-gen is used.
+func (in *HealthCheck_CustomHealthCheck) DeepCopyInto(out *HealthCheck_CustomHealthCheck) {
+	p := proto.Clone(in).(*HealthCheck_CustomHealthCheck)
+	*out = *p
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new HealthCheck_CustomHealthCheck. Required by controller-gen.
+func (in *HealthCheck_CustomHealthCheck) DeepCopy() *HealthCheck_CustomHealthCheck {
+	if in == nil {
+		return nil
+	}
+	out := new(HealthCheck_CustomHealthCheck)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInterface is an autogenerated deepcopy function, copying the receiver, creating a new HealthCheck_CustomHealthCheck. Required by controller-gen.
+func (in *HealthCheck_CustomHealthCheck) DeepCopyInterface() interface{} {
+	return in.DeepCopy()
+}
+
+// DeepCopyInto supports using HealthCheck_TlsOptions within kubernetes types, where deepcopy-gen is used.
+func (in *HealthCheck_TlsOptions) DeepCopyInto(out *HealthCheck_TlsOptions) {
+	p := proto.Clone(in).(*HealthCheck_TlsOptions)
+	*out = *p
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new HealthCheck_TlsOptions. Required by controller-gen.
+func (in *HealthCheck_TlsOptions) DeepCopy() *HealthCheck_TlsOptions {
+	if in == nil {
+		return nil
+	}
+	out := new(HealthCheck_TlsOptions)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInterface is an autogenerated deepcopy function, copying the receiver, creating a new HealthCheck_TlsOptions. Required by controller-gen.
+func (in *HealthCheck_TlsOptions) DeepCopyInterface() interface{} {
+	return in.DeepCopy()
+}
diff --git a/networking/v1alpha3/destination_rule_json.gen.go b/networking/v1alpha3/destination_rule_json.gen.go
index 76a7466a..52172cbf 100644
--- a/networking/v1alpha3/destination_rule_json.gen.go
+++ b/networking/v1alpha3/destination_rule_json.gen.go
@@ -335,6 +335,116 @@ func (this *LocalityLoadBalancerSetting_Failover) UnmarshalJSON(b []byte) error
 	return DestinationRuleUnmarshaler.Unmarshal(bytes.NewReader(b), this)
 }
 
+// MarshalJSON is a custom marshaler for Int64Range
+func (this *Int64Range) MarshalJSON() ([]byte, error) {
+	str, err := DestinationRuleMarshaler.MarshalToString(this)
+	return []byte(str), err
+}
+
+// UnmarshalJSON is a custom unmarshaler for Int64Range
+func (this *Int64Range) UnmarshalJSON(b []byte) error {
+	return DestinationRuleUnmarshaler.Unmarshal(bytes.NewReader(b), this)
+}
+
+// MarshalJSON is a custom marshaler for HealthStatusSet
+func (this *HealthStatusSet) MarshalJSON() ([]byte, error) {
+	str, err := DestinationRuleMarshaler.MarshalToString(this)
+	return []byte(str), err
+}
+
+// UnmarshalJSON is a custom unmarshaler for HealthStatusSet
+func (this *HealthStatusSet) UnmarshalJSON(b []byte) error {
+	return DestinationRuleUnmarshaler.Unmarshal(bytes.NewReader(b), this)
+}
+
+// MarshalJSON is a custom marshaler for Payload
+func (this *Payload) MarshalJSON() ([]byte, error) {
+	str, err := DestinationRuleMarshaler.MarshalToString(this)
+	return []byte(str), err
+}
+
+// UnmarshalJSON is a custom unmarshaler for Payload
+func (this *Payload) UnmarshalJSON(b []byte) error {
+	return DestinationRuleUnmarshaler.Unmarshal(bytes.NewReader(b), this)
+}
+
+// MarshalJSON is a custom marshaler for HealthCheck
+func (this *HealthCheck) MarshalJSON() ([]byte, error) {
+	str, err := DestinationRuleMarshaler.MarshalToString(this)
+	return []byte(str), err
+}
+
+// UnmarshalJSON is a custom unmarshaler for HealthCheck
+func (this *HealthCheck) UnmarshalJSON(b []byte) error {
+	return DestinationRuleUnmarshaler.Unmarshal(bytes.NewReader(b), this)
+}
+
+// MarshalJSON is a custom marshaler for HealthCheck_HttpHealthCheck
+func (this *HealthCheck_HttpHealthCheck) MarshalJSON() ([]byte, error) {
+	str, err := DestinationRuleMarshaler.MarshalToString(this)
+	return []byte(str), err
+}
+
+// UnmarshalJSON is a custom unmarshaler for HealthCheck_HttpHealthCheck
+func (this *HealthCheck_HttpHealthCheck) UnmarshalJSON(b []byte) error {
+	return DestinationRuleUnmarshaler.Unmarshal(bytes.NewReader(b), this)
+}
+
+// MarshalJSON is a custom marshaler for HealthCheck_TcpHealthCheck
+func (this *HealthCheck_TcpHealthCheck) MarshalJSON() ([]byte, error) {
+	str, err := DestinationRuleMarshaler.MarshalToString(this)
+	return []byte(str), err
+}
+
+// UnmarshalJSON is a custom unmarshaler for HealthCheck_TcpHealthCheck
+func (this *HealthCheck_TcpHealthCheck) UnmarshalJSON(b []byte) error {
+	return DestinationRuleUnmarshaler.Unmarshal(bytes.NewReader(b), this)
+}
+
+// MarshalJSON is a custom marshaler for HealthCheck_RedisHealthCheck
+func (this *HealthCheck_RedisHealthCheck) MarshalJSON() ([]byte, error) {
+	str, err := DestinationRuleMarshaler.MarshalToString(this)
+	return []byte(str), err
+}
+
+// UnmarshalJSON is a custom unmarshaler for HealthCheck_RedisHealthCheck
+func (this *HealthCheck_RedisHealthCheck) UnmarshalJSON(b []byte) error {
+	return DestinationRuleUnmarshaler.Unmarshal(bytes.NewReader(b), this)
+}
+
+// MarshalJSON is a custom marshaler for HealthCheck_GrpcHealthCheck
+func (this *HealthCheck_GrpcHealthCheck) MarshalJSON() ([]byte, error) {
+	str, err := DestinationRuleMarshaler.MarshalToString(this)
+	return []byte(str), err
+}
+
+// UnmarshalJSON is a custom unmarshaler for HealthCheck_GrpcHealthCheck
+func (this *HealthCheck_GrpcHealthCheck) UnmarshalJSON(b []byte) error {
+	return DestinationRuleUnmarshaler.Unmarshal(bytes.NewReader(b), this)
+}
+
+// MarshalJSON is a custom marshaler for HealthCheck_CustomHealthCheck
+func (this *HealthCheck_CustomHealthCheck) MarshalJSON() ([]byte, error) {
+	str, err := DestinationRuleMarshaler.MarshalToString(this)
+	return []byte(str), err
+}
+
+// UnmarshalJSON is a custom unmarshaler for HealthCheck_CustomHealthCheck
+func (this *HealthCheck_CustomHealthCheck) UnmarshalJSON(b []byte) error {
+	return DestinationRuleUnmarshaler.Unmarshal(bytes.NewReader(b), this)
+}
+
+// MarshalJSON is a custom marshaler for HealthCheck_TlsOptions
+func (this *HealthCheck_TlsOptions) MarshalJSON() ([]byte, error) {
+	str, err := DestinationRuleMarshaler.MarshalToString(this)
+	return []byte(str), err
+}
+
+// UnmarshalJSON is a custom unmarshaler for HealthCheck_TlsOptions
+func (this *HealthCheck_TlsOptions) UnmarshalJSON(b []byte) error {
+	return DestinationRuleUnmarshaler.Unmarshal(bytes.NewReader(b), this)
+}
+
 var (
 	DestinationRuleMarshaler   = &github_com_gogo_protobuf_jsonpb.Marshaler{}
 	DestinationRuleUnmarshaler = &github_com_gogo_protobuf_jsonpb.Unmarshaler{AllowUnknownFields: true}
diff --git a/networking/v1alpha3/service_subscription_list.gen.json b/networking/v1alpha3/service_subscription_list.gen.json
new file mode 100644
index 00000000..64754550
--- /dev/null
+++ b/networking/v1alpha3/service_subscription_list.gen.json
@@ -0,0 +1,85 @@
+{
+  "openapi": "3.0.0",
+  "info": {
+    "title": "",
+    "version": "v1alpha3"
+  },
+  "components": {
+    "schemas": {
+      "istio.networking.v1alpha3.Port": {
+        "description": "Port describes the properties of a specific port of a service.",
+        "type": "object",
+        "properties": {
+          "number": {
+            "description": "A valid non-negative integer port number.",
+            "type": "integer"
+          },
+          "protocol": {
+            "description": "The protocol exposed on the port. MUST BE one of HTTP|HTTPS|GRPC|HTTP2|MONGO|TCP|TLS. TLS implies the connection will be routed based on the SNI header to the destination without terminating the TLS connection.",
+            "type": "string"
+          },
+          "name": {
+            "description": "Label assigned to the port.",
+            "type": "string"
+          },
+          "targetPort": {
+            "description": "The port number on the endpoint where the traffic will be received. Applicable only when used with ServiceEntries.",
+            "type": "integer"
+          }
+        }
+      },
+      "istio.networking.v1alpha3.ServiceSubscription": {
+        "type": "object",
+        "properties": {
+          "hostname": {
+            "type": "string"
+          },
+          "version": {
+            "type": "string"
+          },
+          "group": {
+            "type": "string"
+          },
+          "port": {
+            "$ref": "#/components/schemas/istio.networking.v1alpha3.Port"
+          },
+          "units": {
+            "type": "array",
+            "items": {
+              "type": "string"
+            }
+          },
+          "labels": {
+            "type": "object",
+            "additionalProperties": {
+              "type": "string"
+            }
+          }
+        }
+      },
+      "istio.networking.v1alpha3.ServiceSubscriptionList": {
+        "description": "\u003c!-- crd generation tags +cue-gen:ServiceSubscriptionList:groupName:networking.istio.io +cue-gen:ServiceSubscriptionList:version:v1alpha3 +cue-gen:ServiceSubscriptionList:storageVersion +cue-gen:ServiceSubscriptionList:annotations:helm.sh/resource-policy=keep +cue-gen:ServiceSubscriptionList:labels:app=istio-pilot,chart=istio,heritage=Tiller,release=istio +cue-gen:ServiceSubscriptionList:subresource:status +cue-gen:ServiceSubscriptionList:scope:Namespaced +cue-gen:ServiceSubscriptionList:resource:categories=istio-io,networking-istio-io +cue-gen:ServiceSubscriptionList:preserveUnknownFields:false --\u003e",
+        "type": "object",
+        "properties": {
+          "resolution": {
+            "$ref": "#/components/schemas/istio.networking.v1alpha3.ServiceSubscriptionList.Resolution"
+          },
+          "subscriptions": {
+            "type": "array",
+            "items": {
+              "$ref": "#/components/schemas/istio.networking.v1alpha3.ServiceSubscription"
+            }
+          }
+        }
+      },
+      "istio.networking.v1alpha3.ServiceSubscriptionList.Resolution": {
+        "type": "string",
+        "enum": [
+          "CONFIGSERVER",
+          "VIPSERVER",
+          "NACOS"
+        ]
+      }
+    }
+  }
+}
\ No newline at end of file
diff --git a/networking/v1alpha3/service_subscription_list.pb.go b/networking/v1alpha3/service_subscription_list.pb.go
new file mode 100644
index 00000000..739ff363
--- /dev/null
+++ b/networking/v1alpha3/service_subscription_list.pb.go
@@ -0,0 +1,997 @@
+// Code generated by protoc-gen-gogo. DO NOT EDIT.
+// source: networking/v1alpha3/service_subscription_list.proto
+
+package v1alpha3
+
+import (
+	fmt "fmt"
+	proto "github.com/gogo/protobuf/proto"
+	io "io"
+	math "math"
+	math_bits "math/bits"
+)
+
+// Reference imports to suppress errors if they are not otherwise used.
+var _ = proto.Marshal
+var _ = fmt.Errorf
+var _ = math.Inf
+
+// This is a compile-time assertion to ensure that this generated file
+// is compatible with the proto package it is being compiled against.
+// A compilation error at this line likely means your copy of the
+// proto package needs to be updated.
+const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package
+
+type ServiceSubscriptionList_Resolution int32
+
+const (
+	ServiceSubscriptionList_CONFIGSERVER ServiceSubscriptionList_Resolution = 0
+	ServiceSubscriptionList_VIPSERVER    ServiceSubscriptionList_Resolution = 1
+	ServiceSubscriptionList_NACOS        ServiceSubscriptionList_Resolution = 2
+)
+
+var ServiceSubscriptionList_Resolution_name = map[int32]string{
+	0: "CONFIGSERVER",
+	1: "VIPSERVER",
+	2: "NACOS",
+}
+
+var ServiceSubscriptionList_Resolution_value = map[string]int32{
+	"CONFIGSERVER": 0,
+	"VIPSERVER":    1,
+	"NACOS":        2,
+}
+
+func (x ServiceSubscriptionList_Resolution) String() string {
+	return proto.EnumName(ServiceSubscriptionList_Resolution_name, int32(x))
+}
+
+func (ServiceSubscriptionList_Resolution) EnumDescriptor() ([]byte, []int) {
+	return fileDescriptor_609e56f44a3ac490, []int{0, 0}
+}
+
+// <!-- crd generation tags
+// +cue-gen:ServiceSubscriptionList:groupName:networking.istio.io
+// +cue-gen:ServiceSubscriptionList:version:v1alpha3
+// +cue-gen:ServiceSubscriptionList:storageVersion
+// +cue-gen:ServiceSubscriptionList:annotations:helm.sh/resource-policy=keep
+// +cue-gen:ServiceSubscriptionList:labels:app=istio-pilot,chart=istio,heritage=Tiller,release=istio
+// +cue-gen:ServiceSubscriptionList:subresource:status
+// +cue-gen:ServiceSubscriptionList:scope:Namespaced
+// +cue-gen:ServiceSubscriptionList:resource:categories=istio-io,networking-istio-io
+// +cue-gen:ServiceSubscriptionList:preserveUnknownFields:false
+// -->
+//
+// <!-- go code generation tags
+// +kubetype-gen
+// +kubetype-gen:groupVersion=networking.istio.io/v1alpha3
+// +genclient
+// +k8s:deepcopy-gen=true
+// -->
+type ServiceSubscriptionList struct {
+	Resolution           ServiceSubscriptionList_Resolution `protobuf:"varint,1,opt,name=resolution,proto3,enum=istio.networking.v1alpha3.ServiceSubscriptionList_Resolution" json:"resolution,omitempty"`
+	Subscriptions        []*ServiceSubscription             `protobuf:"bytes,2,rep,name=subscriptions,proto3" json:"subscriptions,omitempty"`
+	XXX_NoUnkeyedLiteral struct{}                           `json:"-"`
+	XXX_unrecognized     []byte                             `json:"-"`
+	XXX_sizecache        int32                              `json:"-"`
+}
+
+func (m *ServiceSubscriptionList) Reset()         { *m = ServiceSubscriptionList{} }
+func (m *ServiceSubscriptionList) String() string { return proto.CompactTextString(m) }
+func (*ServiceSubscriptionList) ProtoMessage()    {}
+func (*ServiceSubscriptionList) Descriptor() ([]byte, []int) {
+	return fileDescriptor_609e56f44a3ac490, []int{0}
+}
+func (m *ServiceSubscriptionList) XXX_Unmarshal(b []byte) error {
+	return m.Unmarshal(b)
+}
+func (m *ServiceSubscriptionList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	if deterministic {
+		return xxx_messageInfo_ServiceSubscriptionList.Marshal(b, m, deterministic)
+	} else {
+		b = b[:cap(b)]
+		n, err := m.MarshalToSizedBuffer(b)
+		if err != nil {
+			return nil, err
+		}
+		return b[:n], nil
+	}
+}
+func (m *ServiceSubscriptionList) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_ServiceSubscriptionList.Merge(m, src)
+}
+func (m *ServiceSubscriptionList) XXX_Size() int {
+	return m.Size()
+}
+func (m *ServiceSubscriptionList) XXX_DiscardUnknown() {
+	xxx_messageInfo_ServiceSubscriptionList.DiscardUnknown(m)
+}
+
+var xxx_messageInfo_ServiceSubscriptionList proto.InternalMessageInfo
+
+func (m *ServiceSubscriptionList) GetResolution() ServiceSubscriptionList_Resolution {
+	if m != nil {
+		return m.Resolution
+	}
+	return ServiceSubscriptionList_CONFIGSERVER
+}
+
+func (m *ServiceSubscriptionList) GetSubscriptions() []*ServiceSubscription {
+	if m != nil {
+		return m.Subscriptions
+	}
+	return nil
+}
+
+type ServiceSubscription struct {
+	Hostname             string            `protobuf:"bytes,1,opt,name=hostname,proto3" json:"hostname,omitempty"`
+	Version              string            `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
+	Group                string            `protobuf:"bytes,3,opt,name=group,proto3" json:"group,omitempty"`
+	Port                 *Port             `protobuf:"bytes,4,opt,name=port,proto3" json:"port,omitempty"`
+	Units                []string          `protobuf:"bytes,5,rep,name=units,proto3" json:"units,omitempty"`
+	Labels               map[string]string `protobuf:"bytes,6,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
+	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
+	XXX_unrecognized     []byte            `json:"-"`
+	XXX_sizecache        int32             `json:"-"`
+}
+
+func (m *ServiceSubscription) Reset()         { *m = ServiceSubscription{} }
+func (m *ServiceSubscription) String() string { return proto.CompactTextString(m) }
+func (*ServiceSubscription) ProtoMessage()    {}
+func (*ServiceSubscription) Descriptor() ([]byte, []int) {
+	return fileDescriptor_609e56f44a3ac490, []int{1}
+}
+func (m *ServiceSubscription) XXX_Unmarshal(b []byte) error {
+	return m.Unmarshal(b)
+}
+func (m *ServiceSubscription) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	if deterministic {
+		return xxx_messageInfo_ServiceSubscription.Marshal(b, m, deterministic)
+	} else {
+		b = b[:cap(b)]
+		n, err := m.MarshalToSizedBuffer(b)
+		if err != nil {
+			return nil, err
+		}
+		return b[:n], nil
+	}
+}
+func (m *ServiceSubscription) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_ServiceSubscription.Merge(m, src)
+}
+func (m *ServiceSubscription) XXX_Size() int {
+	return m.Size()
+}
+func (m *ServiceSubscription) XXX_DiscardUnknown() {
+	xxx_messageInfo_ServiceSubscription.DiscardUnknown(m)
+}
+
+var xxx_messageInfo_ServiceSubscription proto.InternalMessageInfo
+
+func (m *ServiceSubscription) GetHostname() string {
+	if m != nil {
+		return m.Hostname
+	}
+	return ""
+}
+
+func (m *ServiceSubscription) GetVersion() string {
+	if m != nil {
+		return m.Version
+	}
+	return ""
+}
+
+func (m *ServiceSubscription) GetGroup() string {
+	if m != nil {
+		return m.Group
+	}
+	return ""
+}
+
+func (m *ServiceSubscription) GetPort() *Port {
+	if m != nil {
+		return m.Port
+	}
+	return nil
+}
+
+func (m *ServiceSubscription) GetUnits() []string {
+	if m != nil {
+		return m.Units
+	}
+	return nil
+}
+
+func (m *ServiceSubscription) GetLabels() map[string]string {
+	if m != nil {
+		return m.Labels
+	}
+	return nil
+}
+
+func init() {
+	proto.RegisterEnum("istio.networking.v1alpha3.ServiceSubscriptionList_Resolution", ServiceSubscriptionList_Resolution_name, ServiceSubscriptionList_Resolution_value)
+	proto.RegisterType((*ServiceSubscriptionList)(nil), "istio.networking.v1alpha3.ServiceSubscriptionList")
+	proto.RegisterType((*ServiceSubscription)(nil), "istio.networking.v1alpha3.ServiceSubscription")
+	proto.RegisterMapType((map[string]string)(nil), "istio.networking.v1alpha3.ServiceSubscription.LabelsEntry")
+}
+
+func init() {
+	proto.RegisterFile("networking/v1alpha3/service_subscription_list.proto", fileDescriptor_609e56f44a3ac490)
+}
+
+var fileDescriptor_609e56f44a3ac490 = []byte{
+	// 401 bytes of a gzipped FileDescriptorProto
+	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x92, 0xc1, 0x8a, 0xd3, 0x40,
+	0x1c, 0xc6, 0x9d, 0x64, 0x5b, 0xed, 0xbf, 0xae, 0x84, 0x51, 0x30, 0xf6, 0x50, 0x63, 0x4f, 0x3d,
+	0x4d, 0xb0, 0xb9, 0xac, 0x0b, 0x1e, 0x74, 0xa9, 0xb2, 0xb0, 0xec, 0x2e, 0x13, 0xd9, 0x83, 0x20,
+	0x65, 0x5a, 0x86, 0x76, 0x68, 0xcc, 0x84, 0x99, 0x49, 0x4a, 0xdf, 0xc0, 0x77, 0xf2, 0x05, 0x3c,
+	0xfa, 0x08, 0xd2, 0x27, 0x91, 0x4c, 0xd2, 0x36, 0x42, 0x2b, 0xf4, 0x96, 0xef, 0x9f, 0xf9, 0xff,
+	0xbe, 0xf9, 0x3e, 0x06, 0xa2, 0x94, 0x9b, 0x95, 0x54, 0x4b, 0x91, 0xce, 0xc3, 0xe2, 0x2d, 0x4b,
+	0xb2, 0x05, 0x8b, 0x42, 0xcd, 0x55, 0x21, 0x66, 0x7c, 0xa2, 0xf3, 0xa9, 0x9e, 0x29, 0x91, 0x19,
+	0x21, 0xd3, 0x49, 0x22, 0xb4, 0x21, 0x99, 0x92, 0x46, 0xe2, 0x57, 0x42, 0x1b, 0x21, 0xc9, 0x7e,
+	0x95, 0x6c, 0x57, 0x7b, 0x6f, 0x0e, 0xf1, 0xe6, 0xcc, 0xf0, 0x15, 0x5b, 0x57, 0xdb, 0x83, 0x1f,
+	0x0e, 0xbc, 0x8c, 0x2b, 0x87, 0xb8, 0x61, 0x70, 0x23, 0xb4, 0xc1, 0xdf, 0x00, 0x14, 0xd7, 0x32,
+	0xc9, 0xcb, 0x89, 0x8f, 0x02, 0x34, 0x7c, 0x36, 0x7a, 0x4f, 0x8e, 0xda, 0x91, 0x23, 0x1c, 0x42,
+	0x77, 0x10, 0xda, 0x00, 0xe2, 0x2f, 0x70, 0xde, 0xcc, 0xa4, 0x7d, 0x27, 0x70, 0x87, 0xdd, 0x11,
+	0x39, 0xcd, 0x81, 0xfe, 0x0b, 0x19, 0x5c, 0x00, 0xec, 0xfd, 0xb0, 0x07, 0x4f, 0xaf, 0xee, 0x6e,
+	0x3f, 0x5d, 0x7f, 0x8e, 0xc7, 0xf4, 0x61, 0x4c, 0xbd, 0x47, 0xf8, 0x1c, 0x3a, 0x0f, 0xd7, 0xf7,
+	0xb5, 0x44, 0xb8, 0x03, 0xad, 0xdb, 0x0f, 0x57, 0x77, 0xb1, 0xe7, 0x0c, 0x7e, 0x3a, 0xf0, 0xfc,
+	0x80, 0x01, 0xee, 0xc1, 0x93, 0x85, 0xd4, 0x26, 0x65, 0xdf, 0xb9, 0x2d, 0xa1, 0x43, 0x77, 0x1a,
+	0xfb, 0xf0, 0xb8, 0xe0, 0x4a, 0x97, 0xfd, 0x38, 0xf6, 0xd7, 0x56, 0xe2, 0x17, 0xd0, 0x9a, 0x2b,
+	0x99, 0x67, 0xbe, 0x6b, 0xe7, 0x95, 0xc0, 0x11, 0x9c, 0x65, 0x52, 0x19, 0xff, 0x2c, 0x40, 0xc3,
+	0xee, 0xe8, 0xf5, 0x7f, 0xa2, 0xde, 0x4b, 0x65, 0xa8, 0x3d, 0x5c, 0xa2, 0xf2, 0x54, 0x18, 0xed,
+	0xb7, 0x02, 0xb7, 0x44, 0x59, 0x81, 0x29, 0xb4, 0x13, 0x36, 0xe5, 0x89, 0xf6, 0xdb, 0xb6, 0xb7,
+	0xcb, 0xd3, 0x7a, 0x23, 0x37, 0x76, 0x79, 0x9c, 0x1a, 0xb5, 0xa6, 0x35, 0xa9, 0xf7, 0x0e, 0xba,
+	0x8d, 0x31, 0xf6, 0xc0, 0x5d, 0xf2, 0x75, 0x1d, 0xba, 0xfc, 0x2c, 0xaf, 0x52, 0xb0, 0x24, 0xe7,
+	0x75, 0xda, 0x4a, 0x5c, 0x3a, 0x17, 0xe8, 0x23, 0xf9, 0xb5, 0xe9, 0xa3, 0xdf, 0x9b, 0x3e, 0xfa,
+	0xb3, 0xe9, 0xa3, 0xaf, 0x41, 0x75, 0x17, 0x21, 0x43, 0x96, 0x89, 0xf0, 0xc0, 0x33, 0x9c, 0xb6,
+	0xed, 0xfb, 0x8b, 0xfe, 0x06, 0x00, 0x00, 0xff, 0xff, 0xbc, 0x7f, 0x26, 0x38, 0xf4, 0x02, 0x00,
+	0x00,
+}
+
+func (m *ServiceSubscriptionList) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *ServiceSubscriptionList) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *ServiceSubscriptionList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
+	var l int
+	_ = l
+	if m.XXX_unrecognized != nil {
+		i -= len(m.XXX_unrecognized)
+		copy(dAtA[i:], m.XXX_unrecognized)
+	}
+	if len(m.Subscriptions) > 0 {
+		for iNdEx := len(m.Subscriptions) - 1; iNdEx >= 0; iNdEx-- {
+			{
+				size, err := m.Subscriptions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
+				if err != nil {
+					return 0, err
+				}
+				i -= size
+				i = encodeVarintServiceSubscriptionList(dAtA, i, uint64(size))
+			}
+			i--
+			dAtA[i] = 0x12
+		}
+	}
+	if m.Resolution != 0 {
+		i = encodeVarintServiceSubscriptionList(dAtA, i, uint64(m.Resolution))
+		i--
+		dAtA[i] = 0x8
+	}
+	return len(dAtA) - i, nil
+}
+
+func (m *ServiceSubscription) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *ServiceSubscription) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *ServiceSubscription) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
+	var l int
+	_ = l
+	if m.XXX_unrecognized != nil {
+		i -= len(m.XXX_unrecognized)
+		copy(dAtA[i:], m.XXX_unrecognized)
+	}
+	if len(m.Labels) > 0 {
+		for k := range m.Labels {
+			v := m.Labels[k]
+			baseI := i
+			i -= len(v)
+			copy(dAtA[i:], v)
+			i = encodeVarintServiceSubscriptionList(dAtA, i, uint64(len(v)))
+			i--
+			dAtA[i] = 0x12
+			i -= len(k)
+			copy(dAtA[i:], k)
+			i = encodeVarintServiceSubscriptionList(dAtA, i, uint64(len(k)))
+			i--
+			dAtA[i] = 0xa
+			i = encodeVarintServiceSubscriptionList(dAtA, i, uint64(baseI-i))
+			i--
+			dAtA[i] = 0x32
+		}
+	}
+	if len(m.Units) > 0 {
+		for iNdEx := len(m.Units) - 1; iNdEx >= 0; iNdEx-- {
+			i -= len(m.Units[iNdEx])
+			copy(dAtA[i:], m.Units[iNdEx])
+			i = encodeVarintServiceSubscriptionList(dAtA, i, uint64(len(m.Units[iNdEx])))
+			i--
+			dAtA[i] = 0x2a
+		}
+	}
+	if m.Port != nil {
+		{
+			size, err := m.Port.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintServiceSubscriptionList(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x22
+	}
+	if len(m.Group) > 0 {
+		i -= len(m.Group)
+		copy(dAtA[i:], m.Group)
+		i = encodeVarintServiceSubscriptionList(dAtA, i, uint64(len(m.Group)))
+		i--
+		dAtA[i] = 0x1a
+	}
+	if len(m.Version) > 0 {
+		i -= len(m.Version)
+		copy(dAtA[i:], m.Version)
+		i = encodeVarintServiceSubscriptionList(dAtA, i, uint64(len(m.Version)))
+		i--
+		dAtA[i] = 0x12
+	}
+	if len(m.Hostname) > 0 {
+		i -= len(m.Hostname)
+		copy(dAtA[i:], m.Hostname)
+		i = encodeVarintServiceSubscriptionList(dAtA, i, uint64(len(m.Hostname)))
+		i--
+		dAtA[i] = 0xa
+	}
+	return len(dAtA) - i, nil
+}
+
+func encodeVarintServiceSubscriptionList(dAtA []byte, offset int, v uint64) int {
+	offset -= sovServiceSubscriptionList(v)
+	base := offset
+	for v >= 1<<7 {
+		dAtA[offset] = uint8(v&0x7f | 0x80)
+		v >>= 7
+		offset++
+	}
+	dAtA[offset] = uint8(v)
+	return base
+}
+func (m *ServiceSubscriptionList) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if m.Resolution != 0 {
+		n += 1 + sovServiceSubscriptionList(uint64(m.Resolution))
+	}
+	if len(m.Subscriptions) > 0 {
+		for _, e := range m.Subscriptions {
+			l = e.Size()
+			n += 1 + l + sovServiceSubscriptionList(uint64(l))
+		}
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *ServiceSubscription) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	l = len(m.Hostname)
+	if l > 0 {
+		n += 1 + l + sovServiceSubscriptionList(uint64(l))
+	}
+	l = len(m.Version)
+	if l > 0 {
+		n += 1 + l + sovServiceSubscriptionList(uint64(l))
+	}
+	l = len(m.Group)
+	if l > 0 {
+		n += 1 + l + sovServiceSubscriptionList(uint64(l))
+	}
+	if m.Port != nil {
+		l = m.Port.Size()
+		n += 1 + l + sovServiceSubscriptionList(uint64(l))
+	}
+	if len(m.Units) > 0 {
+		for _, s := range m.Units {
+			l = len(s)
+			n += 1 + l + sovServiceSubscriptionList(uint64(l))
+		}
+	}
+	if len(m.Labels) > 0 {
+		for k, v := range m.Labels {
+			_ = k
+			_ = v
+			mapEntrySize := 1 + len(k) + sovServiceSubscriptionList(uint64(len(k))) + 1 + len(v) + sovServiceSubscriptionList(uint64(len(v)))
+			n += mapEntrySize + 1 + sovServiceSubscriptionList(uint64(mapEntrySize))
+		}
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func sovServiceSubscriptionList(x uint64) (n int) {
+	return (math_bits.Len64(x|1) + 6) / 7
+}
+func sozServiceSubscriptionList(x uint64) (n int) {
+	return sovServiceSubscriptionList(uint64((x << 1) ^ uint64((int64(x) >> 63))))
+}
+func (m *ServiceSubscriptionList) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowServiceSubscriptionList
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: ServiceSubscriptionList: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: ServiceSubscriptionList: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Resolution", wireType)
+			}
+			m.Resolution = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowServiceSubscriptionList
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.Resolution |= ServiceSubscriptionList_Resolution(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Subscriptions", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowServiceSubscriptionList
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthServiceSubscriptionList
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthServiceSubscriptionList
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Subscriptions = append(m.Subscriptions, &ServiceSubscription{})
+			if err := m.Subscriptions[len(m.Subscriptions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipServiceSubscriptionList(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthServiceSubscriptionList
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *ServiceSubscription) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowServiceSubscriptionList
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: ServiceSubscription: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: ServiceSubscription: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowServiceSubscriptionList
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthServiceSubscriptionList
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthServiceSubscriptionList
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Hostname = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowServiceSubscriptionList
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthServiceSubscriptionList
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthServiceSubscriptionList
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Version = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 3:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowServiceSubscriptionList
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthServiceSubscriptionList
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthServiceSubscriptionList
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Group = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 4:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowServiceSubscriptionList
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthServiceSubscriptionList
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthServiceSubscriptionList
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.Port == nil {
+				m.Port = &Port{}
+			}
+			if err := m.Port.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 5:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Units", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowServiceSubscriptionList
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthServiceSubscriptionList
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthServiceSubscriptionList
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Units = append(m.Units, string(dAtA[iNdEx:postIndex]))
+			iNdEx = postIndex
+		case 6:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowServiceSubscriptionList
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthServiceSubscriptionList
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthServiceSubscriptionList
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.Labels == nil {
+				m.Labels = make(map[string]string)
+			}
+			var mapkey string
+			var mapvalue string
+			for iNdEx < postIndex {
+				entryPreIndex := iNdEx
+				var wire uint64
+				for shift := uint(0); ; shift += 7 {
+					if shift >= 64 {
+						return ErrIntOverflowServiceSubscriptionList
+					}
+					if iNdEx >= l {
+						return io.ErrUnexpectedEOF
+					}
+					b := dAtA[iNdEx]
+					iNdEx++
+					wire |= uint64(b&0x7F) << shift
+					if b < 0x80 {
+						break
+					}
+				}
+				fieldNum := int32(wire >> 3)
+				if fieldNum == 1 {
+					var stringLenmapkey uint64
+					for shift := uint(0); ; shift += 7 {
+						if shift >= 64 {
+							return ErrIntOverflowServiceSubscriptionList
+						}
+						if iNdEx >= l {
+							return io.ErrUnexpectedEOF
+						}
+						b := dAtA[iNdEx]
+						iNdEx++
+						stringLenmapkey |= uint64(b&0x7F) << shift
+						if b < 0x80 {
+							break
+						}
+					}
+					intStringLenmapkey := int(stringLenmapkey)
+					if intStringLenmapkey < 0 {
+						return ErrInvalidLengthServiceSubscriptionList
+					}
+					postStringIndexmapkey := iNdEx + intStringLenmapkey
+					if postStringIndexmapkey < 0 {
+						return ErrInvalidLengthServiceSubscriptionList
+					}
+					if postStringIndexmapkey > l {
+						return io.ErrUnexpectedEOF
+					}
+					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
+					iNdEx = postStringIndexmapkey
+				} else if fieldNum == 2 {
+					var stringLenmapvalue uint64
+					for shift := uint(0); ; shift += 7 {
+						if shift >= 64 {
+							return ErrIntOverflowServiceSubscriptionList
+						}
+						if iNdEx >= l {
+							return io.ErrUnexpectedEOF
+						}
+						b := dAtA[iNdEx]
+						iNdEx++
+						stringLenmapvalue |= uint64(b&0x7F) << shift
+						if b < 0x80 {
+							break
+						}
+					}
+					intStringLenmapvalue := int(stringLenmapvalue)
+					if intStringLenmapvalue < 0 {
+						return ErrInvalidLengthServiceSubscriptionList
+					}
+					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
+					if postStringIndexmapvalue < 0 {
+						return ErrInvalidLengthServiceSubscriptionList
+					}
+					if postStringIndexmapvalue > l {
+						return io.ErrUnexpectedEOF
+					}
+					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
+					iNdEx = postStringIndexmapvalue
+				} else {
+					iNdEx = entryPreIndex
+					skippy, err := skipServiceSubscriptionList(dAtA[iNdEx:])
+					if err != nil {
+						return err
+					}
+					if (skippy < 0) || (iNdEx+skippy) < 0 {
+						return ErrInvalidLengthServiceSubscriptionList
+					}
+					if (iNdEx + skippy) > postIndex {
+						return io.ErrUnexpectedEOF
+					}
+					iNdEx += skippy
+				}
+			}
+			m.Labels[mapkey] = mapvalue
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipServiceSubscriptionList(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthServiceSubscriptionList
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func skipServiceSubscriptionList(dAtA []byte) (n int, err error) {
+	l := len(dAtA)
+	iNdEx := 0
+	depth := 0
+	for iNdEx < l {
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return 0, ErrIntOverflowServiceSubscriptionList
+			}
+			if iNdEx >= l {
+				return 0, io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= (uint64(b) & 0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		wireType := int(wire & 0x7)
+		switch wireType {
+		case 0:
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return 0, ErrIntOverflowServiceSubscriptionList
+				}
+				if iNdEx >= l {
+					return 0, io.ErrUnexpectedEOF
+				}
+				iNdEx++
+				if dAtA[iNdEx-1] < 0x80 {
+					break
+				}
+			}
+		case 1:
+			iNdEx += 8
+		case 2:
+			var length int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return 0, ErrIntOverflowServiceSubscriptionList
+				}
+				if iNdEx >= l {
+					return 0, io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				length |= (int(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if length < 0 {
+				return 0, ErrInvalidLengthServiceSubscriptionList
+			}
+			iNdEx += length
+		case 3:
+			depth++
+		case 4:
+			if depth == 0 {
+				return 0, ErrUnexpectedEndOfGroupServiceSubscriptionList
+			}
+			depth--
+		case 5:
+			iNdEx += 4
+		default:
+			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
+		}
+		if iNdEx < 0 {
+			return 0, ErrInvalidLengthServiceSubscriptionList
+		}
+		if depth == 0 {
+			return iNdEx, nil
+		}
+	}
+	return 0, io.ErrUnexpectedEOF
+}
+
+var (
+	ErrInvalidLengthServiceSubscriptionList        = fmt.Errorf("proto: negative length found during unmarshaling")
+	ErrIntOverflowServiceSubscriptionList          = fmt.Errorf("proto: integer overflow")
+	ErrUnexpectedEndOfGroupServiceSubscriptionList = fmt.Errorf("proto: unexpected end of group")
+)
diff --git a/networking/v1alpha3/service_subscription_list.pb.html b/networking/v1alpha3/service_subscription_list.pb.html
new file mode 100644
index 00000000..f69095c2
--- /dev/null
+++ b/networking/v1alpha3/service_subscription_list.pb.html
@@ -0,0 +1,137 @@
+---
+title: istio.networking.v1alpha3
+layout: protoc-gen-docs
+generator: protoc-gen-docs
+number_of_entries: 3
+---
+<h2 id="ServiceSubscriptionList">ServiceSubscriptionList</h2>
+<section>
+
+<table class="message-fields">
+<thead>
+<tr>
+<th>Field</th>
+<th>Type</th>
+<th>Description</th>
+<th>Required</th>
+</tr>
+</thead>
+<tbody>
+<tr id="ServiceSubscriptionList-resolution">
+<td><code>resolution</code></td>
+<td><code><a href="https://istio.io/docs/reference/config/networking/virtual-service.html#ServiceSubscriptionList-Resolution">Resolution</a></code></td>
+<td>
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="ServiceSubscriptionList-subscriptions">
+<td><code>subscriptions</code></td>
+<td><code><a href="https://istio.io/docs/reference/config/networking/virtual-service.html#ServiceSubscription">ServiceSubscription[]</a></code></td>
+<td>
+</td>
+<td>
+No
+</td>
+</tr>
+</tbody>
+</table>
+</section>
+<h2 id="ServiceSubscription">ServiceSubscription</h2>
+<section>
+<table class="message-fields">
+<thead>
+<tr>
+<th>Field</th>
+<th>Type</th>
+<th>Description</th>
+<th>Required</th>
+</tr>
+</thead>
+<tbody>
+<tr id="ServiceSubscription-hostname">
+<td><code>hostname</code></td>
+<td><code>string</code></td>
+<td>
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="ServiceSubscription-version">
+<td><code>version</code></td>
+<td><code>string</code></td>
+<td>
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="ServiceSubscription-group">
+<td><code>group</code></td>
+<td><code>string</code></td>
+<td>
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="ServiceSubscription-port">
+<td><code>port</code></td>
+<td><code><a href="https://istio.io/docs/reference/config/networking/gateway.html#Port">Port</a></code></td>
+<td>
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="ServiceSubscription-units">
+<td><code>units</code></td>
+<td><code>string[]</code></td>
+<td>
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="ServiceSubscription-labels">
+<td><code>labels</code></td>
+<td><code>map&lt;string,&nbsp;string&gt;</code></td>
+<td>
+</td>
+<td>
+No
+</td>
+</tr>
+</tbody>
+</table>
+</section>
+<h2 id="ServiceSubscriptionList-Resolution">ServiceSubscriptionList.Resolution</h2>
+<section>
+<table class="enum-values">
+<thead>
+<tr>
+<th>Name</th>
+<th>Description</th>
+</tr>
+</thead>
+<tbody>
+<tr id="ServiceSubscriptionList-Resolution-CONFIGSERVER">
+<td><code>CONFIGSERVER</code></td>
+<td>
+</td>
+</tr>
+<tr id="ServiceSubscriptionList-Resolution-VIPSERVER">
+<td><code>VIPSERVER</code></td>
+<td>
+</td>
+</tr>
+<tr id="ServiceSubscriptionList-Resolution-NACOS">
+<td><code>NACOS</code></td>
+<td>
+</td>
+</tr>
+</tbody>
+</table>
+</section>
diff --git a/networking/v1alpha3/service_subscription_list.proto b/networking/v1alpha3/service_subscription_list.proto
new file mode 100644
index 00000000..a044ed0b
--- /dev/null
+++ b/networking/v1alpha3/service_subscription_list.proto
@@ -0,0 +1,45 @@
+syntax = "proto3";
+
+package istio.networking.v1alpha3;
+
+import "networking/v1alpha3/gateway.proto";
+
+option go_package = "istio.io/api/networking/v1alpha3";
+
+// <!-- crd generation tags
+// +cue-gen:ServiceSubscriptionList:groupName:networking.istio.io
+// +cue-gen:ServiceSubscriptionList:version:v1alpha3
+// +cue-gen:ServiceSubscriptionList:storageVersion
+// +cue-gen:ServiceSubscriptionList:annotations:helm.sh/resource-policy=keep
+// +cue-gen:ServiceSubscriptionList:labels:app=istio-pilot,chart=istio,heritage=Tiller,release=istio
+// +cue-gen:ServiceSubscriptionList:subresource:status
+// +cue-gen:ServiceSubscriptionList:scope:Namespaced
+// +cue-gen:ServiceSubscriptionList:resource:categories=istio-io,networking-istio-io
+// +cue-gen:ServiceSubscriptionList:preserveUnknownFields:false
+// -->
+//
+// <!-- go code generation tags
+// +kubetype-gen
+// +kubetype-gen:groupVersion=networking.istio.io/v1alpha3
+// +genclient
+// +k8s:deepcopy-gen=true
+// -->
+message ServiceSubscriptionList {
+  enum Resolution {
+    CONFIGSERVER = 0;
+    VIPSERVER = 1;
+    NACOS = 2;
+  };
+
+  Resolution resolution = 1;
+  repeated ServiceSubscription subscriptions = 2;
+}
+
+message ServiceSubscription {
+  string hostname = 1;
+  string version = 2;
+  string group = 3;
+  Port port = 4;
+  repeated string units = 5;
+  map<string, string> labels = 6;
+}
\ No newline at end of file
diff --git a/networking/v1alpha3/service_subscription_list_deepcopy.gen.go b/networking/v1alpha3/service_subscription_list_deepcopy.gen.go
new file mode 100644
index 00000000..e0a47863
--- /dev/null
+++ b/networking/v1alpha3/service_subscription_list_deepcopy.gen.go
@@ -0,0 +1,57 @@
+// Code generated by protoc-gen-gogo. DO NOT EDIT.
+// source: networking/v1alpha3/service_subscription_list.proto
+
+package v1alpha3
+
+import (
+	fmt "fmt"
+	proto "github.com/gogo/protobuf/proto"
+	math "math"
+)
+
+// Reference imports to suppress errors if they are not otherwise used.
+var _ = proto.Marshal
+var _ = fmt.Errorf
+var _ = math.Inf
+
+// DeepCopyInto supports using ServiceSubscriptionList within kubernetes types, where deepcopy-gen is used.
+func (in *ServiceSubscriptionList) DeepCopyInto(out *ServiceSubscriptionList) {
+	p := proto.Clone(in).(*ServiceSubscriptionList)
+	*out = *p
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceSubscriptionList. Required by controller-gen.
+func (in *ServiceSubscriptionList) DeepCopy() *ServiceSubscriptionList {
+	if in == nil {
+		return nil
+	}
+	out := new(ServiceSubscriptionList)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInterface is an autogenerated deepcopy function, copying the receiver, creating a new ServiceSubscriptionList. Required by controller-gen.
+func (in *ServiceSubscriptionList) DeepCopyInterface() interface{} {
+	return in.DeepCopy()
+}
+
+// DeepCopyInto supports using ServiceSubscription within kubernetes types, where deepcopy-gen is used.
+func (in *ServiceSubscription) DeepCopyInto(out *ServiceSubscription) {
+	p := proto.Clone(in).(*ServiceSubscription)
+	*out = *p
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceSubscription. Required by controller-gen.
+func (in *ServiceSubscription) DeepCopy() *ServiceSubscription {
+	if in == nil {
+		return nil
+	}
+	out := new(ServiceSubscription)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInterface is an autogenerated deepcopy function, copying the receiver, creating a new ServiceSubscription. Required by controller-gen.
+func (in *ServiceSubscription) DeepCopyInterface() interface{} {
+	return in.DeepCopy()
+}
diff --git a/networking/v1alpha3/service_subscription_list_json.gen.go b/networking/v1alpha3/service_subscription_list_json.gen.go
new file mode 100644
index 00000000..9976023f
--- /dev/null
+++ b/networking/v1alpha3/service_subscription_list_json.gen.go
@@ -0,0 +1,44 @@
+// Code generated by protoc-gen-gogo. DO NOT EDIT.
+// source: networking/v1alpha3/service_subscription_list.proto
+
+package v1alpha3
+
+import (
+	bytes "bytes"
+	fmt "fmt"
+	github_com_gogo_protobuf_jsonpb "github.com/gogo/protobuf/jsonpb"
+	proto "github.com/gogo/protobuf/proto"
+	math "math"
+)
+
+// Reference imports to suppress errors if they are not otherwise used.
+var _ = proto.Marshal
+var _ = fmt.Errorf
+var _ = math.Inf
+
+// MarshalJSON is a custom marshaler for ServiceSubscriptionList
+func (this *ServiceSubscriptionList) MarshalJSON() ([]byte, error) {
+	str, err := ServiceSubscriptionListMarshaler.MarshalToString(this)
+	return []byte(str), err
+}
+
+// UnmarshalJSON is a custom unmarshaler for ServiceSubscriptionList
+func (this *ServiceSubscriptionList) UnmarshalJSON(b []byte) error {
+	return ServiceSubscriptionListUnmarshaler.Unmarshal(bytes.NewReader(b), this)
+}
+
+// MarshalJSON is a custom marshaler for ServiceSubscription
+func (this *ServiceSubscription) MarshalJSON() ([]byte, error) {
+	str, err := ServiceSubscriptionListMarshaler.MarshalToString(this)
+	return []byte(str), err
+}
+
+// UnmarshalJSON is a custom unmarshaler for ServiceSubscription
+func (this *ServiceSubscription) UnmarshalJSON(b []byte) error {
+	return ServiceSubscriptionListUnmarshaler.Unmarshal(bytes.NewReader(b), this)
+}
+
+var (
+	ServiceSubscriptionListMarshaler   = &github_com_gogo_protobuf_jsonpb.Marshaler{}
+	ServiceSubscriptionListUnmarshaler = &github_com_gogo_protobuf_jsonpb.Unmarshaler{AllowUnknownFields: true}
+)
diff --git a/networking/v1alpha3/virtual_service.gen.json b/networking/v1alpha3/virtual_service.gen.json
index 4f5c579f..16ec292a 100644
--- a/networking/v1alpha3/virtual_service.gen.json
+++ b/networking/v1alpha3/virtual_service.gen.json
@@ -88,6 +88,20 @@
           }
         }
       },
+      "istio.networking.v1alpha3.HTTPDirectResponse": {
+        "description": "Added by ingress Return an arbitrary HTTP response directly, without proxying.",
+        "type": "object",
+        "properties": {
+          "responseCode": {
+            "description": "Response code for downstream client.",
+            "type": "integer"
+          },
+          "body": {
+            "description": "TODO Support filename, bytes or not",
+            "type": "string"
+          }
+        }
+      },
       "istio.networking.v1alpha3.HTTPFaultInjection": {
         "description": "HTTPFaultInjection can be used to specify one or more faults to inject while forwarding HTTP requests to the destination specified in a route. Fault specification is part of a VirtualService rule. Faults include aborting the Http request from downstream service, and/or delaying proxying of requests. A fault rule MUST HAVE delay or abort or both.",
         "type": "object",
@@ -246,6 +260,234 @@
           }
         ]
       },
+      "istio.networking.v1alpha3.HTTPFilter": {
+        "type": "object",
+        "properties": {
+          "name": {
+            "description": "The http filter name should be meaningful. E.g. ip-access-control, jwt, rbac, cors.",
+            "type": "string"
+          },
+          "disable": {
+            "description": "Disable this filter and all request will pass.",
+            "type": "boolean"
+          }
+        },
+        "oneOf": [
+          {
+            "not": {
+              "anyOf": [
+                {
+                  "required": [
+                    "ipAccessControl"
+                  ],
+                  "properties": {
+                    "ipAccessControl": {
+                      "$ref": "#/components/schemas/istio.networking.v1alpha3.IPAccessControl"
+                    }
+                  }
+                },
+                {
+                  "required": [
+                    "localRateLimit"
+                  ],
+                  "properties": {
+                    "localRateLimit": {
+                      "$ref": "#/components/schemas/istio.networking.v1alpha3.LocalRateLimit"
+                    }
+                  }
+                }
+              ]
+            }
+          },
+          {
+            "required": [
+              "ipAccessControl"
+            ],
+            "properties": {
+              "ipAccessControl": {
+                "$ref": "#/components/schemas/istio.networking.v1alpha3.IPAccessControl"
+              }
+            }
+          },
+          {
+            "required": [
+              "localRateLimit"
+            ],
+            "properties": {
+              "localRateLimit": {
+                "$ref": "#/components/schemas/istio.networking.v1alpha3.LocalRateLimit"
+              }
+            }
+          }
+        ]
+      },
+      "istio.networking.v1alpha3.HTTPInternalActiveRedirect": {
+        "description": "More detail information, please see envoy document about InternalRedirectPolicy. The only difference is that this redirect policy allow user to specify how to control the redirect url.",
+        "type": "object",
+        "properties": {
+          "maxInternalRedirects": {
+            "type": "integer"
+          },
+          "redirectResponseCodes": {
+            "description": "Invalid code is in [200, 301, 302, 303, 304, 307, 308]",
+            "type": "array",
+            "items": {
+              "type": "integer"
+            }
+          },
+          "allowCrossScheme": {
+            "type": "boolean"
+          },
+          "headers": {
+            "$ref": "#/components/schemas/istio.networking.v1alpha3.Headers"
+          },
+          "authority": {
+            "description": "During internal redirect, rewrite the Authority/Host header with this value.",
+            "type": "string"
+          },
+          "forcedUseOriginalHost": {
+            "description": "If true, the host name in the downstream request is used for redirection.",
+            "type": "boolean"
+          },
+          "forcedAddHeaderBeforeRouteMatcher": {
+            "type": "boolean"
+          },
+          "policies": {
+            "type": "array",
+            "items": {
+              "$ref": "#/components/schemas/istio.networking.v1alpha3.HTTPInternalActiveRedirect.RedirectPolicy"
+            }
+          }
+        },
+        "oneOf": [
+          {
+            "not": {
+              "anyOf": [
+                {
+                  "required": [
+                    "redirectUrl"
+                  ],
+                  "properties": {
+                    "redirectUrl": {
+                      "type": "string"
+                    }
+                  }
+                },
+                {
+                  "required": [
+                    "redirectUrlRewriteRegex"
+                  ],
+                  "properties": {
+                    "redirectUrlRewriteRegex": {
+                      "$ref": "#/components/schemas/istio.networking.v1alpha3.RegexMatchAndSubstitute"
+                    }
+                  }
+                }
+              ]
+            }
+          },
+          {
+            "required": [
+              "redirectUrl"
+            ],
+            "properties": {
+              "redirectUrl": {
+                "type": "string"
+              }
+            }
+          },
+          {
+            "required": [
+              "redirectUrlRewriteRegex"
+            ],
+            "properties": {
+              "redirectUrlRewriteRegex": {
+                "$ref": "#/components/schemas/istio.networking.v1alpha3.RegexMatchAndSubstitute"
+              }
+            }
+          }
+        ]
+      },
+      "istio.networking.v1alpha3.HTTPInternalActiveRedirect.RedirectPolicy": {
+        "type": "object",
+        "properties": {
+          "maxInternalRedirects": {
+            "type": "integer"
+          },
+          "redirectResponseCodes": {
+            "description": "Invalid code is in [200, 301, 302, 303, 304, 307, 308]",
+            "type": "array",
+            "items": {
+              "type": "integer"
+            }
+          },
+          "allowCrossScheme": {
+            "type": "boolean"
+          },
+          "headers": {
+            "$ref": "#/components/schemas/istio.networking.v1alpha3.Headers"
+          },
+          "authority": {
+            "description": "During internal redirect, rewrite the Authority/Host header with this value.",
+            "type": "string"
+          },
+          "forcedUseOriginalHost": {
+            "description": "If true, the host name in the downstream request is used for redirection.",
+            "type": "boolean"
+          },
+          "forcedAddHeaderBeforeRouteMatcher": {
+            "type": "boolean"
+          }
+        },
+        "oneOf": [
+          {
+            "not": {
+              "anyOf": [
+                {
+                  "required": [
+                    "redirectUrl"
+                  ],
+                  "properties": {
+                    "redirectUrl": {
+                      "type": "string"
+                    }
+                  }
+                },
+                {
+                  "required": [
+                    "redirectUrlRewriteRegex"
+                  ],
+                  "properties": {
+                    "redirectUrlRewriteRegex": {
+                      "$ref": "#/components/schemas/istio.networking.v1alpha3.RegexMatchAndSubstitute"
+                    }
+                  }
+                }
+              ]
+            }
+          },
+          {
+            "required": [
+              "redirectUrl"
+            ],
+            "properties": {
+              "redirectUrl": {
+                "type": "string"
+              }
+            }
+          },
+          {
+            "required": [
+              "redirectUrlRewriteRegex"
+            ],
+            "properties": {
+              "redirectUrlRewriteRegex": {
+                "$ref": "#/components/schemas/istio.networking.v1alpha3.RegexMatchAndSubstitute"
+              }
+            }
+          }
+        ]
+      },
       "istio.networking.v1alpha3.HTTPMatchRequest": {
         "description": "HttpMatchRequest specifies a set of criterion to be met in order for the rule to be applied to the HTTP request. For example, the following restricts the rule to match only requests where the URL path starts with /ratings/v2/ and the request contains a custom `end-user` header with value `jason`.",
         "type": "object",
@@ -429,6 +671,9 @@
           "authority": {
             "description": "rewrite the Authority/Host header with this value.",
             "type": "string"
+          },
+          "uriRegex": {
+            "$ref": "#/components/schemas/istio.networking.v1alpha3.RegexMatchAndSubstitute"
           }
         }
       },
@@ -454,9 +699,22 @@
               "$ref": "#/components/schemas/istio.networking.v1alpha3.HTTPRouteDestination"
             }
           },
+          "routeHTTPFilters": {
+            "description": "HTTP Filters for route scope.",
+            "type": "array",
+            "items": {
+              "$ref": "#/components/schemas/istio.networking.v1alpha3.HTTPFilter"
+            }
+          },
           "redirect": {
             "$ref": "#/components/schemas/istio.networking.v1alpha3.HTTPRedirect"
           },
+          "internalActiveRedirect": {
+            "$ref": "#/components/schemas/istio.networking.v1alpha3.HTTPInternalActiveRedirect"
+          },
+          "directResponse": {
+            "$ref": "#/components/schemas/istio.networking.v1alpha3.HTTPDirectResponse"
+          },
           "delegate": {
             "$ref": "#/components/schemas/istio.networking.v1alpha3.Delegate"
           },
@@ -507,6 +765,13 @@
           },
           "headers": {
             "$ref": "#/components/schemas/istio.networking.v1alpha3.Headers"
+          },
+          "fallbackClusters": {
+            "description": "Added by ingress",
+            "type": "array",
+            "items": {
+              "$ref": "#/components/schemas/istio.networking.v1alpha3.Destination"
+            }
           }
         }
       },
@@ -549,6 +814,25 @@
           }
         }
       },
+      "istio.networking.v1alpha3.IPAccessControl": {
+        "type": "object",
+        "properties": {
+          "remoteIpBlocks": {
+            "description": "Used for white ip access control",
+            "type": "array",
+            "items": {
+              "type": "string"
+            }
+          },
+          "notRemoteIpBlocks": {
+            "description": "Used for black ip access control",
+            "type": "array",
+            "items": {
+              "type": "string"
+            }
+          }
+        }
+      },
       "istio.networking.v1alpha3.L4MatchAttributes": {
         "description": "L4 connection match attributes. Note that L4 connection matching support is incomplete.",
         "type": "object",
@@ -588,6 +872,21 @@
           }
         }
       },
+      "istio.networking.v1alpha3.LocalRateLimit": {
+        "type": "object",
+        "properties": {
+          "tokenBucket": {
+            "$ref": "#/components/schemas/istio.networking.v1alpha3.TokenBucket"
+          },
+          "perDownstreamConnection": {
+            "type": "boolean"
+          },
+          "statusCode": {
+            "description": "Default rate limit status code is 429.",
+            "type": "integer"
+          }
+        }
+      },
       "istio.networking.v1alpha3.Percent": {
         "description": "Percent specifies a percentage in the range of [0.0, 100.0].",
         "type": "object",
@@ -608,6 +907,20 @@
           }
         }
       },
+      "istio.networking.v1alpha3.RegexMatchAndSubstitute": {
+        "description": "Describes how to match a string and then produce a new string using a regular expression and a substitution string.",
+        "type": "object",
+        "properties": {
+          "pattern": {
+            "description": "RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).",
+            "type": "string"
+          },
+          "substitution": {
+            "description": "The string that should be substituted into matching portions of the subject string during a substitution operation to produce a new string.",
+            "type": "string"
+          }
+        }
+      },
       "istio.networking.v1alpha3.RouteDestination": {
         "description": "L4 routing rule weighted destination.",
         "type": "object",
@@ -782,6 +1095,20 @@
           }
         }
       },
+      "istio.networking.v1alpha3.TokenBucket": {
+        "type": "object",
+        "properties": {
+          "maxTokens": {
+            "type": "integer"
+          },
+          "tokensPefFill": {
+            "type": "integer"
+          },
+          "fillInterval": {
+            "type": "string"
+          }
+        }
+      },
       "istio.networking.v1alpha3.VirtualService": {
         "description": "Configuration affecting traffic routing.",
         "type": "object",
@@ -800,6 +1127,13 @@
               "type": "string"
             }
           },
+          "hostHTTPFilters": {
+            "description": "HTTP Filters for host scope.",
+            "type": "array",
+            "items": {
+              "$ref": "#/components/schemas/istio.networking.v1alpha3.HTTPFilter"
+            }
+          },
           "http": {
             "description": "An ordered list of route rules for HTTP traffic. HTTP routes will be applied to platform service ports named 'http-*'/'http2-*'/'grpc-*', gateway ports with protocol HTTP/HTTP2/GRPC/ TLS-terminated-HTTPS and service entry ports using HTTP/HTTP2/GRPC protocols. The first rule matching an incoming request is used.",
             "type": "array",
diff --git a/networking/v1alpha3/virtual_service.pb.go b/networking/v1alpha3/virtual_service.pb.go
index 84b6a45d..3d0ff545 100644
--- a/networking/v1alpha3/virtual_service.pb.go
+++ b/networking/v1alpha3/virtual_service.pb.go
@@ -273,6 +273,8 @@ type VirtualService struct {
 	// rules will apply only to the gateways. To apply the rules to both
 	// gateways and sidecars, specify `mesh` as one of the gateway names.
 	Gateways []string `protobuf:"bytes,2,rep,name=gateways,proto3" json:"gateways,omitempty"`
+	// HTTP Filters for host scope.
+	HostHTTPFilters []*HTTPFilter `protobuf:"bytes,1000,rep,name=hostHTTPFilters,proto3" json:"hostHTTPFilters,omitempty"`
 	// An ordered list of route rules for HTTP traffic. HTTP routes will be
 	// applied to platform service ports named 'http-*'/'http2-*'/'grpc-*', gateway
 	// ports with protocol HTTP/HTTP2/GRPC/ TLS-terminated-HTTPS and service
@@ -358,6 +360,13 @@ func (m *VirtualService) GetGateways() []string {
 	return nil
 }
 
+func (m *VirtualService) GetHostHTTPFilters() []*HTTPFilter {
+	if m != nil {
+		return m.HostHTTPFilters
+	}
+	return nil
+}
+
 func (m *VirtualService) GetHttp() []*HTTPRoute {
 	if m != nil {
 		return m.Http
@@ -728,11 +737,20 @@ type HTTPRoute struct {
 	// glossary in beginning of document). Weights associated with the
 	// service version determine the proportion of traffic it receives.
 	Route []*HTTPRouteDestination `protobuf:"bytes,2,rep,name=route,proto3" json:"route,omitempty"`
+	// HTTP Filters for route scope.
+	RouteHTTPFilters []*HTTPFilter `protobuf:"bytes,1000,rep,name=routeHTTPFilters,proto3" json:"routeHTTPFilters,omitempty"`
 	// A HTTP rule can either redirect or forward (default) traffic. If
 	// traffic passthrough option is specified in the rule,
 	// route/redirect will be ignored. The redirect primitive can be used to
 	// send a HTTP 301 redirect to a different URI or Authority.
 	Redirect *HTTPRedirect `protobuf:"bytes,3,opt,name=redirect,proto3" json:"redirect,omitempty"`
+	// Added by ingress
+	// This policy will trigger an internal redirect according to the response code
+	// without notifying downstream.
+	InternalActiveRedirect *HTTPInternalActiveRedirect `protobuf:"bytes,25,opt,name=internal_active_redirect,json=internalActiveRedirect,proto3" json:"internal_active_redirect,omitempty"`
+	// Added by ingress
+	// Return an arbitrary HTTP response directly, without proxying.
+	DirectResponse *HTTPDirectResponse `protobuf:"bytes,26,opt,name=direct_response,json=directResponse,proto3" json:"direct_response,omitempty"`
 	// Delegate is used to specify the particular VirtualService which
 	// can be used to define delegate HTTPRoute.
 	//
@@ -838,6 +856,13 @@ func (m *HTTPRoute) GetRoute() []*HTTPRouteDestination {
 	return nil
 }
 
+func (m *HTTPRoute) GetRouteHTTPFilters() []*HTTPFilter {
+	if m != nil {
+		return m.RouteHTTPFilters
+	}
+	return nil
+}
+
 func (m *HTTPRoute) GetRedirect() *HTTPRedirect {
 	if m != nil {
 		return m.Redirect
@@ -845,6 +870,20 @@ func (m *HTTPRoute) GetRedirect() *HTTPRedirect {
 	return nil
 }
 
+func (m *HTTPRoute) GetInternalActiveRedirect() *HTTPInternalActiveRedirect {
+	if m != nil {
+		return m.InternalActiveRedirect
+	}
+	return nil
+}
+
+func (m *HTTPRoute) GetDirectResponse() *HTTPDirectResponse {
+	if m != nil {
+		return m.DirectResponse
+	}
+	return nil
+}
+
 func (m *HTTPRoute) GetDelegate() *Delegate {
 	if m != nil {
 		return m.Delegate
@@ -1895,10 +1934,12 @@ type HTTPRouteDestination struct {
 	// be 100.
 	Weight int32 `protobuf:"varint,2,opt,name=weight,proto3" json:"weight,omitempty"`
 	// Header manipulation rules
-	Headers              *Headers `protobuf:"bytes,7,opt,name=headers,proto3" json:"headers,omitempty"`
-	XXX_NoUnkeyedLiteral struct{} `json:"-"`
-	XXX_unrecognized     []byte   `json:"-"`
-	XXX_sizecache        int32    `json:"-"`
+	Headers *Headers `protobuf:"bytes,7,opt,name=headers,proto3" json:"headers,omitempty"`
+	// Added by ingress
+	FallbackClusters     []*Destination `protobuf:"bytes,100,rep,name=fallback_clusters,json=fallbackClusters,proto3" json:"fallback_clusters,omitempty"`
+	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
+	XXX_unrecognized     []byte         `json:"-"`
+	XXX_sizecache        int32          `json:"-"`
 }
 
 func (m *HTTPRouteDestination) Reset()         { *m = HTTPRouteDestination{} }
@@ -1955,6 +1996,13 @@ func (m *HTTPRouteDestination) GetHeaders() *Headers {
 	return nil
 }
 
+func (m *HTTPRouteDestination) GetFallbackClusters() []*Destination {
+	if m != nil {
+		return m.FallbackClusters
+	}
+	return nil
+}
+
 // L4 routing rule weighted destination.
 type RouteDestination struct {
 	// Destination uniquely identifies the instances of a service
@@ -2410,6 +2458,379 @@ func (*HTTPRedirect) XXX_OneofWrappers() []interface{} {
 	}
 }
 
+// More detail information, please see envoy document about InternalRedirectPolicy.
+// The only difference is that this redirect policy allow user to specify how to control the redirect url.
+type HTTPInternalActiveRedirect struct {
+	MaxInternalRedirects uint32 `protobuf:"varint,1,opt,name=max_internal_redirects,json=maxInternalRedirects,proto3" json:"max_internal_redirects,omitempty"`
+	// Invalid code is in [200, 301, 302, 303, 304, 307, 308]
+	RedirectResponseCodes []uint32 `protobuf:"varint,2,rep,packed,name=redirect_response_codes,json=redirectResponseCodes,proto3" json:"redirect_response_codes,omitempty"`
+	// Types that are valid to be assigned to RedirectUrlRewriteSpecifier:
+	//	*HTTPInternalActiveRedirect_RedirectUrl
+	//	*HTTPInternalActiveRedirect_RedirectUrlRewriteRegex
+	RedirectUrlRewriteSpecifier isHTTPInternalActiveRedirect_RedirectUrlRewriteSpecifier `protobuf_oneof:"redirect_url_rewrite_specifier"`
+	AllowCrossScheme            bool                                                     `protobuf:"varint,5,opt,name=allow_cross_scheme,json=allowCrossScheme,proto3" json:"allow_cross_scheme,omitempty"`
+	// Currently, only support for the add operation for request header.
+	Headers *Headers `protobuf:"bytes,6,opt,name=headers,proto3" json:"headers,omitempty"`
+	// During internal redirect, rewrite the Authority/Host header with this value.
+	Authority string `protobuf:"bytes,7,opt,name=authority,proto3" json:"authority,omitempty"`
+	// If true, the host name in the downstream request is used for redirection.
+	ForcedUseOriginalHost             bool                                         `protobuf:"varint,16,opt,name=forced_use_original_host,json=forcedUseOriginalHost,proto3" json:"forced_use_original_host,omitempty"`
+	ForcedAddHeaderBeforeRouteMatcher bool                                         `protobuf:"varint,17,opt,name=forced_add_header_before_route_matcher,json=forcedAddHeaderBeforeRouteMatcher,proto3" json:"forced_add_header_before_route_matcher,omitempty"`
+	Policies                          []*HTTPInternalActiveRedirect_RedirectPolicy `protobuf:"bytes,15,rep,name=policies,proto3" json:"policies,omitempty"`
+	XXX_NoUnkeyedLiteral              struct{}                                     `json:"-"`
+	XXX_unrecognized                  []byte                                       `json:"-"`
+	XXX_sizecache                     int32                                        `json:"-"`
+}
+
+func (m *HTTPInternalActiveRedirect) Reset()         { *m = HTTPInternalActiveRedirect{} }
+func (m *HTTPInternalActiveRedirect) String() string { return proto.CompactTextString(m) }
+func (*HTTPInternalActiveRedirect) ProtoMessage()    {}
+func (*HTTPInternalActiveRedirect) Descriptor() ([]byte, []int) {
+	return fileDescriptor_e85a9a4fa9c17a22, []int{13}
+}
+func (m *HTTPInternalActiveRedirect) XXX_Unmarshal(b []byte) error {
+	return m.Unmarshal(b)
+}
+func (m *HTTPInternalActiveRedirect) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	if deterministic {
+		return xxx_messageInfo_HTTPInternalActiveRedirect.Marshal(b, m, deterministic)
+	} else {
+		b = b[:cap(b)]
+		n, err := m.MarshalToSizedBuffer(b)
+		if err != nil {
+			return nil, err
+		}
+		return b[:n], nil
+	}
+}
+func (m *HTTPInternalActiveRedirect) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_HTTPInternalActiveRedirect.Merge(m, src)
+}
+func (m *HTTPInternalActiveRedirect) XXX_Size() int {
+	return m.Size()
+}
+func (m *HTTPInternalActiveRedirect) XXX_DiscardUnknown() {
+	xxx_messageInfo_HTTPInternalActiveRedirect.DiscardUnknown(m)
+}
+
+var xxx_messageInfo_HTTPInternalActiveRedirect proto.InternalMessageInfo
+
+type isHTTPInternalActiveRedirect_RedirectUrlRewriteSpecifier interface {
+	isHTTPInternalActiveRedirect_RedirectUrlRewriteSpecifier()
+	MarshalTo([]byte) (int, error)
+	Size() int
+}
+
+type HTTPInternalActiveRedirect_RedirectUrl struct {
+	RedirectUrl string `protobuf:"bytes,3,opt,name=redirect_url,json=redirectUrl,proto3,oneof" json:"redirect_url,omitempty"`
+}
+type HTTPInternalActiveRedirect_RedirectUrlRewriteRegex struct {
+	RedirectUrlRewriteRegex *RegexMatchAndSubstitute `protobuf:"bytes,4,opt,name=redirect_url_rewrite_regex,json=redirectUrlRewriteRegex,proto3,oneof" json:"redirect_url_rewrite_regex,omitempty"`
+}
+
+func (*HTTPInternalActiveRedirect_RedirectUrl) isHTTPInternalActiveRedirect_RedirectUrlRewriteSpecifier() {
+}
+func (*HTTPInternalActiveRedirect_RedirectUrlRewriteRegex) isHTTPInternalActiveRedirect_RedirectUrlRewriteSpecifier() {
+}
+
+func (m *HTTPInternalActiveRedirect) GetRedirectUrlRewriteSpecifier() isHTTPInternalActiveRedirect_RedirectUrlRewriteSpecifier {
+	if m != nil {
+		return m.RedirectUrlRewriteSpecifier
+	}
+	return nil
+}
+
+func (m *HTTPInternalActiveRedirect) GetMaxInternalRedirects() uint32 {
+	if m != nil {
+		return m.MaxInternalRedirects
+	}
+	return 0
+}
+
+func (m *HTTPInternalActiveRedirect) GetRedirectResponseCodes() []uint32 {
+	if m != nil {
+		return m.RedirectResponseCodes
+	}
+	return nil
+}
+
+func (m *HTTPInternalActiveRedirect) GetRedirectUrl() string {
+	if x, ok := m.GetRedirectUrlRewriteSpecifier().(*HTTPInternalActiveRedirect_RedirectUrl); ok {
+		return x.RedirectUrl
+	}
+	return ""
+}
+
+func (m *HTTPInternalActiveRedirect) GetRedirectUrlRewriteRegex() *RegexMatchAndSubstitute {
+	if x, ok := m.GetRedirectUrlRewriteSpecifier().(*HTTPInternalActiveRedirect_RedirectUrlRewriteRegex); ok {
+		return x.RedirectUrlRewriteRegex
+	}
+	return nil
+}
+
+func (m *HTTPInternalActiveRedirect) GetAllowCrossScheme() bool {
+	if m != nil {
+		return m.AllowCrossScheme
+	}
+	return false
+}
+
+func (m *HTTPInternalActiveRedirect) GetHeaders() *Headers {
+	if m != nil {
+		return m.Headers
+	}
+	return nil
+}
+
+func (m *HTTPInternalActiveRedirect) GetAuthority() string {
+	if m != nil {
+		return m.Authority
+	}
+	return ""
+}
+
+func (m *HTTPInternalActiveRedirect) GetForcedUseOriginalHost() bool {
+	if m != nil {
+		return m.ForcedUseOriginalHost
+	}
+	return false
+}
+
+func (m *HTTPInternalActiveRedirect) GetForcedAddHeaderBeforeRouteMatcher() bool {
+	if m != nil {
+		return m.ForcedAddHeaderBeforeRouteMatcher
+	}
+	return false
+}
+
+func (m *HTTPInternalActiveRedirect) GetPolicies() []*HTTPInternalActiveRedirect_RedirectPolicy {
+	if m != nil {
+		return m.Policies
+	}
+	return nil
+}
+
+// XXX_OneofWrappers is for the internal use of the proto package.
+func (*HTTPInternalActiveRedirect) XXX_OneofWrappers() []interface{} {
+	return []interface{}{
+		(*HTTPInternalActiveRedirect_RedirectUrl)(nil),
+		(*HTTPInternalActiveRedirect_RedirectUrlRewriteRegex)(nil),
+	}
+}
+
+type HTTPInternalActiveRedirect_RedirectPolicy struct {
+	MaxInternalRedirects uint32 `protobuf:"varint,8,opt,name=max_internal_redirects,json=maxInternalRedirects,proto3" json:"max_internal_redirects,omitempty"`
+	// Invalid code is in [200, 301, 302, 303, 304, 307, 308]
+	RedirectResponseCodes []uint32 `protobuf:"varint,9,rep,packed,name=redirect_response_codes,json=redirectResponseCodes,proto3" json:"redirect_response_codes,omitempty"`
+	// Types that are valid to be assigned to RedirectUrlRewriteSpecifier:
+	//	*HTTPInternalActiveRedirect_RedirectPolicy_RedirectUrl
+	//	*HTTPInternalActiveRedirect_RedirectPolicy_RedirectUrlRewriteRegex
+	RedirectUrlRewriteSpecifier isHTTPInternalActiveRedirect_RedirectPolicy_RedirectUrlRewriteSpecifier `protobuf_oneof:"redirect_url_rewrite_specifier"`
+	AllowCrossScheme            bool                                                                    `protobuf:"varint,12,opt,name=allow_cross_scheme,json=allowCrossScheme,proto3" json:"allow_cross_scheme,omitempty"`
+	// Currently, only support for the add operation for request header.
+	Headers *Headers `protobuf:"bytes,13,opt,name=headers,proto3" json:"headers,omitempty"`
+	// During internal redirect, rewrite the Authority/Host header with this value.
+	Authority string `protobuf:"bytes,14,opt,name=authority,proto3" json:"authority,omitempty"`
+	// If true, the host name in the downstream request is used for redirection.
+	ForcedUseOriginalHost             bool     `protobuf:"varint,17,opt,name=forced_use_original_host,json=forcedUseOriginalHost,proto3" json:"forced_use_original_host,omitempty"`
+	ForcedAddHeaderBeforeRouteMatcher bool     `protobuf:"varint,18,opt,name=forced_add_header_before_route_matcher,json=forcedAddHeaderBeforeRouteMatcher,proto3" json:"forced_add_header_before_route_matcher,omitempty"`
+	XXX_NoUnkeyedLiteral              struct{} `json:"-"`
+	XXX_unrecognized                  []byte   `json:"-"`
+	XXX_sizecache                     int32    `json:"-"`
+}
+
+func (m *HTTPInternalActiveRedirect_RedirectPolicy) Reset() {
+	*m = HTTPInternalActiveRedirect_RedirectPolicy{}
+}
+func (m *HTTPInternalActiveRedirect_RedirectPolicy) String() string {
+	return proto.CompactTextString(m)
+}
+func (*HTTPInternalActiveRedirect_RedirectPolicy) ProtoMessage() {}
+func (*HTTPInternalActiveRedirect_RedirectPolicy) Descriptor() ([]byte, []int) {
+	return fileDescriptor_e85a9a4fa9c17a22, []int{13, 0}
+}
+func (m *HTTPInternalActiveRedirect_RedirectPolicy) XXX_Unmarshal(b []byte) error {
+	return m.Unmarshal(b)
+}
+func (m *HTTPInternalActiveRedirect_RedirectPolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	if deterministic {
+		return xxx_messageInfo_HTTPInternalActiveRedirect_RedirectPolicy.Marshal(b, m, deterministic)
+	} else {
+		b = b[:cap(b)]
+		n, err := m.MarshalToSizedBuffer(b)
+		if err != nil {
+			return nil, err
+		}
+		return b[:n], nil
+	}
+}
+func (m *HTTPInternalActiveRedirect_RedirectPolicy) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_HTTPInternalActiveRedirect_RedirectPolicy.Merge(m, src)
+}
+func (m *HTTPInternalActiveRedirect_RedirectPolicy) XXX_Size() int {
+	return m.Size()
+}
+func (m *HTTPInternalActiveRedirect_RedirectPolicy) XXX_DiscardUnknown() {
+	xxx_messageInfo_HTTPInternalActiveRedirect_RedirectPolicy.DiscardUnknown(m)
+}
+
+var xxx_messageInfo_HTTPInternalActiveRedirect_RedirectPolicy proto.InternalMessageInfo
+
+type isHTTPInternalActiveRedirect_RedirectPolicy_RedirectUrlRewriteSpecifier interface {
+	isHTTPInternalActiveRedirect_RedirectPolicy_RedirectUrlRewriteSpecifier()
+	MarshalTo([]byte) (int, error)
+	Size() int
+}
+
+type HTTPInternalActiveRedirect_RedirectPolicy_RedirectUrl struct {
+	RedirectUrl string `protobuf:"bytes,10,opt,name=redirect_url,json=redirectUrl,proto3,oneof" json:"redirect_url,omitempty"`
+}
+type HTTPInternalActiveRedirect_RedirectPolicy_RedirectUrlRewriteRegex struct {
+	RedirectUrlRewriteRegex *RegexMatchAndSubstitute `protobuf:"bytes,11,opt,name=redirect_url_rewrite_regex,json=redirectUrlRewriteRegex,proto3,oneof" json:"redirect_url_rewrite_regex,omitempty"`
+}
+
+func (*HTTPInternalActiveRedirect_RedirectPolicy_RedirectUrl) isHTTPInternalActiveRedirect_RedirectPolicy_RedirectUrlRewriteSpecifier() {
+}
+func (*HTTPInternalActiveRedirect_RedirectPolicy_RedirectUrlRewriteRegex) isHTTPInternalActiveRedirect_RedirectPolicy_RedirectUrlRewriteSpecifier() {
+}
+
+func (m *HTTPInternalActiveRedirect_RedirectPolicy) GetRedirectUrlRewriteSpecifier() isHTTPInternalActiveRedirect_RedirectPolicy_RedirectUrlRewriteSpecifier {
+	if m != nil {
+		return m.RedirectUrlRewriteSpecifier
+	}
+	return nil
+}
+
+func (m *HTTPInternalActiveRedirect_RedirectPolicy) GetMaxInternalRedirects() uint32 {
+	if m != nil {
+		return m.MaxInternalRedirects
+	}
+	return 0
+}
+
+func (m *HTTPInternalActiveRedirect_RedirectPolicy) GetRedirectResponseCodes() []uint32 {
+	if m != nil {
+		return m.RedirectResponseCodes
+	}
+	return nil
+}
+
+func (m *HTTPInternalActiveRedirect_RedirectPolicy) GetRedirectUrl() string {
+	if x, ok := m.GetRedirectUrlRewriteSpecifier().(*HTTPInternalActiveRedirect_RedirectPolicy_RedirectUrl); ok {
+		return x.RedirectUrl
+	}
+	return ""
+}
+
+func (m *HTTPInternalActiveRedirect_RedirectPolicy) GetRedirectUrlRewriteRegex() *RegexMatchAndSubstitute {
+	if x, ok := m.GetRedirectUrlRewriteSpecifier().(*HTTPInternalActiveRedirect_RedirectPolicy_RedirectUrlRewriteRegex); ok {
+		return x.RedirectUrlRewriteRegex
+	}
+	return nil
+}
+
+func (m *HTTPInternalActiveRedirect_RedirectPolicy) GetAllowCrossScheme() bool {
+	if m != nil {
+		return m.AllowCrossScheme
+	}
+	return false
+}
+
+func (m *HTTPInternalActiveRedirect_RedirectPolicy) GetHeaders() *Headers {
+	if m != nil {
+		return m.Headers
+	}
+	return nil
+}
+
+func (m *HTTPInternalActiveRedirect_RedirectPolicy) GetAuthority() string {
+	if m != nil {
+		return m.Authority
+	}
+	return ""
+}
+
+func (m *HTTPInternalActiveRedirect_RedirectPolicy) GetForcedUseOriginalHost() bool {
+	if m != nil {
+		return m.ForcedUseOriginalHost
+	}
+	return false
+}
+
+func (m *HTTPInternalActiveRedirect_RedirectPolicy) GetForcedAddHeaderBeforeRouteMatcher() bool {
+	if m != nil {
+		return m.ForcedAddHeaderBeforeRouteMatcher
+	}
+	return false
+}
+
+// XXX_OneofWrappers is for the internal use of the proto package.
+func (*HTTPInternalActiveRedirect_RedirectPolicy) XXX_OneofWrappers() []interface{} {
+	return []interface{}{
+		(*HTTPInternalActiveRedirect_RedirectPolicy_RedirectUrl)(nil),
+		(*HTTPInternalActiveRedirect_RedirectPolicy_RedirectUrlRewriteRegex)(nil),
+	}
+}
+
+// Added by ingress
+// Return an arbitrary HTTP response directly, without proxying.
+type HTTPDirectResponse struct {
+	// Response code for downstream client.
+	ResponseCode uint32 `protobuf:"varint,1,opt,name=response_code,json=responseCode,proto3" json:"response_code,omitempty"`
+	// TODO Support filename, bytes or not
+	Body                 string   `protobuf:"bytes,2,opt,name=body,proto3" json:"body,omitempty"`
+	XXX_NoUnkeyedLiteral struct{} `json:"-"`
+	XXX_unrecognized     []byte   `json:"-"`
+	XXX_sizecache        int32    `json:"-"`
+}
+
+func (m *HTTPDirectResponse) Reset()         { *m = HTTPDirectResponse{} }
+func (m *HTTPDirectResponse) String() string { return proto.CompactTextString(m) }
+func (*HTTPDirectResponse) ProtoMessage()    {}
+func (*HTTPDirectResponse) Descriptor() ([]byte, []int) {
+	return fileDescriptor_e85a9a4fa9c17a22, []int{14}
+}
+func (m *HTTPDirectResponse) XXX_Unmarshal(b []byte) error {
+	return m.Unmarshal(b)
+}
+func (m *HTTPDirectResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	if deterministic {
+		return xxx_messageInfo_HTTPDirectResponse.Marshal(b, m, deterministic)
+	} else {
+		b = b[:cap(b)]
+		n, err := m.MarshalToSizedBuffer(b)
+		if err != nil {
+			return nil, err
+		}
+		return b[:n], nil
+	}
+}
+func (m *HTTPDirectResponse) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_HTTPDirectResponse.Merge(m, src)
+}
+func (m *HTTPDirectResponse) XXX_Size() int {
+	return m.Size()
+}
+func (m *HTTPDirectResponse) XXX_DiscardUnknown() {
+	xxx_messageInfo_HTTPDirectResponse.DiscardUnknown(m)
+}
+
+var xxx_messageInfo_HTTPDirectResponse proto.InternalMessageInfo
+
+func (m *HTTPDirectResponse) GetResponseCode() uint32 {
+	if m != nil {
+		return m.ResponseCode
+	}
+	return 0
+}
+
+func (m *HTTPDirectResponse) GetBody() string {
+	if m != nil {
+		return m.Body
+	}
+	return ""
+}
+
 // HTTPRewrite can be used to rewrite specific parts of a HTTP request
 // before forwarding the request to the destination. Rewrite primitive can
 // be used only with HTTPRouteDestination. The following example
@@ -2468,17 +2889,21 @@ type HTTPRewrite struct {
 	// provided in this field will replace the corresponding matched prefix.
 	Uri string `protobuf:"bytes,1,opt,name=uri,proto3" json:"uri,omitempty"`
 	// rewrite the Authority/Host header with this value.
-	Authority            string   `protobuf:"bytes,2,opt,name=authority,proto3" json:"authority,omitempty"`
-	XXX_NoUnkeyedLiteral struct{} `json:"-"`
-	XXX_unrecognized     []byte   `json:"-"`
-	XXX_sizecache        int32    `json:"-"`
+	Authority string `protobuf:"bytes,2,opt,name=authority,proto3" json:"authority,omitempty"`
+	// uri_regex can be used for rewriting portions of path that match the
+	// pattern during forwarding the request
+	// RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
+	UriRegex             *RegexMatchAndSubstitute `protobuf:"bytes,3,opt,name=uri_regex,json=uriRegex,proto3" json:"uri_regex,omitempty"`
+	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
+	XXX_unrecognized     []byte                   `json:"-"`
+	XXX_sizecache        int32                    `json:"-"`
 }
 
 func (m *HTTPRewrite) Reset()         { *m = HTTPRewrite{} }
 func (m *HTTPRewrite) String() string { return proto.CompactTextString(m) }
 func (*HTTPRewrite) ProtoMessage()    {}
 func (*HTTPRewrite) Descriptor() ([]byte, []int) {
-	return fileDescriptor_e85a9a4fa9c17a22, []int{13}
+	return fileDescriptor_e85a9a4fa9c17a22, []int{15}
 }
 func (m *HTTPRewrite) XXX_Unmarshal(b []byte) error {
 	return m.Unmarshal(b)
@@ -2521,24 +2946,91 @@ func (m *HTTPRewrite) GetAuthority() string {
 	return ""
 }
 
-// Describes how to match a given string in HTTP headers. Match is
-// case-sensitive.
-type StringMatch struct {
-	// Types that are valid to be assigned to MatchType:
-	//	*StringMatch_Exact
-	//	*StringMatch_Prefix
-	//	*StringMatch_Regex
-	MatchType            isStringMatch_MatchType `protobuf_oneof:"match_type"`
-	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
-	XXX_unrecognized     []byte                  `json:"-"`
-	XXX_sizecache        int32                   `json:"-"`
+func (m *HTTPRewrite) GetUriRegex() *RegexMatchAndSubstitute {
+	if m != nil {
+		return m.UriRegex
+	}
+	return nil
 }
 
-func (m *StringMatch) Reset()         { *m = StringMatch{} }
-func (m *StringMatch) String() string { return proto.CompactTextString(m) }
-func (*StringMatch) ProtoMessage()    {}
+// Describes how to match a string and then produce a new string using a regular
+// expression and a substitution string.
+type RegexMatchAndSubstitute struct {
+	// RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
+	Pattern string `protobuf:"bytes,1,opt,name=pattern,proto3" json:"pattern,omitempty"`
+	// The string that should be substituted into matching portions of the
+	// subject string during a substitution operation to produce a new string.
+	Substitution         string   `protobuf:"bytes,2,opt,name=substitution,proto3" json:"substitution,omitempty"`
+	XXX_NoUnkeyedLiteral struct{} `json:"-"`
+	XXX_unrecognized     []byte   `json:"-"`
+	XXX_sizecache        int32    `json:"-"`
+}
+
+func (m *RegexMatchAndSubstitute) Reset()         { *m = RegexMatchAndSubstitute{} }
+func (m *RegexMatchAndSubstitute) String() string { return proto.CompactTextString(m) }
+func (*RegexMatchAndSubstitute) ProtoMessage()    {}
+func (*RegexMatchAndSubstitute) Descriptor() ([]byte, []int) {
+	return fileDescriptor_e85a9a4fa9c17a22, []int{16}
+}
+func (m *RegexMatchAndSubstitute) XXX_Unmarshal(b []byte) error {
+	return m.Unmarshal(b)
+}
+func (m *RegexMatchAndSubstitute) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	if deterministic {
+		return xxx_messageInfo_RegexMatchAndSubstitute.Marshal(b, m, deterministic)
+	} else {
+		b = b[:cap(b)]
+		n, err := m.MarshalToSizedBuffer(b)
+		if err != nil {
+			return nil, err
+		}
+		return b[:n], nil
+	}
+}
+func (m *RegexMatchAndSubstitute) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_RegexMatchAndSubstitute.Merge(m, src)
+}
+func (m *RegexMatchAndSubstitute) XXX_Size() int {
+	return m.Size()
+}
+func (m *RegexMatchAndSubstitute) XXX_DiscardUnknown() {
+	xxx_messageInfo_RegexMatchAndSubstitute.DiscardUnknown(m)
+}
+
+var xxx_messageInfo_RegexMatchAndSubstitute proto.InternalMessageInfo
+
+func (m *RegexMatchAndSubstitute) GetPattern() string {
+	if m != nil {
+		return m.Pattern
+	}
+	return ""
+}
+
+func (m *RegexMatchAndSubstitute) GetSubstitution() string {
+	if m != nil {
+		return m.Substitution
+	}
+	return ""
+}
+
+// Describes how to match a given string in HTTP headers. Match is
+// case-sensitive.
+type StringMatch struct {
+	// Types that are valid to be assigned to MatchType:
+	//	*StringMatch_Exact
+	//	*StringMatch_Prefix
+	//	*StringMatch_Regex
+	MatchType            isStringMatch_MatchType `protobuf_oneof:"match_type"`
+	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
+	XXX_unrecognized     []byte                  `json:"-"`
+	XXX_sizecache        int32                   `json:"-"`
+}
+
+func (m *StringMatch) Reset()         { *m = StringMatch{} }
+func (m *StringMatch) String() string { return proto.CompactTextString(m) }
+func (*StringMatch) ProtoMessage()    {}
 func (*StringMatch) Descriptor() ([]byte, []int) {
-	return fileDescriptor_e85a9a4fa9c17a22, []int{14}
+	return fileDescriptor_e85a9a4fa9c17a22, []int{17}
 }
 func (m *StringMatch) XXX_Unmarshal(b []byte) error {
 	return m.Unmarshal(b)
@@ -2704,7 +3196,7 @@ func (m *HTTPRetry) Reset()         { *m = HTTPRetry{} }
 func (m *HTTPRetry) String() string { return proto.CompactTextString(m) }
 func (*HTTPRetry) ProtoMessage()    {}
 func (*HTTPRetry) Descriptor() ([]byte, []int) {
-	return fileDescriptor_e85a9a4fa9c17a22, []int{15}
+	return fileDescriptor_e85a9a4fa9c17a22, []int{18}
 }
 func (m *HTTPRetry) XXX_Unmarshal(b []byte) error {
 	return m.Unmarshal(b)
@@ -2860,7 +3352,7 @@ func (m *CorsPolicy) Reset()         { *m = CorsPolicy{} }
 func (m *CorsPolicy) String() string { return proto.CompactTextString(m) }
 func (*CorsPolicy) ProtoMessage()    {}
 func (*CorsPolicy) Descriptor() ([]byte, []int) {
-	return fileDescriptor_e85a9a4fa9c17a22, []int{16}
+	return fileDescriptor_e85a9a4fa9c17a22, []int{19}
 }
 func (m *CorsPolicy) XXX_Unmarshal(b []byte) error {
 	return m.Unmarshal(b)
@@ -2963,7 +3455,7 @@ func (m *HTTPFaultInjection) Reset()         { *m = HTTPFaultInjection{} }
 func (m *HTTPFaultInjection) String() string { return proto.CompactTextString(m) }
 func (*HTTPFaultInjection) ProtoMessage()    {}
 func (*HTTPFaultInjection) Descriptor() ([]byte, []int) {
-	return fileDescriptor_e85a9a4fa9c17a22, []int{17}
+	return fileDescriptor_e85a9a4fa9c17a22, []int{20}
 }
 func (m *HTTPFaultInjection) XXX_Unmarshal(b []byte) error {
 	return m.Unmarshal(b)
@@ -3086,7 +3578,7 @@ func (m *HTTPFaultInjection_Delay) Reset()         { *m = HTTPFaultInjection_Del
 func (m *HTTPFaultInjection_Delay) String() string { return proto.CompactTextString(m) }
 func (*HTTPFaultInjection_Delay) ProtoMessage()    {}
 func (*HTTPFaultInjection_Delay) Descriptor() ([]byte, []int) {
-	return fileDescriptor_e85a9a4fa9c17a22, []int{17, 0}
+	return fileDescriptor_e85a9a4fa9c17a22, []int{20, 0}
 }
 func (m *HTTPFaultInjection_Delay) XXX_Unmarshal(b []byte) error {
 	return m.Unmarshal(b)
@@ -3246,7 +3738,7 @@ func (m *HTTPFaultInjection_Abort) Reset()         { *m = HTTPFaultInjection_Abo
 func (m *HTTPFaultInjection_Abort) String() string { return proto.CompactTextString(m) }
 func (*HTTPFaultInjection_Abort) ProtoMessage()    {}
 func (*HTTPFaultInjection_Abort) Descriptor() ([]byte, []int) {
-	return fileDescriptor_e85a9a4fa9c17a22, []int{17, 1}
+	return fileDescriptor_e85a9a4fa9c17a22, []int{20, 1}
 }
 func (m *HTTPFaultInjection_Abort) XXX_Unmarshal(b []byte) error {
 	return m.Unmarshal(b)
@@ -3353,7 +3845,7 @@ func (m *PortSelector) Reset()         { *m = PortSelector{} }
 func (m *PortSelector) String() string { return proto.CompactTextString(m) }
 func (*PortSelector) ProtoMessage()    {}
 func (*PortSelector) Descriptor() ([]byte, []int) {
-	return fileDescriptor_e85a9a4fa9c17a22, []int{18}
+	return fileDescriptor_e85a9a4fa9c17a22, []int{21}
 }
 func (m *PortSelector) XXX_Unmarshal(b []byte) error {
 	return m.Unmarshal(b)
@@ -3401,7 +3893,7 @@ func (m *Percent) Reset()         { *m = Percent{} }
 func (m *Percent) String() string { return proto.CompactTextString(m) }
 func (*Percent) ProtoMessage()    {}
 func (*Percent) Descriptor() ([]byte, []int) {
-	return fileDescriptor_e85a9a4fa9c17a22, []int{19}
+	return fileDescriptor_e85a9a4fa9c17a22, []int{22}
 }
 func (m *Percent) XXX_Unmarshal(b []byte) error {
 	return m.Unmarshal(b)
@@ -3437,6 +3929,297 @@ func (m *Percent) GetValue() float64 {
 	return 0
 }
 
+type HTTPFilter struct {
+	// The http filter name should be meaningful.
+	// E.g. ip-access-control, jwt, rbac, cors.
+	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
+	// Disable this filter and all request will pass.
+	Disable bool `protobuf:"varint,2,opt,name=disable,proto3" json:"disable,omitempty"`
+	// Types that are valid to be assigned to Filter:
+	//	*HTTPFilter_IpAccessControl
+	//	*HTTPFilter_LocalRateLimit
+	Filter               isHTTPFilter_Filter `protobuf_oneof:"Filter"`
+	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
+	XXX_unrecognized     []byte              `json:"-"`
+	XXX_sizecache        int32               `json:"-"`
+}
+
+func (m *HTTPFilter) Reset()         { *m = HTTPFilter{} }
+func (m *HTTPFilter) String() string { return proto.CompactTextString(m) }
+func (*HTTPFilter) ProtoMessage()    {}
+func (*HTTPFilter) Descriptor() ([]byte, []int) {
+	return fileDescriptor_e85a9a4fa9c17a22, []int{23}
+}
+func (m *HTTPFilter) XXX_Unmarshal(b []byte) error {
+	return m.Unmarshal(b)
+}
+func (m *HTTPFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	if deterministic {
+		return xxx_messageInfo_HTTPFilter.Marshal(b, m, deterministic)
+	} else {
+		b = b[:cap(b)]
+		n, err := m.MarshalToSizedBuffer(b)
+		if err != nil {
+			return nil, err
+		}
+		return b[:n], nil
+	}
+}
+func (m *HTTPFilter) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_HTTPFilter.Merge(m, src)
+}
+func (m *HTTPFilter) XXX_Size() int {
+	return m.Size()
+}
+func (m *HTTPFilter) XXX_DiscardUnknown() {
+	xxx_messageInfo_HTTPFilter.DiscardUnknown(m)
+}
+
+var xxx_messageInfo_HTTPFilter proto.InternalMessageInfo
+
+type isHTTPFilter_Filter interface {
+	isHTTPFilter_Filter()
+	MarshalTo([]byte) (int, error)
+	Size() int
+}
+
+type HTTPFilter_IpAccessControl struct {
+	IpAccessControl *IPAccessControl `protobuf:"bytes,3,opt,name=ip_access_control,json=ipAccessControl,proto3,oneof" json:"ip_access_control,omitempty"`
+}
+type HTTPFilter_LocalRateLimit struct {
+	LocalRateLimit *LocalRateLimit `protobuf:"bytes,4,opt,name=local_rate_limit,json=localRateLimit,proto3,oneof" json:"local_rate_limit,omitempty"`
+}
+
+func (*HTTPFilter_IpAccessControl) isHTTPFilter_Filter() {}
+func (*HTTPFilter_LocalRateLimit) isHTTPFilter_Filter()  {}
+
+func (m *HTTPFilter) GetFilter() isHTTPFilter_Filter {
+	if m != nil {
+		return m.Filter
+	}
+	return nil
+}
+
+func (m *HTTPFilter) GetName() string {
+	if m != nil {
+		return m.Name
+	}
+	return ""
+}
+
+func (m *HTTPFilter) GetDisable() bool {
+	if m != nil {
+		return m.Disable
+	}
+	return false
+}
+
+func (m *HTTPFilter) GetIpAccessControl() *IPAccessControl {
+	if x, ok := m.GetFilter().(*HTTPFilter_IpAccessControl); ok {
+		return x.IpAccessControl
+	}
+	return nil
+}
+
+func (m *HTTPFilter) GetLocalRateLimit() *LocalRateLimit {
+	if x, ok := m.GetFilter().(*HTTPFilter_LocalRateLimit); ok {
+		return x.LocalRateLimit
+	}
+	return nil
+}
+
+// XXX_OneofWrappers is for the internal use of the proto package.
+func (*HTTPFilter) XXX_OneofWrappers() []interface{} {
+	return []interface{}{
+		(*HTTPFilter_IpAccessControl)(nil),
+		(*HTTPFilter_LocalRateLimit)(nil),
+	}
+}
+
+type IPAccessControl struct {
+	// Used for white ip access control
+	RemoteIpBlocks []string `protobuf:"bytes,1,rep,name=remote_ip_blocks,json=remoteIpBlocks,proto3" json:"remote_ip_blocks,omitempty"`
+	// Used for black ip access control
+	NotRemoteIpBlocks    []string `protobuf:"bytes,2,rep,name=not_remote_ip_blocks,json=notRemoteIpBlocks,proto3" json:"not_remote_ip_blocks,omitempty"`
+	XXX_NoUnkeyedLiteral struct{} `json:"-"`
+	XXX_unrecognized     []byte   `json:"-"`
+	XXX_sizecache        int32    `json:"-"`
+}
+
+func (m *IPAccessControl) Reset()         { *m = IPAccessControl{} }
+func (m *IPAccessControl) String() string { return proto.CompactTextString(m) }
+func (*IPAccessControl) ProtoMessage()    {}
+func (*IPAccessControl) Descriptor() ([]byte, []int) {
+	return fileDescriptor_e85a9a4fa9c17a22, []int{24}
+}
+func (m *IPAccessControl) XXX_Unmarshal(b []byte) error {
+	return m.Unmarshal(b)
+}
+func (m *IPAccessControl) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	if deterministic {
+		return xxx_messageInfo_IPAccessControl.Marshal(b, m, deterministic)
+	} else {
+		b = b[:cap(b)]
+		n, err := m.MarshalToSizedBuffer(b)
+		if err != nil {
+			return nil, err
+		}
+		return b[:n], nil
+	}
+}
+func (m *IPAccessControl) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_IPAccessControl.Merge(m, src)
+}
+func (m *IPAccessControl) XXX_Size() int {
+	return m.Size()
+}
+func (m *IPAccessControl) XXX_DiscardUnknown() {
+	xxx_messageInfo_IPAccessControl.DiscardUnknown(m)
+}
+
+var xxx_messageInfo_IPAccessControl proto.InternalMessageInfo
+
+func (m *IPAccessControl) GetRemoteIpBlocks() []string {
+	if m != nil {
+		return m.RemoteIpBlocks
+	}
+	return nil
+}
+
+func (m *IPAccessControl) GetNotRemoteIpBlocks() []string {
+	if m != nil {
+		return m.NotRemoteIpBlocks
+	}
+	return nil
+}
+
+type LocalRateLimit struct {
+	TokenBucket             *TokenBucket `protobuf:"bytes,1,opt,name=token_bucket,json=tokenBucket,proto3" json:"token_bucket,omitempty"`
+	PerDownstreamConnection bool         `protobuf:"varint,2,opt,name=per_downstream_connection,json=perDownstreamConnection,proto3" json:"per_downstream_connection,omitempty"`
+	// Default rate limit status code is 429.
+	StatusCode           uint32   `protobuf:"varint,3,opt,name=status_code,json=statusCode,proto3" json:"status_code,omitempty"`
+	XXX_NoUnkeyedLiteral struct{} `json:"-"`
+	XXX_unrecognized     []byte   `json:"-"`
+	XXX_sizecache        int32    `json:"-"`
+}
+
+func (m *LocalRateLimit) Reset()         { *m = LocalRateLimit{} }
+func (m *LocalRateLimit) String() string { return proto.CompactTextString(m) }
+func (*LocalRateLimit) ProtoMessage()    {}
+func (*LocalRateLimit) Descriptor() ([]byte, []int) {
+	return fileDescriptor_e85a9a4fa9c17a22, []int{25}
+}
+func (m *LocalRateLimit) XXX_Unmarshal(b []byte) error {
+	return m.Unmarshal(b)
+}
+func (m *LocalRateLimit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	if deterministic {
+		return xxx_messageInfo_LocalRateLimit.Marshal(b, m, deterministic)
+	} else {
+		b = b[:cap(b)]
+		n, err := m.MarshalToSizedBuffer(b)
+		if err != nil {
+			return nil, err
+		}
+		return b[:n], nil
+	}
+}
+func (m *LocalRateLimit) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_LocalRateLimit.Merge(m, src)
+}
+func (m *LocalRateLimit) XXX_Size() int {
+	return m.Size()
+}
+func (m *LocalRateLimit) XXX_DiscardUnknown() {
+	xxx_messageInfo_LocalRateLimit.DiscardUnknown(m)
+}
+
+var xxx_messageInfo_LocalRateLimit proto.InternalMessageInfo
+
+func (m *LocalRateLimit) GetTokenBucket() *TokenBucket {
+	if m != nil {
+		return m.TokenBucket
+	}
+	return nil
+}
+
+func (m *LocalRateLimit) GetPerDownstreamConnection() bool {
+	if m != nil {
+		return m.PerDownstreamConnection
+	}
+	return false
+}
+
+func (m *LocalRateLimit) GetStatusCode() uint32 {
+	if m != nil {
+		return m.StatusCode
+	}
+	return 0
+}
+
+type TokenBucket struct {
+	MaxTokens            uint32          `protobuf:"varint,1,opt,name=max_tokens,json=maxTokens,proto3" json:"max_tokens,omitempty"`
+	TokensPefFill        uint32          `protobuf:"varint,2,opt,name=tokens_pef_fill,json=tokensPefFill,proto3" json:"tokens_pef_fill,omitempty"`
+	FillInterval         *types.Duration `protobuf:"bytes,3,opt,name=fill_interval,json=fillInterval,proto3" json:"fill_interval,omitempty"`
+	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
+	XXX_unrecognized     []byte          `json:"-"`
+	XXX_sizecache        int32           `json:"-"`
+}
+
+func (m *TokenBucket) Reset()         { *m = TokenBucket{} }
+func (m *TokenBucket) String() string { return proto.CompactTextString(m) }
+func (*TokenBucket) ProtoMessage()    {}
+func (*TokenBucket) Descriptor() ([]byte, []int) {
+	return fileDescriptor_e85a9a4fa9c17a22, []int{26}
+}
+func (m *TokenBucket) XXX_Unmarshal(b []byte) error {
+	return m.Unmarshal(b)
+}
+func (m *TokenBucket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	if deterministic {
+		return xxx_messageInfo_TokenBucket.Marshal(b, m, deterministic)
+	} else {
+		b = b[:cap(b)]
+		n, err := m.MarshalToSizedBuffer(b)
+		if err != nil {
+			return nil, err
+		}
+		return b[:n], nil
+	}
+}
+func (m *TokenBucket) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_TokenBucket.Merge(m, src)
+}
+func (m *TokenBucket) XXX_Size() int {
+	return m.Size()
+}
+func (m *TokenBucket) XXX_DiscardUnknown() {
+	xxx_messageInfo_TokenBucket.DiscardUnknown(m)
+}
+
+var xxx_messageInfo_TokenBucket proto.InternalMessageInfo
+
+func (m *TokenBucket) GetMaxTokens() uint32 {
+	if m != nil {
+		return m.MaxTokens
+	}
+	return 0
+}
+
+func (m *TokenBucket) GetTokensPefFill() uint32 {
+	if m != nil {
+		return m.TokensPefFill
+	}
+	return 0
+}
+
+func (m *TokenBucket) GetFillInterval() *types.Duration {
+	if m != nil {
+		return m.FillInterval
+	}
+	return nil
+}
+
 func init() {
 	proto.RegisterEnum("istio.networking.v1alpha3.HTTPRedirect_RedirectPortSelection", HTTPRedirect_RedirectPortSelection_name, HTTPRedirect_RedirectPortSelection_value)
 	proto.RegisterType((*VirtualService)(nil), "istio.networking.v1alpha3.VirtualService")
@@ -3461,7 +4244,11 @@ func init() {
 	proto.RegisterType((*TLSMatchAttributes)(nil), "istio.networking.v1alpha3.TLSMatchAttributes")
 	proto.RegisterMapType((map[string]string)(nil), "istio.networking.v1alpha3.TLSMatchAttributes.SourceLabelsEntry")
 	proto.RegisterType((*HTTPRedirect)(nil), "istio.networking.v1alpha3.HTTPRedirect")
+	proto.RegisterType((*HTTPInternalActiveRedirect)(nil), "istio.networking.v1alpha3.HTTPInternalActiveRedirect")
+	proto.RegisterType((*HTTPInternalActiveRedirect_RedirectPolicy)(nil), "istio.networking.v1alpha3.HTTPInternalActiveRedirect.RedirectPolicy")
+	proto.RegisterType((*HTTPDirectResponse)(nil), "istio.networking.v1alpha3.HTTPDirectResponse")
 	proto.RegisterType((*HTTPRewrite)(nil), "istio.networking.v1alpha3.HTTPRewrite")
+	proto.RegisterType((*RegexMatchAndSubstitute)(nil), "istio.networking.v1alpha3.RegexMatchAndSubstitute")
 	proto.RegisterType((*StringMatch)(nil), "istio.networking.v1alpha3.StringMatch")
 	proto.RegisterType((*HTTPRetry)(nil), "istio.networking.v1alpha3.HTTPRetry")
 	proto.RegisterType((*CorsPolicy)(nil), "istio.networking.v1alpha3.CorsPolicy")
@@ -3470,6 +4257,10 @@ func init() {
 	proto.RegisterType((*HTTPFaultInjection_Abort)(nil), "istio.networking.v1alpha3.HTTPFaultInjection.Abort")
 	proto.RegisterType((*PortSelector)(nil), "istio.networking.v1alpha3.PortSelector")
 	proto.RegisterType((*Percent)(nil), "istio.networking.v1alpha3.Percent")
+	proto.RegisterType((*HTTPFilter)(nil), "istio.networking.v1alpha3.HTTPFilter")
+	proto.RegisterType((*IPAccessControl)(nil), "istio.networking.v1alpha3.IPAccessControl")
+	proto.RegisterType((*LocalRateLimit)(nil), "istio.networking.v1alpha3.LocalRateLimit")
+	proto.RegisterType((*TokenBucket)(nil), "istio.networking.v1alpha3.TokenBucket")
 }
 
 func init() {
@@ -3477,139 +4268,186 @@ func init() {
 }
 
 var fileDescriptor_e85a9a4fa9c17a22 = []byte{
-	// 2099 bytes of a gzipped FileDescriptorProto
-	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x59, 0x4b, 0x77, 0x1b, 0x49,
-	0xf5, 0x77, 0xeb, 0xad, 0x2b, 0xc9, 0x96, 0x2b, 0x8f, 0xe9, 0xf8, 0x9f, 0x93, 0xf1, 0x28, 0xff,
-	0xcc, 0x78, 0x0e, 0x8c, 0x7c, 0x70, 0x80, 0x93, 0x03, 0x99, 0x04, 0xbf, 0x32, 0x4e, 0x70, 0x22,
-	0x4f, 0x59, 0x19, 0xce, 0x61, 0xd3, 0xb4, 0xba, 0xaf, 0xa5, 0x26, 0x52, 0x77, 0xa7, 0xba, 0xda,
-	0xb6, 0x38, 0xec, 0x39, 0x87, 0xdd, 0xec, 0x58, 0xb0, 0x9c, 0x4f, 0xc1, 0x27, 0x60, 0x07, 0x3b,
-	0x96, 0x70, 0xb2, 0x60, 0xc1, 0x82, 0xaf, 0x00, 0xa7, 0x1e, 0x2d, 0xb5, 0x6c, 0x47, 0x8f, 0x30,
-	0x81, 0x95, 0x55, 0x55, 0xf7, 0xf7, 0xab, 0xaa, 0x7b, 0xeb, 0x3e, 0xfa, 0x1a, 0x3e, 0xf5, 0x91,
-	0x9f, 0x05, 0xec, 0x95, 0xe7, 0x77, 0x37, 0x4f, 0xbf, 0x67, 0xf7, 0xc3, 0x9e, 0x7d, 0x7f, 0xf3,
-	0xd4, 0x63, 0x3c, 0xb6, 0xfb, 0x56, 0x84, 0xec, 0xd4, 0x73, 0xb0, 0x19, 0xb2, 0x80, 0x07, 0xe4,
-	0x96, 0x17, 0x71, 0x2f, 0x68, 0x8e, 0x01, 0xcd, 0x04, 0xb0, 0xf6, 0x61, 0x37, 0x08, 0xba, 0x7d,
-	0xdc, 0xb4, 0x43, 0x6f, 0xf3, 0xc4, 0xc3, 0xbe, 0x6b, 0x75, 0xb0, 0x67, 0x9f, 0x7a, 0x01, 0x53,
-	0xd8, 0xb5, 0x3b, 0x5a, 0x40, 0x8e, 0x3a, 0xf1, 0xc9, 0xa6, 0x1b, 0x33, 0x9b, 0x7b, 0x81, 0xff,
-	0xb6, 0xf5, 0x33, 0x66, 0x87, 0x21, 0xb2, 0x48, 0xad, 0x37, 0x7e, 0x93, 0x81, 0xe5, 0xaf, 0xd4,
-	0xa9, 0x8e, 0xd5, 0xa1, 0xc8, 0x75, 0xc8, 0xf7, 0x82, 0x88, 0x47, 0xa6, 0xb1, 0x9e, 0xdd, 0x28,
-	0x53, 0x35, 0x20, 0x6b, 0x50, 0xea, 0xda, 0x1c, 0xcf, 0xec, 0x61, 0x64, 0x66, 0xe4, 0xc2, 0x68,
-	0x4c, 0x1e, 0x40, 0xae, 0xc7, 0x79, 0x68, 0x66, 0xd7, 0xb3, 0x1b, 0x95, 0xad, 0xff, 0x6f, 0xbe,
-	0xf5, 0x3e, 0xcd, 0x83, 0x76, 0xfb, 0x88, 0x06, 0x31, 0x47, 0x2a, 0x11, 0xe4, 0x07, 0x90, 0xe5,
-	0xfd, 0xc8, 0xcc, 0x4b, 0xe0, 0xdd, 0x29, 0xc0, 0xf6, 0xe1, 0xb1, 0xc2, 0x09, 0x79, 0x09, 0x73,
-	0x42, 0x33, 0x37, 0x1b, 0xb6, 0x7b, 0x94, 0xc0, 0x9c, 0x90, 0xfc, 0x1f, 0x94, 0xf1, 0x3c, 0x0c,
-	0x18, 0xb7, 0x78, 0x60, 0x16, 0xd4, 0x25, 0xd4, 0x44, 0x3b, 0x68, 0xfc, 0x1a, 0x2a, 0x7b, 0x18,
-	0x71, 0xcf, 0x97, 0xea, 0x23, 0x26, 0xe4, 0xc4, 0xc5, 0x4d, 0x63, 0xdd, 0xd8, 0x28, 0xef, 0xe4,
-	0xde, 0x6c, 0x1b, 0x19, 0x2a, 0x67, 0xc8, 0x4d, 0x28, 0x44, 0x71, 0x27, 0x42, 0x6e, 0x66, 0xc4,
-	0x1a, 0xd5, 0x23, 0xf2, 0x63, 0xc8, 0x09, 0x2a, 0x33, 0xbb, 0x6e, 0x6c, 0x54, 0xb6, 0x3e, 0x99,
-	0x72, 0xaa, 0xa3, 0x80, 0xf1, 0x63, 0xec, 0xa3, 0xc3, 0x03, 0x46, 0x25, 0xa8, 0xf1, 0xfb, 0x12,
-	0x94, 0x47, 0xca, 0x21, 0x04, 0x72, 0xbe, 0x3d, 0x40, 0x73, 0x55, 0x6e, 0x20, 0x7f, 0x93, 0x6d,
-	0xc8, 0x0f, 0x6c, 0xee, 0xf4, 0xa4, 0x59, 0x2a, 0x5b, 0xdf, 0x99, 0xa1, 0xe5, 0xe7, 0x42, 0x96,
-	0xe2, 0xeb, 0x18, 0x23, 0x4e, 0x15, 0x92, 0xec, 0x43, 0x9e, 0x09, 0x7e, 0x69, 0xc0, 0xca, 0xd6,
-	0xe6, 0x3c, 0x86, 0x4a, 0xe9, 0x84, 0x2a, 0x34, 0xd9, 0x85, 0x12, 0x43, 0xd7, 0x63, 0xe8, 0xcc,
-	0x73, 0x59, 0xc9, 0xa4, 0xc5, 0xe9, 0x08, 0x48, 0x1e, 0x43, 0xc9, 0xc5, 0x3e, 0x8a, 0x37, 0x64,
-	0x5e, 0x97, 0x24, 0xd3, 0xec, 0xb8, 0xa7, 0x45, 0xe9, 0x08, 0x44, 0x7e, 0x02, 0x45, 0x86, 0x67,
-	0xcc, 0xe3, 0x68, 0xe6, 0x24, 0xfe, 0xe3, 0x99, 0x87, 0x90, 0xd2, 0x34, 0x81, 0x91, 0xfb, 0x50,
-	0xe4, 0xde, 0x00, 0x83, 0x98, 0x9b, 0x05, 0xc9, 0x70, 0xab, 0xa9, 0xbc, 0xa5, 0x99, 0x78, 0x4b,
-	0x73, 0x4f, 0x7b, 0x13, 0x4d, 0x24, 0xc9, 0x23, 0xb1, 0x2d, 0x67, 0x1e, 0x46, 0x66, 0x51, 0x82,
-	0x66, 0x3e, 0x77, 0xe4, 0x6c, 0x48, 0x13, 0x10, 0xd9, 0x85, 0xfc, 0x89, 0x1d, 0xf7, 0xb9, 0x59,
-	0x92, 0xe8, 0xcf, 0x66, 0xa0, 0x9f, 0x08, 0xd9, 0xa7, 0xfe, 0x2f, 0xd1, 0x51, 0x16, 0x90, 0x58,
-	0xf2, 0x08, 0x0a, 0x03, 0x8f, 0xb1, 0x80, 0x99, 0xe5, 0x99, 0x57, 0x4f, 0x1b, 0x50, 0xa3, 0xc8,
-	0x17, 0xb0, 0xac, 0x7e, 0x59, 0x21, 0x32, 0x07, 0x7d, 0x6e, 0x12, 0xc9, 0x73, 0xfb, 0x92, 0x02,
-	0x5e, 0x3e, 0xf5, 0xf9, 0xfd, 0xad, 0xaf, 0xec, 0x7e, 0x8c, 0x3b, 0x19, 0xd3, 0xa0, 0x35, 0x85,
-	0x3b, 0x52, 0x30, 0xd2, 0x82, 0xd5, 0x49, 0x22, 0xbb, 0x8b, 0xe6, 0x35, 0xc9, 0xd5, 0x98, 0xe6,
-	0x00, 0x4a, 0x98, 0xd6, 0x27, 0xd8, 0xec, 0x2e, 0x92, 0x27, 0x50, 0x71, 0x02, 0x16, 0x59, 0x61,
-	0xd0, 0xf7, 0x9c, 0xa1, 0x09, 0x92, 0xea, 0xde, 0x14, 0xaa, 0xdd, 0x80, 0x45, 0x47, 0x52, 0x98,
-	0x82, 0x33, 0xfa, 0x4d, 0x1e, 0x42, 0xb1, 0x87, 0xb6, 0x8b, 0x2c, 0x32, 0xeb, 0x33, 0x8f, 0x73,
-	0xa0, 0x24, 0x69, 0x02, 0x79, 0x96, 0x2b, 0xe5, 0xeb, 0x85, 0x67, 0xb9, 0x52, 0xa5, 0x5e, 0xa7,
-	0xab, 0x67, 0xd8, 0x89, 0x02, 0xe7, 0x15, 0x72, 0x2b, 0x0e, 0xbb, 0xcc, 0x76, 0x91, 0x2e, 0x8b,
-	0x10, 0xea, 0xbb, 0x96, 0x16, 0xa7, 0x1f, 0x30, 0x1c, 0x04, 0xa7, 0x68, 0x31, 0x8c, 0xc2, 0xc0,
-	0x8f, 0x70, 0xbc, 0xa0, 0x05, 0x2f, 0x2d, 0xdc, 0x1c, 0x21, 0xa4, 0x83, 0x8e, 0xe7, 0x47, 0x80,
-	0x89, 0xf9, 0xc6, 0x43, 0x28, 0x25, 0x2e, 0x30, 0x0a, 0x0e, 0x46, 0x2a, 0x38, 0xdc, 0x86, 0xb2,
-	0xf8, 0x1b, 0x85, 0xb6, 0x83, 0x3a, 0x2c, 0x8d, 0x27, 0x1a, 0x7f, 0xcf, 0x42, 0x51, 0xdf, 0x91,
-	0x3c, 0x17, 0xef, 0x57, 0x92, 0x4b, 0x82, 0xca, 0xd6, 0xfd, 0xd9, 0x8a, 0xd1, 0x7f, 0x5b, 0x21,
-	0x2a, 0x6f, 0x88, 0x68, 0xc2, 0x41, 0x5a, 0x22, 0x16, 0xa8, 0xcb, 0xc9, 0x7d, 0xdf, 0x91, 0x6f,
-	0x44, 0xb2, 0xf6, 0x87, 0x0c, 0xd4, 0x2f, 0x2e, 0x93, 0x17, 0x90, 0x15, 0xf1, 0x56, 0x45, 0xbe,
-	0x87, 0xef, 0xb0, 0x41, 0xf3, 0x18, 0xf9, 0xbe, 0x2f, 0x1c, 0x51, 0x10, 0x09, 0x3e, 0xdb, 0x75,
-	0x75, 0x18, 0x7c, 0x27, 0xbe, 0x6d, 0xd7, 0xd5, 0x7c, 0xb6, 0xeb, 0x8a, 0x94, 0xa0, 0x0c, 0x2a,
-	0x53, 0x60, 0x99, 0xea, 0xd1, 0xda, 0x0f, 0xa1, 0x94, 0x6c, 0x4c, 0xea, 0x90, 0x7d, 0x85, 0x43,
-	0x6d, 0x35, 0xf1, 0x53, 0x24, 0xda, 0x53, 0xe1, 0x58, 0xda, 0x60, 0x6a, 0xf0, 0xa3, 0xcc, 0x03,
-	0x43, 0xe0, 0x92, 0x0d, 0x16, 0xc1, 0x35, 0x7e, 0x67, 0x40, 0x29, 0xc9, 0x94, 0xe4, 0xe9, 0x64,
-	0xc2, 0xf8, 0x6c, 0x7a, 0x76, 0x95, 0xf9, 0x62, 0x9b, 0x73, 0xe6, 0x75, 0x62, 0x8e, 0x91, 0xce,
-	0x78, 0x3a, 0x71, 0x6c, 0x4f, 0x26, 0x8e, 0x69, 0xb9, 0xe7, 0x2d, 0x49, 0xa3, 0xf1, 0xb5, 0x38,
-	0x9a, 0xce, 0xc6, 0x64, 0x67, 0xf2, 0x68, 0xdf, 0x9d, 0xc2, 0x77, 0xf8, 0xfd, 0x0b, 0x27, 0xfb,
-	0x16, 0xcf, 0xf4, 0x4d, 0x19, 0xea, 0x17, 0x73, 0xe5, 0xc8, 0xbd, 0x2a, 0x29, 0xf7, 0x7a, 0x00,
-	0xd9, 0x98, 0x79, 0xda, 0x61, 0xa6, 0x05, 0xdb, 0x63, 0xce, 0x3c, 0xbf, 0xab, 0xf8, 0x04, 0x44,
-	0x44, 0xea, 0xc8, 0xe9, 0xe1, 0x20, 0xf1, 0x8e, 0x79, 0xc1, 0x1a, 0x25, 0x23, 0x3d, 0xf2, 0x5e,
-	0xe0, 0xea, 0x4c, 0x3b, 0x37, 0x5e, 0xa1, 0xc8, 0x1e, 0x94, 0xed, 0x98, 0xf7, 0x02, 0xe6, 0xf1,
-	0xe1, 0x1c, 0x79, 0x32, 0x4d, 0x31, 0x06, 0x12, 0x3a, 0x8e, 0xa6, 0xaa, 0x54, 0x7b, 0xb0, 0x40,
-	0xf5, 0x91, 0x38, 0x91, 0xf2, 0x97, 0x84, 0x48, 0xe8, 0x59, 0x96, 0x4b, 0x22, 0xf5, 0xd6, 0x54,
-	0x15, 0x44, 0x3a, 0x50, 0x8b, 0x82, 0x98, 0x39, 0x68, 0xf5, 0xed, 0x0e, 0xf6, 0x45, 0x8a, 0x15,
-	0xbb, 0x7d, 0xbe, 0xc8, 0x6e, 0xc7, 0x92, 0xe0, 0x50, 0xe2, 0xd5, 0x96, 0xd5, 0x28, 0x35, 0x35,
-	0x51, 0xc8, 0x96, 0x2e, 0x14, 0xb2, 0x16, 0x54, 0x5f, 0xc7, 0xc8, 0x86, 0x56, 0x68, 0x33, 0x7b,
-	0x10, 0x99, 0xe5, 0xd9, 0x01, 0xe2, 0xe2, 0xf6, 0x5f, 0x0a, 0xfc, 0x91, 0x84, 0xab, 0xdd, 0x2b,
-	0xaf, 0xc7, 0x33, 0xe4, 0x63, 0x58, 0xf1, 0xba, 0x7e, 0xc0, 0xd0, 0x8a, 0x99, 0x67, 0x39, 0x76,
-	0x84, 0x32, 0xc5, 0x95, 0x68, 0x4d, 0x4d, 0xbf, 0x64, 0xde, 0xae, 0x1d, 0x21, 0xe9, 0xc1, 0xca,
-	0x99, 0xc7, 0x7b, 0x41, 0x3c, 0x4a, 0x01, 0x66, 0x55, 0x9e, 0xe5, 0xf1, 0x22, 0x67, 0xf9, 0x99,
-	0xa2, 0x98, 0xd0, 0xff, 0xf2, 0xd9, 0xc4, 0x24, 0xf9, 0x14, 0xea, 0x5a, 0xe5, 0xe3, 0x04, 0x52,
-	0x93, 0x4f, 0x7f, 0x45, 0xcd, 0xbf, 0x48, 0xa6, 0xd7, 0x3a, 0x50, 0x4d, 0x53, 0x5d, 0x11, 0x99,
-	0x1e, 0xa6, 0x23, 0xd3, 0xfc, 0x2f, 0x2d, 0x15, 0xf9, 0x1e, 0xc3, 0xea, 0x25, 0x03, 0x2e, 0x14,
-	0x3a, 0x4f, 0xa0, 0x7e, 0xd1, 0x04, 0xef, 0xe5, 0xa0, 0x1e, 0x5c, 0xbb, 0x42, 0xbd, 0xef, 0x63,
-	0xab, 0xc6, 0x37, 0x19, 0xb8, 0x7e, 0x55, 0x3d, 0x4e, 0x5e, 0x40, 0xc5, 0x1d, 0x0f, 0xe7, 0x08,
-	0x4f, 0x29, 0xb0, 0x0e, 0xf0, 0x69, 0x02, 0x91, 0xc6, 0xce, 0xd0, 0xeb, 0xf6, 0xd4, 0x97, 0x4d,
-	0x9e, 0xea, 0x51, 0xba, 0x98, 0x2a, 0xbe, 0x4b, 0x31, 0x95, 0xad, 0x17, 0xff, 0x0b, 0x35, 0xd2,
-	0xaf, 0xa0, 0xfe, 0xbf, 0xd2, 0x50, 0xe3, 0x1f, 0x19, 0x58, 0xbd, 0x94, 0xa9, 0xc8, 0x26, 0x5c,
-	0x4b, 0x81, 0xad, 0x28, 0xee, 0xf8, 0x38, 0xfa, 0xae, 0x26, 0xa9, 0xa5, 0x63, 0xb5, 0x32, 0x8a,
-	0x89, 0x99, 0x54, 0x4c, 0xbc, 0x3b, 0x8a, 0x89, 0x0a, 0x2f, 0x13, 0x41, 0x39, 0x09, 0x6a, 0x0a,
-	0x49, 0x9c, 0x8b, 0x81, 0x53, 0x7d, 0x1a, 0x3f, 0x5a, 0x24, 0xb1, 0x2e, 0x14, 0x39, 0xf3, 0x17,
-	0x22, 0xe7, 0x55, 0x61, 0xa4, 0x70, 0x75, 0x18, 0xf9, 0x4f, 0x5d, 0xbc, 0xf1, 0xaf, 0x0c, 0x90,
-	0xcb, 0x15, 0x0b, 0xf9, 0x08, 0xca, 0x91, 0xef, 0x59, 0xa9, 0xde, 0x85, 0xb6, 0x60, 0x29, 0xf2,
-	0xbd, 0x03, 0xd9, 0xc4, 0x78, 0x8b, 0x41, 0x32, 0x33, 0x0d, 0x92, 0x4d, 0x19, 0xc4, 0xbd, 0xa8,
-	0xeb, 0xfc, 0xcc, 0xc8, 0x7c, 0xf9, 0xb4, 0x0b, 0x29, 0xbb, 0x30, 0x87, 0xb2, 0x8b, 0xef, 0x47,
-	0xd9, 0xcf, 0x72, 0xa5, 0x5c, 0x3d, 0x4f, 0x27, 0x9f, 0x60, 0xe3, 0x4f, 0x19, 0xa8, 0xa6, 0xbf,
-	0xeb, 0x05, 0x63, 0x52, 0x20, 0x95, 0x55, 0xe1, 0x73, 0x3b, 0x5d, 0x78, 0xe8, 0x2f, 0x92, 0x71,
-	0x41, 0x71, 0x5d, 0xeb, 0x55, 0x54, 0x24, 0xb5, 0x83, 0x25, 0xad, 0xd9, 0x5f, 0x08, 0x6f, 0x65,
-	0xde, 0x29, 0x5a, 0x72, 0x31, 0xbf, 0x6e, 0x6c, 0x2c, 0xcf, 0x4c, 0xfe, 0xc9, 0x19, 0x9a, 0xc9,
-	0x8f, 0x71, 0x77, 0xc5, 0x0b, 0xfc, 0x83, 0x25, 0x0a, 0x8a, 0x53, 0x4c, 0xcb, 0xde, 0x8d, 0x2a,
-	0xc7, 0x0a, 0xba, 0x77, 0xa3, 0xca, 0xac, 0xbb, 0x50, 0x4b, 0x3a, 0x13, 0x96, 0x13, 0xb8, 0xa8,
-	0x0d, 0x5e, 0x4d, 0x26, 0x77, 0x03, 0x17, 0x1b, 0x4f, 0xe1, 0xc6, 0x95, 0x7b, 0x90, 0x5b, 0x70,
-	0xe3, 0x09, 0x6d, 0x3d, 0xb7, 0x8e, 0x68, 0xab, 0xdd, 0xda, 0x6d, 0x1d, 0x5a, 0x7b, 0xfb, 0x4f,
-	0xb6, 0x5f, 0x1e, 0xb6, 0xeb, 0x4b, 0xe4, 0x06, 0xac, 0xca, 0x25, 0xba, 0xff, 0xe5, 0xcb, 0xfd,
-	0xe3, 0xb6, 0x75, 0xd4, 0xa2, 0xed, 0xba, 0xb1, 0xb3, 0x92, 0xda, 0x4f, 0xf6, 0x7f, 0x3e, 0x87,
-	0x4a, 0xaa, 0x47, 0xb1, 0xa8, 0x3e, 0x1b, 0x08, 0x95, 0x54, 0xf2, 0x20, 0x37, 0x21, 0x8f, 0xe7,
-	0xb6, 0xa3, 0xbb, 0x57, 0x07, 0x4b, 0x54, 0x0d, 0x89, 0x09, 0x85, 0x90, 0xe1, 0x89, 0x77, 0xae,
-	0x18, 0x0e, 0x96, 0xa8, 0x1e, 0x0b, 0x04, 0xc3, 0x2e, 0x9e, 0xab, 0xe8, 0x22, 0x10, 0x72, 0xb8,
-	0x53, 0x05, 0x90, 0xe5, 0xb6, 0xc5, 0x87, 0x21, 0x36, 0xfe, 0x6a, 0xe8, 0x2e, 0x15, 0x8a, 0x67,
-	0xb4, 0x0e, 0x25, 0x9b, 0x73, 0x1c, 0x84, 0xd2, 0xdf, 0x8c, 0x8d, 0x7c, 0xe2, 0x6f, 0xc9, 0x2c,
-	0xd9, 0x86, 0x95, 0x10, 0x99, 0xc5, 0xd9, 0xd0, 0x4a, 0x3a, 0x2d, 0x99, 0x59, 0x9d, 0x96, 0x5a,
-	0x88, 0xac, 0xcd, 0x86, 0x6d, 0xdd, 0x6f, 0xb9, 0x25, 0x3e, 0x30, 0x05, 0x41, 0xe0, 0xeb, 0xc8,
-	0x27, 0x5b, 0x29, 0xc3, 0x96, 0x4f, 0x28, 0x7c, 0xa0, 0x96, 0x44, 0xa2, 0xe0, 0x68, 0xf5, 0x03,
-	0xc7, 0xee, 0x7b, 0xdc, 0xc3, 0x48, 0x57, 0xba, 0x6b, 0x97, 0x76, 0xd9, 0x09, 0x82, 0xbe, 0x6c,
-	0x66, 0xd0, 0x1b, 0x12, 0x4a, 0x25, 0xf2, 0x70, 0x04, 0x6c, 0xfc, 0x33, 0x03, 0x30, 0x6e, 0x29,
-	0x90, 0x7b, 0x50, 0xb5, 0xfb, 0xfd, 0xe0, 0xcc, 0x0a, 0x98, 0xd7, 0xf5, 0x7c, 0x1d, 0x56, 0x32,
-	0xa6, 0x41, 0x2b, 0x72, 0xbe, 0x25, 0xa7, 0xc9, 0x4f, 0xa1, 0x96, 0x16, 0x4b, 0xea, 0xd6, 0x79,
-	0x73, 0x7d, 0x35, 0xc5, 0x15, 0x89, 0xb7, 0xa8, 0xc8, 0x54, 0x09, 0x9f, 0x84, 0x27, 0x25, 0xf4,
-	0x5c, 0xcd, 0x8d, 0x85, 0x92, 0xc4, 0x9c, 0x4d, 0x09, 0x25, 0xb5, 0xdd, 0x3d, 0x58, 0xc6, 0xf3,
-	0x30, 0x18, 0xe7, 0x54, 0x99, 0x16, 0xca, 0xb4, 0xa6, 0x66, 0x13, 0xb1, 0x2d, 0x28, 0x0e, 0xec,
-	0x73, 0xcb, 0xee, 0xa2, 0x74, 0xb9, 0xa9, 0xd6, 0x29, 0x0c, 0xec, 0xf3, 0xed, 0x2e, 0x92, 0x2f,
-	0x60, 0x55, 0xed, 0xef, 0x30, 0x74, 0xd1, 0xe7, 0x9e, 0xdd, 0x8f, 0x74, 0x17, 0x6d, 0x9a, 0xd6,
-	0xeb, 0x12, 0xb4, 0x3b, 0xc6, 0x34, 0xbe, 0xce, 0x03, 0xb9, 0xdc, 0xe8, 0x12, 0x1f, 0xaf, 0x2e,
-	0xf6, 0xed, 0xe1, 0x3c, 0x4d, 0x8a, 0x4b, 0xe8, 0xe6, 0x9e, 0x80, 0x52, 0xc5, 0x20, 0xa8, 0xec,
-	0x4e, 0x92, 0x55, 0x17, 0xa6, 0xda, 0x16, 0x50, 0xaa, 0x18, 0xd6, 0x7e, 0x9b, 0x81, 0xbc, 0xe4,
-	0x26, 0xb7, 0xa1, 0x98, 0xb4, 0xce, 0xd4, 0xd3, 0x17, 0x6f, 0x22, 0x99, 0x22, 0x3b, 0x50, 0x39,
-	0xf1, 0xce, 0xd1, 0xb5, 0xd4, 0x1d, 0x66, 0xbd, 0x79, 0xe5, 0x37, 0x22, 0x54, 0x49, 0x94, 0xda,
-	0xe1, 0x00, 0x56, 0x85, 0x99, 0x7c, 0xa5, 0x28, 0xcd, 0x94, 0x9d, 0xc1, 0x74, 0xb0, 0x44, 0xeb,
-	0x29, 0x94, 0x62, 0xda, 0x01, 0x48, 0x75, 0xe7, 0xf2, 0x73, 0x77, 0xe7, 0x52, 0xa8, 0x9d, 0x55,
-	0x58, 0xe9, 0x71, 0x1e, 0xaa, 0x63, 0xc8, 0x60, 0xb0, 0xf6, 0x17, 0x03, 0xf2, 0x52, 0x3b, 0xe4,
-	0x13, 0xa8, 0xc8, 0xc5, 0x88, 0xdb, 0x3c, 0x8e, 0x54, 0x69, 0x34, 0xbe, 0x93, 0x58, 0x3a, 0x96,
-	0x2b, 0xe4, 0x23, 0xa8, 0x74, 0x59, 0xe8, 0x24, 0x82, 0x49, 0xac, 0x01, 0x31, 0x39, 0x16, 0x11,
-	0x80, 0x2d, 0x0b, 0x65, 0x7f, 0x33, 0x97, 0x88, 0xc8, 0xc9, 0x7d, 0xd9, 0xbd, 0xfc, 0x36, 0xee,
-	0x53, 0x05, 0x90, 0x1b, 0xc8, 0xab, 0x3c, 0xcb, 0x95, 0x8c, 0x7a, 0x66, 0x64, 0xbe, 0xc6, 0x16,
-	0x54, 0xd3, 0x2d, 0x7a, 0x91, 0x35, 0xfc, 0x78, 0xd0, 0x41, 0x26, 0x6d, 0x5d, 0xa3, 0x7a, 0xf4,
-	0x2c, 0x57, 0xca, 0xd4, 0xb3, 0xaa, 0x45, 0xd0, 0xf8, 0x10, 0x8a, 0x49, 0x53, 0x74, 0x94, 0x4c,
-	0x85, 0xb4, 0xa1, 0x93, 0xe9, 0x4e, 0xf3, 0x8f, 0x6f, 0xee, 0x18, 0x7f, 0x7e, 0x73, 0xc7, 0xf8,
-	0xdb, 0x9b, 0x3b, 0xc6, 0xcf, 0xd7, 0xd5, 0x71, 0xbd, 0x40, 0xfe, 0x6b, 0xe7, 0x8a, 0xff, 0x15,
-	0x75, 0x0a, 0xd2, 0xb8, 0xf7, 0xff, 0x1d, 0x00, 0x00, 0xff, 0xff, 0xd2, 0x9c, 0x74, 0x5c, 0x49,
-	0x1a, 0x00, 0x00,
+	// 2862 bytes of a gzipped FileDescriptorProto
+	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x5a, 0x4b, 0x73, 0x24, 0x47,
+	0x11, 0xd6, 0xbc, 0x34, 0x33, 0x39, 0x33, 0xd2, 0xa8, 0xbc, 0x8f, 0x5e, 0xb1, 0xac, 0xe5, 0x59,
+	0x6c, 0xaf, 0xc1, 0x96, 0x02, 0xad, 0x6d, 0x36, 0xcc, 0xb2, 0x46, 0x23, 0xed, 0x5a, 0x5a, 0x76,
+	0x2d, 0xb9, 0x24, 0xd9, 0x04, 0x97, 0x76, 0x4f, 0x77, 0x69, 0xa6, 0x50, 0x4f, 0x77, 0x6f, 0x75,
+	0xb5, 0x1e, 0x04, 0xbf, 0x80, 0x08, 0x88, 0x70, 0x04, 0x07, 0x7e, 0x00, 0x3f, 0x02, 0xf8, 0x05,
+	0x9c, 0x80, 0x1b, 0xc1, 0x09, 0x62, 0x0f, 0x04, 0xc1, 0x81, 0x1b, 0x07, 0x4e, 0x10, 0xf5, 0xea,
+	0xe9, 0x91, 0xb4, 0xf3, 0x90, 0x1f, 0x9c, 0x34, 0x95, 0x95, 0x5f, 0xd6, 0x2b, 0xeb, 0xcb, 0xac,
+	0x6c, 0xc1, 0x1b, 0x01, 0xe1, 0xc7, 0x21, 0x3b, 0xa4, 0x41, 0x77, 0xe5, 0xe8, 0xdb, 0x8e, 0x1f,
+	0xf5, 0x9c, 0xbb, 0x2b, 0x47, 0x94, 0xf1, 0xc4, 0xf1, 0xed, 0x98, 0xb0, 0x23, 0xea, 0x92, 0xe5,
+	0x88, 0x85, 0x3c, 0x44, 0x37, 0x68, 0xcc, 0x69, 0xb8, 0x3c, 0x00, 0x2c, 0x1b, 0xc0, 0xe2, 0xcb,
+	0xdd, 0x30, 0xec, 0xfa, 0x64, 0xc5, 0x89, 0xe8, 0xca, 0x01, 0x25, 0xbe, 0x67, 0x77, 0x48, 0xcf,
+	0x39, 0xa2, 0x21, 0x53, 0xd8, 0xc5, 0x5b, 0x5a, 0x41, 0xb6, 0x3a, 0xc9, 0xc1, 0x8a, 0x97, 0x30,
+	0x87, 0xd3, 0x30, 0x78, 0x51, 0xff, 0x31, 0x73, 0xa2, 0x88, 0xb0, 0x58, 0xf5, 0xb7, 0xfe, 0x92,
+	0x87, 0xb9, 0x8f, 0xd5, 0xac, 0x76, 0xd5, 0xa4, 0xd0, 0x15, 0x28, 0xf5, 0xc2, 0x98, 0xc7, 0x56,
+	0x6e, 0xa9, 0x70, 0xa7, 0x8a, 0x55, 0x03, 0x2d, 0x42, 0xa5, 0xeb, 0x70, 0x72, 0xec, 0x9c, 0xc6,
+	0x56, 0x5e, 0x76, 0xa4, 0x6d, 0xb4, 0x03, 0xf3, 0x42, 0x69, 0x73, 0x6f, 0x6f, 0xe7, 0x11, 0xf5,
+	0x39, 0x61, 0xb1, 0xf5, 0x8f, 0xf2, 0x52, 0xe1, 0x4e, 0x6d, 0xf5, 0xd5, 0xe5, 0x17, 0xae, 0x6d,
+	0x79, 0xa0, 0x8e, 0xcf, 0xc2, 0xd1, 0x3d, 0x28, 0xf6, 0x38, 0x8f, 0xac, 0x82, 0xb4, 0xf2, 0x8d,
+	0x31, 0x56, 0x70, 0x98, 0x70, 0x82, 0x25, 0x02, 0xbd, 0x03, 0x05, 0xee, 0xc7, 0x56, 0x49, 0x02,
+	0x6f, 0x8f, 0x00, 0xee, 0x3d, 0xd9, 0x55, 0x38, 0xa1, 0x2f, 0x61, 0x6e, 0x64, 0x15, 0xc7, 0xc3,
+	0xd6, 0x77, 0x0c, 0xcc, 0x8d, 0xd0, 0xd7, 0xa0, 0x4a, 0x4e, 0xa2, 0x90, 0x71, 0x9b, 0x87, 0xd6,
+	0xac, 0xda, 0x16, 0x25, 0xd8, 0x0b, 0x5b, 0x3f, 0x85, 0xda, 0x06, 0x89, 0x39, 0x0d, 0xe4, 0x81,
+	0x20, 0x0b, 0x8a, 0x62, 0x99, 0x56, 0x6e, 0x29, 0x77, 0xa7, 0xda, 0x2e, 0x3e, 0x5f, 0xcb, 0xe5,
+	0xb1, 0x94, 0xa0, 0x6b, 0x30, 0x1b, 0x27, 0x9d, 0x98, 0x70, 0x2b, 0x2f, 0xfa, 0xb0, 0x6e, 0xa1,
+	0xef, 0x42, 0x51, 0x98, 0xb2, 0x0a, 0x4b, 0xb9, 0x3b, 0xb5, 0xd5, 0xd7, 0x47, 0xcc, 0x6a, 0x27,
+	0x64, 0x7c, 0x97, 0xf8, 0xc4, 0xe5, 0x21, 0xc3, 0x12, 0xd4, 0xfa, 0x2d, 0x40, 0x35, 0xdd, 0x1c,
+	0x84, 0xa0, 0x18, 0x38, 0x7d, 0x62, 0x2d, 0xc8, 0x01, 0xe4, 0x6f, 0xb4, 0x06, 0xa5, 0xbe, 0xc3,
+	0xdd, 0x9e, 0x3c, 0xe8, 0xda, 0xea, 0xb7, 0xc6, 0xec, 0xf2, 0x53, 0xa1, 0x8b, 0xc9, 0xb3, 0x84,
+	0xc4, 0x1c, 0x2b, 0x24, 0x7a, 0x08, 0x25, 0x26, 0xec, 0x4b, 0x97, 0xa8, 0xad, 0xae, 0x4c, 0x72,
+	0x50, 0x99, 0x3d, 0xc1, 0x0a, 0x8d, 0x30, 0x34, 0xe5, 0x8f, 0xcb, 0x7b, 0xd0, 0x39, 0x3c, 0x5a,
+	0x87, 0x0a, 0x23, 0x1e, 0x65, 0xc4, 0x9d, 0x64, 0x03, 0xe5, 0xec, 0xb4, 0x3a, 0x4e, 0x81, 0x28,
+	0x04, 0x8b, 0x06, 0x9c, 0xb0, 0xc0, 0xf1, 0x6d, 0xc7, 0xe5, 0xf4, 0x88, 0xd8, 0xa9, 0xd1, 0x1b,
+	0xd2, 0xe8, 0x3b, 0x63, 0x8c, 0x6e, 0x69, 0xf8, 0x9a, 0x44, 0xa7, 0x43, 0x5c, 0xa3, 0x17, 0xca,
+	0xd1, 0xc7, 0x30, 0xaf, 0x7e, 0xd9, 0x8c, 0xc4, 0x51, 0x18, 0xc4, 0xc4, 0x5a, 0x94, 0xe3, 0xbc,
+	0x35, 0x66, 0x9c, 0x0d, 0x65, 0x57, 0x83, 0xf0, 0x9c, 0x37, 0xd4, 0x46, 0xef, 0x43, 0xc5, 0x23,
+	0x3e, 0x11, 0x57, 0xd6, 0xba, 0x22, 0x0d, 0x8e, 0x72, 0xf2, 0x0d, 0xad, 0x8a, 0x53, 0x10, 0xfa,
+	0x3e, 0x94, 0x19, 0x39, 0x66, 0x94, 0x13, 0xab, 0x28, 0xf1, 0xaf, 0x8d, 0xdd, 0x4d, 0xa9, 0x8d,
+	0x0d, 0x0c, 0xdd, 0x85, 0x32, 0xa7, 0x7d, 0x12, 0x26, 0xdc, 0x9a, 0x95, 0x16, 0x6e, 0x2c, 0x2b,
+	0x72, 0x5a, 0x36, 0xe4, 0xb4, 0xbc, 0xa1, 0xc9, 0x0b, 0x1b, 0x4d, 0xf4, 0x40, 0x0c, 0xcb, 0x19,
+	0x25, 0xb1, 0x55, 0x96, 0xa0, 0xb1, 0x5c, 0x40, 0x38, 0x3b, 0xc5, 0x06, 0x84, 0xd6, 0xa1, 0x74,
+	0xe0, 0x24, 0x3e, 0xb7, 0x2a, 0x13, 0xed, 0xe2, 0x23, 0xa1, 0xbb, 0x15, 0xfc, 0x98, 0xb8, 0xca,
+	0x3d, 0x25, 0x16, 0x3d, 0x80, 0xd9, 0x3e, 0x65, 0x2c, 0x64, 0x56, 0x75, 0xec, 0xd2, 0xb3, 0xde,
+	0xad, 0x51, 0xe8, 0x03, 0x98, 0x53, 0xbf, 0xec, 0x88, 0x30, 0x97, 0x04, 0xdc, 0x42, 0xd2, 0xce,
+	0xcd, 0x73, 0x1b, 0xb0, 0xbf, 0x15, 0xf0, 0xbb, 0xab, 0x1f, 0x3b, 0x7e, 0x42, 0xda, 0x79, 0x2b,
+	0x87, 0x1b, 0x0a, 0xb7, 0xa3, 0x60, 0x68, 0x1b, 0x16, 0x86, 0x0d, 0x39, 0x5d, 0x62, 0xbd, 0x24,
+	0x6d, 0xb5, 0x46, 0xb1, 0x83, 0x52, 0xc6, 0xcd, 0x21, 0x6b, 0x4e, 0x97, 0xa0, 0x47, 0x50, 0x73,
+	0x43, 0x16, 0xdb, 0x51, 0xe8, 0x53, 0xf7, 0xd4, 0x02, 0x69, 0x6a, 0xd4, 0x95, 0x5b, 0x0f, 0x59,
+	0xbc, 0x23, 0x95, 0x31, 0xb8, 0xe9, 0x6f, 0x74, 0x1f, 0xca, 0x3d, 0xe2, 0x78, 0xe2, 0xde, 0x36,
+	0xc7, 0x4e, 0x67, 0x53, 0x69, 0x62, 0x03, 0x79, 0x5c, 0xac, 0x94, 0x9a, 0xb3, 0x8f, 0x8b, 0x95,
+	0x5a, 0xb3, 0x89, 0x17, 0x8e, 0x49, 0x27, 0x0e, 0xdd, 0x43, 0xc2, 0xed, 0x24, 0xea, 0x32, 0xc7,
+	0x23, 0x78, 0x4e, 0x44, 0xac, 0xc0, 0xb3, 0xb5, 0x3a, 0xbe, 0xce, 0x48, 0x3f, 0x94, 0x37, 0x51,
+	0x39, 0xf7, 0xa0, 0x43, 0x2b, 0x9e, 0xeb, 0xb8, 0x96, 0x22, 0x24, 0x7b, 0x0d, 0xe4, 0x29, 0x60,
+	0x48, 0xde, 0xba, 0x0f, 0x15, 0x73, 0x05, 0x52, 0xe6, 0xcc, 0x65, 0x98, 0xf3, 0x26, 0x54, 0xc5,
+	0xdf, 0x38, 0x72, 0x5c, 0xa2, 0x39, 0x7b, 0x20, 0x68, 0xfd, 0xbd, 0x00, 0x65, 0xbd, 0x46, 0xf4,
+	0x54, 0xf8, 0xaf, 0x34, 0x2e, 0x0d, 0xd4, 0x56, 0xef, 0x8e, 0xdf, 0x18, 0xfd, 0x77, 0x3b, 0x22,
+	0xea, 0x36, 0xc4, 0xd8, 0xd8, 0x40, 0xdb, 0x82, 0xd4, 0x34, 0x2f, 0xe4, 0x2f, 0x6f, 0x2f, 0x35,
+	0xb2, 0xf8, 0xbb, 0x3c, 0x34, 0xcf, 0x76, 0xa3, 0x0f, 0xa1, 0x20, 0x82, 0x91, 0x0a, 0x0b, 0xf7,
+	0x2f, 0x31, 0xc0, 0xf2, 0x2e, 0xe1, 0x0f, 0x03, 0x71, 0x11, 0x85, 0x21, 0x61, 0xcf, 0xf1, 0x3c,
+	0x1d, 0x23, 0x2e, 0x65, 0x6f, 0xcd, 0xf3, 0xb4, 0x3d, 0xc7, 0xf3, 0x44, 0xbc, 0x54, 0x07, 0x2a,
+	0xf3, 0x83, 0x2a, 0xd6, 0xad, 0xc5, 0x77, 0xa1, 0x62, 0x06, 0x46, 0x4d, 0x28, 0x1c, 0x92, 0x53,
+	0x7d, 0x6a, 0xe2, 0xa7, 0xc8, 0x6b, 0x8e, 0xc4, 0xc5, 0xd2, 0x07, 0xa6, 0x1a, 0xef, 0xe5, 0xef,
+	0xe5, 0x04, 0xce, 0x0c, 0x30, 0x0d, 0xae, 0xf5, 0xab, 0x1c, 0x54, 0x4c, 0x1a, 0x81, 0xb6, 0x86,
+	0xa3, 0xe9, 0x5b, 0xa3, 0x53, 0x0f, 0x19, 0x4c, 0xd7, 0x38, 0x67, 0xb4, 0x93, 0x70, 0x12, 0xeb,
+	0x74, 0x40, 0x47, 0xd5, 0xb5, 0xe1, 0xa8, 0x3a, 0x2a, 0x30, 0xbf, 0x20, 0xa2, 0xb6, 0x3e, 0x13,
+	0x53, 0xd3, 0xa9, 0x0a, 0x6a, 0x0f, 0x4f, 0xed, 0xcd, 0x11, 0xf6, 0x9e, 0xbc, 0x7d, 0x66, 0x66,
+	0x5f, 0xe0, 0x9c, 0x7e, 0x5d, 0x85, 0xe6, 0xd9, 0x44, 0x22, 0xbd, 0x5e, 0xb5, 0xcc, 0xf5, 0xba,
+	0x07, 0x85, 0x84, 0x51, 0x7d, 0x61, 0x46, 0x91, 0xed, 0x2e, 0x67, 0x34, 0xe8, 0x2a, 0x7b, 0x02,
+	0x22, 0x98, 0x3a, 0x76, 0x7b, 0xa4, 0x6f, 0x6e, 0xc7, 0xa4, 0x60, 0x8d, 0x92, 0x4c, 0x4f, 0x78,
+	0x2f, 0xf4, 0x74, 0xca, 0x30, 0x31, 0x5e, 0xa1, 0xd0, 0x06, 0x54, 0x9d, 0x84, 0xf7, 0x42, 0x46,
+	0xf9, 0xe9, 0x04, 0x71, 0x32, 0x6b, 0x62, 0x00, 0x44, 0x78, 0xc0, 0xa6, 0x2a, 0x8f, 0xbd, 0x37,
+	0x45, 0x6a, 0x66, 0x2e, 0x91, 0xba, 0x2f, 0xc6, 0x90, 0xd8, 0x67, 0x99, 0x4b, 0x8a, 0xd0, 0xdb,
+	0x50, 0x29, 0x22, 0xea, 0x40, 0x23, 0x0e, 0x13, 0xe6, 0x12, 0xdb, 0x77, 0x3a, 0xc4, 0x17, 0x21,
+	0x56, 0x8c, 0xf6, 0xbd, 0x69, 0x46, 0xdb, 0x95, 0x06, 0x9e, 0x48, 0xbc, 0x1a, 0xb2, 0x1e, 0x67,
+	0x44, 0x43, 0xef, 0x86, 0xca, 0x99, 0x77, 0x83, 0x0d, 0xf5, 0x67, 0x09, 0x61, 0xa7, 0x76, 0xe4,
+	0x30, 0xa7, 0x1f, 0x5b, 0xd5, 0xf1, 0x04, 0x71, 0x76, 0xf8, 0x8f, 0x04, 0x7e, 0x47, 0xc2, 0xd5,
+	0xe8, 0xb5, 0x67, 0x03, 0x09, 0x7a, 0x0d, 0xe6, 0x69, 0x37, 0x08, 0x19, 0xb1, 0x13, 0x46, 0x6d,
+	0xd7, 0x89, 0x89, 0x0c, 0x71, 0x15, 0xdc, 0x50, 0xe2, 0x7d, 0x46, 0xd7, 0x9d, 0x98, 0xa0, 0x1e,
+	0xcc, 0x1f, 0x53, 0xde, 0x0b, 0x93, 0x34, 0x04, 0x58, 0x75, 0x39, 0x97, 0xf7, 0xa7, 0x99, 0xcb,
+	0x27, 0xca, 0xc4, 0xd0, 0xfe, 0xcf, 0x1d, 0x0f, 0x09, 0xd1, 0x1b, 0xd0, 0xd4, 0x5b, 0x3e, 0x08,
+	0x20, 0x0d, 0xe9, 0xfa, 0xf3, 0x4a, 0xfe, 0xa1, 0x11, 0x2f, 0x76, 0xa0, 0x9e, 0x35, 0x75, 0x01,
+	0x33, 0xdd, 0xcf, 0x32, 0xd3, 0xe4, 0x9e, 0x96, 0x61, 0xbe, 0xf7, 0x61, 0xe1, 0xdc, 0x01, 0x4e,
+	0x45, 0x9d, 0x07, 0xd0, 0x3c, 0x7b, 0x04, 0x5f, 0xca, 0x44, 0x29, 0xbc, 0x74, 0xc1, 0xf6, 0x7e,
+	0x19, 0x43, 0xb5, 0xfe, 0x93, 0x87, 0x2b, 0x17, 0x3d, 0x56, 0xd0, 0x87, 0x50, 0xf3, 0x06, 0xcd,
+	0x09, 0xe8, 0x29, 0x03, 0xd6, 0x04, 0x9f, 0x35, 0x20, 0xc2, 0xd8, 0x31, 0xa1, 0xdd, 0x9e, 0x7a,
+	0xf6, 0x95, 0xb0, 0x6e, 0x65, 0x93, 0xa9, 0xf2, 0xd4, 0xc9, 0x14, 0xda, 0x85, 0x85, 0x03, 0xc7,
+	0xf7, 0x3b, 0x8e, 0x7b, 0x68, 0xbb, 0x7e, 0x12, 0xcb, 0xc7, 0x94, 0x27, 0xbd, 0x79, 0xd2, 0xbc,
+	0xb5, 0x69, 0x0c, 0xac, 0x6b, 0xfc, 0xe3, 0x62, 0xa5, 0xd0, 0x2c, 0x7f, 0x05, 0x89, 0xd7, 0x4f,
+	0xa0, 0xf9, 0xff, 0xda, 0xf6, 0xd6, 0x3f, 0xf3, 0xb0, 0x70, 0x2e, 0xfc, 0xa1, 0x15, 0x78, 0x29,
+	0x03, 0xb6, 0xe3, 0xa4, 0x13, 0x90, 0xb4, 0x36, 0x82, 0x32, 0x5d, 0xbb, 0xaa, 0x27, 0x25, 0xda,
+	0x7c, 0x86, 0x68, 0x6f, 0xa7, 0x44, 0xab, 0xf0, 0x32, 0xba, 0x54, 0x0d, 0x53, 0x2a, 0x24, 0x72,
+	0xcf, 0xb2, 0xb1, 0x2a, 0x46, 0x3c, 0x98, 0x26, 0x5a, 0x4f, 0x45, 0xc7, 0xa5, 0x33, 0x74, 0x7c,
+	0x11, 0x37, 0xcd, 0x5e, 0xcc, 0x4d, 0x9f, 0x97, 0x37, 0x5a, 0xff, 0xcd, 0x03, 0x3a, 0x9f, 0x06,
+	0xa1, 0x57, 0xa0, 0x1a, 0x07, 0xd4, 0xce, 0xd4, 0x9f, 0xf4, 0x09, 0x56, 0xe2, 0x80, 0x6e, 0xca,
+	0x42, 0xd4, 0x0b, 0x0e, 0x24, 0x3f, 0xf6, 0x40, 0x0a, 0x99, 0x03, 0xf1, 0xce, 0xee, 0x75, 0x69,
+	0x2c, 0xdd, 0x9f, 0x9f, 0xed, 0x54, 0x9b, 0x3d, 0x3b, 0xc1, 0x66, 0x97, 0xbf, 0x9c, 0xcd, 0x7e,
+	0x5c, 0xac, 0x14, 0x9b, 0x25, 0x3c, 0xec, 0x82, 0xad, 0x3f, 0xe6, 0xa1, 0x9e, 0xad, 0x7a, 0x08,
+	0x8b, 0x26, 0xeb, 0xaa, 0xaa, 0x6c, 0xea, 0x66, 0x36, 0x9b, 0xd1, 0xcf, 0x9c, 0x41, 0x96, 0x72,
+	0x45, 0xef, 0xab, 0x48, 0x73, 0x1a, 0x9b, 0x33, 0x7a, 0x67, 0x3f, 0x15, 0xb7, 0x95, 0xd1, 0x23,
+	0x62, 0xcb, 0xce, 0xd2, 0x52, 0xee, 0xce, 0xdc, 0xd8, 0x8c, 0xc2, 0xcc, 0x61, 0xd9, 0xfc, 0x18,
+	0xd4, 0xb3, 0x68, 0x18, 0x6c, 0xce, 0x60, 0x50, 0x36, 0x85, 0x58, 0x56, 0xcb, 0x54, 0x8e, 0x37,
+	0xab, 0xab, 0x65, 0x2a, 0x77, 0xbb, 0x0d, 0x0d, 0x53, 0x9b, 0xb1, 0xdd, 0xd0, 0x23, 0xfa, 0xc0,
+	0xeb, 0x46, 0xb8, 0x1e, 0x7a, 0xa4, 0xb5, 0x05, 0x57, 0x2f, 0x1c, 0x03, 0xdd, 0x80, 0xab, 0x8f,
+	0xf0, 0xf6, 0x53, 0x7b, 0x07, 0x6f, 0xef, 0x6d, 0xaf, 0x6f, 0x3f, 0xb1, 0x37, 0x1e, 0x3e, 0x5a,
+	0xdb, 0x7f, 0xb2, 0xd7, 0x9c, 0x41, 0x57, 0x61, 0x41, 0x76, 0xe1, 0x87, 0x1f, 0xed, 0x3f, 0xdc,
+	0xdd, 0xb3, 0x77, 0xb6, 0xf1, 0x5e, 0x33, 0xd7, 0x9e, 0xcf, 0x8c, 0x27, 0x2b, 0x6e, 0x3f, 0x07,
+	0x58, 0x7c, 0x71, 0xc9, 0x07, 0xbd, 0x0d, 0xd7, 0xfa, 0xce, 0x89, 0x9d, 0xd6, 0x93, 0x0c, 0x38,
+	0x96, 0x5b, 0xde, 0xc0, 0x57, 0xfa, 0xce, 0x89, 0x81, 0x1a, 0x50, 0x8c, 0xde, 0x85, 0xeb, 0xe9,
+	0x28, 0x29, 0xbd, 0x8a, 0xe5, 0x29, 0x97, 0x6f, 0xe0, 0xab, 0xa6, 0xdb, 0xd4, 0x7a, 0xc4, 0x3a,
+	0x63, 0x74, 0x1b, 0xd2, 0x85, 0xdb, 0x09, 0xf3, 0x15, 0xe3, 0x6c, 0xce, 0xe0, 0x9a, 0x91, 0xee,
+	0x33, 0x1f, 0x3d, 0x83, 0xc5, 0xac, 0x92, 0xad, 0x4b, 0x35, 0x36, 0x23, 0x5d, 0x72, 0xa2, 0xf3,
+	0xd7, 0xd5, 0x51, 0x99, 0xbe, 0xd0, 0x53, 0xb7, 0x22, 0xf0, 0x76, 0x93, 0x4e, 0xcc, 0x29, 0x4f,
+	0x38, 0xd9, 0x9c, 0xc1, 0xd7, 0x33, 0xc3, 0x98, 0x4a, 0x90, 0x50, 0x46, 0x6f, 0x02, 0x72, 0x7c,
+	0x3f, 0x3c, 0xb6, 0x5d, 0x16, 0xc6, 0xb1, 0xad, 0x4f, 0xb2, 0x24, 0xb3, 0xb2, 0xa6, 0xec, 0x59,
+	0x17, 0x1d, 0xbb, 0xea, 0x4c, 0x33, 0xa1, 0x70, 0x76, 0xfa, 0x50, 0x38, 0xe4, 0xbf, 0xe5, 0xb3,
+	0xfe, 0xfb, 0x1d, 0xb0, 0x0e, 0x42, 0xe6, 0x12, 0xcf, 0x4e, 0x62, 0x62, 0x87, 0x8c, 0x76, 0xa9,
+	0x38, 0x16, 0x59, 0xa3, 0x6d, 0xca, 0xf9, 0x5c, 0x55, 0xfd, 0xfb, 0x31, 0xd9, 0xd6, 0xbd, 0x82,
+	0x82, 0xd0, 0x47, 0xf0, 0x9a, 0x06, 0x3a, 0x9e, 0xa9, 0x4a, 0xd8, 0x1d, 0x72, 0x20, 0xf2, 0x4c,
+	0xf9, 0xd2, 0xb1, 0xe5, 0x93, 0x89, 0x30, 0x59, 0x6d, 0xad, 0xe0, 0x57, 0x94, 0xf6, 0x9a, 0xe7,
+	0xa9, 0x19, 0xb6, 0xa5, 0xaa, 0x8c, 0x73, 0x4f, 0x95, 0x22, 0xfa, 0x14, 0x2a, 0xb2, 0x04, 0x43,
+	0x49, 0x6c, 0xcd, 0x4b, 0x2a, 0xda, 0xb8, 0x54, 0x5d, 0x31, 0x73, 0x81, 0x64, 0x8d, 0x26, 0xb5,
+	0xba, 0xf8, 0x87, 0x22, 0xcc, 0x0d, 0x77, 0x8e, 0x70, 0xc8, 0xca, 0xe5, 0x1c, 0xb2, 0x3a, 0x8d,
+	0x43, 0xc2, 0xf4, 0x0e, 0x59, 0xfb, 0xea, 0x1c, 0xb2, 0x3e, 0xde, 0x21, 0x1b, 0x9f, 0xd3, 0x21,
+	0xe7, 0xa6, 0x71, 0xc8, 0x85, 0x2f, 0xc6, 0x21, 0xd1, 0x84, 0x0e, 0xd9, 0x5e, 0x82, 0x5b, 0x17,
+	0x1e, 0x44, 0x1c, 0x11, 0x97, 0x1e, 0xd0, 0x49, 0x34, 0x5a, 0x4f, 0x01, 0x9d, 0xaf, 0x4c, 0x2b,
+	0x9a, 0xce, 0xb8, 0x8d, 0x66, 0xbf, 0x3a, 0xcb, 0x78, 0x8b, 0x88, 0xd9, 0x9d, 0xd0, 0x33, 0x41,
+	0x47, 0xfe, 0x6e, 0xfd, 0x22, 0x07, 0xb5, 0x4c, 0x61, 0x79, 0xea, 0x78, 0xb5, 0x0d, 0x55, 0xf1,
+	0x0a, 0x54, 0xae, 0x54, 0xb8, 0xac, 0x2b, 0xe1, 0x4a, 0xc2, 0xa8, 0xec, 0x6b, 0x7d, 0x02, 0xd7,
+	0x5f, 0xa0, 0x84, 0x2c, 0x28, 0x47, 0x0e, 0x17, 0x57, 0x47, 0xcf, 0xcf, 0x34, 0x51, 0x0b, 0xea,
+	0xb1, 0xd1, 0x13, 0xe9, 0x6c, 0x5e, 0x67, 0x82, 0x19, 0x59, 0x8b, 0x40, 0x2d, 0xf3, 0x36, 0x41,
+	0xd7, 0xa0, 0x44, 0x4e, 0x1c, 0x57, 0x7f, 0x39, 0xda, 0x9c, 0xc1, 0xaa, 0x89, 0x2c, 0x98, 0x8d,
+	0x18, 0x39, 0xa0, 0x27, 0xca, 0xc8, 0xe6, 0x0c, 0xd6, 0x6d, 0x81, 0x18, 0x2c, 0x53, 0x22, 0x64,
+	0xb3, 0x5d, 0x07, 0x90, 0x9e, 0x60, 0xf3, 0xd3, 0x88, 0xb4, 0xfe, 0x9a, 0xd3, 0x5f, 0x88, 0x88,
+	0x48, 0x28, 0x96, 0xa0, 0x22, 0xa6, 0xd8, 0x8f, 0x74, 0x40, 0x2a, 0x99, 0xcc, 0xcb, 0x48, 0xd1,
+	0x1a, 0xcc, 0x47, 0x84, 0xd9, 0x9c, 0x9d, 0xda, 0xa6, 0x90, 0x9f, 0x1f, 0x57, 0xc8, 0x6f, 0x44,
+	0x84, 0xed, 0xb1, 0xd3, 0x3d, 0x5d, 0xce, 0xbf, 0x01, 0x15, 0x26, 0x46, 0xb3, 0xc3, 0x40, 0xe7,
+	0xc0, 0xb2, 0x52, 0x7f, 0xba, 0x1d, 0x20, 0x2c, 0x78, 0x45, 0x74, 0x89, 0x27, 0x03, 0x27, 0xb6,
+	0x1f, 0xba, 0x8e, 0x4f, 0xb9, 0x60, 0x44, 0x15, 0x88, 0x16, 0xcf, 0x8d, 0xd2, 0x0e, 0x43, 0x5f,
+	0xd6, 0xca, 0x05, 0xe7, 0x88, 0xf4, 0x4b, 0x22, 0x9f, 0xa4, 0xc0, 0xd6, 0xbf, 0xf2, 0x00, 0x83,
+	0x8a, 0x35, 0x7a, 0x15, 0xea, 0xea, 0xaa, 0xab, 0xbb, 0xa5, 0x13, 0xcc, 0xbc, 0x95, 0xc3, 0x35,
+	0x29, 0x57, 0x97, 0x0a, 0xfd, 0x00, 0x1a, 0x59, 0x35, 0x53, 0x16, 0x99, 0xf4, 0x29, 0x59, 0xcf,
+	0xd8, 0x12, 0xb4, 0xa7, 0x8d, 0xa9, 0x0a, 0x91, 0x49, 0x54, 0x95, 0xd2, 0x53, 0x25, 0x1b, 0x28,
+	0x19, 0x6e, 0x29, 0x64, 0x94, 0x4c, 0xe9, 0xe0, 0x55, 0x98, 0x23, 0x27, 0x51, 0x38, 0x78, 0x5d,
+	0xc9, 0x07, 0x42, 0x15, 0x37, 0x94, 0xd4, 0xa8, 0xad, 0x42, 0x59, 0xb0, 0xba, 0xd3, 0x55, 0x51,
+	0x75, 0xe4, 0xe9, 0xcc, 0xf6, 0x9d, 0x93, 0xb5, 0x2e, 0x41, 0x1f, 0xc0, 0x82, 0xe1, 0x40, 0xe2,
+	0x91, 0x80, 0x53, 0xc7, 0x37, 0x01, 0x77, 0xd4, 0xae, 0x1b, 0x7a, 0x4c, 0x31, 0xad, 0xcf, 0x4a,
+	0xea, 0xce, 0x0f, 0x7f, 0x47, 0x41, 0x5b, 0x50, 0xf2, 0x88, 0xef, 0x9c, 0x4e, 0x52, 0x03, 0x3f,
+	0x87, 0x5e, 0xde, 0x10, 0x50, 0xac, 0x2c, 0x08, 0x53, 0x4e, 0xc7, 0xbc, 0xaf, 0xa6, 0x36, 0xb5,
+	0x26, 0xa0, 0x58, 0x59, 0x58, 0xfc, 0x59, 0x1e, 0x4a, 0xd2, 0x36, 0xba, 0x09, 0x65, 0xf3, 0x65,
+	0x46, 0xb9, 0xbe, 0xf0, 0x09, 0x23, 0x42, 0x6d, 0xa8, 0x1d, 0xd0, 0x13, 0xe2, 0xd9, 0x6a, 0x0d,
+	0xe3, 0x7c, 0x5e, 0xdd, 0x1b, 0x91, 0xb4, 0x4a, 0x94, 0x1a, 0x61, 0x13, 0x16, 0xc4, 0x31, 0x05,
+	0x6a, 0xa3, 0xb4, 0xa5, 0xc2, 0x18, 0x4b, 0x9b, 0x33, 0xb8, 0x99, 0x41, 0x29, 0x4b, 0x6d, 0x80,
+	0xcc, 0xc7, 0x9f, 0xd2, 0xc4, 0x1f, 0x7f, 0x32, 0xa8, 0xf6, 0x02, 0xcc, 0xf7, 0x38, 0x8f, 0xd4,
+	0x34, 0x24, 0x19, 0x2c, 0xfe, 0x39, 0x07, 0x25, 0xb9, 0x3b, 0xe8, 0x75, 0xa8, 0xc9, 0xce, 0x98,
+	0x3b, 0x3c, 0x89, 0xd5, 0x23, 0x79, 0xb0, 0x26, 0xd1, 0xb5, 0x2b, 0x7b, 0xd0, 0x2b, 0x50, 0xeb,
+	0xb2, 0xc8, 0x35, 0x8a, 0x86, 0x6b, 0x40, 0x08, 0x07, 0x2a, 0x02, 0xb0, 0x6a, 0x13, 0xf9, 0xf9,
+	0xac, 0x68, 0x54, 0xa4, 0xf0, 0xa1, 0xfc, 0x38, 0xf6, 0x45, 0xac, 0xa7, 0x0e, 0x20, 0x07, 0x90,
+	0x4b, 0x79, 0x5c, 0xac, 0xe4, 0x9a, 0xf9, 0xf4, 0xf8, 0x5a, 0xab, 0x50, 0xcf, 0x7e, 0x1e, 0x17,
+	0xef, 0x87, 0x20, 0xe9, 0x77, 0x08, 0xd3, 0x91, 0x47, 0xb7, 0x1e, 0x17, 0x2b, 0xf9, 0x66, 0x41,
+	0x55, 0xa0, 0x5b, 0x2f, 0x43, 0xd9, 0x7c, 0x73, 0x4b, 0x9f, 0x55, 0x42, 0x3b, 0xa7, 0x9f, 0x55,
+	0xad, 0x7f, 0xe7, 0x00, 0x06, 0x5f, 0x9b, 0x2f, 0xfc, 0x48, 0x64, 0x41, 0xd9, 0xa3, 0xb1, 0xd3,
+	0xf1, 0xd5, 0x8b, 0xac, 0x82, 0x4d, 0x13, 0xfd, 0x10, 0x16, 0x68, 0x64, 0x3b, 0xae, 0x4b, 0xe2,
+	0xd8, 0x76, 0xc3, 0x80, 0xb3, 0xd0, 0xd7, 0xce, 0xf0, 0xcd, 0x11, 0x2b, 0xdf, 0xda, 0x59, 0x93,
+	0x90, 0x75, 0x85, 0xd8, 0x9c, 0xc1, 0xf3, 0x34, 0x1a, 0x12, 0xa1, 0x7d, 0x68, 0x4a, 0xde, 0xb4,
+	0x99, 0x23, 0x28, 0x94, 0xf6, 0x29, 0xd7, 0xec, 0xf9, 0xc6, 0xa8, 0x32, 0x82, 0x80, 0x60, 0x87,
+	0x93, 0x27, 0x02, 0xb0, 0x39, 0x83, 0xe7, 0xfc, 0x21, 0x49, 0xbb, 0x02, 0xb3, 0x6a, 0xa1, 0x2d,
+	0x1f, 0xe6, 0xcf, 0x4c, 0x03, 0xdd, 0x81, 0xa6, 0xa6, 0x6c, 0x1a, 0xd9, 0x1d, 0x3f, 0x74, 0x0f,
+	0x4d, 0x79, 0x64, 0x4e, 0xc9, 0xb7, 0xa2, 0xb6, 0x94, 0xa2, 0x15, 0xb8, 0x12, 0x84, 0xdc, 0x3e,
+	0xa7, 0xad, 0x28, 0x71, 0x21, 0x08, 0x39, 0x1e, 0x02, 0xb4, 0x7e, 0x93, 0x83, 0xb9, 0xe1, 0xc9,
+	0xa1, 0x2d, 0xa8, 0xf3, 0xf0, 0x90, 0x04, 0x76, 0x27, 0x71, 0x0f, 0x09, 0x9f, 0xa0, 0x1c, 0xb4,
+	0x27, 0xd4, 0xdb, 0x52, 0x1b, 0xd7, 0xf8, 0xa0, 0x81, 0xde, 0x83, 0x1b, 0x22, 0x9e, 0x79, 0xe1,
+	0x71, 0x10, 0x73, 0x46, 0x9c, 0xbe, 0x38, 0x8b, 0x40, 0x31, 0x85, 0x3e, 0xb2, 0xeb, 0x11, 0x61,
+	0x1b, 0x69, 0xff, 0x7a, 0xda, 0x8d, 0x5e, 0x86, 0x9a, 0x72, 0xfb, 0xec, 0x53, 0x13, 0x94, 0x48,
+	0x3e, 0x34, 0x7f, 0x99, 0x83, 0x5a, 0x66, 0x64, 0xf4, 0x75, 0x11, 0x7a, 0x4f, 0x6c, 0x39, 0xbe,
+	0x79, 0xf1, 0x55, 0xfb, 0xce, 0x89, 0xd4, 0x91, 0x95, 0x6a, 0xd5, 0x65, 0x47, 0xe4, 0xc0, 0x3e,
+	0xa0, 0xbe, 0xaf, 0x0b, 0x48, 0x0d, 0x25, 0xde, 0x21, 0x07, 0x8f, 0xa8, 0xef, 0xa3, 0x07, 0xd0,
+	0x10, 0x9d, 0x2a, 0x69, 0x3f, 0x72, 0xfc, 0xb1, 0x1c, 0x82, 0xeb, 0x42, 0x7f, 0x4b, 0xab, 0xb7,
+	0x97, 0x7f, 0xff, 0xfc, 0x56, 0xee, 0x4f, 0xcf, 0x6f, 0xe5, 0xfe, 0xf6, 0xfc, 0x56, 0xee, 0x47,
+	0x4b, 0x6a, 0xd7, 0x68, 0x28, 0xff, 0xc1, 0xe8, 0x82, 0xff, 0x58, 0xea, 0xcc, 0x4a, 0x83, 0x77,
+	0xff, 0x17, 0x00, 0x00, 0xff, 0xff, 0x0e, 0x92, 0x80, 0x8a, 0xcf, 0x24, 0x00, 0x00,
 }
 
 func (m *VirtualService) Marshal() (dAtA []byte, err error) {
@@ -3636,6 +4474,22 @@ func (m *VirtualService) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 		i -= len(m.XXX_unrecognized)
 		copy(dAtA[i:], m.XXX_unrecognized)
 	}
+	if len(m.HostHTTPFilters) > 0 {
+		for iNdEx := len(m.HostHTTPFilters) - 1; iNdEx >= 0; iNdEx-- {
+			{
+				size, err := m.HostHTTPFilters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
+				if err != nil {
+					return 0, err
+				}
+				i -= size
+				i = encodeVarintVirtualService(dAtA, i, uint64(size))
+			}
+			i--
+			dAtA[i] = 0x3e
+			i--
+			dAtA[i] = 0xc2
+		}
+	}
 	if len(m.ExportTo) > 0 {
 		for iNdEx := len(m.ExportTo) - 1; iNdEx >= 0; iNdEx-- {
 			i -= len(m.ExportTo[iNdEx])
@@ -3785,9 +4639,25 @@ func (m *HTTPRoute) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 		i -= len(m.XXX_unrecognized)
 		copy(dAtA[i:], m.XXX_unrecognized)
 	}
-	if m.Delegate != nil {
+	if len(m.RouteHTTPFilters) > 0 {
+		for iNdEx := len(m.RouteHTTPFilters) - 1; iNdEx >= 0; iNdEx-- {
+			{
+				size, err := m.RouteHTTPFilters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
+				if err != nil {
+					return 0, err
+				}
+				i -= size
+				i = encodeVarintVirtualService(dAtA, i, uint64(size))
+			}
+			i--
+			dAtA[i] = 0x3e
+			i--
+			dAtA[i] = 0xc2
+		}
+	}
+	if m.DirectResponse != nil {
 		{
-			size, err := m.Delegate.MarshalToSizedBuffer(dAtA[:i])
+			size, err := m.DirectResponse.MarshalToSizedBuffer(dAtA[:i])
 			if err != nil {
 				return 0, err
 			}
@@ -3797,7 +4667,35 @@ func (m *HTTPRoute) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 		i--
 		dAtA[i] = 0x1
 		i--
-		dAtA[i] = 0xa2
+		dAtA[i] = 0xd2
+	}
+	if m.InternalActiveRedirect != nil {
+		{
+			size, err := m.InternalActiveRedirect.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintVirtualService(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x1
+		i--
+		dAtA[i] = 0xca
+	}
+	if m.Delegate != nil {
+		{
+			size, err := m.Delegate.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintVirtualService(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x1
+		i--
+		dAtA[i] = 0xa2
 	}
 	if m.MirrorPercentage != nil {
 		{
@@ -4475,6 +5373,22 @@ func (m *HTTPRouteDestination) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 		i -= len(m.XXX_unrecognized)
 		copy(dAtA[i:], m.XXX_unrecognized)
 	}
+	if len(m.FallbackClusters) > 0 {
+		for iNdEx := len(m.FallbackClusters) - 1; iNdEx >= 0; iNdEx-- {
+			{
+				size, err := m.FallbackClusters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
+				if err != nil {
+					return 0, err
+				}
+				i -= size
+				i = encodeVarintVirtualService(dAtA, i, uint64(size))
+			}
+			i--
+			dAtA[i] = 0x6
+			i--
+			dAtA[i] = 0xa2
+		}
+	}
 	if m.Headers != nil {
 		{
 			size, err := m.Headers.MarshalToSizedBuffer(dAtA[:i])
@@ -4805,7 +5719,7 @@ func (m *HTTPRedirect_DerivePort) MarshalToSizedBuffer(dAtA []byte) (int, error)
 	dAtA[i] = 0x28
 	return len(dAtA) - i, nil
 }
-func (m *HTTPRewrite) Marshal() (dAtA []byte, err error) {
+func (m *HTTPInternalActiveRedirect) Marshal() (dAtA []byte, err error) {
 	size := m.Size()
 	dAtA = make([]byte, size)
 	n, err := m.MarshalToSizedBuffer(dAtA[:size])
@@ -4815,12 +5729,12 @@ func (m *HTTPRewrite) Marshal() (dAtA []byte, err error) {
 	return dAtA[:n], nil
 }
 
-func (m *HTTPRewrite) MarshalTo(dAtA []byte) (int, error) {
+func (m *HTTPInternalActiveRedirect) MarshalTo(dAtA []byte) (int, error) {
 	size := m.Size()
 	return m.MarshalToSizedBuffer(dAtA[:size])
 }
 
-func (m *HTTPRewrite) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+func (m *HTTPInternalActiveRedirect) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 	i := len(dAtA)
 	_ = i
 	var l int
@@ -4829,102 +5743,144 @@ func (m *HTTPRewrite) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 		i -= len(m.XXX_unrecognized)
 		copy(dAtA[i:], m.XXX_unrecognized)
 	}
+	if m.ForcedAddHeaderBeforeRouteMatcher {
+		i--
+		if m.ForcedAddHeaderBeforeRouteMatcher {
+			dAtA[i] = 1
+		} else {
+			dAtA[i] = 0
+		}
+		i--
+		dAtA[i] = 0x1
+		i--
+		dAtA[i] = 0x88
+	}
+	if m.ForcedUseOriginalHost {
+		i--
+		if m.ForcedUseOriginalHost {
+			dAtA[i] = 1
+		} else {
+			dAtA[i] = 0
+		}
+		i--
+		dAtA[i] = 0x1
+		i--
+		dAtA[i] = 0x80
+	}
+	if len(m.Policies) > 0 {
+		for iNdEx := len(m.Policies) - 1; iNdEx >= 0; iNdEx-- {
+			{
+				size, err := m.Policies[iNdEx].MarshalToSizedBuffer(dAtA[:i])
+				if err != nil {
+					return 0, err
+				}
+				i -= size
+				i = encodeVarintVirtualService(dAtA, i, uint64(size))
+			}
+			i--
+			dAtA[i] = 0x7a
+		}
+	}
 	if len(m.Authority) > 0 {
 		i -= len(m.Authority)
 		copy(dAtA[i:], m.Authority)
 		i = encodeVarintVirtualService(dAtA, i, uint64(len(m.Authority)))
 		i--
-		dAtA[i] = 0x12
+		dAtA[i] = 0x3a
 	}
-	if len(m.Uri) > 0 {
-		i -= len(m.Uri)
-		copy(dAtA[i:], m.Uri)
-		i = encodeVarintVirtualService(dAtA, i, uint64(len(m.Uri)))
+	if m.Headers != nil {
+		{
+			size, err := m.Headers.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintVirtualService(dAtA, i, uint64(size))
+		}
 		i--
-		dAtA[i] = 0xa
-	}
-	return len(dAtA) - i, nil
-}
-
-func (m *StringMatch) Marshal() (dAtA []byte, err error) {
-	size := m.Size()
-	dAtA = make([]byte, size)
-	n, err := m.MarshalToSizedBuffer(dAtA[:size])
-	if err != nil {
-		return nil, err
+		dAtA[i] = 0x32
 	}
-	return dAtA[:n], nil
-}
-
-func (m *StringMatch) MarshalTo(dAtA []byte) (int, error) {
-	size := m.Size()
-	return m.MarshalToSizedBuffer(dAtA[:size])
-}
-
-func (m *StringMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
-	i := len(dAtA)
-	_ = i
-	var l int
-	_ = l
-	if m.XXX_unrecognized != nil {
-		i -= len(m.XXX_unrecognized)
-		copy(dAtA[i:], m.XXX_unrecognized)
+	if m.AllowCrossScheme {
+		i--
+		if m.AllowCrossScheme {
+			dAtA[i] = 1
+		} else {
+			dAtA[i] = 0
+		}
+		i--
+		dAtA[i] = 0x28
 	}
-	if m.MatchType != nil {
+	if m.RedirectUrlRewriteSpecifier != nil {
 		{
-			size := m.MatchType.Size()
+			size := m.RedirectUrlRewriteSpecifier.Size()
 			i -= size
-			if _, err := m.MatchType.MarshalTo(dAtA[i:]); err != nil {
+			if _, err := m.RedirectUrlRewriteSpecifier.MarshalTo(dAtA[i:]); err != nil {
 				return 0, err
 			}
 		}
 	}
+	if len(m.RedirectResponseCodes) > 0 {
+		dAtA29 := make([]byte, len(m.RedirectResponseCodes)*10)
+		var j28 int
+		for _, num := range m.RedirectResponseCodes {
+			for num >= 1<<7 {
+				dAtA29[j28] = uint8(uint64(num)&0x7f | 0x80)
+				num >>= 7
+				j28++
+			}
+			dAtA29[j28] = uint8(num)
+			j28++
+		}
+		i -= j28
+		copy(dAtA[i:], dAtA29[:j28])
+		i = encodeVarintVirtualService(dAtA, i, uint64(j28))
+		i--
+		dAtA[i] = 0x12
+	}
+	if m.MaxInternalRedirects != 0 {
+		i = encodeVarintVirtualService(dAtA, i, uint64(m.MaxInternalRedirects))
+		i--
+		dAtA[i] = 0x8
+	}
 	return len(dAtA) - i, nil
 }
 
-func (m *StringMatch_Exact) MarshalTo(dAtA []byte) (int, error) {
-	size := m.Size()
-	return m.MarshalToSizedBuffer(dAtA[:size])
-}
-
-func (m *StringMatch_Exact) MarshalToSizedBuffer(dAtA []byte) (int, error) {
-	i := len(dAtA)
-	i -= len(m.Exact)
-	copy(dAtA[i:], m.Exact)
-	i = encodeVarintVirtualService(dAtA, i, uint64(len(m.Exact)))
-	i--
-	dAtA[i] = 0xa
-	return len(dAtA) - i, nil
-}
-func (m *StringMatch_Prefix) MarshalTo(dAtA []byte) (int, error) {
+func (m *HTTPInternalActiveRedirect_RedirectUrl) MarshalTo(dAtA []byte) (int, error) {
 	size := m.Size()
 	return m.MarshalToSizedBuffer(dAtA[:size])
 }
 
-func (m *StringMatch_Prefix) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+func (m *HTTPInternalActiveRedirect_RedirectUrl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 	i := len(dAtA)
-	i -= len(m.Prefix)
-	copy(dAtA[i:], m.Prefix)
-	i = encodeVarintVirtualService(dAtA, i, uint64(len(m.Prefix)))
+	i -= len(m.RedirectUrl)
+	copy(dAtA[i:], m.RedirectUrl)
+	i = encodeVarintVirtualService(dAtA, i, uint64(len(m.RedirectUrl)))
 	i--
-	dAtA[i] = 0x12
+	dAtA[i] = 0x1a
 	return len(dAtA) - i, nil
 }
-func (m *StringMatch_Regex) MarshalTo(dAtA []byte) (int, error) {
+func (m *HTTPInternalActiveRedirect_RedirectUrlRewriteRegex) MarshalTo(dAtA []byte) (int, error) {
 	size := m.Size()
 	return m.MarshalToSizedBuffer(dAtA[:size])
 }
 
-func (m *StringMatch_Regex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+func (m *HTTPInternalActiveRedirect_RedirectUrlRewriteRegex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 	i := len(dAtA)
-	i -= len(m.Regex)
-	copy(dAtA[i:], m.Regex)
-	i = encodeVarintVirtualService(dAtA, i, uint64(len(m.Regex)))
-	i--
-	dAtA[i] = 0x1a
+	if m.RedirectUrlRewriteRegex != nil {
+		{
+			size, err := m.RedirectUrlRewriteRegex.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintVirtualService(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x22
+	}
 	return len(dAtA) - i, nil
 }
-func (m *HTTPRetry) Marshal() (dAtA []byte, err error) {
+func (m *HTTPInternalActiveRedirect_RedirectPolicy) Marshal() (dAtA []byte, err error) {
 	size := m.Size()
 	dAtA = make([]byte, size)
 	n, err := m.MarshalToSizedBuffer(dAtA[:size])
@@ -4934,12 +5890,12 @@ func (m *HTTPRetry) Marshal() (dAtA []byte, err error) {
 	return dAtA[:n], nil
 }
 
-func (m *HTTPRetry) MarshalTo(dAtA []byte) (int, error) {
+func (m *HTTPInternalActiveRedirect_RedirectPolicy) MarshalTo(dAtA []byte) (int, error) {
 	size := m.Size()
 	return m.MarshalToSizedBuffer(dAtA[:size])
 }
 
-func (m *HTTPRetry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+func (m *HTTPInternalActiveRedirect_RedirectPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 	i := len(dAtA)
 	_ = i
 	var l int
@@ -4948,9 +5904,40 @@ func (m *HTTPRetry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 		i -= len(m.XXX_unrecognized)
 		copy(dAtA[i:], m.XXX_unrecognized)
 	}
-	if m.RetryRemoteLocalities != nil {
+	if m.ForcedAddHeaderBeforeRouteMatcher {
+		i--
+		if m.ForcedAddHeaderBeforeRouteMatcher {
+			dAtA[i] = 1
+		} else {
+			dAtA[i] = 0
+		}
+		i--
+		dAtA[i] = 0x1
+		i--
+		dAtA[i] = 0x90
+	}
+	if m.ForcedUseOriginalHost {
+		i--
+		if m.ForcedUseOriginalHost {
+			dAtA[i] = 1
+		} else {
+			dAtA[i] = 0
+		}
+		i--
+		dAtA[i] = 0x1
+		i--
+		dAtA[i] = 0x88
+	}
+	if len(m.Authority) > 0 {
+		i -= len(m.Authority)
+		copy(dAtA[i:], m.Authority)
+		i = encodeVarintVirtualService(dAtA, i, uint64(len(m.Authority)))
+		i--
+		dAtA[i] = 0x72
+	}
+	if m.Headers != nil {
 		{
-			size, err := m.RetryRemoteLocalities.MarshalToSizedBuffer(dAtA[:i])
+			size, err := m.Headers.MarshalToSizedBuffer(dAtA[:i])
 			if err != nil {
 				return 0, err
 			}
@@ -4958,36 +5945,89 @@ func (m *HTTPRetry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 			i = encodeVarintVirtualService(dAtA, i, uint64(size))
 		}
 		i--
-		dAtA[i] = 0x22
+		dAtA[i] = 0x6a
 	}
-	if len(m.RetryOn) > 0 {
-		i -= len(m.RetryOn)
-		copy(dAtA[i:], m.RetryOn)
-		i = encodeVarintVirtualService(dAtA, i, uint64(len(m.RetryOn)))
+	if m.AllowCrossScheme {
 		i--
-		dAtA[i] = 0x1a
+		if m.AllowCrossScheme {
+			dAtA[i] = 1
+		} else {
+			dAtA[i] = 0
+		}
+		i--
+		dAtA[i] = 0x60
 	}
-	if m.PerTryTimeout != nil {
+	if m.RedirectUrlRewriteSpecifier != nil {
 		{
-			size, err := m.PerTryTimeout.MarshalToSizedBuffer(dAtA[:i])
-			if err != nil {
+			size := m.RedirectUrlRewriteSpecifier.Size()
+			i -= size
+			if _, err := m.RedirectUrlRewriteSpecifier.MarshalTo(dAtA[i:]); err != nil {
 				return 0, err
 			}
-			i -= size
-			i = encodeVarintVirtualService(dAtA, i, uint64(size))
 		}
+	}
+	if len(m.RedirectResponseCodes) > 0 {
+		dAtA33 := make([]byte, len(m.RedirectResponseCodes)*10)
+		var j32 int
+		for _, num := range m.RedirectResponseCodes {
+			for num >= 1<<7 {
+				dAtA33[j32] = uint8(uint64(num)&0x7f | 0x80)
+				num >>= 7
+				j32++
+			}
+			dAtA33[j32] = uint8(num)
+			j32++
+		}
+		i -= j32
+		copy(dAtA[i:], dAtA33[:j32])
+		i = encodeVarintVirtualService(dAtA, i, uint64(j32))
 		i--
-		dAtA[i] = 0x12
+		dAtA[i] = 0x4a
 	}
-	if m.Attempts != 0 {
-		i = encodeVarintVirtualService(dAtA, i, uint64(m.Attempts))
+	if m.MaxInternalRedirects != 0 {
+		i = encodeVarintVirtualService(dAtA, i, uint64(m.MaxInternalRedirects))
 		i--
-		dAtA[i] = 0x8
+		dAtA[i] = 0x40
 	}
 	return len(dAtA) - i, nil
 }
 
-func (m *CorsPolicy) Marshal() (dAtA []byte, err error) {
+func (m *HTTPInternalActiveRedirect_RedirectPolicy_RedirectUrl) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *HTTPInternalActiveRedirect_RedirectPolicy_RedirectUrl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	i -= len(m.RedirectUrl)
+	copy(dAtA[i:], m.RedirectUrl)
+	i = encodeVarintVirtualService(dAtA, i, uint64(len(m.RedirectUrl)))
+	i--
+	dAtA[i] = 0x52
+	return len(dAtA) - i, nil
+}
+func (m *HTTPInternalActiveRedirect_RedirectPolicy_RedirectUrlRewriteRegex) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *HTTPInternalActiveRedirect_RedirectPolicy_RedirectUrlRewriteRegex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	if m.RedirectUrlRewriteRegex != nil {
+		{
+			size, err := m.RedirectUrlRewriteRegex.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintVirtualService(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x5a
+	}
+	return len(dAtA) - i, nil
+}
+func (m *HTTPDirectResponse) Marshal() (dAtA []byte, err error) {
 	size := m.Size()
 	dAtA = make([]byte, size)
 	n, err := m.MarshalToSizedBuffer(dAtA[:size])
@@ -4997,12 +6037,12 @@ func (m *CorsPolicy) Marshal() (dAtA []byte, err error) {
 	return dAtA[:n], nil
 }
 
-func (m *CorsPolicy) MarshalTo(dAtA []byte) (int, error) {
+func (m *HTTPDirectResponse) MarshalTo(dAtA []byte) (int, error) {
 	size := m.Size()
 	return m.MarshalToSizedBuffer(dAtA[:size])
 }
 
-func (m *CorsPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+func (m *HTTPDirectResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 	i := len(dAtA)
 	_ = i
 	var l int
@@ -5011,84 +6051,22 @@ func (m *CorsPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 		i -= len(m.XXX_unrecognized)
 		copy(dAtA[i:], m.XXX_unrecognized)
 	}
-	if len(m.AllowOrigins) > 0 {
-		for iNdEx := len(m.AllowOrigins) - 1; iNdEx >= 0; iNdEx-- {
-			{
-				size, err := m.AllowOrigins[iNdEx].MarshalToSizedBuffer(dAtA[:i])
-				if err != nil {
-					return 0, err
-				}
-				i -= size
-				i = encodeVarintVirtualService(dAtA, i, uint64(size))
-			}
-			i--
-			dAtA[i] = 0x3a
-		}
-	}
-	if m.AllowCredentials != nil {
-		{
-			size, err := m.AllowCredentials.MarshalToSizedBuffer(dAtA[:i])
-			if err != nil {
-				return 0, err
-			}
-			i -= size
-			i = encodeVarintVirtualService(dAtA, i, uint64(size))
-		}
+	if len(m.Body) > 0 {
+		i -= len(m.Body)
+		copy(dAtA[i:], m.Body)
+		i = encodeVarintVirtualService(dAtA, i, uint64(len(m.Body)))
 		i--
-		dAtA[i] = 0x32
+		dAtA[i] = 0x12
 	}
-	if m.MaxAge != nil {
-		{
-			size, err := m.MaxAge.MarshalToSizedBuffer(dAtA[:i])
-			if err != nil {
-				return 0, err
-			}
-			i -= size
-			i = encodeVarintVirtualService(dAtA, i, uint64(size))
-		}
+	if m.ResponseCode != 0 {
+		i = encodeVarintVirtualService(dAtA, i, uint64(m.ResponseCode))
 		i--
-		dAtA[i] = 0x2a
-	}
-	if len(m.ExposeHeaders) > 0 {
-		for iNdEx := len(m.ExposeHeaders) - 1; iNdEx >= 0; iNdEx-- {
-			i -= len(m.ExposeHeaders[iNdEx])
-			copy(dAtA[i:], m.ExposeHeaders[iNdEx])
-			i = encodeVarintVirtualService(dAtA, i, uint64(len(m.ExposeHeaders[iNdEx])))
-			i--
-			dAtA[i] = 0x22
-		}
-	}
-	if len(m.AllowHeaders) > 0 {
-		for iNdEx := len(m.AllowHeaders) - 1; iNdEx >= 0; iNdEx-- {
-			i -= len(m.AllowHeaders[iNdEx])
-			copy(dAtA[i:], m.AllowHeaders[iNdEx])
-			i = encodeVarintVirtualService(dAtA, i, uint64(len(m.AllowHeaders[iNdEx])))
-			i--
-			dAtA[i] = 0x1a
-		}
-	}
-	if len(m.AllowMethods) > 0 {
-		for iNdEx := len(m.AllowMethods) - 1; iNdEx >= 0; iNdEx-- {
-			i -= len(m.AllowMethods[iNdEx])
-			copy(dAtA[i:], m.AllowMethods[iNdEx])
-			i = encodeVarintVirtualService(dAtA, i, uint64(len(m.AllowMethods[iNdEx])))
-			i--
-			dAtA[i] = 0x12
-		}
-	}
-	if len(m.AllowOrigin) > 0 {
-		for iNdEx := len(m.AllowOrigin) - 1; iNdEx >= 0; iNdEx-- {
-			i -= len(m.AllowOrigin[iNdEx])
-			copy(dAtA[i:], m.AllowOrigin[iNdEx])
-			i = encodeVarintVirtualService(dAtA, i, uint64(len(m.AllowOrigin[iNdEx])))
-			i--
-			dAtA[i] = 0xa
-		}
+		dAtA[i] = 0x8
 	}
 	return len(dAtA) - i, nil
 }
 
-func (m *HTTPFaultInjection) Marshal() (dAtA []byte, err error) {
+func (m *HTTPRewrite) Marshal() (dAtA []byte, err error) {
 	size := m.Size()
 	dAtA = make([]byte, size)
 	n, err := m.MarshalToSizedBuffer(dAtA[:size])
@@ -5098,12 +6076,12 @@ func (m *HTTPFaultInjection) Marshal() (dAtA []byte, err error) {
 	return dAtA[:n], nil
 }
 
-func (m *HTTPFaultInjection) MarshalTo(dAtA []byte) (int, error) {
+func (m *HTTPRewrite) MarshalTo(dAtA []byte) (int, error) {
 	size := m.Size()
 	return m.MarshalToSizedBuffer(dAtA[:size])
 }
 
-func (m *HTTPFaultInjection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+func (m *HTTPRewrite) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 	i := len(dAtA)
 	_ = i
 	var l int
@@ -5112,9 +6090,9 @@ func (m *HTTPFaultInjection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 		i -= len(m.XXX_unrecognized)
 		copy(dAtA[i:], m.XXX_unrecognized)
 	}
-	if m.Abort != nil {
+	if m.UriRegex != nil {
 		{
-			size, err := m.Abort.MarshalToSizedBuffer(dAtA[:i])
+			size, err := m.UriRegex.MarshalToSizedBuffer(dAtA[:i])
 			if err != nil {
 				return 0, err
 			}
@@ -5122,24 +6100,26 @@ func (m *HTTPFaultInjection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 			i = encodeVarintVirtualService(dAtA, i, uint64(size))
 		}
 		i--
+		dAtA[i] = 0x1a
+	}
+	if len(m.Authority) > 0 {
+		i -= len(m.Authority)
+		copy(dAtA[i:], m.Authority)
+		i = encodeVarintVirtualService(dAtA, i, uint64(len(m.Authority)))
+		i--
 		dAtA[i] = 0x12
 	}
-	if m.Delay != nil {
-		{
-			size, err := m.Delay.MarshalToSizedBuffer(dAtA[:i])
-			if err != nil {
-				return 0, err
-			}
-			i -= size
-			i = encodeVarintVirtualService(dAtA, i, uint64(size))
-		}
+	if len(m.Uri) > 0 {
+		i -= len(m.Uri)
+		copy(dAtA[i:], m.Uri)
+		i = encodeVarintVirtualService(dAtA, i, uint64(len(m.Uri)))
 		i--
 		dAtA[i] = 0xa
 	}
 	return len(dAtA) - i, nil
 }
 
-func (m *HTTPFaultInjection_Delay) Marshal() (dAtA []byte, err error) {
+func (m *RegexMatchAndSubstitute) Marshal() (dAtA []byte, err error) {
 	size := m.Size()
 	dAtA = make([]byte, size)
 	n, err := m.MarshalToSizedBuffer(dAtA[:size])
@@ -5149,12 +6129,12 @@ func (m *HTTPFaultInjection_Delay) Marshal() (dAtA []byte, err error) {
 	return dAtA[:n], nil
 }
 
-func (m *HTTPFaultInjection_Delay) MarshalTo(dAtA []byte) (int, error) {
+func (m *RegexMatchAndSubstitute) MarshalTo(dAtA []byte) (int, error) {
 	size := m.Size()
 	return m.MarshalToSizedBuffer(dAtA[:size])
 }
 
-func (m *HTTPFaultInjection_Delay) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+func (m *RegexMatchAndSubstitute) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 	i := len(dAtA)
 	_ = i
 	var l int
@@ -5163,78 +6143,24 @@ func (m *HTTPFaultInjection_Delay) MarshalToSizedBuffer(dAtA []byte) (int, error
 		i -= len(m.XXX_unrecognized)
 		copy(dAtA[i:], m.XXX_unrecognized)
 	}
-	if m.Percentage != nil {
-		{
-			size, err := m.Percentage.MarshalToSizedBuffer(dAtA[:i])
-			if err != nil {
-				return 0, err
-			}
-			i -= size
-			i = encodeVarintVirtualService(dAtA, i, uint64(size))
-		}
-		i--
-		dAtA[i] = 0x2a
-	}
-	if m.HttpDelayType != nil {
-		{
-			size := m.HttpDelayType.Size()
-			i -= size
-			if _, err := m.HttpDelayType.MarshalTo(dAtA[i:]); err != nil {
-				return 0, err
-			}
-		}
-	}
-	if m.Percent != 0 {
-		i = encodeVarintVirtualService(dAtA, i, uint64(m.Percent))
-		i--
-		dAtA[i] = 0x8
-	}
-	return len(dAtA) - i, nil
-}
-
-func (m *HTTPFaultInjection_Delay_FixedDelay) MarshalTo(dAtA []byte) (int, error) {
-	size := m.Size()
-	return m.MarshalToSizedBuffer(dAtA[:size])
-}
-
-func (m *HTTPFaultInjection_Delay_FixedDelay) MarshalToSizedBuffer(dAtA []byte) (int, error) {
-	i := len(dAtA)
-	if m.FixedDelay != nil {
-		{
-			size, err := m.FixedDelay.MarshalToSizedBuffer(dAtA[:i])
-			if err != nil {
-				return 0, err
-			}
-			i -= size
-			i = encodeVarintVirtualService(dAtA, i, uint64(size))
-		}
+	if len(m.Substitution) > 0 {
+		i -= len(m.Substitution)
+		copy(dAtA[i:], m.Substitution)
+		i = encodeVarintVirtualService(dAtA, i, uint64(len(m.Substitution)))
 		i--
 		dAtA[i] = 0x12
 	}
-	return len(dAtA) - i, nil
-}
-func (m *HTTPFaultInjection_Delay_ExponentialDelay) MarshalTo(dAtA []byte) (int, error) {
-	size := m.Size()
-	return m.MarshalToSizedBuffer(dAtA[:size])
-}
-
-func (m *HTTPFaultInjection_Delay_ExponentialDelay) MarshalToSizedBuffer(dAtA []byte) (int, error) {
-	i := len(dAtA)
-	if m.ExponentialDelay != nil {
-		{
-			size, err := m.ExponentialDelay.MarshalToSizedBuffer(dAtA[:i])
-			if err != nil {
-				return 0, err
-			}
-			i -= size
-			i = encodeVarintVirtualService(dAtA, i, uint64(size))
-		}
+	if len(m.Pattern) > 0 {
+		i -= len(m.Pattern)
+		copy(dAtA[i:], m.Pattern)
+		i = encodeVarintVirtualService(dAtA, i, uint64(len(m.Pattern)))
 		i--
-		dAtA[i] = 0x1a
+		dAtA[i] = 0xa
 	}
 	return len(dAtA) - i, nil
 }
-func (m *HTTPFaultInjection_Abort) Marshal() (dAtA []byte, err error) {
+
+func (m *StringMatch) Marshal() (dAtA []byte, err error) {
 	size := m.Size()
 	dAtA = make([]byte, size)
 	n, err := m.MarshalToSizedBuffer(dAtA[:size])
@@ -5244,12 +6170,12 @@ func (m *HTTPFaultInjection_Abort) Marshal() (dAtA []byte, err error) {
 	return dAtA[:n], nil
 }
 
-func (m *HTTPFaultInjection_Abort) MarshalTo(dAtA []byte) (int, error) {
+func (m *StringMatch) MarshalTo(dAtA []byte) (int, error) {
 	size := m.Size()
 	return m.MarshalToSizedBuffer(dAtA[:size])
 }
 
-func (m *HTTPFaultInjection_Abort) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+func (m *StringMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 	i := len(dAtA)
 	_ = i
 	var l int
@@ -5258,23 +6184,11 @@ func (m *HTTPFaultInjection_Abort) MarshalToSizedBuffer(dAtA []byte) (int, error
 		i -= len(m.XXX_unrecognized)
 		copy(dAtA[i:], m.XXX_unrecognized)
 	}
-	if m.Percentage != nil {
-		{
-			size, err := m.Percentage.MarshalToSizedBuffer(dAtA[:i])
-			if err != nil {
-				return 0, err
-			}
-			i -= size
-			i = encodeVarintVirtualService(dAtA, i, uint64(size))
-		}
-		i--
-		dAtA[i] = 0x2a
-	}
-	if m.ErrorType != nil {
+	if m.MatchType != nil {
 		{
-			size := m.ErrorType.Size()
+			size := m.MatchType.Size()
 			i -= size
-			if _, err := m.ErrorType.MarshalTo(dAtA[i:]); err != nil {
+			if _, err := m.MatchType.MarshalTo(dAtA[i:]); err != nil {
 				return 0, err
 			}
 		}
@@ -5282,47 +6196,49 @@ func (m *HTTPFaultInjection_Abort) MarshalToSizedBuffer(dAtA []byte) (int, error
 	return len(dAtA) - i, nil
 }
 
-func (m *HTTPFaultInjection_Abort_HttpStatus) MarshalTo(dAtA []byte) (int, error) {
+func (m *StringMatch_Exact) MarshalTo(dAtA []byte) (int, error) {
 	size := m.Size()
 	return m.MarshalToSizedBuffer(dAtA[:size])
 }
 
-func (m *HTTPFaultInjection_Abort_HttpStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+func (m *StringMatch_Exact) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 	i := len(dAtA)
-	i = encodeVarintVirtualService(dAtA, i, uint64(m.HttpStatus))
+	i -= len(m.Exact)
+	copy(dAtA[i:], m.Exact)
+	i = encodeVarintVirtualService(dAtA, i, uint64(len(m.Exact)))
 	i--
-	dAtA[i] = 0x10
+	dAtA[i] = 0xa
 	return len(dAtA) - i, nil
 }
-func (m *HTTPFaultInjection_Abort_GrpcStatus) MarshalTo(dAtA []byte) (int, error) {
+func (m *StringMatch_Prefix) MarshalTo(dAtA []byte) (int, error) {
 	size := m.Size()
 	return m.MarshalToSizedBuffer(dAtA[:size])
 }
 
-func (m *HTTPFaultInjection_Abort_GrpcStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+func (m *StringMatch_Prefix) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 	i := len(dAtA)
-	i -= len(m.GrpcStatus)
-	copy(dAtA[i:], m.GrpcStatus)
-	i = encodeVarintVirtualService(dAtA, i, uint64(len(m.GrpcStatus)))
+	i -= len(m.Prefix)
+	copy(dAtA[i:], m.Prefix)
+	i = encodeVarintVirtualService(dAtA, i, uint64(len(m.Prefix)))
 	i--
-	dAtA[i] = 0x1a
+	dAtA[i] = 0x12
 	return len(dAtA) - i, nil
 }
-func (m *HTTPFaultInjection_Abort_Http2Error) MarshalTo(dAtA []byte) (int, error) {
+func (m *StringMatch_Regex) MarshalTo(dAtA []byte) (int, error) {
 	size := m.Size()
 	return m.MarshalToSizedBuffer(dAtA[:size])
 }
 
-func (m *HTTPFaultInjection_Abort_Http2Error) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+func (m *StringMatch_Regex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 	i := len(dAtA)
-	i -= len(m.Http2Error)
-	copy(dAtA[i:], m.Http2Error)
-	i = encodeVarintVirtualService(dAtA, i, uint64(len(m.Http2Error)))
+	i -= len(m.Regex)
+	copy(dAtA[i:], m.Regex)
+	i = encodeVarintVirtualService(dAtA, i, uint64(len(m.Regex)))
 	i--
-	dAtA[i] = 0x22
+	dAtA[i] = 0x1a
 	return len(dAtA) - i, nil
 }
-func (m *PortSelector) Marshal() (dAtA []byte, err error) {
+func (m *HTTPRetry) Marshal() (dAtA []byte, err error) {
 	size := m.Size()
 	dAtA = make([]byte, size)
 	n, err := m.MarshalToSizedBuffer(dAtA[:size])
@@ -5332,12 +6248,12 @@ func (m *PortSelector) Marshal() (dAtA []byte, err error) {
 	return dAtA[:n], nil
 }
 
-func (m *PortSelector) MarshalTo(dAtA []byte) (int, error) {
+func (m *HTTPRetry) MarshalTo(dAtA []byte) (int, error) {
 	size := m.Size()
 	return m.MarshalToSizedBuffer(dAtA[:size])
 }
 
-func (m *PortSelector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+func (m *HTTPRetry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 	i := len(dAtA)
 	_ = i
 	var l int
@@ -5346,30 +6262,61 @@ func (m *PortSelector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 		i -= len(m.XXX_unrecognized)
 		copy(dAtA[i:], m.XXX_unrecognized)
 	}
-	if m.Number != 0 {
-		i = encodeVarintVirtualService(dAtA, i, uint64(m.Number))
+	if m.RetryRemoteLocalities != nil {
+		{
+			size, err := m.RetryRemoteLocalities.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintVirtualService(dAtA, i, uint64(size))
+		}
 		i--
-		dAtA[i] = 0x8
+		dAtA[i] = 0x22
 	}
-	return len(dAtA) - i, nil
-}
-
-func (m *Percent) Marshal() (dAtA []byte, err error) {
-	size := m.Size()
-	dAtA = make([]byte, size)
-	n, err := m.MarshalToSizedBuffer(dAtA[:size])
-	if err != nil {
-		return nil, err
+	if len(m.RetryOn) > 0 {
+		i -= len(m.RetryOn)
+		copy(dAtA[i:], m.RetryOn)
+		i = encodeVarintVirtualService(dAtA, i, uint64(len(m.RetryOn)))
+		i--
+		dAtA[i] = 0x1a
 	}
-	return dAtA[:n], nil
+	if m.PerTryTimeout != nil {
+		{
+			size, err := m.PerTryTimeout.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintVirtualService(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x12
+	}
+	if m.Attempts != 0 {
+		i = encodeVarintVirtualService(dAtA, i, uint64(m.Attempts))
+		i--
+		dAtA[i] = 0x8
+	}
+	return len(dAtA) - i, nil
 }
 
-func (m *Percent) MarshalTo(dAtA []byte) (int, error) {
+func (m *CorsPolicy) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *CorsPolicy) MarshalTo(dAtA []byte) (int, error) {
 	size := m.Size()
 	return m.MarshalToSizedBuffer(dAtA[:size])
 }
 
-func (m *Percent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+func (m *CorsPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 	i := len(dAtA)
 	_ = i
 	var l int
@@ -5378,282 +6325,912 @@ func (m *Percent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 		i -= len(m.XXX_unrecognized)
 		copy(dAtA[i:], m.XXX_unrecognized)
 	}
-	if m.Value != 0 {
-		i -= 8
-		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Value))))
-		i--
-		dAtA[i] = 0x9
-	}
-	return len(dAtA) - i, nil
-}
-
-func encodeVarintVirtualService(dAtA []byte, offset int, v uint64) int {
-	offset -= sovVirtualService(v)
-	base := offset
-	for v >= 1<<7 {
-		dAtA[offset] = uint8(v&0x7f | 0x80)
-		v >>= 7
-		offset++
-	}
-	dAtA[offset] = uint8(v)
-	return base
-}
-func (m *VirtualService) Size() (n int) {
-	if m == nil {
-		return 0
-	}
-	var l int
-	_ = l
-	if len(m.Hosts) > 0 {
-		for _, s := range m.Hosts {
-			l = len(s)
-			n += 1 + l + sovVirtualService(uint64(l))
+	if len(m.AllowOrigins) > 0 {
+		for iNdEx := len(m.AllowOrigins) - 1; iNdEx >= 0; iNdEx-- {
+			{
+				size, err := m.AllowOrigins[iNdEx].MarshalToSizedBuffer(dAtA[:i])
+				if err != nil {
+					return 0, err
+				}
+				i -= size
+				i = encodeVarintVirtualService(dAtA, i, uint64(size))
+			}
+			i--
+			dAtA[i] = 0x3a
 		}
 	}
-	if len(m.Gateways) > 0 {
-		for _, s := range m.Gateways {
-			l = len(s)
-			n += 1 + l + sovVirtualService(uint64(l))
+	if m.AllowCredentials != nil {
+		{
+			size, err := m.AllowCredentials.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintVirtualService(dAtA, i, uint64(size))
 		}
+		i--
+		dAtA[i] = 0x32
 	}
-	if len(m.Http) > 0 {
-		for _, e := range m.Http {
-			l = e.Size()
-			n += 1 + l + sovVirtualService(uint64(l))
+	if m.MaxAge != nil {
+		{
+			size, err := m.MaxAge.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintVirtualService(dAtA, i, uint64(size))
 		}
+		i--
+		dAtA[i] = 0x2a
 	}
-	if len(m.Tcp) > 0 {
-		for _, e := range m.Tcp {
-			l = e.Size()
-			n += 1 + l + sovVirtualService(uint64(l))
+	if len(m.ExposeHeaders) > 0 {
+		for iNdEx := len(m.ExposeHeaders) - 1; iNdEx >= 0; iNdEx-- {
+			i -= len(m.ExposeHeaders[iNdEx])
+			copy(dAtA[i:], m.ExposeHeaders[iNdEx])
+			i = encodeVarintVirtualService(dAtA, i, uint64(len(m.ExposeHeaders[iNdEx])))
+			i--
+			dAtA[i] = 0x22
 		}
 	}
-	if len(m.Tls) > 0 {
-		for _, e := range m.Tls {
-			l = e.Size()
-			n += 1 + l + sovVirtualService(uint64(l))
+	if len(m.AllowHeaders) > 0 {
+		for iNdEx := len(m.AllowHeaders) - 1; iNdEx >= 0; iNdEx-- {
+			i -= len(m.AllowHeaders[iNdEx])
+			copy(dAtA[i:], m.AllowHeaders[iNdEx])
+			i = encodeVarintVirtualService(dAtA, i, uint64(len(m.AllowHeaders[iNdEx])))
+			i--
+			dAtA[i] = 0x1a
 		}
 	}
-	if len(m.ExportTo) > 0 {
-		for _, s := range m.ExportTo {
-			l = len(s)
-			n += 1 + l + sovVirtualService(uint64(l))
+	if len(m.AllowMethods) > 0 {
+		for iNdEx := len(m.AllowMethods) - 1; iNdEx >= 0; iNdEx-- {
+			i -= len(m.AllowMethods[iNdEx])
+			copy(dAtA[i:], m.AllowMethods[iNdEx])
+			i = encodeVarintVirtualService(dAtA, i, uint64(len(m.AllowMethods[iNdEx])))
+			i--
+			dAtA[i] = 0x12
 		}
 	}
-	if m.XXX_unrecognized != nil {
-		n += len(m.XXX_unrecognized)
+	if len(m.AllowOrigin) > 0 {
+		for iNdEx := len(m.AllowOrigin) - 1; iNdEx >= 0; iNdEx-- {
+			i -= len(m.AllowOrigin[iNdEx])
+			copy(dAtA[i:], m.AllowOrigin[iNdEx])
+			i = encodeVarintVirtualService(dAtA, i, uint64(len(m.AllowOrigin[iNdEx])))
+			i--
+			dAtA[i] = 0xa
+		}
 	}
-	return n
+	return len(dAtA) - i, nil
 }
 
-func (m *Destination) Size() (n int) {
-	if m == nil {
-		return 0
+func (m *HTTPFaultInjection) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
 	}
+	return dAtA[:n], nil
+}
+
+func (m *HTTPFaultInjection) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *HTTPFaultInjection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
 	var l int
 	_ = l
-	l = len(m.Host)
-	if l > 0 {
-		n += 1 + l + sovVirtualService(uint64(l))
-	}
-	l = len(m.Subset)
-	if l > 0 {
-		n += 1 + l + sovVirtualService(uint64(l))
+	if m.XXX_unrecognized != nil {
+		i -= len(m.XXX_unrecognized)
+		copy(dAtA[i:], m.XXX_unrecognized)
 	}
-	if m.Port != nil {
-		l = m.Port.Size()
-		n += 1 + l + sovVirtualService(uint64(l))
+	if m.Abort != nil {
+		{
+			size, err := m.Abort.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintVirtualService(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x12
 	}
-	if m.XXX_unrecognized != nil {
-		n += len(m.XXX_unrecognized)
+	if m.Delay != nil {
+		{
+			size, err := m.Delay.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintVirtualService(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0xa
 	}
-	return n
+	return len(dAtA) - i, nil
 }
 
-func (m *HTTPRoute) Size() (n int) {
-	if m == nil {
-		return 0
+func (m *HTTPFaultInjection_Delay) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
 	}
+	return dAtA[:n], nil
+}
+
+func (m *HTTPFaultInjection_Delay) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *HTTPFaultInjection_Delay) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
 	var l int
 	_ = l
-	if len(m.Match) > 0 {
-		for _, e := range m.Match {
-			l = e.Size()
-			n += 1 + l + sovVirtualService(uint64(l))
+	if m.XXX_unrecognized != nil {
+		i -= len(m.XXX_unrecognized)
+		copy(dAtA[i:], m.XXX_unrecognized)
+	}
+	if m.Percentage != nil {
+		{
+			size, err := m.Percentage.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintVirtualService(dAtA, i, uint64(size))
 		}
+		i--
+		dAtA[i] = 0x2a
 	}
-	if len(m.Route) > 0 {
-		for _, e := range m.Route {
-			l = e.Size()
-			n += 1 + l + sovVirtualService(uint64(l))
+	if m.HttpDelayType != nil {
+		{
+			size := m.HttpDelayType.Size()
+			i -= size
+			if _, err := m.HttpDelayType.MarshalTo(dAtA[i:]); err != nil {
+				return 0, err
+			}
 		}
 	}
-	if m.Redirect != nil {
-		l = m.Redirect.Size()
-		n += 1 + l + sovVirtualService(uint64(l))
-	}
-	if m.Rewrite != nil {
-		l = m.Rewrite.Size()
-		n += 1 + l + sovVirtualService(uint64(l))
-	}
-	if m.Timeout != nil {
-		l = m.Timeout.Size()
-		n += 1 + l + sovVirtualService(uint64(l))
-	}
-	if m.Retries != nil {
-		l = m.Retries.Size()
-		n += 1 + l + sovVirtualService(uint64(l))
-	}
-	if m.Fault != nil {
-		l = m.Fault.Size()
-		n += 1 + l + sovVirtualService(uint64(l))
-	}
-	if m.Mirror != nil {
-		l = m.Mirror.Size()
-		n += 1 + l + sovVirtualService(uint64(l))
-	}
-	if m.CorsPolicy != nil {
-		l = m.CorsPolicy.Size()
-		n += 1 + l + sovVirtualService(uint64(l))
-	}
-	if m.Headers != nil {
-		l = m.Headers.Size()
-		n += 2 + l + sovVirtualService(uint64(l))
-	}
-	l = len(m.Name)
-	if l > 0 {
-		n += 2 + l + sovVirtualService(uint64(l))
-	}
-	if m.MirrorPercent != nil {
-		l = m.MirrorPercent.Size()
-		n += 2 + l + sovVirtualService(uint64(l))
+	if m.Percent != 0 {
+		i = encodeVarintVirtualService(dAtA, i, uint64(m.Percent))
+		i--
+		dAtA[i] = 0x8
 	}
-	if m.MirrorPercentage != nil {
-		l = m.MirrorPercentage.Size()
-		n += 2 + l + sovVirtualService(uint64(l))
+	return len(dAtA) - i, nil
+}
+
+func (m *HTTPFaultInjection_Delay_FixedDelay) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *HTTPFaultInjection_Delay_FixedDelay) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	if m.FixedDelay != nil {
+		{
+			size, err := m.FixedDelay.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintVirtualService(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x12
 	}
-	if m.Delegate != nil {
-		l = m.Delegate.Size()
-		n += 2 + l + sovVirtualService(uint64(l))
+	return len(dAtA) - i, nil
+}
+func (m *HTTPFaultInjection_Delay_ExponentialDelay) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *HTTPFaultInjection_Delay_ExponentialDelay) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	if m.ExponentialDelay != nil {
+		{
+			size, err := m.ExponentialDelay.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintVirtualService(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x1a
 	}
-	if m.XXX_unrecognized != nil {
-		n += len(m.XXX_unrecognized)
+	return len(dAtA) - i, nil
+}
+func (m *HTTPFaultInjection_Abort) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
 	}
-	return n
+	return dAtA[:n], nil
 }
 
-func (m *Delegate) Size() (n int) {
-	if m == nil {
-		return 0
-	}
+func (m *HTTPFaultInjection_Abort) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *HTTPFaultInjection_Abort) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
 	var l int
 	_ = l
-	l = len(m.Name)
-	if l > 0 {
-		n += 1 + l + sovVirtualService(uint64(l))
+	if m.XXX_unrecognized != nil {
+		i -= len(m.XXX_unrecognized)
+		copy(dAtA[i:], m.XXX_unrecognized)
 	}
-	l = len(m.Namespace)
-	if l > 0 {
-		n += 1 + l + sovVirtualService(uint64(l))
+	if m.Percentage != nil {
+		{
+			size, err := m.Percentage.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintVirtualService(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x2a
 	}
-	if m.XXX_unrecognized != nil {
-		n += len(m.XXX_unrecognized)
+	if m.ErrorType != nil {
+		{
+			size := m.ErrorType.Size()
+			i -= size
+			if _, err := m.ErrorType.MarshalTo(dAtA[i:]); err != nil {
+				return 0, err
+			}
+		}
 	}
-	return n
+	return len(dAtA) - i, nil
 }
 
-func (m *Headers) Size() (n int) {
-	if m == nil {
-		return 0
+func (m *HTTPFaultInjection_Abort_HttpStatus) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *HTTPFaultInjection_Abort_HttpStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	i = encodeVarintVirtualService(dAtA, i, uint64(m.HttpStatus))
+	i--
+	dAtA[i] = 0x10
+	return len(dAtA) - i, nil
+}
+func (m *HTTPFaultInjection_Abort_GrpcStatus) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *HTTPFaultInjection_Abort_GrpcStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	i -= len(m.GrpcStatus)
+	copy(dAtA[i:], m.GrpcStatus)
+	i = encodeVarintVirtualService(dAtA, i, uint64(len(m.GrpcStatus)))
+	i--
+	dAtA[i] = 0x1a
+	return len(dAtA) - i, nil
+}
+func (m *HTTPFaultInjection_Abort_Http2Error) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *HTTPFaultInjection_Abort_Http2Error) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	i -= len(m.Http2Error)
+	copy(dAtA[i:], m.Http2Error)
+	i = encodeVarintVirtualService(dAtA, i, uint64(len(m.Http2Error)))
+	i--
+	dAtA[i] = 0x22
+	return len(dAtA) - i, nil
+}
+func (m *PortSelector) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
 	}
+	return dAtA[:n], nil
+}
+
+func (m *PortSelector) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *PortSelector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
 	var l int
 	_ = l
-	if m.Request != nil {
-		l = m.Request.Size()
-		n += 1 + l + sovVirtualService(uint64(l))
-	}
-	if m.Response != nil {
-		l = m.Response.Size()
-		n += 1 + l + sovVirtualService(uint64(l))
-	}
 	if m.XXX_unrecognized != nil {
-		n += len(m.XXX_unrecognized)
+		i -= len(m.XXX_unrecognized)
+		copy(dAtA[i:], m.XXX_unrecognized)
 	}
-	return n
+	if m.Number != 0 {
+		i = encodeVarintVirtualService(dAtA, i, uint64(m.Number))
+		i--
+		dAtA[i] = 0x8
+	}
+	return len(dAtA) - i, nil
 }
 
-func (m *Headers_HeaderOperations) Size() (n int) {
-	if m == nil {
-		return 0
+func (m *Percent) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
 	}
+	return dAtA[:n], nil
+}
+
+func (m *Percent) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *Percent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
 	var l int
 	_ = l
-	if len(m.Set) > 0 {
-		for k, v := range m.Set {
-			_ = k
-			_ = v
-			mapEntrySize := 1 + len(k) + sovVirtualService(uint64(len(k))) + 1 + len(v) + sovVirtualService(uint64(len(v)))
-			n += mapEntrySize + 1 + sovVirtualService(uint64(mapEntrySize))
-		}
+	if m.XXX_unrecognized != nil {
+		i -= len(m.XXX_unrecognized)
+		copy(dAtA[i:], m.XXX_unrecognized)
 	}
-	if len(m.Add) > 0 {
-		for k, v := range m.Add {
-			_ = k
-			_ = v
-			mapEntrySize := 1 + len(k) + sovVirtualService(uint64(len(k))) + 1 + len(v) + sovVirtualService(uint64(len(v)))
-			n += mapEntrySize + 1 + sovVirtualService(uint64(mapEntrySize))
+	if m.Value != 0 {
+		i -= 8
+		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Value))))
+		i--
+		dAtA[i] = 0x9
+	}
+	return len(dAtA) - i, nil
+}
+
+func (m *HTTPFilter) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *HTTPFilter) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *HTTPFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
+	var l int
+	_ = l
+	if m.XXX_unrecognized != nil {
+		i -= len(m.XXX_unrecognized)
+		copy(dAtA[i:], m.XXX_unrecognized)
+	}
+	if m.Filter != nil {
+		{
+			size := m.Filter.Size()
+			i -= size
+			if _, err := m.Filter.MarshalTo(dAtA[i:]); err != nil {
+				return 0, err
+			}
 		}
 	}
-	if len(m.Remove) > 0 {
-		for _, s := range m.Remove {
-			l = len(s)
-			n += 1 + l + sovVirtualService(uint64(l))
+	if m.Disable {
+		i--
+		if m.Disable {
+			dAtA[i] = 1
+		} else {
+			dAtA[i] = 0
+		}
+		i--
+		dAtA[i] = 0x10
+	}
+	if len(m.Name) > 0 {
+		i -= len(m.Name)
+		copy(dAtA[i:], m.Name)
+		i = encodeVarintVirtualService(dAtA, i, uint64(len(m.Name)))
+		i--
+		dAtA[i] = 0xa
+	}
+	return len(dAtA) - i, nil
+}
+
+func (m *HTTPFilter_IpAccessControl) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *HTTPFilter_IpAccessControl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	if m.IpAccessControl != nil {
+		{
+			size, err := m.IpAccessControl.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintVirtualService(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x1a
+	}
+	return len(dAtA) - i, nil
+}
+func (m *HTTPFilter_LocalRateLimit) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *HTTPFilter_LocalRateLimit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	if m.LocalRateLimit != nil {
+		{
+			size, err := m.LocalRateLimit.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintVirtualService(dAtA, i, uint64(size))
 		}
+		i--
+		dAtA[i] = 0x22
+	}
+	return len(dAtA) - i, nil
+}
+func (m *IPAccessControl) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
 	}
+	return dAtA[:n], nil
+}
+
+func (m *IPAccessControl) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *IPAccessControl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
+	var l int
+	_ = l
 	if m.XXX_unrecognized != nil {
-		n += len(m.XXX_unrecognized)
+		i -= len(m.XXX_unrecognized)
+		copy(dAtA[i:], m.XXX_unrecognized)
 	}
-	return n
+	if len(m.NotRemoteIpBlocks) > 0 {
+		for iNdEx := len(m.NotRemoteIpBlocks) - 1; iNdEx >= 0; iNdEx-- {
+			i -= len(m.NotRemoteIpBlocks[iNdEx])
+			copy(dAtA[i:], m.NotRemoteIpBlocks[iNdEx])
+			i = encodeVarintVirtualService(dAtA, i, uint64(len(m.NotRemoteIpBlocks[iNdEx])))
+			i--
+			dAtA[i] = 0x12
+		}
+	}
+	if len(m.RemoteIpBlocks) > 0 {
+		for iNdEx := len(m.RemoteIpBlocks) - 1; iNdEx >= 0; iNdEx-- {
+			i -= len(m.RemoteIpBlocks[iNdEx])
+			copy(dAtA[i:], m.RemoteIpBlocks[iNdEx])
+			i = encodeVarintVirtualService(dAtA, i, uint64(len(m.RemoteIpBlocks[iNdEx])))
+			i--
+			dAtA[i] = 0xa
+		}
+	}
+	return len(dAtA) - i, nil
 }
 
-func (m *TLSRoute) Size() (n int) {
-	if m == nil {
-		return 0
+func (m *LocalRateLimit) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
 	}
+	return dAtA[:n], nil
+}
+
+func (m *LocalRateLimit) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *LocalRateLimit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
 	var l int
 	_ = l
-	if len(m.Match) > 0 {
-		for _, e := range m.Match {
-			l = e.Size()
-			n += 1 + l + sovVirtualService(uint64(l))
+	if m.XXX_unrecognized != nil {
+		i -= len(m.XXX_unrecognized)
+		copy(dAtA[i:], m.XXX_unrecognized)
+	}
+	if m.StatusCode != 0 {
+		i = encodeVarintVirtualService(dAtA, i, uint64(m.StatusCode))
+		i--
+		dAtA[i] = 0x18
+	}
+	if m.PerDownstreamConnection {
+		i--
+		if m.PerDownstreamConnection {
+			dAtA[i] = 1
+		} else {
+			dAtA[i] = 0
 		}
+		i--
+		dAtA[i] = 0x10
 	}
-	if len(m.Route) > 0 {
-		for _, e := range m.Route {
-			l = e.Size()
-			n += 1 + l + sovVirtualService(uint64(l))
+	if m.TokenBucket != nil {
+		{
+			size, err := m.TokenBucket.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintVirtualService(dAtA, i, uint64(size))
 		}
+		i--
+		dAtA[i] = 0xa
+	}
+	return len(dAtA) - i, nil
+}
+
+func (m *TokenBucket) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
 	}
+	return dAtA[:n], nil
+}
+
+func (m *TokenBucket) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *TokenBucket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
+	var l int
+	_ = l
 	if m.XXX_unrecognized != nil {
-		n += len(m.XXX_unrecognized)
+		i -= len(m.XXX_unrecognized)
+		copy(dAtA[i:], m.XXX_unrecognized)
 	}
-	return n
+	if m.FillInterval != nil {
+		{
+			size, err := m.FillInterval.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintVirtualService(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x1a
+	}
+	if m.TokensPefFill != 0 {
+		i = encodeVarintVirtualService(dAtA, i, uint64(m.TokensPefFill))
+		i--
+		dAtA[i] = 0x10
+	}
+	if m.MaxTokens != 0 {
+		i = encodeVarintVirtualService(dAtA, i, uint64(m.MaxTokens))
+		i--
+		dAtA[i] = 0x8
+	}
+	return len(dAtA) - i, nil
 }
 
-func (m *TCPRoute) Size() (n int) {
+func encodeVarintVirtualService(dAtA []byte, offset int, v uint64) int {
+	offset -= sovVirtualService(v)
+	base := offset
+	for v >= 1<<7 {
+		dAtA[offset] = uint8(v&0x7f | 0x80)
+		v >>= 7
+		offset++
+	}
+	dAtA[offset] = uint8(v)
+	return base
+}
+func (m *VirtualService) Size() (n int) {
 	if m == nil {
 		return 0
 	}
 	var l int
 	_ = l
-	if len(m.Match) > 0 {
-		for _, e := range m.Match {
+	if len(m.Hosts) > 0 {
+		for _, s := range m.Hosts {
+			l = len(s)
+			n += 1 + l + sovVirtualService(uint64(l))
+		}
+	}
+	if len(m.Gateways) > 0 {
+		for _, s := range m.Gateways {
+			l = len(s)
+			n += 1 + l + sovVirtualService(uint64(l))
+		}
+	}
+	if len(m.Http) > 0 {
+		for _, e := range m.Http {
 			l = e.Size()
 			n += 1 + l + sovVirtualService(uint64(l))
 		}
 	}
-	if len(m.Route) > 0 {
-		for _, e := range m.Route {
+	if len(m.Tcp) > 0 {
+		for _, e := range m.Tcp {
+			l = e.Size()
+			n += 1 + l + sovVirtualService(uint64(l))
+		}
+	}
+	if len(m.Tls) > 0 {
+		for _, e := range m.Tls {
+			l = e.Size()
+			n += 1 + l + sovVirtualService(uint64(l))
+		}
+	}
+	if len(m.ExportTo) > 0 {
+		for _, s := range m.ExportTo {
+			l = len(s)
+			n += 1 + l + sovVirtualService(uint64(l))
+		}
+	}
+	if len(m.HostHTTPFilters) > 0 {
+		for _, e := range m.HostHTTPFilters {
+			l = e.Size()
+			n += 2 + l + sovVirtualService(uint64(l))
+		}
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *Destination) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	l = len(m.Host)
+	if l > 0 {
+		n += 1 + l + sovVirtualService(uint64(l))
+	}
+	l = len(m.Subset)
+	if l > 0 {
+		n += 1 + l + sovVirtualService(uint64(l))
+	}
+	if m.Port != nil {
+		l = m.Port.Size()
+		n += 1 + l + sovVirtualService(uint64(l))
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *HTTPRoute) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if len(m.Match) > 0 {
+		for _, e := range m.Match {
+			l = e.Size()
+			n += 1 + l + sovVirtualService(uint64(l))
+		}
+	}
+	if len(m.Route) > 0 {
+		for _, e := range m.Route {
+			l = e.Size()
+			n += 1 + l + sovVirtualService(uint64(l))
+		}
+	}
+	if m.Redirect != nil {
+		l = m.Redirect.Size()
+		n += 1 + l + sovVirtualService(uint64(l))
+	}
+	if m.Rewrite != nil {
+		l = m.Rewrite.Size()
+		n += 1 + l + sovVirtualService(uint64(l))
+	}
+	if m.Timeout != nil {
+		l = m.Timeout.Size()
+		n += 1 + l + sovVirtualService(uint64(l))
+	}
+	if m.Retries != nil {
+		l = m.Retries.Size()
+		n += 1 + l + sovVirtualService(uint64(l))
+	}
+	if m.Fault != nil {
+		l = m.Fault.Size()
+		n += 1 + l + sovVirtualService(uint64(l))
+	}
+	if m.Mirror != nil {
+		l = m.Mirror.Size()
+		n += 1 + l + sovVirtualService(uint64(l))
+	}
+	if m.CorsPolicy != nil {
+		l = m.CorsPolicy.Size()
+		n += 1 + l + sovVirtualService(uint64(l))
+	}
+	if m.Headers != nil {
+		l = m.Headers.Size()
+		n += 2 + l + sovVirtualService(uint64(l))
+	}
+	l = len(m.Name)
+	if l > 0 {
+		n += 2 + l + sovVirtualService(uint64(l))
+	}
+	if m.MirrorPercent != nil {
+		l = m.MirrorPercent.Size()
+		n += 2 + l + sovVirtualService(uint64(l))
+	}
+	if m.MirrorPercentage != nil {
+		l = m.MirrorPercentage.Size()
+		n += 2 + l + sovVirtualService(uint64(l))
+	}
+	if m.Delegate != nil {
+		l = m.Delegate.Size()
+		n += 2 + l + sovVirtualService(uint64(l))
+	}
+	if m.InternalActiveRedirect != nil {
+		l = m.InternalActiveRedirect.Size()
+		n += 2 + l + sovVirtualService(uint64(l))
+	}
+	if m.DirectResponse != nil {
+		l = m.DirectResponse.Size()
+		n += 2 + l + sovVirtualService(uint64(l))
+	}
+	if len(m.RouteHTTPFilters) > 0 {
+		for _, e := range m.RouteHTTPFilters {
+			l = e.Size()
+			n += 2 + l + sovVirtualService(uint64(l))
+		}
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *Delegate) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	l = len(m.Name)
+	if l > 0 {
+		n += 1 + l + sovVirtualService(uint64(l))
+	}
+	l = len(m.Namespace)
+	if l > 0 {
+		n += 1 + l + sovVirtualService(uint64(l))
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *Headers) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if m.Request != nil {
+		l = m.Request.Size()
+		n += 1 + l + sovVirtualService(uint64(l))
+	}
+	if m.Response != nil {
+		l = m.Response.Size()
+		n += 1 + l + sovVirtualService(uint64(l))
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *Headers_HeaderOperations) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if len(m.Set) > 0 {
+		for k, v := range m.Set {
+			_ = k
+			_ = v
+			mapEntrySize := 1 + len(k) + sovVirtualService(uint64(len(k))) + 1 + len(v) + sovVirtualService(uint64(len(v)))
+			n += mapEntrySize + 1 + sovVirtualService(uint64(mapEntrySize))
+		}
+	}
+	if len(m.Add) > 0 {
+		for k, v := range m.Add {
+			_ = k
+			_ = v
+			mapEntrySize := 1 + len(k) + sovVirtualService(uint64(len(k))) + 1 + len(v) + sovVirtualService(uint64(len(v)))
+			n += mapEntrySize + 1 + sovVirtualService(uint64(mapEntrySize))
+		}
+	}
+	if len(m.Remove) > 0 {
+		for _, s := range m.Remove {
+			l = len(s)
+			n += 1 + l + sovVirtualService(uint64(l))
+		}
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *TLSRoute) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if len(m.Match) > 0 {
+		for _, e := range m.Match {
+			l = e.Size()
+			n += 1 + l + sovVirtualService(uint64(l))
+		}
+	}
+	if len(m.Route) > 0 {
+		for _, e := range m.Route {
+			l = e.Size()
+			n += 1 + l + sovVirtualService(uint64(l))
+		}
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *TCPRoute) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if len(m.Match) > 0 {
+		for _, e := range m.Match {
+			l = e.Size()
+			n += 1 + l + sovVirtualService(uint64(l))
+		}
+	}
+	if len(m.Route) > 0 {
+		for _, e := range m.Route {
 			l = e.Size()
 			n += 1 + l + sovVirtualService(uint64(l))
 		}
@@ -5776,6 +7353,12 @@ func (m *HTTPRouteDestination) Size() (n int) {
 		l = m.Headers.Size()
 		n += 1 + l + sovVirtualService(uint64(l))
 	}
+	if len(m.FallbackClusters) > 0 {
+		for _, e := range m.FallbackClusters {
+			l = e.Size()
+			n += 2 + l + sovVirtualService(uint64(l))
+		}
+	}
 	if m.XXX_unrecognized != nil {
 		n += len(m.XXX_unrecognized)
 	}
@@ -5937,48 +7520,225 @@ func (m *HTTPRedirect_DerivePort) Size() (n int) {
 	n += 1 + sovVirtualService(uint64(m.DerivePort))
 	return n
 }
-func (m *HTTPRewrite) Size() (n int) {
+func (m *HTTPInternalActiveRedirect) Size() (n int) {
 	if m == nil {
 		return 0
 	}
 	var l int
 	_ = l
-	l = len(m.Uri)
-	if l > 0 {
+	if m.MaxInternalRedirects != 0 {
+		n += 1 + sovVirtualService(uint64(m.MaxInternalRedirects))
+	}
+	if len(m.RedirectResponseCodes) > 0 {
+		l = 0
+		for _, e := range m.RedirectResponseCodes {
+			l += sovVirtualService(uint64(e))
+		}
+		n += 1 + sovVirtualService(uint64(l)) + l
+	}
+	if m.RedirectUrlRewriteSpecifier != nil {
+		n += m.RedirectUrlRewriteSpecifier.Size()
+	}
+	if m.AllowCrossScheme {
+		n += 2
+	}
+	if m.Headers != nil {
+		l = m.Headers.Size()
 		n += 1 + l + sovVirtualService(uint64(l))
 	}
 	l = len(m.Authority)
 	if l > 0 {
 		n += 1 + l + sovVirtualService(uint64(l))
 	}
+	if len(m.Policies) > 0 {
+		for _, e := range m.Policies {
+			l = e.Size()
+			n += 1 + l + sovVirtualService(uint64(l))
+		}
+	}
+	if m.ForcedUseOriginalHost {
+		n += 3
+	}
+	if m.ForcedAddHeaderBeforeRouteMatcher {
+		n += 3
+	}
 	if m.XXX_unrecognized != nil {
 		n += len(m.XXX_unrecognized)
 	}
 	return n
 }
 
-func (m *StringMatch) Size() (n int) {
+func (m *HTTPInternalActiveRedirect_RedirectUrl) Size() (n int) {
 	if m == nil {
 		return 0
 	}
 	var l int
 	_ = l
-	if m.MatchType != nil {
-		n += m.MatchType.Size()
-	}
-	if m.XXX_unrecognized != nil {
-		n += len(m.XXX_unrecognized)
-	}
+	l = len(m.RedirectUrl)
+	n += 1 + l + sovVirtualService(uint64(l))
 	return n
 }
-
-func (m *StringMatch_Exact) Size() (n int) {
+func (m *HTTPInternalActiveRedirect_RedirectUrlRewriteRegex) Size() (n int) {
 	if m == nil {
 		return 0
 	}
 	var l int
 	_ = l
-	l = len(m.Exact)
+	if m.RedirectUrlRewriteRegex != nil {
+		l = m.RedirectUrlRewriteRegex.Size()
+		n += 1 + l + sovVirtualService(uint64(l))
+	}
+	return n
+}
+func (m *HTTPInternalActiveRedirect_RedirectPolicy) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if m.MaxInternalRedirects != 0 {
+		n += 1 + sovVirtualService(uint64(m.MaxInternalRedirects))
+	}
+	if len(m.RedirectResponseCodes) > 0 {
+		l = 0
+		for _, e := range m.RedirectResponseCodes {
+			l += sovVirtualService(uint64(e))
+		}
+		n += 1 + sovVirtualService(uint64(l)) + l
+	}
+	if m.RedirectUrlRewriteSpecifier != nil {
+		n += m.RedirectUrlRewriteSpecifier.Size()
+	}
+	if m.AllowCrossScheme {
+		n += 2
+	}
+	if m.Headers != nil {
+		l = m.Headers.Size()
+		n += 1 + l + sovVirtualService(uint64(l))
+	}
+	l = len(m.Authority)
+	if l > 0 {
+		n += 1 + l + sovVirtualService(uint64(l))
+	}
+	if m.ForcedUseOriginalHost {
+		n += 3
+	}
+	if m.ForcedAddHeaderBeforeRouteMatcher {
+		n += 3
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *HTTPInternalActiveRedirect_RedirectPolicy_RedirectUrl) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	l = len(m.RedirectUrl)
+	n += 1 + l + sovVirtualService(uint64(l))
+	return n
+}
+func (m *HTTPInternalActiveRedirect_RedirectPolicy_RedirectUrlRewriteRegex) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if m.RedirectUrlRewriteRegex != nil {
+		l = m.RedirectUrlRewriteRegex.Size()
+		n += 1 + l + sovVirtualService(uint64(l))
+	}
+	return n
+}
+func (m *HTTPDirectResponse) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if m.ResponseCode != 0 {
+		n += 1 + sovVirtualService(uint64(m.ResponseCode))
+	}
+	l = len(m.Body)
+	if l > 0 {
+		n += 1 + l + sovVirtualService(uint64(l))
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *HTTPRewrite) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	l = len(m.Uri)
+	if l > 0 {
+		n += 1 + l + sovVirtualService(uint64(l))
+	}
+	l = len(m.Authority)
+	if l > 0 {
+		n += 1 + l + sovVirtualService(uint64(l))
+	}
+	if m.UriRegex != nil {
+		l = m.UriRegex.Size()
+		n += 1 + l + sovVirtualService(uint64(l))
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *RegexMatchAndSubstitute) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	l = len(m.Pattern)
+	if l > 0 {
+		n += 1 + l + sovVirtualService(uint64(l))
+	}
+	l = len(m.Substitution)
+	if l > 0 {
+		n += 1 + l + sovVirtualService(uint64(l))
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *StringMatch) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if m.MatchType != nil {
+		n += m.MatchType.Size()
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *StringMatch_Exact) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	l = len(m.Exact)
 	n += 1 + l + sovVirtualService(uint64(l))
 	return n
 }
@@ -6223,6 +7983,120 @@ func (m *Percent) Size() (n int) {
 	return n
 }
 
+func (m *HTTPFilter) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	l = len(m.Name)
+	if l > 0 {
+		n += 1 + l + sovVirtualService(uint64(l))
+	}
+	if m.Disable {
+		n += 2
+	}
+	if m.Filter != nil {
+		n += m.Filter.Size()
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *HTTPFilter_IpAccessControl) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if m.IpAccessControl != nil {
+		l = m.IpAccessControl.Size()
+		n += 1 + l + sovVirtualService(uint64(l))
+	}
+	return n
+}
+func (m *HTTPFilter_LocalRateLimit) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if m.LocalRateLimit != nil {
+		l = m.LocalRateLimit.Size()
+		n += 1 + l + sovVirtualService(uint64(l))
+	}
+	return n
+}
+func (m *IPAccessControl) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if len(m.RemoteIpBlocks) > 0 {
+		for _, s := range m.RemoteIpBlocks {
+			l = len(s)
+			n += 1 + l + sovVirtualService(uint64(l))
+		}
+	}
+	if len(m.NotRemoteIpBlocks) > 0 {
+		for _, s := range m.NotRemoteIpBlocks {
+			l = len(s)
+			n += 1 + l + sovVirtualService(uint64(l))
+		}
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *LocalRateLimit) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if m.TokenBucket != nil {
+		l = m.TokenBucket.Size()
+		n += 1 + l + sovVirtualService(uint64(l))
+	}
+	if m.PerDownstreamConnection {
+		n += 2
+	}
+	if m.StatusCode != 0 {
+		n += 1 + sovVirtualService(uint64(m.StatusCode))
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *TokenBucket) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if m.MaxTokens != 0 {
+		n += 1 + sovVirtualService(uint64(m.MaxTokens))
+	}
+	if m.TokensPefFill != 0 {
+		n += 1 + sovVirtualService(uint64(m.TokensPefFill))
+	}
+	if m.FillInterval != nil {
+		l = m.FillInterval.Size()
+		n += 1 + l + sovVirtualService(uint64(l))
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
 func sovVirtualService(x uint64) (n int) {
 	return (math_bits.Len64(x|1) + 6) / 7
 }
@@ -6248,21 +8122,1473 @@ func (m *VirtualService) Unmarshal(dAtA []byte) error {
 			if b < 0x80 {
 				break
 			}
-		}
-		fieldNum := int32(wire >> 3)
-		wireType := int(wire & 0x7)
-		if wireType == 4 {
-			return fmt.Errorf("proto: VirtualService: wiretype end group for non-group")
-		}
-		if fieldNum <= 0 {
-			return fmt.Errorf("proto: VirtualService: illegal tag %d (wire type %d)", fieldNum, wire)
-		}
-		switch fieldNum {
-		case 1:
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: VirtualService: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: VirtualService: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Hosts", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Hosts = append(m.Hosts, string(dAtA[iNdEx:postIndex]))
+			iNdEx = postIndex
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Gateways", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Gateways = append(m.Gateways, string(dAtA[iNdEx:postIndex]))
+			iNdEx = postIndex
+		case 3:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Http", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Http = append(m.Http, &HTTPRoute{})
+			if err := m.Http[len(m.Http)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 4:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Tcp", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Tcp = append(m.Tcp, &TCPRoute{})
+			if err := m.Tcp[len(m.Tcp)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 5:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Tls", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Tls = append(m.Tls, &TLSRoute{})
+			if err := m.Tls[len(m.Tls)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 6:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field ExportTo", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.ExportTo = append(m.ExportTo, string(dAtA[iNdEx:postIndex]))
+			iNdEx = postIndex
+		case 1000:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field HostHTTPFilters", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.HostHTTPFilters = append(m.HostHTTPFilters, &HTTPFilter{})
+			if err := m.HostHTTPFilters[len(m.HostHTTPFilters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipVirtualService(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *Destination) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowVirtualService
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: Destination: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: Destination: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Host = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Subset", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Subset = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 3:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.Port == nil {
+				m.Port = &PortSelector{}
+			}
+			if err := m.Port.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipVirtualService(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *HTTPRoute) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowVirtualService
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: HTTPRoute: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: HTTPRoute: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Match", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Match = append(m.Match, &HTTPMatchRequest{})
+			if err := m.Match[len(m.Match)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Route", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Route = append(m.Route, &HTTPRouteDestination{})
+			if err := m.Route[len(m.Route)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 3:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Redirect", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.Redirect == nil {
+				m.Redirect = &HTTPRedirect{}
+			}
+			if err := m.Redirect.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 4:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Rewrite", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.Rewrite == nil {
+				m.Rewrite = &HTTPRewrite{}
+			}
+			if err := m.Rewrite.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 6:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.Timeout == nil {
+				m.Timeout = &types.Duration{}
+			}
+			if err := m.Timeout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 7:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Retries", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.Retries == nil {
+				m.Retries = &HTTPRetry{}
+			}
+			if err := m.Retries.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 8:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Fault", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.Fault == nil {
+				m.Fault = &HTTPFaultInjection{}
+			}
+			if err := m.Fault.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 9:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Mirror", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.Mirror == nil {
+				m.Mirror = &Destination{}
+			}
+			if err := m.Mirror.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 10:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field CorsPolicy", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.CorsPolicy == nil {
+				m.CorsPolicy = &CorsPolicy{}
+			}
+			if err := m.CorsPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 16:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.Headers == nil {
+				m.Headers = &Headers{}
+			}
+			if err := m.Headers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 17:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Name = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 18:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field MirrorPercent", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.MirrorPercent == nil {
+				m.MirrorPercent = &types.UInt32Value{}
+			}
+			if err := m.MirrorPercent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 19:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field MirrorPercentage", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.MirrorPercentage == nil {
+				m.MirrorPercentage = &Percent{}
+			}
+			if err := m.MirrorPercentage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 20:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Delegate", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.Delegate == nil {
+				m.Delegate = &Delegate{}
+			}
+			if err := m.Delegate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 25:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field InternalActiveRedirect", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.InternalActiveRedirect == nil {
+				m.InternalActiveRedirect = &HTTPInternalActiveRedirect{}
+			}
+			if err := m.InternalActiveRedirect.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 26:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field DirectResponse", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.DirectResponse == nil {
+				m.DirectResponse = &HTTPDirectResponse{}
+			}
+			if err := m.DirectResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 1000:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field RouteHTTPFilters", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.RouteHTTPFilters = append(m.RouteHTTPFilters, &HTTPFilter{})
+			if err := m.RouteHTTPFilters[len(m.RouteHTTPFilters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipVirtualService(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *Delegate) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowVirtualService
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: Delegate: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: Delegate: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Name = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Namespace = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipVirtualService(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *Headers) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowVirtualService
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: Headers: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: Headers: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.Request == nil {
+				m.Request = &Headers_HeaderOperations{}
+			}
+			if err := m.Request.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.Response == nil {
+				m.Response = &Headers_HeaderOperations{}
+			}
+			if err := m.Response.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipVirtualService(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *Headers_HeaderOperations) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowVirtualService
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: HeaderOperations: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: HeaderOperations: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Set", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.Set == nil {
+				m.Set = make(map[string]string)
+			}
+			var mapkey string
+			var mapvalue string
+			for iNdEx < postIndex {
+				entryPreIndex := iNdEx
+				var wire uint64
+				for shift := uint(0); ; shift += 7 {
+					if shift >= 64 {
+						return ErrIntOverflowVirtualService
+					}
+					if iNdEx >= l {
+						return io.ErrUnexpectedEOF
+					}
+					b := dAtA[iNdEx]
+					iNdEx++
+					wire |= uint64(b&0x7F) << shift
+					if b < 0x80 {
+						break
+					}
+				}
+				fieldNum := int32(wire >> 3)
+				if fieldNum == 1 {
+					var stringLenmapkey uint64
+					for shift := uint(0); ; shift += 7 {
+						if shift >= 64 {
+							return ErrIntOverflowVirtualService
+						}
+						if iNdEx >= l {
+							return io.ErrUnexpectedEOF
+						}
+						b := dAtA[iNdEx]
+						iNdEx++
+						stringLenmapkey |= uint64(b&0x7F) << shift
+						if b < 0x80 {
+							break
+						}
+					}
+					intStringLenmapkey := int(stringLenmapkey)
+					if intStringLenmapkey < 0 {
+						return ErrInvalidLengthVirtualService
+					}
+					postStringIndexmapkey := iNdEx + intStringLenmapkey
+					if postStringIndexmapkey < 0 {
+						return ErrInvalidLengthVirtualService
+					}
+					if postStringIndexmapkey > l {
+						return io.ErrUnexpectedEOF
+					}
+					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
+					iNdEx = postStringIndexmapkey
+				} else if fieldNum == 2 {
+					var stringLenmapvalue uint64
+					for shift := uint(0); ; shift += 7 {
+						if shift >= 64 {
+							return ErrIntOverflowVirtualService
+						}
+						if iNdEx >= l {
+							return io.ErrUnexpectedEOF
+						}
+						b := dAtA[iNdEx]
+						iNdEx++
+						stringLenmapvalue |= uint64(b&0x7F) << shift
+						if b < 0x80 {
+							break
+						}
+					}
+					intStringLenmapvalue := int(stringLenmapvalue)
+					if intStringLenmapvalue < 0 {
+						return ErrInvalidLengthVirtualService
+					}
+					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
+					if postStringIndexmapvalue < 0 {
+						return ErrInvalidLengthVirtualService
+					}
+					if postStringIndexmapvalue > l {
+						return io.ErrUnexpectedEOF
+					}
+					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
+					iNdEx = postStringIndexmapvalue
+				} else {
+					iNdEx = entryPreIndex
+					skippy, err := skipVirtualService(dAtA[iNdEx:])
+					if err != nil {
+						return err
+					}
+					if (skippy < 0) || (iNdEx+skippy) < 0 {
+						return ErrInvalidLengthVirtualService
+					}
+					if (iNdEx + skippy) > postIndex {
+						return io.ErrUnexpectedEOF
+					}
+					iNdEx += skippy
+				}
+			}
+			m.Set[mapkey] = mapvalue
+			iNdEx = postIndex
+		case 2:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Hosts", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Add", wireType)
 			}
-			var stringLen uint64
+			var msglen int
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowVirtualService
@@ -6272,27 +9598,122 @@ func (m *VirtualService) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				stringLen |= uint64(b&0x7F) << shift
+				msglen |= int(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			intStringLen := int(stringLen)
-			if intStringLen < 0 {
+			if msglen < 0 {
 				return ErrInvalidLengthVirtualService
 			}
-			postIndex := iNdEx + intStringLen
+			postIndex := iNdEx + msglen
 			if postIndex < 0 {
 				return ErrInvalidLengthVirtualService
 			}
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.Hosts = append(m.Hosts, string(dAtA[iNdEx:postIndex]))
+			if m.Add == nil {
+				m.Add = make(map[string]string)
+			}
+			var mapkey string
+			var mapvalue string
+			for iNdEx < postIndex {
+				entryPreIndex := iNdEx
+				var wire uint64
+				for shift := uint(0); ; shift += 7 {
+					if shift >= 64 {
+						return ErrIntOverflowVirtualService
+					}
+					if iNdEx >= l {
+						return io.ErrUnexpectedEOF
+					}
+					b := dAtA[iNdEx]
+					iNdEx++
+					wire |= uint64(b&0x7F) << shift
+					if b < 0x80 {
+						break
+					}
+				}
+				fieldNum := int32(wire >> 3)
+				if fieldNum == 1 {
+					var stringLenmapkey uint64
+					for shift := uint(0); ; shift += 7 {
+						if shift >= 64 {
+							return ErrIntOverflowVirtualService
+						}
+						if iNdEx >= l {
+							return io.ErrUnexpectedEOF
+						}
+						b := dAtA[iNdEx]
+						iNdEx++
+						stringLenmapkey |= uint64(b&0x7F) << shift
+						if b < 0x80 {
+							break
+						}
+					}
+					intStringLenmapkey := int(stringLenmapkey)
+					if intStringLenmapkey < 0 {
+						return ErrInvalidLengthVirtualService
+					}
+					postStringIndexmapkey := iNdEx + intStringLenmapkey
+					if postStringIndexmapkey < 0 {
+						return ErrInvalidLengthVirtualService
+					}
+					if postStringIndexmapkey > l {
+						return io.ErrUnexpectedEOF
+					}
+					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
+					iNdEx = postStringIndexmapkey
+				} else if fieldNum == 2 {
+					var stringLenmapvalue uint64
+					for shift := uint(0); ; shift += 7 {
+						if shift >= 64 {
+							return ErrIntOverflowVirtualService
+						}
+						if iNdEx >= l {
+							return io.ErrUnexpectedEOF
+						}
+						b := dAtA[iNdEx]
+						iNdEx++
+						stringLenmapvalue |= uint64(b&0x7F) << shift
+						if b < 0x80 {
+							break
+						}
+					}
+					intStringLenmapvalue := int(stringLenmapvalue)
+					if intStringLenmapvalue < 0 {
+						return ErrInvalidLengthVirtualService
+					}
+					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
+					if postStringIndexmapvalue < 0 {
+						return ErrInvalidLengthVirtualService
+					}
+					if postStringIndexmapvalue > l {
+						return io.ErrUnexpectedEOF
+					}
+					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
+					iNdEx = postStringIndexmapvalue
+				} else {
+					iNdEx = entryPreIndex
+					skippy, err := skipVirtualService(dAtA[iNdEx:])
+					if err != nil {
+						return err
+					}
+					if (skippy < 0) || (iNdEx+skippy) < 0 {
+						return ErrInvalidLengthVirtualService
+					}
+					if (iNdEx + skippy) > postIndex {
+						return io.ErrUnexpectedEOF
+					}
+					iNdEx += skippy
+				}
+			}
+			m.Add[mapkey] = mapvalue
 			iNdEx = postIndex
-		case 2:
+		case 3:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Gateways", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Remove", wireType)
 			}
 			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
@@ -6320,79 +9741,62 @@ func (m *VirtualService) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.Gateways = append(m.Gateways, string(dAtA[iNdEx:postIndex]))
+			m.Remove = append(m.Remove, string(dAtA[iNdEx:postIndex]))
 			iNdEx = postIndex
-		case 3:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Http", wireType)
-			}
-			var msglen int
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowVirtualService
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				msglen |= int(b&0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-			if msglen < 0 {
-				return ErrInvalidLengthVirtualService
+		default:
+			iNdEx = preIndex
+			skippy, err := skipVirtualService(dAtA[iNdEx:])
+			if err != nil {
+				return err
 			}
-			postIndex := iNdEx + msglen
-			if postIndex < 0 {
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
 				return ErrInvalidLengthVirtualService
 			}
-			if postIndex > l {
+			if (iNdEx + skippy) > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.Http = append(m.Http, &HTTPRoute{})
-			if err := m.Http[len(m.Http)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
-			iNdEx = postIndex
-		case 4:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Tcp", wireType)
-			}
-			var msglen int
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowVirtualService
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				msglen |= int(b&0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-			if msglen < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			postIndex := iNdEx + msglen
-			if postIndex < 0 {
-				return ErrInvalidLengthVirtualService
+			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *TLSRoute) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowVirtualService
 			}
-			if postIndex > l {
+			if iNdEx >= l {
 				return io.ErrUnexpectedEOF
 			}
-			m.Tcp = append(m.Tcp, &TCPRoute{})
-			if err := m.Tcp[len(m.Tcp)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
 			}
-			iNdEx = postIndex
-		case 5:
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: TLSRoute: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: TLSRoute: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Tls", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Match", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -6419,16 +9823,16 @@ func (m *VirtualService) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.Tls = append(m.Tls, &TLSRoute{})
-			if err := m.Tls[len(m.Tls)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+			m.Match = append(m.Match, &TLSMatchAttributes{})
+			if err := m.Match[len(m.Match)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
 			iNdEx = postIndex
-		case 6:
+		case 2:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field ExportTo", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Route", wireType)
 			}
-			var stringLen uint64
+			var msglen int
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowVirtualService
@@ -6438,23 +9842,25 @@ func (m *VirtualService) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				stringLen |= uint64(b&0x7F) << shift
+				msglen |= int(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			intStringLen := int(stringLen)
-			if intStringLen < 0 {
+			if msglen < 0 {
 				return ErrInvalidLengthVirtualService
 			}
-			postIndex := iNdEx + intStringLen
+			postIndex := iNdEx + msglen
 			if postIndex < 0 {
 				return ErrInvalidLengthVirtualService
 			}
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.ExportTo = append(m.ExportTo, string(dAtA[iNdEx:postIndex]))
+			m.Route = append(m.Route, &RouteDestination{})
+			if err := m.Route[len(m.Route)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
 			iNdEx = postIndex
 		default:
 			iNdEx = preIndex
@@ -6478,7 +9884,7 @@ func (m *VirtualService) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
-func (m *Destination) Unmarshal(dAtA []byte) error {
+func (m *TCPRoute) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
 	for iNdEx < l {
@@ -6501,17 +9907,17 @@ func (m *Destination) Unmarshal(dAtA []byte) error {
 		fieldNum := int32(wire >> 3)
 		wireType := int(wire & 0x7)
 		if wireType == 4 {
-			return fmt.Errorf("proto: Destination: wiretype end group for non-group")
+			return fmt.Errorf("proto: TCPRoute: wiretype end group for non-group")
 		}
 		if fieldNum <= 0 {
-			return fmt.Errorf("proto: Destination: illegal tag %d (wire type %d)", fieldNum, wire)
+			return fmt.Errorf("proto: TCPRoute: illegal tag %d (wire type %d)", fieldNum, wire)
 		}
 		switch fieldNum {
 		case 1:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Match", wireType)
 			}
-			var stringLen uint64
+			var msglen int
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowVirtualService
@@ -6521,59 +9927,29 @@ func (m *Destination) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				stringLen |= uint64(b&0x7F) << shift
+				msglen |= int(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			intStringLen := int(stringLen)
-			if intStringLen < 0 {
+			if msglen < 0 {
 				return ErrInvalidLengthVirtualService
 			}
-			postIndex := iNdEx + intStringLen
+			postIndex := iNdEx + msglen
 			if postIndex < 0 {
 				return ErrInvalidLengthVirtualService
 			}
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.Host = string(dAtA[iNdEx:postIndex])
-			iNdEx = postIndex
-		case 2:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Subset", wireType)
-			}
-			var stringLen uint64
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowVirtualService
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				stringLen |= uint64(b&0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-			intStringLen := int(stringLen)
-			if intStringLen < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			postIndex := iNdEx + intStringLen
-			if postIndex < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
+			m.Match = append(m.Match, &L4MatchAttributes{})
+			if err := m.Match[len(m.Match)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
 			}
-			m.Subset = string(dAtA[iNdEx:postIndex])
 			iNdEx = postIndex
-		case 3:
+		case 2:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Route", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -6600,10 +9976,8 @@ func (m *Destination) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.Port == nil {
-				m.Port = &PortSelector{}
-			}
-			if err := m.Port.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+			m.Route = append(m.Route, &RouteDestination{})
+			if err := m.Route[len(m.Route)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
 			iNdEx = postIndex
@@ -6629,7 +10003,7 @@ func (m *Destination) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
-func (m *HTTPRoute) Unmarshal(dAtA []byte) error {
+func (m *HTTPMatchRequest) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
 	for iNdEx < l {
@@ -6652,15 +10026,15 @@ func (m *HTTPRoute) Unmarshal(dAtA []byte) error {
 		fieldNum := int32(wire >> 3)
 		wireType := int(wire & 0x7)
 		if wireType == 4 {
-			return fmt.Errorf("proto: HTTPRoute: wiretype end group for non-group")
+			return fmt.Errorf("proto: HTTPMatchRequest: wiretype end group for non-group")
 		}
 		if fieldNum <= 0 {
-			return fmt.Errorf("proto: HTTPRoute: illegal tag %d (wire type %d)", fieldNum, wire)
+			return fmt.Errorf("proto: HTTPMatchRequest: illegal tag %d (wire type %d)", fieldNum, wire)
 		}
 		switch fieldNum {
 		case 1:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Match", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -6687,14 +10061,16 @@ func (m *HTTPRoute) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.Match = append(m.Match, &HTTPMatchRequest{})
-			if err := m.Match[len(m.Match)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+			if m.Uri == nil {
+				m.Uri = &StringMatch{}
+			}
+			if err := m.Uri.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
 			iNdEx = postIndex
 		case 2:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Route", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Scheme", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -6721,14 +10097,16 @@ func (m *HTTPRoute) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.Route = append(m.Route, &HTTPRouteDestination{})
-			if err := m.Route[len(m.Route)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+			if m.Scheme == nil {
+				m.Scheme = &StringMatch{}
+			}
+			if err := m.Scheme.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
 			iNdEx = postIndex
 		case 3:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Redirect", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -6755,16 +10133,16 @@ func (m *HTTPRoute) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.Redirect == nil {
-				m.Redirect = &HTTPRedirect{}
+			if m.Method == nil {
+				m.Method = &StringMatch{}
 			}
-			if err := m.Redirect.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+			if err := m.Method.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
 			iNdEx = postIndex
 		case 4:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Rewrite", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -6791,18 +10169,147 @@ func (m *HTTPRoute) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.Rewrite == nil {
-				m.Rewrite = &HTTPRewrite{}
+			if m.Authority == nil {
+				m.Authority = &StringMatch{}
 			}
-			if err := m.Rewrite.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+			if err := m.Authority.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
 			iNdEx = postIndex
-		case 6:
+		case 5:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.Headers == nil {
+				m.Headers = make(map[string]*StringMatch)
+			}
+			var mapkey string
+			var mapvalue *StringMatch
+			for iNdEx < postIndex {
+				entryPreIndex := iNdEx
+				var wire uint64
+				for shift := uint(0); ; shift += 7 {
+					if shift >= 64 {
+						return ErrIntOverflowVirtualService
+					}
+					if iNdEx >= l {
+						return io.ErrUnexpectedEOF
+					}
+					b := dAtA[iNdEx]
+					iNdEx++
+					wire |= uint64(b&0x7F) << shift
+					if b < 0x80 {
+						break
+					}
+				}
+				fieldNum := int32(wire >> 3)
+				if fieldNum == 1 {
+					var stringLenmapkey uint64
+					for shift := uint(0); ; shift += 7 {
+						if shift >= 64 {
+							return ErrIntOverflowVirtualService
+						}
+						if iNdEx >= l {
+							return io.ErrUnexpectedEOF
+						}
+						b := dAtA[iNdEx]
+						iNdEx++
+						stringLenmapkey |= uint64(b&0x7F) << shift
+						if b < 0x80 {
+							break
+						}
+					}
+					intStringLenmapkey := int(stringLenmapkey)
+					if intStringLenmapkey < 0 {
+						return ErrInvalidLengthVirtualService
+					}
+					postStringIndexmapkey := iNdEx + intStringLenmapkey
+					if postStringIndexmapkey < 0 {
+						return ErrInvalidLengthVirtualService
+					}
+					if postStringIndexmapkey > l {
+						return io.ErrUnexpectedEOF
+					}
+					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
+					iNdEx = postStringIndexmapkey
+				} else if fieldNum == 2 {
+					var mapmsglen int
+					for shift := uint(0); ; shift += 7 {
+						if shift >= 64 {
+							return ErrIntOverflowVirtualService
+						}
+						if iNdEx >= l {
+							return io.ErrUnexpectedEOF
+						}
+						b := dAtA[iNdEx]
+						iNdEx++
+						mapmsglen |= int(b&0x7F) << shift
+						if b < 0x80 {
+							break
+						}
+					}
+					if mapmsglen < 0 {
+						return ErrInvalidLengthVirtualService
+					}
+					postmsgIndex := iNdEx + mapmsglen
+					if postmsgIndex < 0 {
+						return ErrInvalidLengthVirtualService
+					}
+					if postmsgIndex > l {
+						return io.ErrUnexpectedEOF
+					}
+					mapvalue = &StringMatch{}
+					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
+						return err
+					}
+					iNdEx = postmsgIndex
+				} else {
+					iNdEx = entryPreIndex
+					skippy, err := skipVirtualService(dAtA[iNdEx:])
+					if err != nil {
+						return err
+					}
+					if (skippy < 0) || (iNdEx+skippy) < 0 {
+						return ErrInvalidLengthVirtualService
+					}
+					if (iNdEx + skippy) > postIndex {
+						return io.ErrUnexpectedEOF
+					}
+					iNdEx += skippy
+				}
+			}
+			m.Headers[mapkey] = mapvalue
+			iNdEx = postIndex
+		case 6:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
 			}
-			var msglen int
+			m.Port = 0
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowVirtualService
@@ -6812,31 +10319,14 @@ func (m *HTTPRoute) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				msglen |= int(b&0x7F) << shift
+				m.Port |= uint32(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			if msglen < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			postIndex := iNdEx + msglen
-			if postIndex < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			if m.Timeout == nil {
-				m.Timeout = &types.Duration{}
-			}
-			if err := m.Timeout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
-			iNdEx = postIndex
 		case 7:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Retries", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field SourceLabels", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -6863,18 +10353,109 @@ func (m *HTTPRoute) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.Retries == nil {
-				m.Retries = &HTTPRetry{}
+			if m.SourceLabels == nil {
+				m.SourceLabels = make(map[string]string)
 			}
-			if err := m.Retries.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
+			var mapkey string
+			var mapvalue string
+			for iNdEx < postIndex {
+				entryPreIndex := iNdEx
+				var wire uint64
+				for shift := uint(0); ; shift += 7 {
+					if shift >= 64 {
+						return ErrIntOverflowVirtualService
+					}
+					if iNdEx >= l {
+						return io.ErrUnexpectedEOF
+					}
+					b := dAtA[iNdEx]
+					iNdEx++
+					wire |= uint64(b&0x7F) << shift
+					if b < 0x80 {
+						break
+					}
+				}
+				fieldNum := int32(wire >> 3)
+				if fieldNum == 1 {
+					var stringLenmapkey uint64
+					for shift := uint(0); ; shift += 7 {
+						if shift >= 64 {
+							return ErrIntOverflowVirtualService
+						}
+						if iNdEx >= l {
+							return io.ErrUnexpectedEOF
+						}
+						b := dAtA[iNdEx]
+						iNdEx++
+						stringLenmapkey |= uint64(b&0x7F) << shift
+						if b < 0x80 {
+							break
+						}
+					}
+					intStringLenmapkey := int(stringLenmapkey)
+					if intStringLenmapkey < 0 {
+						return ErrInvalidLengthVirtualService
+					}
+					postStringIndexmapkey := iNdEx + intStringLenmapkey
+					if postStringIndexmapkey < 0 {
+						return ErrInvalidLengthVirtualService
+					}
+					if postStringIndexmapkey > l {
+						return io.ErrUnexpectedEOF
+					}
+					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
+					iNdEx = postStringIndexmapkey
+				} else if fieldNum == 2 {
+					var stringLenmapvalue uint64
+					for shift := uint(0); ; shift += 7 {
+						if shift >= 64 {
+							return ErrIntOverflowVirtualService
+						}
+						if iNdEx >= l {
+							return io.ErrUnexpectedEOF
+						}
+						b := dAtA[iNdEx]
+						iNdEx++
+						stringLenmapvalue |= uint64(b&0x7F) << shift
+						if b < 0x80 {
+							break
+						}
+					}
+					intStringLenmapvalue := int(stringLenmapvalue)
+					if intStringLenmapvalue < 0 {
+						return ErrInvalidLengthVirtualService
+					}
+					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
+					if postStringIndexmapvalue < 0 {
+						return ErrInvalidLengthVirtualService
+					}
+					if postStringIndexmapvalue > l {
+						return io.ErrUnexpectedEOF
+					}
+					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
+					iNdEx = postStringIndexmapvalue
+				} else {
+					iNdEx = entryPreIndex
+					skippy, err := skipVirtualService(dAtA[iNdEx:])
+					if err != nil {
+						return err
+					}
+					if (skippy < 0) || (iNdEx+skippy) < 0 {
+						return ErrInvalidLengthVirtualService
+					}
+					if (iNdEx + skippy) > postIndex {
+						return io.ErrUnexpectedEOF
+					}
+					iNdEx += skippy
+				}
 			}
+			m.SourceLabels[mapkey] = mapvalue
 			iNdEx = postIndex
 		case 8:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Fault", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Gateways", wireType)
 			}
-			var msglen int
+			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowVirtualService
@@ -6884,31 +10465,27 @@ func (m *HTTPRoute) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				msglen |= int(b&0x7F) << shift
+				stringLen |= uint64(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			if msglen < 0 {
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
 				return ErrInvalidLengthVirtualService
 			}
-			postIndex := iNdEx + msglen
+			postIndex := iNdEx + intStringLen
 			if postIndex < 0 {
 				return ErrInvalidLengthVirtualService
 			}
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.Fault == nil {
-				m.Fault = &HTTPFaultInjection{}
-			}
-			if err := m.Fault.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
+			m.Gateways = append(m.Gateways, string(dAtA[iNdEx:postIndex]))
 			iNdEx = postIndex
 		case 9:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Mirror", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field QueryParams", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -6935,54 +10512,111 @@ func (m *HTTPRoute) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.Mirror == nil {
-				m.Mirror = &Destination{}
-			}
-			if err := m.Mirror.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
-			iNdEx = postIndex
-		case 10:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field CorsPolicy", wireType)
+			if m.QueryParams == nil {
+				m.QueryParams = make(map[string]*StringMatch)
 			}
-			var msglen int
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowVirtualService
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
+			var mapkey string
+			var mapvalue *StringMatch
+			for iNdEx < postIndex {
+				entryPreIndex := iNdEx
+				var wire uint64
+				for shift := uint(0); ; shift += 7 {
+					if shift >= 64 {
+						return ErrIntOverflowVirtualService
+					}
+					if iNdEx >= l {
+						return io.ErrUnexpectedEOF
+					}
+					b := dAtA[iNdEx]
+					iNdEx++
+					wire |= uint64(b&0x7F) << shift
+					if b < 0x80 {
+						break
+					}
 				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				msglen |= int(b&0x7F) << shift
-				if b < 0x80 {
-					break
+				fieldNum := int32(wire >> 3)
+				if fieldNum == 1 {
+					var stringLenmapkey uint64
+					for shift := uint(0); ; shift += 7 {
+						if shift >= 64 {
+							return ErrIntOverflowVirtualService
+						}
+						if iNdEx >= l {
+							return io.ErrUnexpectedEOF
+						}
+						b := dAtA[iNdEx]
+						iNdEx++
+						stringLenmapkey |= uint64(b&0x7F) << shift
+						if b < 0x80 {
+							break
+						}
+					}
+					intStringLenmapkey := int(stringLenmapkey)
+					if intStringLenmapkey < 0 {
+						return ErrInvalidLengthVirtualService
+					}
+					postStringIndexmapkey := iNdEx + intStringLenmapkey
+					if postStringIndexmapkey < 0 {
+						return ErrInvalidLengthVirtualService
+					}
+					if postStringIndexmapkey > l {
+						return io.ErrUnexpectedEOF
+					}
+					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
+					iNdEx = postStringIndexmapkey
+				} else if fieldNum == 2 {
+					var mapmsglen int
+					for shift := uint(0); ; shift += 7 {
+						if shift >= 64 {
+							return ErrIntOverflowVirtualService
+						}
+						if iNdEx >= l {
+							return io.ErrUnexpectedEOF
+						}
+						b := dAtA[iNdEx]
+						iNdEx++
+						mapmsglen |= int(b&0x7F) << shift
+						if b < 0x80 {
+							break
+						}
+					}
+					if mapmsglen < 0 {
+						return ErrInvalidLengthVirtualService
+					}
+					postmsgIndex := iNdEx + mapmsglen
+					if postmsgIndex < 0 {
+						return ErrInvalidLengthVirtualService
+					}
+					if postmsgIndex > l {
+						return io.ErrUnexpectedEOF
+					}
+					mapvalue = &StringMatch{}
+					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
+						return err
+					}
+					iNdEx = postmsgIndex
+				} else {
+					iNdEx = entryPreIndex
+					skippy, err := skipVirtualService(dAtA[iNdEx:])
+					if err != nil {
+						return err
+					}
+					if (skippy < 0) || (iNdEx+skippy) < 0 {
+						return ErrInvalidLengthVirtualService
+					}
+					if (iNdEx + skippy) > postIndex {
+						return io.ErrUnexpectedEOF
+					}
+					iNdEx += skippy
 				}
 			}
-			if msglen < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			postIndex := iNdEx + msglen
-			if postIndex < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			if m.CorsPolicy == nil {
-				m.CorsPolicy = &CorsPolicy{}
-			}
-			if err := m.CorsPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
+			m.QueryParams[mapkey] = mapvalue
 			iNdEx = postIndex
-		case 16:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
+		case 10:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field IgnoreUriCase", wireType)
 			}
-			var msglen int
+			var v int
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowVirtualService
@@ -6992,29 +10626,13 @@ func (m *HTTPRoute) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				msglen |= int(b&0x7F) << shift
+				v |= int(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			if msglen < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			postIndex := iNdEx + msglen
-			if postIndex < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			if m.Headers == nil {
-				m.Headers = &Headers{}
-			}
-			if err := m.Headers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
-			iNdEx = postIndex
-		case 17:
+			m.IgnoreUriCase = bool(v != 0)
+		case 11:
 			if wireType != 2 {
 				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
 			}
@@ -7046,81 +10664,9 @@ func (m *HTTPRoute) Unmarshal(dAtA []byte) error {
 			}
 			m.Name = string(dAtA[iNdEx:postIndex])
 			iNdEx = postIndex
-		case 18:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field MirrorPercent", wireType)
-			}
-			var msglen int
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowVirtualService
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				msglen |= int(b&0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-			if msglen < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			postIndex := iNdEx + msglen
-			if postIndex < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			if m.MirrorPercent == nil {
-				m.MirrorPercent = &types.UInt32Value{}
-			}
-			if err := m.MirrorPercent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
-			iNdEx = postIndex
-		case 19:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field MirrorPercentage", wireType)
-			}
-			var msglen int
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowVirtualService
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				msglen |= int(b&0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-			if msglen < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			postIndex := iNdEx + msglen
-			if postIndex < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			if m.MirrorPercentage == nil {
-				m.MirrorPercentage = &Percent{}
-			}
-			if err := m.MirrorPercentage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
-			iNdEx = postIndex
-		case 20:
+		case 12:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Delegate", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field WithoutHeaders", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -7147,99 +10693,109 @@ func (m *HTTPRoute) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.Delegate == nil {
-				m.Delegate = &Delegate{}
-			}
-			if err := m.Delegate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
-			iNdEx = postIndex
-		default:
-			iNdEx = preIndex
-			skippy, err := skipVirtualService(dAtA[iNdEx:])
-			if err != nil {
-				return err
-			}
-			if (skippy < 0) || (iNdEx+skippy) < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			if (iNdEx + skippy) > l {
-				return io.ErrUnexpectedEOF
-			}
-			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
-			iNdEx += skippy
-		}
-	}
-
-	if iNdEx > l {
-		return io.ErrUnexpectedEOF
-	}
-	return nil
-}
-func (m *Delegate) Unmarshal(dAtA []byte) error {
-	l := len(dAtA)
-	iNdEx := 0
-	for iNdEx < l {
-		preIndex := iNdEx
-		var wire uint64
-		for shift := uint(0); ; shift += 7 {
-			if shift >= 64 {
-				return ErrIntOverflowVirtualService
-			}
-			if iNdEx >= l {
-				return io.ErrUnexpectedEOF
-			}
-			b := dAtA[iNdEx]
-			iNdEx++
-			wire |= uint64(b&0x7F) << shift
-			if b < 0x80 {
-				break
-			}
-		}
-		fieldNum := int32(wire >> 3)
-		wireType := int(wire & 0x7)
-		if wireType == 4 {
-			return fmt.Errorf("proto: Delegate: wiretype end group for non-group")
-		}
-		if fieldNum <= 0 {
-			return fmt.Errorf("proto: Delegate: illegal tag %d (wire type %d)", fieldNum, wire)
-		}
-		switch fieldNum {
-		case 1:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
+			if m.WithoutHeaders == nil {
+				m.WithoutHeaders = make(map[string]*StringMatch)
 			}
-			var stringLen uint64
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowVirtualService
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
+			var mapkey string
+			var mapvalue *StringMatch
+			for iNdEx < postIndex {
+				entryPreIndex := iNdEx
+				var wire uint64
+				for shift := uint(0); ; shift += 7 {
+					if shift >= 64 {
+						return ErrIntOverflowVirtualService
+					}
+					if iNdEx >= l {
+						return io.ErrUnexpectedEOF
+					}
+					b := dAtA[iNdEx]
+					iNdEx++
+					wire |= uint64(b&0x7F) << shift
+					if b < 0x80 {
+						break
+					}
 				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				stringLen |= uint64(b&0x7F) << shift
-				if b < 0x80 {
-					break
+				fieldNum := int32(wire >> 3)
+				if fieldNum == 1 {
+					var stringLenmapkey uint64
+					for shift := uint(0); ; shift += 7 {
+						if shift >= 64 {
+							return ErrIntOverflowVirtualService
+						}
+						if iNdEx >= l {
+							return io.ErrUnexpectedEOF
+						}
+						b := dAtA[iNdEx]
+						iNdEx++
+						stringLenmapkey |= uint64(b&0x7F) << shift
+						if b < 0x80 {
+							break
+						}
+					}
+					intStringLenmapkey := int(stringLenmapkey)
+					if intStringLenmapkey < 0 {
+						return ErrInvalidLengthVirtualService
+					}
+					postStringIndexmapkey := iNdEx + intStringLenmapkey
+					if postStringIndexmapkey < 0 {
+						return ErrInvalidLengthVirtualService
+					}
+					if postStringIndexmapkey > l {
+						return io.ErrUnexpectedEOF
+					}
+					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
+					iNdEx = postStringIndexmapkey
+				} else if fieldNum == 2 {
+					var mapmsglen int
+					for shift := uint(0); ; shift += 7 {
+						if shift >= 64 {
+							return ErrIntOverflowVirtualService
+						}
+						if iNdEx >= l {
+							return io.ErrUnexpectedEOF
+						}
+						b := dAtA[iNdEx]
+						iNdEx++
+						mapmsglen |= int(b&0x7F) << shift
+						if b < 0x80 {
+							break
+						}
+					}
+					if mapmsglen < 0 {
+						return ErrInvalidLengthVirtualService
+					}
+					postmsgIndex := iNdEx + mapmsglen
+					if postmsgIndex < 0 {
+						return ErrInvalidLengthVirtualService
+					}
+					if postmsgIndex > l {
+						return io.ErrUnexpectedEOF
+					}
+					mapvalue = &StringMatch{}
+					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
+						return err
+					}
+					iNdEx = postmsgIndex
+				} else {
+					iNdEx = entryPreIndex
+					skippy, err := skipVirtualService(dAtA[iNdEx:])
+					if err != nil {
+						return err
+					}
+					if (skippy < 0) || (iNdEx+skippy) < 0 {
+						return ErrInvalidLengthVirtualService
+					}
+					if (iNdEx + skippy) > postIndex {
+						return io.ErrUnexpectedEOF
+					}
+					iNdEx += skippy
 				}
 			}
-			intStringLen := int(stringLen)
-			if intStringLen < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			postIndex := iNdEx + intStringLen
-			if postIndex < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			m.Name = string(dAtA[iNdEx:postIndex])
+			m.WithoutHeaders[mapkey] = mapvalue
 			iNdEx = postIndex
-		case 2:
+		case 13:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field SourceNamespace", wireType)
 			}
 			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
@@ -7267,7 +10823,7 @@ func (m *Delegate) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.Namespace = string(dAtA[iNdEx:postIndex])
+			m.SourceNamespace = string(dAtA[iNdEx:postIndex])
 			iNdEx = postIndex
 		default:
 			iNdEx = preIndex
@@ -7291,7 +10847,7 @@ func (m *Delegate) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
-func (m *Headers) Unmarshal(dAtA []byte) error {
+func (m *HTTPRouteDestination) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
 	for iNdEx < l {
@@ -7314,15 +10870,15 @@ func (m *Headers) Unmarshal(dAtA []byte) error {
 		fieldNum := int32(wire >> 3)
 		wireType := int(wire & 0x7)
 		if wireType == 4 {
-			return fmt.Errorf("proto: Headers: wiretype end group for non-group")
+			return fmt.Errorf("proto: HTTPRouteDestination: wiretype end group for non-group")
 		}
 		if fieldNum <= 0 {
-			return fmt.Errorf("proto: Headers: illegal tag %d (wire type %d)", fieldNum, wire)
+			return fmt.Errorf("proto: HTTPRouteDestination: illegal tag %d (wire type %d)", fieldNum, wire)
 		}
 		switch fieldNum {
 		case 1:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Destination", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -7349,18 +10905,18 @@ func (m *Headers) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.Request == nil {
-				m.Request = &Headers_HeaderOperations{}
+			if m.Destination == nil {
+				m.Destination = &Destination{}
 			}
-			if err := m.Request.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+			if err := m.Destination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
 			iNdEx = postIndex
 		case 2:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
 			}
-			var msglen int
+			m.Weight = 0
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowVirtualService
@@ -7370,82 +10926,14 @@ func (m *Headers) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				msglen |= int(b&0x7F) << shift
+				m.Weight |= int32(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			if msglen < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			postIndex := iNdEx + msglen
-			if postIndex < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			if m.Response == nil {
-				m.Response = &Headers_HeaderOperations{}
-			}
-			if err := m.Response.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
-			iNdEx = postIndex
-		default:
-			iNdEx = preIndex
-			skippy, err := skipVirtualService(dAtA[iNdEx:])
-			if err != nil {
-				return err
-			}
-			if (skippy < 0) || (iNdEx+skippy) < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			if (iNdEx + skippy) > l {
-				return io.ErrUnexpectedEOF
-			}
-			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
-			iNdEx += skippy
-		}
-	}
-
-	if iNdEx > l {
-		return io.ErrUnexpectedEOF
-	}
-	return nil
-}
-func (m *Headers_HeaderOperations) Unmarshal(dAtA []byte) error {
-	l := len(dAtA)
-	iNdEx := 0
-	for iNdEx < l {
-		preIndex := iNdEx
-		var wire uint64
-		for shift := uint(0); ; shift += 7 {
-			if shift >= 64 {
-				return ErrIntOverflowVirtualService
-			}
-			if iNdEx >= l {
-				return io.ErrUnexpectedEOF
-			}
-			b := dAtA[iNdEx]
-			iNdEx++
-			wire |= uint64(b&0x7F) << shift
-			if b < 0x80 {
-				break
-			}
-		}
-		fieldNum := int32(wire >> 3)
-		wireType := int(wire & 0x7)
-		if wireType == 4 {
-			return fmt.Errorf("proto: HeaderOperations: wiretype end group for non-group")
-		}
-		if fieldNum <= 0 {
-			return fmt.Errorf("proto: HeaderOperations: illegal tag %d (wire type %d)", fieldNum, wire)
-		}
-		switch fieldNum {
-		case 1:
+		case 7:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Set", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -7459,120 +10947,29 @@ func (m *Headers_HeaderOperations) Unmarshal(dAtA []byte) error {
 				iNdEx++
 				msglen |= int(b&0x7F) << shift
 				if b < 0x80 {
-					break
-				}
-			}
-			if msglen < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			postIndex := iNdEx + msglen
-			if postIndex < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			if m.Set == nil {
-				m.Set = make(map[string]string)
-			}
-			var mapkey string
-			var mapvalue string
-			for iNdEx < postIndex {
-				entryPreIndex := iNdEx
-				var wire uint64
-				for shift := uint(0); ; shift += 7 {
-					if shift >= 64 {
-						return ErrIntOverflowVirtualService
-					}
-					if iNdEx >= l {
-						return io.ErrUnexpectedEOF
-					}
-					b := dAtA[iNdEx]
-					iNdEx++
-					wire |= uint64(b&0x7F) << shift
-					if b < 0x80 {
-						break
-					}
-				}
-				fieldNum := int32(wire >> 3)
-				if fieldNum == 1 {
-					var stringLenmapkey uint64
-					for shift := uint(0); ; shift += 7 {
-						if shift >= 64 {
-							return ErrIntOverflowVirtualService
-						}
-						if iNdEx >= l {
-							return io.ErrUnexpectedEOF
-						}
-						b := dAtA[iNdEx]
-						iNdEx++
-						stringLenmapkey |= uint64(b&0x7F) << shift
-						if b < 0x80 {
-							break
-						}
-					}
-					intStringLenmapkey := int(stringLenmapkey)
-					if intStringLenmapkey < 0 {
-						return ErrInvalidLengthVirtualService
-					}
-					postStringIndexmapkey := iNdEx + intStringLenmapkey
-					if postStringIndexmapkey < 0 {
-						return ErrInvalidLengthVirtualService
-					}
-					if postStringIndexmapkey > l {
-						return io.ErrUnexpectedEOF
-					}
-					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
-					iNdEx = postStringIndexmapkey
-				} else if fieldNum == 2 {
-					var stringLenmapvalue uint64
-					for shift := uint(0); ; shift += 7 {
-						if shift >= 64 {
-							return ErrIntOverflowVirtualService
-						}
-						if iNdEx >= l {
-							return io.ErrUnexpectedEOF
-						}
-						b := dAtA[iNdEx]
-						iNdEx++
-						stringLenmapvalue |= uint64(b&0x7F) << shift
-						if b < 0x80 {
-							break
-						}
-					}
-					intStringLenmapvalue := int(stringLenmapvalue)
-					if intStringLenmapvalue < 0 {
-						return ErrInvalidLengthVirtualService
-					}
-					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
-					if postStringIndexmapvalue < 0 {
-						return ErrInvalidLengthVirtualService
-					}
-					if postStringIndexmapvalue > l {
-						return io.ErrUnexpectedEOF
-					}
-					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
-					iNdEx = postStringIndexmapvalue
-				} else {
-					iNdEx = entryPreIndex
-					skippy, err := skipVirtualService(dAtA[iNdEx:])
-					if err != nil {
-						return err
-					}
-					if (skippy < 0) || (iNdEx+skippy) < 0 {
-						return ErrInvalidLengthVirtualService
-					}
-					if (iNdEx + skippy) > postIndex {
-						return io.ErrUnexpectedEOF
-					}
-					iNdEx += skippy
+					break
 				}
 			}
-			m.Set[mapkey] = mapvalue
+			if msglen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.Headers == nil {
+				m.Headers = &Headers{}
+			}
+			if err := m.Headers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
 			iNdEx = postIndex
-		case 2:
+		case 100:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Add", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field FallbackClusters", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -7599,109 +10996,67 @@ func (m *Headers_HeaderOperations) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.Add == nil {
-				m.Add = make(map[string]string)
-			}
-			var mapkey string
-			var mapvalue string
-			for iNdEx < postIndex {
-				entryPreIndex := iNdEx
-				var wire uint64
-				for shift := uint(0); ; shift += 7 {
-					if shift >= 64 {
-						return ErrIntOverflowVirtualService
-					}
-					if iNdEx >= l {
-						return io.ErrUnexpectedEOF
-					}
-					b := dAtA[iNdEx]
-					iNdEx++
-					wire |= uint64(b&0x7F) << shift
-					if b < 0x80 {
-						break
-					}
-				}
-				fieldNum := int32(wire >> 3)
-				if fieldNum == 1 {
-					var stringLenmapkey uint64
-					for shift := uint(0); ; shift += 7 {
-						if shift >= 64 {
-							return ErrIntOverflowVirtualService
-						}
-						if iNdEx >= l {
-							return io.ErrUnexpectedEOF
-						}
-						b := dAtA[iNdEx]
-						iNdEx++
-						stringLenmapkey |= uint64(b&0x7F) << shift
-						if b < 0x80 {
-							break
-						}
-					}
-					intStringLenmapkey := int(stringLenmapkey)
-					if intStringLenmapkey < 0 {
-						return ErrInvalidLengthVirtualService
-					}
-					postStringIndexmapkey := iNdEx + intStringLenmapkey
-					if postStringIndexmapkey < 0 {
-						return ErrInvalidLengthVirtualService
-					}
-					if postStringIndexmapkey > l {
-						return io.ErrUnexpectedEOF
-					}
-					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
-					iNdEx = postStringIndexmapkey
-				} else if fieldNum == 2 {
-					var stringLenmapvalue uint64
-					for shift := uint(0); ; shift += 7 {
-						if shift >= 64 {
-							return ErrIntOverflowVirtualService
-						}
-						if iNdEx >= l {
-							return io.ErrUnexpectedEOF
-						}
-						b := dAtA[iNdEx]
-						iNdEx++
-						stringLenmapvalue |= uint64(b&0x7F) << shift
-						if b < 0x80 {
-							break
-						}
-					}
-					intStringLenmapvalue := int(stringLenmapvalue)
-					if intStringLenmapvalue < 0 {
-						return ErrInvalidLengthVirtualService
-					}
-					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
-					if postStringIndexmapvalue < 0 {
-						return ErrInvalidLengthVirtualService
-					}
-					if postStringIndexmapvalue > l {
-						return io.ErrUnexpectedEOF
-					}
-					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
-					iNdEx = postStringIndexmapvalue
-				} else {
-					iNdEx = entryPreIndex
-					skippy, err := skipVirtualService(dAtA[iNdEx:])
-					if err != nil {
-						return err
-					}
-					if (skippy < 0) || (iNdEx+skippy) < 0 {
-						return ErrInvalidLengthVirtualService
-					}
-					if (iNdEx + skippy) > postIndex {
-						return io.ErrUnexpectedEOF
-					}
-					iNdEx += skippy
-				}
+			m.FallbackClusters = append(m.FallbackClusters, &Destination{})
+			if err := m.FallbackClusters[len(m.FallbackClusters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
 			}
-			m.Add[mapkey] = mapvalue
 			iNdEx = postIndex
-		case 3:
+		default:
+			iNdEx = preIndex
+			skippy, err := skipVirtualService(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *RouteDestination) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowVirtualService
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: RouteDestination: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: RouteDestination: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Remove", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Destination", wireType)
 			}
-			var stringLen uint64
+			var msglen int
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowVirtualService
@@ -7711,24 +11066,47 @@ func (m *Headers_HeaderOperations) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				stringLen |= uint64(b&0x7F) << shift
+				msglen |= int(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			intStringLen := int(stringLen)
-			if intStringLen < 0 {
+			if msglen < 0 {
 				return ErrInvalidLengthVirtualService
 			}
-			postIndex := iNdEx + intStringLen
+			postIndex := iNdEx + msglen
 			if postIndex < 0 {
 				return ErrInvalidLengthVirtualService
 			}
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.Remove = append(m.Remove, string(dAtA[iNdEx:postIndex]))
+			if m.Destination == nil {
+				m.Destination = &Destination{}
+			}
+			if err := m.Destination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
 			iNdEx = postIndex
+		case 2:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
+			}
+			m.Weight = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.Weight |= int32(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
 		default:
 			iNdEx = preIndex
 			skippy, err := skipVirtualService(dAtA[iNdEx:])
@@ -7751,7 +11129,7 @@ func (m *Headers_HeaderOperations) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
-func (m *TLSRoute) Unmarshal(dAtA []byte) error {
+func (m *L4MatchAttributes) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
 	for iNdEx < l {
@@ -7774,17 +11152,68 @@ func (m *TLSRoute) Unmarshal(dAtA []byte) error {
 		fieldNum := int32(wire >> 3)
 		wireType := int(wire & 0x7)
 		if wireType == 4 {
-			return fmt.Errorf("proto: TLSRoute: wiretype end group for non-group")
+			return fmt.Errorf("proto: L4MatchAttributes: wiretype end group for non-group")
 		}
 		if fieldNum <= 0 {
-			return fmt.Errorf("proto: TLSRoute: illegal tag %d (wire type %d)", fieldNum, wire)
+			return fmt.Errorf("proto: L4MatchAttributes: illegal tag %d (wire type %d)", fieldNum, wire)
 		}
 		switch fieldNum {
 		case 1:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Match", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field DestinationSubnets", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.DestinationSubnets = append(m.DestinationSubnets, string(dAtA[iNdEx:postIndex]))
+			iNdEx = postIndex
+		case 2:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
+			}
+			m.Port = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.Port |= uint32(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		case 3:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field SourceSubnet", wireType)
 			}
-			var msglen int
+			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowVirtualService
@@ -7794,29 +11223,27 @@ func (m *TLSRoute) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				msglen |= int(b&0x7F) << shift
+				stringLen |= uint64(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			if msglen < 0 {
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
 				return ErrInvalidLengthVirtualService
 			}
-			postIndex := iNdEx + msglen
+			postIndex := iNdEx + intStringLen
 			if postIndex < 0 {
 				return ErrInvalidLengthVirtualService
 			}
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.Match = append(m.Match, &TLSMatchAttributes{})
-			if err := m.Match[len(m.Match)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
+			m.SourceSubnet = string(dAtA[iNdEx:postIndex])
 			iNdEx = postIndex
-		case 2:
+		case 4:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Route", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field SourceLabels", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -7843,67 +11270,109 @@ func (m *TLSRoute) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.Route = append(m.Route, &RouteDestination{})
-			if err := m.Route[len(m.Route)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
-			iNdEx = postIndex
-		default:
-			iNdEx = preIndex
-			skippy, err := skipVirtualService(dAtA[iNdEx:])
-			if err != nil {
-				return err
-			}
-			if (skippy < 0) || (iNdEx+skippy) < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			if (iNdEx + skippy) > l {
-				return io.ErrUnexpectedEOF
-			}
-			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
-			iNdEx += skippy
-		}
-	}
-
-	if iNdEx > l {
-		return io.ErrUnexpectedEOF
-	}
-	return nil
-}
-func (m *TCPRoute) Unmarshal(dAtA []byte) error {
-	l := len(dAtA)
-	iNdEx := 0
-	for iNdEx < l {
-		preIndex := iNdEx
-		var wire uint64
-		for shift := uint(0); ; shift += 7 {
-			if shift >= 64 {
-				return ErrIntOverflowVirtualService
-			}
-			if iNdEx >= l {
-				return io.ErrUnexpectedEOF
+			if m.SourceLabels == nil {
+				m.SourceLabels = make(map[string]string)
 			}
-			b := dAtA[iNdEx]
-			iNdEx++
-			wire |= uint64(b&0x7F) << shift
-			if b < 0x80 {
-				break
+			var mapkey string
+			var mapvalue string
+			for iNdEx < postIndex {
+				entryPreIndex := iNdEx
+				var wire uint64
+				for shift := uint(0); ; shift += 7 {
+					if shift >= 64 {
+						return ErrIntOverflowVirtualService
+					}
+					if iNdEx >= l {
+						return io.ErrUnexpectedEOF
+					}
+					b := dAtA[iNdEx]
+					iNdEx++
+					wire |= uint64(b&0x7F) << shift
+					if b < 0x80 {
+						break
+					}
+				}
+				fieldNum := int32(wire >> 3)
+				if fieldNum == 1 {
+					var stringLenmapkey uint64
+					for shift := uint(0); ; shift += 7 {
+						if shift >= 64 {
+							return ErrIntOverflowVirtualService
+						}
+						if iNdEx >= l {
+							return io.ErrUnexpectedEOF
+						}
+						b := dAtA[iNdEx]
+						iNdEx++
+						stringLenmapkey |= uint64(b&0x7F) << shift
+						if b < 0x80 {
+							break
+						}
+					}
+					intStringLenmapkey := int(stringLenmapkey)
+					if intStringLenmapkey < 0 {
+						return ErrInvalidLengthVirtualService
+					}
+					postStringIndexmapkey := iNdEx + intStringLenmapkey
+					if postStringIndexmapkey < 0 {
+						return ErrInvalidLengthVirtualService
+					}
+					if postStringIndexmapkey > l {
+						return io.ErrUnexpectedEOF
+					}
+					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
+					iNdEx = postStringIndexmapkey
+				} else if fieldNum == 2 {
+					var stringLenmapvalue uint64
+					for shift := uint(0); ; shift += 7 {
+						if shift >= 64 {
+							return ErrIntOverflowVirtualService
+						}
+						if iNdEx >= l {
+							return io.ErrUnexpectedEOF
+						}
+						b := dAtA[iNdEx]
+						iNdEx++
+						stringLenmapvalue |= uint64(b&0x7F) << shift
+						if b < 0x80 {
+							break
+						}
+					}
+					intStringLenmapvalue := int(stringLenmapvalue)
+					if intStringLenmapvalue < 0 {
+						return ErrInvalidLengthVirtualService
+					}
+					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
+					if postStringIndexmapvalue < 0 {
+						return ErrInvalidLengthVirtualService
+					}
+					if postStringIndexmapvalue > l {
+						return io.ErrUnexpectedEOF
+					}
+					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
+					iNdEx = postStringIndexmapvalue
+				} else {
+					iNdEx = entryPreIndex
+					skippy, err := skipVirtualService(dAtA[iNdEx:])
+					if err != nil {
+						return err
+					}
+					if (skippy < 0) || (iNdEx+skippy) < 0 {
+						return ErrInvalidLengthVirtualService
+					}
+					if (iNdEx + skippy) > postIndex {
+						return io.ErrUnexpectedEOF
+					}
+					iNdEx += skippy
+				}
 			}
-		}
-		fieldNum := int32(wire >> 3)
-		wireType := int(wire & 0x7)
-		if wireType == 4 {
-			return fmt.Errorf("proto: TCPRoute: wiretype end group for non-group")
-		}
-		if fieldNum <= 0 {
-			return fmt.Errorf("proto: TCPRoute: illegal tag %d (wire type %d)", fieldNum, wire)
-		}
-		switch fieldNum {
-		case 1:
+			m.SourceLabels[mapkey] = mapvalue
+			iNdEx = postIndex
+		case 5:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Match", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Gateways", wireType)
 			}
-			var msglen int
+			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowVirtualService
@@ -7913,31 +11382,29 @@ func (m *TCPRoute) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				msglen |= int(b&0x7F) << shift
+				stringLen |= uint64(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			if msglen < 0 {
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
 				return ErrInvalidLengthVirtualService
 			}
-			postIndex := iNdEx + msglen
+			postIndex := iNdEx + intStringLen
 			if postIndex < 0 {
 				return ErrInvalidLengthVirtualService
 			}
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.Match = append(m.Match, &L4MatchAttributes{})
-			if err := m.Match[len(m.Match)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
+			m.Gateways = append(m.Gateways, string(dAtA[iNdEx:postIndex]))
 			iNdEx = postIndex
-		case 2:
+		case 6:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Route", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field SourceNamespace", wireType)
 			}
-			var msglen int
+			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowVirtualService
@@ -7947,25 +11414,23 @@ func (m *TCPRoute) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				msglen |= int(b&0x7F) << shift
+				stringLen |= uint64(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			if msglen < 0 {
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
 				return ErrInvalidLengthVirtualService
 			}
-			postIndex := iNdEx + msglen
+			postIndex := iNdEx + intStringLen
 			if postIndex < 0 {
 				return ErrInvalidLengthVirtualService
 			}
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.Route = append(m.Route, &RouteDestination{})
-			if err := m.Route[len(m.Route)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
+			m.SourceNamespace = string(dAtA[iNdEx:postIndex])
 			iNdEx = postIndex
 		default:
 			iNdEx = preIndex
@@ -7989,7 +11454,7 @@ func (m *TCPRoute) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
-func (m *HTTPMatchRequest) Unmarshal(dAtA []byte) error {
+func (m *TLSMatchAttributes) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
 	for iNdEx < l {
@@ -8012,53 +11477,17 @@ func (m *HTTPMatchRequest) Unmarshal(dAtA []byte) error {
 		fieldNum := int32(wire >> 3)
 		wireType := int(wire & 0x7)
 		if wireType == 4 {
-			return fmt.Errorf("proto: HTTPMatchRequest: wiretype end group for non-group")
+			return fmt.Errorf("proto: TLSMatchAttributes: wiretype end group for non-group")
 		}
 		if fieldNum <= 0 {
-			return fmt.Errorf("proto: HTTPMatchRequest: illegal tag %d (wire type %d)", fieldNum, wire)
+			return fmt.Errorf("proto: TLSMatchAttributes: illegal tag %d (wire type %d)", fieldNum, wire)
 		}
 		switch fieldNum {
 		case 1:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
-			}
-			var msglen int
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowVirtualService
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				msglen |= int(b&0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-			if msglen < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			postIndex := iNdEx + msglen
-			if postIndex < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			if m.Uri == nil {
-				m.Uri = &StringMatch{}
-			}
-			if err := m.Uri.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
-			iNdEx = postIndex
-		case 2:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Scheme", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field SniHosts", wireType)
 			}
-			var msglen int
+			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowVirtualService
@@ -8068,33 +11497,29 @@ func (m *HTTPMatchRequest) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				msglen |= int(b&0x7F) << shift
+				stringLen |= uint64(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			if msglen < 0 {
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
 				return ErrInvalidLengthVirtualService
 			}
-			postIndex := iNdEx + msglen
+			postIndex := iNdEx + intStringLen
 			if postIndex < 0 {
 				return ErrInvalidLengthVirtualService
 			}
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.Scheme == nil {
-				m.Scheme = &StringMatch{}
-			}
-			if err := m.Scheme.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
+			m.SniHosts = append(m.SniHosts, string(dAtA[iNdEx:postIndex]))
 			iNdEx = postIndex
-		case 3:
+		case 2:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field DestinationSubnets", wireType)
 			}
-			var msglen int
+			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowVirtualService
@@ -8104,33 +11529,29 @@ func (m *HTTPMatchRequest) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				msglen |= int(b&0x7F) << shift
+				stringLen |= uint64(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			if msglen < 0 {
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
 				return ErrInvalidLengthVirtualService
 			}
-			postIndex := iNdEx + msglen
+			postIndex := iNdEx + intStringLen
 			if postIndex < 0 {
 				return ErrInvalidLengthVirtualService
 			}
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.Method == nil {
-				m.Method = &StringMatch{}
-			}
-			if err := m.Method.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
+			m.DestinationSubnets = append(m.DestinationSubnets, string(dAtA[iNdEx:postIndex]))
 			iNdEx = postIndex
-		case 4:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
+		case 3:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
 			}
-			var msglen int
+			m.Port = 0
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowVirtualService
@@ -8140,31 +11561,14 @@ func (m *HTTPMatchRequest) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				msglen |= int(b&0x7F) << shift
+				m.Port |= uint32(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			if msglen < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			postIndex := iNdEx + msglen
-			if postIndex < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			if m.Authority == nil {
-				m.Authority = &StringMatch{}
-			}
-			if err := m.Authority.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
-			iNdEx = postIndex
 		case 5:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field SourceLabels", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -8191,11 +11595,11 @@ func (m *HTTPMatchRequest) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.Headers == nil {
-				m.Headers = make(map[string]*StringMatch)
+			if m.SourceLabels == nil {
+				m.SourceLabels = make(map[string]string)
 			}
 			var mapkey string
-			var mapvalue *StringMatch
+			var mapvalue string
 			for iNdEx < postIndex {
 				entryPreIndex := iNdEx
 				var wire uint64
@@ -8244,7 +11648,7 @@ func (m *HTTPMatchRequest) Unmarshal(dAtA []byte) error {
 					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
 					iNdEx = postStringIndexmapkey
 				} else if fieldNum == 2 {
-					var mapmsglen int
+					var stringLenmapvalue uint64
 					for shift := uint(0); ; shift += 7 {
 						if shift >= 64 {
 							return ErrIntOverflowVirtualService
@@ -8254,26 +11658,24 @@ func (m *HTTPMatchRequest) Unmarshal(dAtA []byte) error {
 						}
 						b := dAtA[iNdEx]
 						iNdEx++
-						mapmsglen |= int(b&0x7F) << shift
+						stringLenmapvalue |= uint64(b&0x7F) << shift
 						if b < 0x80 {
 							break
 						}
 					}
-					if mapmsglen < 0 {
+					intStringLenmapvalue := int(stringLenmapvalue)
+					if intStringLenmapvalue < 0 {
 						return ErrInvalidLengthVirtualService
 					}
-					postmsgIndex := iNdEx + mapmsglen
-					if postmsgIndex < 0 {
+					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
+					if postStringIndexmapvalue < 0 {
 						return ErrInvalidLengthVirtualService
 					}
-					if postmsgIndex > l {
+					if postStringIndexmapvalue > l {
 						return io.ErrUnexpectedEOF
 					}
-					mapvalue = &StringMatch{}
-					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
-						return err
-					}
-					iNdEx = postmsgIndex
+					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
+					iNdEx = postStringIndexmapvalue
 				} else {
 					iNdEx = entryPreIndex
 					skippy, err := skipVirtualService(dAtA[iNdEx:])
@@ -8289,13 +11691,211 @@ func (m *HTTPMatchRequest) Unmarshal(dAtA []byte) error {
 					iNdEx += skippy
 				}
 			}
-			m.Headers[mapkey] = mapvalue
+			m.SourceLabels[mapkey] = mapvalue
+			iNdEx = postIndex
+		case 6:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Gateways", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Gateways = append(m.Gateways, string(dAtA[iNdEx:postIndex]))
+			iNdEx = postIndex
+		case 7:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field SourceNamespace", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.SourceNamespace = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipVirtualService(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *HTTPRedirect) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowVirtualService
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: HTTPRedirect: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: HTTPRedirect: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Uri = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Authority = string(dAtA[iNdEx:postIndex])
 			iNdEx = postIndex
-		case 6:
+		case 3:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field RedirectCode", wireType)
+			}
+			m.RedirectCode = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.RedirectCode |= uint32(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		case 4:
 			if wireType != 0 {
 				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
 			}
-			m.Port = 0
+			var v uint32
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowVirtualService
@@ -8305,16 +11905,37 @@ func (m *HTTPMatchRequest) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				m.Port |= uint32(b&0x7F) << shift
+				v |= uint32(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-		case 7:
+			m.RedirectPort = &HTTPRedirect_Port{v}
+		case 5:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field DerivePort", wireType)
+			}
+			var v HTTPRedirect_RedirectPortSelection
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				v |= HTTPRedirect_RedirectPortSelection(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			m.RedirectPort = &HTTPRedirect_DerivePort{v}
+		case 6:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field SourceLabels", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Scheme", wireType)
 			}
-			var msglen int
+			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowVirtualService
@@ -8324,29 +11945,97 @@ func (m *HTTPMatchRequest) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				msglen |= int(b&0x7F) << shift
+				stringLen |= uint64(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			if msglen < 0 {
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
 				return ErrInvalidLengthVirtualService
 			}
-			postIndex := iNdEx + msglen
+			postIndex := iNdEx + intStringLen
 			if postIndex < 0 {
 				return ErrInvalidLengthVirtualService
 			}
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.SourceLabels == nil {
-				m.SourceLabels = make(map[string]string)
+			m.Scheme = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipVirtualService(dAtA[iNdEx:])
+			if err != nil {
+				return err
 			}
-			var mapkey string
-			var mapvalue string
-			for iNdEx < postIndex {
-				entryPreIndex := iNdEx
-				var wire uint64
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *HTTPInternalActiveRedirect) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowVirtualService
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: HTTPInternalActiveRedirect: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: HTTPInternalActiveRedirect: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field MaxInternalRedirects", wireType)
+			}
+			m.MaxInternalRedirects = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.MaxInternalRedirects |= uint32(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		case 2:
+			if wireType == 0 {
+				var v uint32
 				for shift := uint(0); ; shift += 7 {
 					if shift >= 64 {
 						return ErrIntOverflowVirtualService
@@ -8356,43 +12045,51 @@ func (m *HTTPMatchRequest) Unmarshal(dAtA []byte) error {
 					}
 					b := dAtA[iNdEx]
 					iNdEx++
-					wire |= uint64(b&0x7F) << shift
+					v |= uint32(b&0x7F) << shift
 					if b < 0x80 {
 						break
 					}
 				}
-				fieldNum := int32(wire >> 3)
-				if fieldNum == 1 {
-					var stringLenmapkey uint64
-					for shift := uint(0); ; shift += 7 {
-						if shift >= 64 {
-							return ErrIntOverflowVirtualService
-						}
-						if iNdEx >= l {
-							return io.ErrUnexpectedEOF
-						}
-						b := dAtA[iNdEx]
-						iNdEx++
-						stringLenmapkey |= uint64(b&0x7F) << shift
-						if b < 0x80 {
-							break
-						}
+				m.RedirectResponseCodes = append(m.RedirectResponseCodes, v)
+			} else if wireType == 2 {
+				var packedLen int
+				for shift := uint(0); ; shift += 7 {
+					if shift >= 64 {
+						return ErrIntOverflowVirtualService
 					}
-					intStringLenmapkey := int(stringLenmapkey)
-					if intStringLenmapkey < 0 {
-						return ErrInvalidLengthVirtualService
+					if iNdEx >= l {
+						return io.ErrUnexpectedEOF
 					}
-					postStringIndexmapkey := iNdEx + intStringLenmapkey
-					if postStringIndexmapkey < 0 {
-						return ErrInvalidLengthVirtualService
+					b := dAtA[iNdEx]
+					iNdEx++
+					packedLen |= int(b&0x7F) << shift
+					if b < 0x80 {
+						break
 					}
-					if postStringIndexmapkey > l {
-						return io.ErrUnexpectedEOF
+				}
+				if packedLen < 0 {
+					return ErrInvalidLengthVirtualService
+				}
+				postIndex := iNdEx + packedLen
+				if postIndex < 0 {
+					return ErrInvalidLengthVirtualService
+				}
+				if postIndex > l {
+					return io.ErrUnexpectedEOF
+				}
+				var elementCount int
+				var count int
+				for _, integer := range dAtA[iNdEx:postIndex] {
+					if integer < 128 {
+						count++
 					}
-					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
-					iNdEx = postStringIndexmapkey
-				} else if fieldNum == 2 {
-					var stringLenmapvalue uint64
+				}
+				elementCount = count
+				if elementCount != 0 && len(m.RedirectResponseCodes) == 0 {
+					m.RedirectResponseCodes = make([]uint32, 0, elementCount)
+				}
+				for iNdEx < postIndex {
+					var v uint32
 					for shift := uint(0); ; shift += 7 {
 						if shift >= 64 {
 							return ErrIntOverflowVirtualService
@@ -8402,44 +12099,142 @@ func (m *HTTPMatchRequest) Unmarshal(dAtA []byte) error {
 						}
 						b := dAtA[iNdEx]
 						iNdEx++
-						stringLenmapvalue |= uint64(b&0x7F) << shift
+						v |= uint32(b&0x7F) << shift
 						if b < 0x80 {
 							break
 						}
 					}
-					intStringLenmapvalue := int(stringLenmapvalue)
-					if intStringLenmapvalue < 0 {
-						return ErrInvalidLengthVirtualService
-					}
-					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
-					if postStringIndexmapvalue < 0 {
-						return ErrInvalidLengthVirtualService
-					}
-					if postStringIndexmapvalue > l {
-						return io.ErrUnexpectedEOF
-					}
-					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
-					iNdEx = postStringIndexmapvalue
-				} else {
-					iNdEx = entryPreIndex
-					skippy, err := skipVirtualService(dAtA[iNdEx:])
-					if err != nil {
-						return err
-					}
-					if (skippy < 0) || (iNdEx+skippy) < 0 {
-						return ErrInvalidLengthVirtualService
-					}
-					if (iNdEx + skippy) > postIndex {
-						return io.ErrUnexpectedEOF
-					}
-					iNdEx += skippy
+					m.RedirectResponseCodes = append(m.RedirectResponseCodes, v)
+				}
+			} else {
+				return fmt.Errorf("proto: wrong wireType = %d for field RedirectResponseCodes", wireType)
+			}
+		case 3:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field RedirectUrl", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.RedirectUrlRewriteSpecifier = &HTTPInternalActiveRedirect_RedirectUrl{string(dAtA[iNdEx:postIndex])}
+			iNdEx = postIndex
+		case 4:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field RedirectUrlRewriteRegex", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
 				}
 			}
-			m.SourceLabels[mapkey] = mapvalue
+			if msglen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			v := &RegexMatchAndSubstitute{}
+			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			m.RedirectUrlRewriteSpecifier = &HTTPInternalActiveRedirect_RedirectUrlRewriteRegex{v}
 			iNdEx = postIndex
-		case 8:
+		case 5:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field AllowCrossScheme", wireType)
+			}
+			var v int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				v |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			m.AllowCrossScheme = bool(v != 0)
+		case 6:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Gateways", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.Headers == nil {
+				m.Headers = &Headers{}
+			}
+			if err := m.Headers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 7:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
 			}
 			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
@@ -8467,11 +12262,11 @@ func (m *HTTPMatchRequest) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.Gateways = append(m.Gateways, string(dAtA[iNdEx:postIndex]))
+			m.Authority = string(dAtA[iNdEx:postIndex])
 			iNdEx = postIndex
-		case 9:
+		case 15:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field QueryParams", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Policies", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -8498,109 +12293,14 @@ func (m *HTTPMatchRequest) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.QueryParams == nil {
-				m.QueryParams = make(map[string]*StringMatch)
-			}
-			var mapkey string
-			var mapvalue *StringMatch
-			for iNdEx < postIndex {
-				entryPreIndex := iNdEx
-				var wire uint64
-				for shift := uint(0); ; shift += 7 {
-					if shift >= 64 {
-						return ErrIntOverflowVirtualService
-					}
-					if iNdEx >= l {
-						return io.ErrUnexpectedEOF
-					}
-					b := dAtA[iNdEx]
-					iNdEx++
-					wire |= uint64(b&0x7F) << shift
-					if b < 0x80 {
-						break
-					}
-				}
-				fieldNum := int32(wire >> 3)
-				if fieldNum == 1 {
-					var stringLenmapkey uint64
-					for shift := uint(0); ; shift += 7 {
-						if shift >= 64 {
-							return ErrIntOverflowVirtualService
-						}
-						if iNdEx >= l {
-							return io.ErrUnexpectedEOF
-						}
-						b := dAtA[iNdEx]
-						iNdEx++
-						stringLenmapkey |= uint64(b&0x7F) << shift
-						if b < 0x80 {
-							break
-						}
-					}
-					intStringLenmapkey := int(stringLenmapkey)
-					if intStringLenmapkey < 0 {
-						return ErrInvalidLengthVirtualService
-					}
-					postStringIndexmapkey := iNdEx + intStringLenmapkey
-					if postStringIndexmapkey < 0 {
-						return ErrInvalidLengthVirtualService
-					}
-					if postStringIndexmapkey > l {
-						return io.ErrUnexpectedEOF
-					}
-					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
-					iNdEx = postStringIndexmapkey
-				} else if fieldNum == 2 {
-					var mapmsglen int
-					for shift := uint(0); ; shift += 7 {
-						if shift >= 64 {
-							return ErrIntOverflowVirtualService
-						}
-						if iNdEx >= l {
-							return io.ErrUnexpectedEOF
-						}
-						b := dAtA[iNdEx]
-						iNdEx++
-						mapmsglen |= int(b&0x7F) << shift
-						if b < 0x80 {
-							break
-						}
-					}
-					if mapmsglen < 0 {
-						return ErrInvalidLengthVirtualService
-					}
-					postmsgIndex := iNdEx + mapmsglen
-					if postmsgIndex < 0 {
-						return ErrInvalidLengthVirtualService
-					}
-					if postmsgIndex > l {
-						return io.ErrUnexpectedEOF
-					}
-					mapvalue = &StringMatch{}
-					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
-						return err
-					}
-					iNdEx = postmsgIndex
-				} else {
-					iNdEx = entryPreIndex
-					skippy, err := skipVirtualService(dAtA[iNdEx:])
-					if err != nil {
-						return err
-					}
-					if (skippy < 0) || (iNdEx+skippy) < 0 {
-						return ErrInvalidLengthVirtualService
-					}
-					if (iNdEx + skippy) > postIndex {
-						return io.ErrUnexpectedEOF
-					}
-					iNdEx += skippy
-				}
+			m.Policies = append(m.Policies, &HTTPInternalActiveRedirect_RedirectPolicy{})
+			if err := m.Policies[len(m.Policies)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
 			}
-			m.QueryParams[mapkey] = mapvalue
 			iNdEx = postIndex
-		case 10:
+		case 16:
 			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field IgnoreUriCase", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field ForcedUseOriginalHost", wireType)
 			}
 			var v int
 			for shift := uint(0); ; shift += 7 {
@@ -8617,12 +12317,12 @@ func (m *HTTPMatchRequest) Unmarshal(dAtA []byte) error {
 					break
 				}
 			}
-			m.IgnoreUriCase = bool(v != 0)
-		case 11:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
+			m.ForcedUseOriginalHost = bool(v != 0)
+		case 17:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field ForcedAddHeaderBeforeRouteMatcher", wireType)
 			}
-			var stringLen uint64
+			var v int
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowVirtualService
@@ -8632,29 +12332,68 @@ func (m *HTTPMatchRequest) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				stringLen |= uint64(b&0x7F) << shift
+				v |= int(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			intStringLen := int(stringLen)
-			if intStringLen < 0 {
-				return ErrInvalidLengthVirtualService
+			m.ForcedAddHeaderBeforeRouteMatcher = bool(v != 0)
+		default:
+			iNdEx = preIndex
+			skippy, err := skipVirtualService(dAtA[iNdEx:])
+			if err != nil {
+				return err
 			}
-			postIndex := iNdEx + intStringLen
-			if postIndex < 0 {
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
 				return ErrInvalidLengthVirtualService
 			}
-			if postIndex > l {
+			if (iNdEx + skippy) > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.Name = string(dAtA[iNdEx:postIndex])
-			iNdEx = postIndex
-		case 12:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field WithoutHeaders", wireType)
+			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *HTTPInternalActiveRedirect_RedirectPolicy) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowVirtualService
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: RedirectPolicy: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: RedirectPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 8:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field MaxInternalRedirects", wireType)
 			}
-			var msglen int
+			m.MaxInternalRedirects = 0
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowVirtualService
@@ -8664,29 +12403,14 @@ func (m *HTTPMatchRequest) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				msglen |= int(b&0x7F) << shift
+				m.MaxInternalRedirects |= uint32(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			if msglen < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			postIndex := iNdEx + msglen
-			if postIndex < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			if m.WithoutHeaders == nil {
-				m.WithoutHeaders = make(map[string]*StringMatch)
-			}
-			var mapkey string
-			var mapvalue *StringMatch
-			for iNdEx < postIndex {
-				entryPreIndex := iNdEx
-				var wire uint64
+		case 9:
+			if wireType == 0 {
+				var v uint32
 				for shift := uint(0); ; shift += 7 {
 					if shift >= 64 {
 						return ErrIntOverflowVirtualService
@@ -8696,43 +12420,51 @@ func (m *HTTPMatchRequest) Unmarshal(dAtA []byte) error {
 					}
 					b := dAtA[iNdEx]
 					iNdEx++
-					wire |= uint64(b&0x7F) << shift
+					v |= uint32(b&0x7F) << shift
 					if b < 0x80 {
 						break
 					}
 				}
-				fieldNum := int32(wire >> 3)
-				if fieldNum == 1 {
-					var stringLenmapkey uint64
-					for shift := uint(0); ; shift += 7 {
-						if shift >= 64 {
-							return ErrIntOverflowVirtualService
-						}
-						if iNdEx >= l {
-							return io.ErrUnexpectedEOF
-						}
-						b := dAtA[iNdEx]
-						iNdEx++
-						stringLenmapkey |= uint64(b&0x7F) << shift
-						if b < 0x80 {
-							break
-						}
+				m.RedirectResponseCodes = append(m.RedirectResponseCodes, v)
+			} else if wireType == 2 {
+				var packedLen int
+				for shift := uint(0); ; shift += 7 {
+					if shift >= 64 {
+						return ErrIntOverflowVirtualService
 					}
-					intStringLenmapkey := int(stringLenmapkey)
-					if intStringLenmapkey < 0 {
-						return ErrInvalidLengthVirtualService
+					if iNdEx >= l {
+						return io.ErrUnexpectedEOF
 					}
-					postStringIndexmapkey := iNdEx + intStringLenmapkey
-					if postStringIndexmapkey < 0 {
-						return ErrInvalidLengthVirtualService
+					b := dAtA[iNdEx]
+					iNdEx++
+					packedLen |= int(b&0x7F) << shift
+					if b < 0x80 {
+						break
 					}
-					if postStringIndexmapkey > l {
-						return io.ErrUnexpectedEOF
+				}
+				if packedLen < 0 {
+					return ErrInvalidLengthVirtualService
+				}
+				postIndex := iNdEx + packedLen
+				if postIndex < 0 {
+					return ErrInvalidLengthVirtualService
+				}
+				if postIndex > l {
+					return io.ErrUnexpectedEOF
+				}
+				var elementCount int
+				var count int
+				for _, integer := range dAtA[iNdEx:postIndex] {
+					if integer < 128 {
+						count++
 					}
-					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
-					iNdEx = postStringIndexmapkey
-				} else if fieldNum == 2 {
-					var mapmsglen int
+				}
+				elementCount = count
+				if elementCount != 0 && len(m.RedirectResponseCodes) == 0 {
+					m.RedirectResponseCodes = make([]uint32, 0, elementCount)
+				}
+				for iNdEx < postIndex {
+					var v uint32
 					for shift := uint(0); ; shift += 7 {
 						if shift >= 64 {
 							return ErrIntOverflowVirtualService
@@ -8742,46 +12474,19 @@ func (m *HTTPMatchRequest) Unmarshal(dAtA []byte) error {
 						}
 						b := dAtA[iNdEx]
 						iNdEx++
-						mapmsglen |= int(b&0x7F) << shift
+						v |= uint32(b&0x7F) << shift
 						if b < 0x80 {
 							break
 						}
 					}
-					if mapmsglen < 0 {
-						return ErrInvalidLengthVirtualService
-					}
-					postmsgIndex := iNdEx + mapmsglen
-					if postmsgIndex < 0 {
-						return ErrInvalidLengthVirtualService
-					}
-					if postmsgIndex > l {
-						return io.ErrUnexpectedEOF
-					}
-					mapvalue = &StringMatch{}
-					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
-						return err
-					}
-					iNdEx = postmsgIndex
-				} else {
-					iNdEx = entryPreIndex
-					skippy, err := skipVirtualService(dAtA[iNdEx:])
-					if err != nil {
-						return err
-					}
-					if (skippy < 0) || (iNdEx+skippy) < 0 {
-						return ErrInvalidLengthVirtualService
-					}
-					if (iNdEx + skippy) > postIndex {
-						return io.ErrUnexpectedEOF
-					}
-					iNdEx += skippy
+					m.RedirectResponseCodes = append(m.RedirectResponseCodes, v)
 				}
+			} else {
+				return fmt.Errorf("proto: wrong wireType = %d for field RedirectResponseCodes", wireType)
 			}
-			m.WithoutHeaders[mapkey] = mapvalue
-			iNdEx = postIndex
-		case 13:
+		case 10:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field SourceNamespace", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field RedirectUrl", wireType)
 			}
 			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
@@ -8809,62 +12514,11 @@ func (m *HTTPMatchRequest) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.SourceNamespace = string(dAtA[iNdEx:postIndex])
+			m.RedirectUrlRewriteSpecifier = &HTTPInternalActiveRedirect_RedirectPolicy_RedirectUrl{string(dAtA[iNdEx:postIndex])}
 			iNdEx = postIndex
-		default:
-			iNdEx = preIndex
-			skippy, err := skipVirtualService(dAtA[iNdEx:])
-			if err != nil {
-				return err
-			}
-			if (skippy < 0) || (iNdEx+skippy) < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			if (iNdEx + skippy) > l {
-				return io.ErrUnexpectedEOF
-			}
-			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
-			iNdEx += skippy
-		}
-	}
-
-	if iNdEx > l {
-		return io.ErrUnexpectedEOF
-	}
-	return nil
-}
-func (m *HTTPRouteDestination) Unmarshal(dAtA []byte) error {
-	l := len(dAtA)
-	iNdEx := 0
-	for iNdEx < l {
-		preIndex := iNdEx
-		var wire uint64
-		for shift := uint(0); ; shift += 7 {
-			if shift >= 64 {
-				return ErrIntOverflowVirtualService
-			}
-			if iNdEx >= l {
-				return io.ErrUnexpectedEOF
-			}
-			b := dAtA[iNdEx]
-			iNdEx++
-			wire |= uint64(b&0x7F) << shift
-			if b < 0x80 {
-				break
-			}
-		}
-		fieldNum := int32(wire >> 3)
-		wireType := int(wire & 0x7)
-		if wireType == 4 {
-			return fmt.Errorf("proto: HTTPRouteDestination: wiretype end group for non-group")
-		}
-		if fieldNum <= 0 {
-			return fmt.Errorf("proto: HTTPRouteDestination: illegal tag %d (wire type %d)", fieldNum, wire)
-		}
-		switch fieldNum {
-		case 1:
+		case 11:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Destination", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field RedirectUrlRewriteRegex", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -8891,18 +12545,17 @@ func (m *HTTPRouteDestination) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.Destination == nil {
-				m.Destination = &Destination{}
-			}
-			if err := m.Destination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+			v := &RegexMatchAndSubstitute{}
+			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
+			m.RedirectUrlRewriteSpecifier = &HTTPInternalActiveRedirect_RedirectPolicy_RedirectUrlRewriteRegex{v}
 			iNdEx = postIndex
-		case 2:
+		case 12:
 			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field AllowCrossScheme", wireType)
 			}
-			m.Weight = 0
+			var v int
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowVirtualService
@@ -8912,12 +12565,13 @@ func (m *HTTPRouteDestination) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				m.Weight |= int32(b&0x7F) << shift
+				v |= int(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-		case 7:
+			m.AllowCrossScheme = bool(v != 0)
+		case 13:
 			if wireType != 2 {
 				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
 			}
@@ -8953,6 +12607,78 @@ func (m *HTTPRouteDestination) Unmarshal(dAtA []byte) error {
 				return err
 			}
 			iNdEx = postIndex
+		case 14:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Authority = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 17:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field ForcedUseOriginalHost", wireType)
+			}
+			var v int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				v |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			m.ForcedUseOriginalHost = bool(v != 0)
+		case 18:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field ForcedAddHeaderBeforeRouteMatcher", wireType)
+			}
+			var v int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				v |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			m.ForcedAddHeaderBeforeRouteMatcher = bool(v != 0)
 		default:
 			iNdEx = preIndex
 			skippy, err := skipVirtualService(dAtA[iNdEx:])
@@ -8975,7 +12701,7 @@ func (m *HTTPRouteDestination) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
-func (m *RouteDestination) Unmarshal(dAtA []byte) error {
+func (m *HTTPDirectResponse) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
 	for iNdEx < l {
@@ -8998,17 +12724,36 @@ func (m *RouteDestination) Unmarshal(dAtA []byte) error {
 		fieldNum := int32(wire >> 3)
 		wireType := int(wire & 0x7)
 		if wireType == 4 {
-			return fmt.Errorf("proto: RouteDestination: wiretype end group for non-group")
+			return fmt.Errorf("proto: HTTPDirectResponse: wiretype end group for non-group")
 		}
 		if fieldNum <= 0 {
-			return fmt.Errorf("proto: RouteDestination: illegal tag %d (wire type %d)", fieldNum, wire)
+			return fmt.Errorf("proto: HTTPDirectResponse: illegal tag %d (wire type %d)", fieldNum, wire)
 		}
 		switch fieldNum {
 		case 1:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field ResponseCode", wireType)
+			}
+			m.ResponseCode = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.ResponseCode |= uint32(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		case 2:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Destination", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
 			}
-			var msglen int
+			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowVirtualService
@@ -9018,47 +12763,24 @@ func (m *RouteDestination) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				msglen |= int(b&0x7F) << shift
+				stringLen |= uint64(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			if msglen < 0 {
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
 				return ErrInvalidLengthVirtualService
 			}
-			postIndex := iNdEx + msglen
+			postIndex := iNdEx + intStringLen
 			if postIndex < 0 {
 				return ErrInvalidLengthVirtualService
 			}
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.Destination == nil {
-				m.Destination = &Destination{}
-			}
-			if err := m.Destination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
+			m.Body = string(dAtA[iNdEx:postIndex])
 			iNdEx = postIndex
-		case 2:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
-			}
-			m.Weight = 0
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowVirtualService
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				m.Weight |= int32(b&0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
 		default:
 			iNdEx = preIndex
 			skippy, err := skipVirtualService(dAtA[iNdEx:])
@@ -9081,7 +12803,7 @@ func (m *RouteDestination) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
-func (m *L4MatchAttributes) Unmarshal(dAtA []byte) error {
+func (m *HTTPRewrite) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
 	for iNdEx < l {
@@ -9104,15 +12826,15 @@ func (m *L4MatchAttributes) Unmarshal(dAtA []byte) error {
 		fieldNum := int32(wire >> 3)
 		wireType := int(wire & 0x7)
 		if wireType == 4 {
-			return fmt.Errorf("proto: L4MatchAttributes: wiretype end group for non-group")
+			return fmt.Errorf("proto: HTTPRewrite: wiretype end group for non-group")
 		}
 		if fieldNum <= 0 {
-			return fmt.Errorf("proto: L4MatchAttributes: illegal tag %d (wire type %d)", fieldNum, wire)
+			return fmt.Errorf("proto: HTTPRewrite: illegal tag %d (wire type %d)", fieldNum, wire)
 		}
 		switch fieldNum {
 		case 1:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field DestinationSubnets", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
 			}
 			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
@@ -9140,30 +12862,11 @@ func (m *L4MatchAttributes) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.DestinationSubnets = append(m.DestinationSubnets, string(dAtA[iNdEx:postIndex]))
+			m.Uri = string(dAtA[iNdEx:postIndex])
 			iNdEx = postIndex
 		case 2:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
-			}
-			m.Port = 0
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowVirtualService
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				m.Port |= uint32(b&0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		case 3:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field SourceSubnet", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
 			}
 			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
@@ -9191,11 +12894,11 @@ func (m *L4MatchAttributes) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.SourceSubnet = string(dAtA[iNdEx:postIndex])
+			m.Authority = string(dAtA[iNdEx:postIndex])
 			iNdEx = postIndex
-		case 4:
+		case 3:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field SourceLabels", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field UriRegex", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -9222,107 +12925,67 @@ func (m *L4MatchAttributes) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.SourceLabels == nil {
-				m.SourceLabels = make(map[string]string)
+			if m.UriRegex == nil {
+				m.UriRegex = &RegexMatchAndSubstitute{}
 			}
-			var mapkey string
-			var mapvalue string
-			for iNdEx < postIndex {
-				entryPreIndex := iNdEx
-				var wire uint64
-				for shift := uint(0); ; shift += 7 {
-					if shift >= 64 {
-						return ErrIntOverflowVirtualService
-					}
-					if iNdEx >= l {
-						return io.ErrUnexpectedEOF
-					}
-					b := dAtA[iNdEx]
-					iNdEx++
-					wire |= uint64(b&0x7F) << shift
-					if b < 0x80 {
-						break
-					}
-				}
-				fieldNum := int32(wire >> 3)
-				if fieldNum == 1 {
-					var stringLenmapkey uint64
-					for shift := uint(0); ; shift += 7 {
-						if shift >= 64 {
-							return ErrIntOverflowVirtualService
-						}
-						if iNdEx >= l {
-							return io.ErrUnexpectedEOF
-						}
-						b := dAtA[iNdEx]
-						iNdEx++
-						stringLenmapkey |= uint64(b&0x7F) << shift
-						if b < 0x80 {
-							break
-						}
-					}
-					intStringLenmapkey := int(stringLenmapkey)
-					if intStringLenmapkey < 0 {
-						return ErrInvalidLengthVirtualService
-					}
-					postStringIndexmapkey := iNdEx + intStringLenmapkey
-					if postStringIndexmapkey < 0 {
-						return ErrInvalidLengthVirtualService
-					}
-					if postStringIndexmapkey > l {
-						return io.ErrUnexpectedEOF
-					}
-					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
-					iNdEx = postStringIndexmapkey
-				} else if fieldNum == 2 {
-					var stringLenmapvalue uint64
-					for shift := uint(0); ; shift += 7 {
-						if shift >= 64 {
-							return ErrIntOverflowVirtualService
-						}
-						if iNdEx >= l {
-							return io.ErrUnexpectedEOF
-						}
-						b := dAtA[iNdEx]
-						iNdEx++
-						stringLenmapvalue |= uint64(b&0x7F) << shift
-						if b < 0x80 {
-							break
-						}
-					}
-					intStringLenmapvalue := int(stringLenmapvalue)
-					if intStringLenmapvalue < 0 {
-						return ErrInvalidLengthVirtualService
-					}
-					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
-					if postStringIndexmapvalue < 0 {
-						return ErrInvalidLengthVirtualService
-					}
-					if postStringIndexmapvalue > l {
-						return io.ErrUnexpectedEOF
-					}
-					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
-					iNdEx = postStringIndexmapvalue
-				} else {
-					iNdEx = entryPreIndex
-					skippy, err := skipVirtualService(dAtA[iNdEx:])
-					if err != nil {
-						return err
-					}
-					if (skippy < 0) || (iNdEx+skippy) < 0 {
-						return ErrInvalidLengthVirtualService
-					}
-					if (iNdEx + skippy) > postIndex {
-						return io.ErrUnexpectedEOF
-					}
-					iNdEx += skippy
-				}
+			if err := m.UriRegex.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
 			}
-			m.SourceLabels[mapkey] = mapvalue
 			iNdEx = postIndex
-		case 5:
+		default:
+			iNdEx = preIndex
+			skippy, err := skipVirtualService(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *RegexMatchAndSubstitute) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowVirtualService
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: RegexMatchAndSubstitute: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: RegexMatchAndSubstitute: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Gateways", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Pattern", wireType)
 			}
 			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
@@ -9350,11 +13013,11 @@ func (m *L4MatchAttributes) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.Gateways = append(m.Gateways, string(dAtA[iNdEx:postIndex]))
+			m.Pattern = string(dAtA[iNdEx:postIndex])
 			iNdEx = postIndex
-		case 6:
+		case 2:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field SourceNamespace", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Substitution", wireType)
 			}
 			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
@@ -9382,7 +13045,7 @@ func (m *L4MatchAttributes) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.SourceNamespace = string(dAtA[iNdEx:postIndex])
+			m.Substitution = string(dAtA[iNdEx:postIndex])
 			iNdEx = postIndex
 		default:
 			iNdEx = preIndex
@@ -9406,7 +13069,7 @@ func (m *L4MatchAttributes) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
-func (m *TLSMatchAttributes) Unmarshal(dAtA []byte) error {
+func (m *StringMatch) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
 	for iNdEx < l {
@@ -9429,15 +13092,47 @@ func (m *TLSMatchAttributes) Unmarshal(dAtA []byte) error {
 		fieldNum := int32(wire >> 3)
 		wireType := int(wire & 0x7)
 		if wireType == 4 {
-			return fmt.Errorf("proto: TLSMatchAttributes: wiretype end group for non-group")
+			return fmt.Errorf("proto: StringMatch: wiretype end group for non-group")
 		}
 		if fieldNum <= 0 {
-			return fmt.Errorf("proto: TLSMatchAttributes: illegal tag %d (wire type %d)", fieldNum, wire)
+			return fmt.Errorf("proto: StringMatch: illegal tag %d (wire type %d)", fieldNum, wire)
 		}
 		switch fieldNum {
 		case 1:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field SniHosts", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Exact", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.MatchType = &StringMatch_Exact{string(dAtA[iNdEx:postIndex])}
+			iNdEx = postIndex
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
 			}
 			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
@@ -9465,11 +13160,11 @@ func (m *TLSMatchAttributes) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.SniHosts = append(m.SniHosts, string(dAtA[iNdEx:postIndex]))
+			m.MatchType = &StringMatch_Prefix{string(dAtA[iNdEx:postIndex])}
 			iNdEx = postIndex
-		case 2:
+		case 3:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field DestinationSubnets", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Regex", wireType)
 			}
 			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
@@ -9497,13 +13192,64 @@ func (m *TLSMatchAttributes) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.DestinationSubnets = append(m.DestinationSubnets, string(dAtA[iNdEx:postIndex]))
+			m.MatchType = &StringMatch_Regex{string(dAtA[iNdEx:postIndex])}
 			iNdEx = postIndex
-		case 3:
+		default:
+			iNdEx = preIndex
+			skippy, err := skipVirtualService(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *HTTPRetry) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowVirtualService
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: HTTPRetry: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: HTTPRetry: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
 			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Attempts", wireType)
 			}
-			m.Port = 0
+			m.Attempts = 0
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowVirtualService
@@ -9513,14 +13259,14 @@ func (m *TLSMatchAttributes) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				m.Port |= uint32(b&0x7F) << shift
+				m.Attempts |= int32(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-		case 5:
+		case 2:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field SourceLabels", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field PerTryTimeout", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -9547,107 +13293,16 @@ func (m *TLSMatchAttributes) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.SourceLabels == nil {
-				m.SourceLabels = make(map[string]string)
+			if m.PerTryTimeout == nil {
+				m.PerTryTimeout = &types.Duration{}
 			}
-			var mapkey string
-			var mapvalue string
-			for iNdEx < postIndex {
-				entryPreIndex := iNdEx
-				var wire uint64
-				for shift := uint(0); ; shift += 7 {
-					if shift >= 64 {
-						return ErrIntOverflowVirtualService
-					}
-					if iNdEx >= l {
-						return io.ErrUnexpectedEOF
-					}
-					b := dAtA[iNdEx]
-					iNdEx++
-					wire |= uint64(b&0x7F) << shift
-					if b < 0x80 {
-						break
-					}
-				}
-				fieldNum := int32(wire >> 3)
-				if fieldNum == 1 {
-					var stringLenmapkey uint64
-					for shift := uint(0); ; shift += 7 {
-						if shift >= 64 {
-							return ErrIntOverflowVirtualService
-						}
-						if iNdEx >= l {
-							return io.ErrUnexpectedEOF
-						}
-						b := dAtA[iNdEx]
-						iNdEx++
-						stringLenmapkey |= uint64(b&0x7F) << shift
-						if b < 0x80 {
-							break
-						}
-					}
-					intStringLenmapkey := int(stringLenmapkey)
-					if intStringLenmapkey < 0 {
-						return ErrInvalidLengthVirtualService
-					}
-					postStringIndexmapkey := iNdEx + intStringLenmapkey
-					if postStringIndexmapkey < 0 {
-						return ErrInvalidLengthVirtualService
-					}
-					if postStringIndexmapkey > l {
-						return io.ErrUnexpectedEOF
-					}
-					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
-					iNdEx = postStringIndexmapkey
-				} else if fieldNum == 2 {
-					var stringLenmapvalue uint64
-					for shift := uint(0); ; shift += 7 {
-						if shift >= 64 {
-							return ErrIntOverflowVirtualService
-						}
-						if iNdEx >= l {
-							return io.ErrUnexpectedEOF
-						}
-						b := dAtA[iNdEx]
-						iNdEx++
-						stringLenmapvalue |= uint64(b&0x7F) << shift
-						if b < 0x80 {
-							break
-						}
-					}
-					intStringLenmapvalue := int(stringLenmapvalue)
-					if intStringLenmapvalue < 0 {
-						return ErrInvalidLengthVirtualService
-					}
-					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
-					if postStringIndexmapvalue < 0 {
-						return ErrInvalidLengthVirtualService
-					}
-					if postStringIndexmapvalue > l {
-						return io.ErrUnexpectedEOF
-					}
-					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
-					iNdEx = postStringIndexmapvalue
-				} else {
-					iNdEx = entryPreIndex
-					skippy, err := skipVirtualService(dAtA[iNdEx:])
-					if err != nil {
-						return err
-					}
-					if (skippy < 0) || (iNdEx+skippy) < 0 {
-						return ErrInvalidLengthVirtualService
-					}
-					if (iNdEx + skippy) > postIndex {
-						return io.ErrUnexpectedEOF
-					}
-					iNdEx += skippy
-				}
+			if err := m.PerTryTimeout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
 			}
-			m.SourceLabels[mapkey] = mapvalue
 			iNdEx = postIndex
-		case 6:
+		case 3:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Gateways", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field RetryOn", wireType)
 			}
 			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
@@ -9675,13 +13330,13 @@ func (m *TLSMatchAttributes) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.Gateways = append(m.Gateways, string(dAtA[iNdEx:postIndex]))
+			m.RetryOn = string(dAtA[iNdEx:postIndex])
 			iNdEx = postIndex
-		case 7:
+		case 4:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field SourceNamespace", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field RetryRemoteLocalities", wireType)
 			}
-			var stringLen uint64
+			var msglen int
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowVirtualService
@@ -9691,23 +13346,27 @@ func (m *TLSMatchAttributes) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				stringLen |= uint64(b&0x7F) << shift
+				msglen |= int(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			intStringLen := int(stringLen)
-			if intStringLen < 0 {
+			if msglen < 0 {
 				return ErrInvalidLengthVirtualService
 			}
-			postIndex := iNdEx + intStringLen
+			postIndex := iNdEx + msglen
 			if postIndex < 0 {
 				return ErrInvalidLengthVirtualService
 			}
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.SourceNamespace = string(dAtA[iNdEx:postIndex])
+			if m.RetryRemoteLocalities == nil {
+				m.RetryRemoteLocalities = &types.BoolValue{}
+			}
+			if err := m.RetryRemoteLocalities.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
 			iNdEx = postIndex
 		default:
 			iNdEx = preIndex
@@ -9731,7 +13390,7 @@ func (m *TLSMatchAttributes) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
-func (m *HTTPRedirect) Unmarshal(dAtA []byte) error {
+func (m *CorsPolicy) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
 	for iNdEx < l {
@@ -9754,15 +13413,15 @@ func (m *HTTPRedirect) Unmarshal(dAtA []byte) error {
 		fieldNum := int32(wire >> 3)
 		wireType := int(wire & 0x7)
 		if wireType == 4 {
-			return fmt.Errorf("proto: HTTPRedirect: wiretype end group for non-group")
+			return fmt.Errorf("proto: CorsPolicy: wiretype end group for non-group")
 		}
 		if fieldNum <= 0 {
-			return fmt.Errorf("proto: HTTPRedirect: illegal tag %d (wire type %d)", fieldNum, wire)
+			return fmt.Errorf("proto: CorsPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
 		}
 		switch fieldNum {
 		case 1:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field AllowOrigin", wireType)
 			}
 			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
@@ -9790,11 +13449,11 @@ func (m *HTTPRedirect) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.Uri = string(dAtA[iNdEx:postIndex])
+			m.AllowOrigin = append(m.AllowOrigin, string(dAtA[iNdEx:postIndex]))
 			iNdEx = postIndex
 		case 2:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field AllowMethods", wireType)
 			}
 			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
@@ -9822,52 +13481,13 @@ func (m *HTTPRedirect) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.Authority = string(dAtA[iNdEx:postIndex])
-			iNdEx = postIndex
-		case 3:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field RedirectCode", wireType)
-			}
-			m.RedirectCode = 0
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowVirtualService
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				m.RedirectCode |= uint32(b&0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		case 4:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
-			}
-			var v uint32
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowVirtualService
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				v |= uint32(b&0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-			m.RedirectPort = &HTTPRedirect_Port{v}
-		case 5:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field DerivePort", wireType)
+			m.AllowMethods = append(m.AllowMethods, string(dAtA[iNdEx:postIndex]))
+			iNdEx = postIndex
+		case 3:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field AllowHeaders", wireType)
 			}
-			var v HTTPRedirect_RedirectPortSelection
+			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowVirtualService
@@ -9877,15 +13497,27 @@ func (m *HTTPRedirect) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				v |= HTTPRedirect_RedirectPortSelection(b&0x7F) << shift
+				stringLen |= uint64(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			m.RedirectPort = &HTTPRedirect_DerivePort{v}
-		case 6:
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.AllowHeaders = append(m.AllowHeaders, string(dAtA[iNdEx:postIndex]))
+			iNdEx = postIndex
+		case 4:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Scheme", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field ExposeHeaders", wireType)
 			}
 			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
@@ -9913,64 +13545,49 @@ func (m *HTTPRedirect) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.Scheme = string(dAtA[iNdEx:postIndex])
+			m.ExposeHeaders = append(m.ExposeHeaders, string(dAtA[iNdEx:postIndex]))
 			iNdEx = postIndex
-		default:
-			iNdEx = preIndex
-			skippy, err := skipVirtualService(dAtA[iNdEx:])
-			if err != nil {
-				return err
+		case 5:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field MaxAge", wireType)
 			}
-			if (skippy < 0) || (iNdEx+skippy) < 0 {
-				return ErrInvalidLengthVirtualService
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
 			}
-			if (iNdEx + skippy) > l {
-				return io.ErrUnexpectedEOF
+			if msglen < 0 {
+				return ErrInvalidLengthVirtualService
 			}
-			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
-			iNdEx += skippy
-		}
-	}
-
-	if iNdEx > l {
-		return io.ErrUnexpectedEOF
-	}
-	return nil
-}
-func (m *HTTPRewrite) Unmarshal(dAtA []byte) error {
-	l := len(dAtA)
-	iNdEx := 0
-	for iNdEx < l {
-		preIndex := iNdEx
-		var wire uint64
-		for shift := uint(0); ; shift += 7 {
-			if shift >= 64 {
-				return ErrIntOverflowVirtualService
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
 			}
-			if iNdEx >= l {
+			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			b := dAtA[iNdEx]
-			iNdEx++
-			wire |= uint64(b&0x7F) << shift
-			if b < 0x80 {
-				break
+			if m.MaxAge == nil {
+				m.MaxAge = &types.Duration{}
 			}
-		}
-		fieldNum := int32(wire >> 3)
-		wireType := int(wire & 0x7)
-		if wireType == 4 {
-			return fmt.Errorf("proto: HTTPRewrite: wiretype end group for non-group")
-		}
-		if fieldNum <= 0 {
-			return fmt.Errorf("proto: HTTPRewrite: illegal tag %d (wire type %d)", fieldNum, wire)
-		}
-		switch fieldNum {
-		case 1:
+			if err := m.MaxAge.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 6:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field AllowCredentials", wireType)
 			}
-			var stringLen uint64
+			var msglen int
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowVirtualService
@@ -9980,29 +13597,33 @@ func (m *HTTPRewrite) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				stringLen |= uint64(b&0x7F) << shift
+				msglen |= int(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			intStringLen := int(stringLen)
-			if intStringLen < 0 {
+			if msglen < 0 {
 				return ErrInvalidLengthVirtualService
 			}
-			postIndex := iNdEx + intStringLen
+			postIndex := iNdEx + msglen
 			if postIndex < 0 {
 				return ErrInvalidLengthVirtualService
 			}
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.Uri = string(dAtA[iNdEx:postIndex])
+			if m.AllowCredentials == nil {
+				m.AllowCredentials = &types.BoolValue{}
+			}
+			if err := m.AllowCredentials.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
 			iNdEx = postIndex
-		case 2:
+		case 7:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field AllowOrigins", wireType)
 			}
-			var stringLen uint64
+			var msglen int
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowVirtualService
@@ -10012,23 +13633,25 @@ func (m *HTTPRewrite) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				stringLen |= uint64(b&0x7F) << shift
+				msglen |= int(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			intStringLen := int(stringLen)
-			if intStringLen < 0 {
+			if msglen < 0 {
 				return ErrInvalidLengthVirtualService
 			}
-			postIndex := iNdEx + intStringLen
+			postIndex := iNdEx + msglen
 			if postIndex < 0 {
 				return ErrInvalidLengthVirtualService
 			}
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.Authority = string(dAtA[iNdEx:postIndex])
+			m.AllowOrigins = append(m.AllowOrigins, &StringMatch{})
+			if err := m.AllowOrigins[len(m.AllowOrigins)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
 			iNdEx = postIndex
 		default:
 			iNdEx = preIndex
@@ -10052,7 +13675,7 @@ func (m *HTTPRewrite) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
-func (m *StringMatch) Unmarshal(dAtA []byte) error {
+func (m *HTTPFaultInjection) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
 	for iNdEx < l {
@@ -10075,17 +13698,17 @@ func (m *StringMatch) Unmarshal(dAtA []byte) error {
 		fieldNum := int32(wire >> 3)
 		wireType := int(wire & 0x7)
 		if wireType == 4 {
-			return fmt.Errorf("proto: StringMatch: wiretype end group for non-group")
+			return fmt.Errorf("proto: HTTPFaultInjection: wiretype end group for non-group")
 		}
 		if fieldNum <= 0 {
-			return fmt.Errorf("proto: StringMatch: illegal tag %d (wire type %d)", fieldNum, wire)
+			return fmt.Errorf("proto: HTTPFaultInjection: illegal tag %d (wire type %d)", fieldNum, wire)
 		}
 		switch fieldNum {
 		case 1:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Exact", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Delay", wireType)
 			}
-			var stringLen uint64
+			var msglen int
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowVirtualService
@@ -10095,29 +13718,33 @@ func (m *StringMatch) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				stringLen |= uint64(b&0x7F) << shift
+				msglen |= int(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			intStringLen := int(stringLen)
-			if intStringLen < 0 {
+			if msglen < 0 {
 				return ErrInvalidLengthVirtualService
 			}
-			postIndex := iNdEx + intStringLen
+			postIndex := iNdEx + msglen
 			if postIndex < 0 {
 				return ErrInvalidLengthVirtualService
 			}
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.MatchType = &StringMatch_Exact{string(dAtA[iNdEx:postIndex])}
+			if m.Delay == nil {
+				m.Delay = &HTTPFaultInjection_Delay{}
+			}
+			if err := m.Delay.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
 			iNdEx = postIndex
 		case 2:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Abort", wireType)
 			}
-			var stringLen uint64
+			var msglen int
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowVirtualService
@@ -10127,55 +13754,27 @@ func (m *StringMatch) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				stringLen |= uint64(b&0x7F) << shift
+				msglen |= int(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			intStringLen := int(stringLen)
-			if intStringLen < 0 {
+			if msglen < 0 {
 				return ErrInvalidLengthVirtualService
 			}
-			postIndex := iNdEx + intStringLen
+			postIndex := iNdEx + msglen
 			if postIndex < 0 {
 				return ErrInvalidLengthVirtualService
 			}
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.MatchType = &StringMatch_Prefix{string(dAtA[iNdEx:postIndex])}
-			iNdEx = postIndex
-		case 3:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Regex", wireType)
-			}
-			var stringLen uint64
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowVirtualService
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				stringLen |= uint64(b&0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-			intStringLen := int(stringLen)
-			if intStringLen < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			postIndex := iNdEx + intStringLen
-			if postIndex < 0 {
-				return ErrInvalidLengthVirtualService
+			if m.Abort == nil {
+				m.Abort = &HTTPFaultInjection_Abort{}
 			}
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
+			if err := m.Abort.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
 			}
-			m.MatchType = &StringMatch_Regex{string(dAtA[iNdEx:postIndex])}
 			iNdEx = postIndex
 		default:
 			iNdEx = preIndex
@@ -10199,7 +13798,7 @@ func (m *StringMatch) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
-func (m *HTTPRetry) Unmarshal(dAtA []byte) error {
+func (m *HTTPFaultInjection_Delay) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
 	for iNdEx < l {
@@ -10222,17 +13821,17 @@ func (m *HTTPRetry) Unmarshal(dAtA []byte) error {
 		fieldNum := int32(wire >> 3)
 		wireType := int(wire & 0x7)
 		if wireType == 4 {
-			return fmt.Errorf("proto: HTTPRetry: wiretype end group for non-group")
+			return fmt.Errorf("proto: Delay: wiretype end group for non-group")
 		}
 		if fieldNum <= 0 {
-			return fmt.Errorf("proto: HTTPRetry: illegal tag %d (wire type %d)", fieldNum, wire)
+			return fmt.Errorf("proto: Delay: illegal tag %d (wire type %d)", fieldNum, wire)
 		}
 		switch fieldNum {
 		case 1:
 			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Attempts", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Percent", wireType)
 			}
-			m.Attempts = 0
+			m.Percent = 0
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowVirtualService
@@ -10242,14 +13841,14 @@ func (m *HTTPRetry) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				m.Attempts |= int32(b&0x7F) << shift
+				m.Percent |= int32(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
 		case 2:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field PerTryTimeout", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field FixedDelay", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -10276,18 +13875,17 @@ func (m *HTTPRetry) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.PerTryTimeout == nil {
-				m.PerTryTimeout = &types.Duration{}
-			}
-			if err := m.PerTryTimeout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+			v := &types.Duration{}
+			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
+			m.HttpDelayType = &HTTPFaultInjection_Delay_FixedDelay{v}
 			iNdEx = postIndex
 		case 3:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field RetryOn", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field ExponentialDelay", wireType)
 			}
-			var stringLen uint64
+			var msglen int
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowVirtualService
@@ -10297,27 +13895,30 @@ func (m *HTTPRetry) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				stringLen |= uint64(b&0x7F) << shift
+				msglen |= int(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			intStringLen := int(stringLen)
-			if intStringLen < 0 {
+			if msglen < 0 {
 				return ErrInvalidLengthVirtualService
 			}
-			postIndex := iNdEx + intStringLen
+			postIndex := iNdEx + msglen
 			if postIndex < 0 {
 				return ErrInvalidLengthVirtualService
 			}
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.RetryOn = string(dAtA[iNdEx:postIndex])
+			v := &types.Duration{}
+			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			m.HttpDelayType = &HTTPFaultInjection_Delay_ExponentialDelay{v}
 			iNdEx = postIndex
-		case 4:
+		case 5:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field RetryRemoteLocalities", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Percentage", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -10344,10 +13945,10 @@ func (m *HTTPRetry) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.RetryRemoteLocalities == nil {
-				m.RetryRemoteLocalities = &types.BoolValue{}
+			if m.Percentage == nil {
+				m.Percentage = &Percent{}
 			}
-			if err := m.RetryRemoteLocalities.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+			if err := m.Percentage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
 			iNdEx = postIndex
@@ -10373,7 +13974,7 @@ func (m *HTTPRetry) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
-func (m *CorsPolicy) Unmarshal(dAtA []byte) error {
+func (m *HTTPFaultInjection_Abort) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
 	for iNdEx < l {
@@ -10396,49 +13997,17 @@ func (m *CorsPolicy) Unmarshal(dAtA []byte) error {
 		fieldNum := int32(wire >> 3)
 		wireType := int(wire & 0x7)
 		if wireType == 4 {
-			return fmt.Errorf("proto: CorsPolicy: wiretype end group for non-group")
+			return fmt.Errorf("proto: Abort: wiretype end group for non-group")
 		}
 		if fieldNum <= 0 {
-			return fmt.Errorf("proto: CorsPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
+			return fmt.Errorf("proto: Abort: illegal tag %d (wire type %d)", fieldNum, wire)
 		}
 		switch fieldNum {
-		case 1:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field AllowOrigin", wireType)
-			}
-			var stringLen uint64
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowVirtualService
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				stringLen |= uint64(b&0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-			intStringLen := int(stringLen)
-			if intStringLen < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			postIndex := iNdEx + intStringLen
-			if postIndex < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			m.AllowOrigin = append(m.AllowOrigin, string(dAtA[iNdEx:postIndex]))
-			iNdEx = postIndex
 		case 2:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field AllowMethods", wireType)
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field HttpStatus", wireType)
 			}
-			var stringLen uint64
+			var v int32
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowVirtualService
@@ -10448,27 +14017,15 @@ func (m *CorsPolicy) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				stringLen |= uint64(b&0x7F) << shift
+				v |= int32(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			intStringLen := int(stringLen)
-			if intStringLen < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			postIndex := iNdEx + intStringLen
-			if postIndex < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			m.AllowMethods = append(m.AllowMethods, string(dAtA[iNdEx:postIndex]))
-			iNdEx = postIndex
+			m.ErrorType = &HTTPFaultInjection_Abort_HttpStatus{v}
 		case 3:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field AllowHeaders", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field GrpcStatus", wireType)
 			}
 			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
@@ -10496,11 +14053,11 @@ func (m *CorsPolicy) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.AllowHeaders = append(m.AllowHeaders, string(dAtA[iNdEx:postIndex]))
+			m.ErrorType = &HTTPFaultInjection_Abort_GrpcStatus{string(dAtA[iNdEx:postIndex])}
 			iNdEx = postIndex
 		case 4:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field ExposeHeaders", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Http2Error", wireType)
 			}
 			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
@@ -10528,47 +14085,11 @@ func (m *CorsPolicy) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.ExposeHeaders = append(m.ExposeHeaders, string(dAtA[iNdEx:postIndex]))
+			m.ErrorType = &HTTPFaultInjection_Abort_Http2Error{string(dAtA[iNdEx:postIndex])}
 			iNdEx = postIndex
 		case 5:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field MaxAge", wireType)
-			}
-			var msglen int
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowVirtualService
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				msglen |= int(b&0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-			if msglen < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			postIndex := iNdEx + msglen
-			if postIndex < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			if m.MaxAge == nil {
-				m.MaxAge = &types.Duration{}
-			}
-			if err := m.MaxAge.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
-			iNdEx = postIndex
-		case 6:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field AllowCredentials", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Percentage", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -10595,44 +14116,10 @@ func (m *CorsPolicy) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.AllowCredentials == nil {
-				m.AllowCredentials = &types.BoolValue{}
-			}
-			if err := m.AllowCredentials.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
-			iNdEx = postIndex
-		case 7:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field AllowOrigins", wireType)
-			}
-			var msglen int
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowVirtualService
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				msglen |= int(b&0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-			if msglen < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			postIndex := iNdEx + msglen
-			if postIndex < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
+			if m.Percentage == nil {
+				m.Percentage = &Percent{}
 			}
-			m.AllowOrigins = append(m.AllowOrigins, &StringMatch{})
-			if err := m.AllowOrigins[len(m.AllowOrigins)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+			if err := m.Percentage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
 			iNdEx = postIndex
@@ -10658,7 +14145,7 @@ func (m *CorsPolicy) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
-func (m *HTTPFaultInjection) Unmarshal(dAtA []byte) error {
+func (m *PortSelector) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
 	for iNdEx < l {
@@ -10681,17 +14168,17 @@ func (m *HTTPFaultInjection) Unmarshal(dAtA []byte) error {
 		fieldNum := int32(wire >> 3)
 		wireType := int(wire & 0x7)
 		if wireType == 4 {
-			return fmt.Errorf("proto: HTTPFaultInjection: wiretype end group for non-group")
+			return fmt.Errorf("proto: PortSelector: wiretype end group for non-group")
 		}
 		if fieldNum <= 0 {
-			return fmt.Errorf("proto: HTTPFaultInjection: illegal tag %d (wire type %d)", fieldNum, wire)
+			return fmt.Errorf("proto: PortSelector: illegal tag %d (wire type %d)", fieldNum, wire)
 		}
 		switch fieldNum {
 		case 1:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Delay", wireType)
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
 			}
-			var msglen int
+			m.Number = 0
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowVirtualService
@@ -10701,64 +14188,73 @@ func (m *HTTPFaultInjection) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				msglen |= int(b&0x7F) << shift
+				m.Number |= uint32(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			if msglen < 0 {
-				return ErrInvalidLengthVirtualService
+		default:
+			iNdEx = preIndex
+			skippy, err := skipVirtualService(dAtA[iNdEx:])
+			if err != nil {
+				return err
 			}
-			postIndex := iNdEx + msglen
-			if postIndex < 0 {
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
 				return ErrInvalidLengthVirtualService
 			}
-			if postIndex > l {
+			if (iNdEx + skippy) > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.Delay == nil {
-				m.Delay = &HTTPFaultInjection_Delay{}
-			}
-			if err := m.Delay.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
-			iNdEx = postIndex
-		case 2:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Abort", wireType)
-			}
-			var msglen int
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowVirtualService
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				msglen |= int(b&0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-			if msglen < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			postIndex := iNdEx + msglen
-			if postIndex < 0 {
-				return ErrInvalidLengthVirtualService
+			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *Percent) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowVirtualService
 			}
-			if postIndex > l {
+			if iNdEx >= l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.Abort == nil {
-				m.Abort = &HTTPFaultInjection_Abort{}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
 			}
-			if err := m.Abort.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: Percent: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: Percent: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 1 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
+			}
+			var v uint64
+			if (iNdEx + 8) > l {
+				return io.ErrUnexpectedEOF
 			}
-			iNdEx = postIndex
+			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
+			iNdEx += 8
+			m.Value = float64(math.Float64frombits(v))
 		default:
 			iNdEx = preIndex
 			skippy, err := skipVirtualService(dAtA[iNdEx:])
@@ -10781,7 +14277,7 @@ func (m *HTTPFaultInjection) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
-func (m *HTTPFaultInjection_Delay) Unmarshal(dAtA []byte) error {
+func (m *HTTPFilter) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
 	for iNdEx < l {
@@ -10804,17 +14300,17 @@ func (m *HTTPFaultInjection_Delay) Unmarshal(dAtA []byte) error {
 		fieldNum := int32(wire >> 3)
 		wireType := int(wire & 0x7)
 		if wireType == 4 {
-			return fmt.Errorf("proto: Delay: wiretype end group for non-group")
+			return fmt.Errorf("proto: HTTPFilter: wiretype end group for non-group")
 		}
 		if fieldNum <= 0 {
-			return fmt.Errorf("proto: Delay: illegal tag %d (wire type %d)", fieldNum, wire)
+			return fmt.Errorf("proto: HTTPFilter: illegal tag %d (wire type %d)", fieldNum, wire)
 		}
 		switch fieldNum {
 		case 1:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Percent", wireType)
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
 			}
-			m.Percent = 0
+			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowVirtualService
@@ -10824,16 +14320,29 @@ func (m *HTTPFaultInjection_Delay) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				m.Percent |= int32(b&0x7F) << shift
+				stringLen |= uint64(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Name = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
 		case 2:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field FixedDelay", wireType)
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Disable", wireType)
 			}
-			var msglen int
+			var v int
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowVirtualService
@@ -10843,30 +14352,15 @@ func (m *HTTPFaultInjection_Delay) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				msglen |= int(b&0x7F) << shift
+				v |= int(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			if msglen < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			postIndex := iNdEx + msglen
-			if postIndex < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			v := &types.Duration{}
-			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
-			m.HttpDelayType = &HTTPFaultInjection_Delay_FixedDelay{v}
-			iNdEx = postIndex
+			m.Disable = bool(v != 0)
 		case 3:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field ExponentialDelay", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field IpAccessControl", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -10893,15 +14387,15 @@ func (m *HTTPFaultInjection_Delay) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			v := &types.Duration{}
+			v := &IPAccessControl{}
 			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
-			m.HttpDelayType = &HTTPFaultInjection_Delay_ExponentialDelay{v}
+			m.Filter = &HTTPFilter_IpAccessControl{v}
 			iNdEx = postIndex
-		case 5:
+		case 4:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Percentage", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field LocalRateLimit", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -10928,12 +14422,11 @@ func (m *HTTPFaultInjection_Delay) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.Percentage == nil {
-				m.Percentage = &Percent{}
-			}
-			if err := m.Percentage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+			v := &LocalRateLimit{}
+			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
+			m.Filter = &HTTPFilter_LocalRateLimit{v}
 			iNdEx = postIndex
 		default:
 			iNdEx = preIndex
@@ -10957,7 +14450,7 @@ func (m *HTTPFaultInjection_Delay) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
-func (m *HTTPFaultInjection_Abort) Unmarshal(dAtA []byte) error {
+func (m *IPAccessControl) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
 	for iNdEx < l {
@@ -10980,35 +14473,15 @@ func (m *HTTPFaultInjection_Abort) Unmarshal(dAtA []byte) error {
 		fieldNum := int32(wire >> 3)
 		wireType := int(wire & 0x7)
 		if wireType == 4 {
-			return fmt.Errorf("proto: Abort: wiretype end group for non-group")
+			return fmt.Errorf("proto: IPAccessControl: wiretype end group for non-group")
 		}
 		if fieldNum <= 0 {
-			return fmt.Errorf("proto: Abort: illegal tag %d (wire type %d)", fieldNum, wire)
+			return fmt.Errorf("proto: IPAccessControl: illegal tag %d (wire type %d)", fieldNum, wire)
 		}
 		switch fieldNum {
-		case 2:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field HttpStatus", wireType)
-			}
-			var v int32
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowVirtualService
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				v |= int32(b&0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-			m.ErrorType = &HTTPFaultInjection_Abort_HttpStatus{v}
-		case 3:
+		case 1:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field GrpcStatus", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field RemoteIpBlocks", wireType)
 			}
 			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
@@ -11036,11 +14509,11 @@ func (m *HTTPFaultInjection_Abort) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.ErrorType = &HTTPFaultInjection_Abort_GrpcStatus{string(dAtA[iNdEx:postIndex])}
+			m.RemoteIpBlocks = append(m.RemoteIpBlocks, string(dAtA[iNdEx:postIndex]))
 			iNdEx = postIndex
-		case 4:
+		case 2:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Http2Error", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field NotRemoteIpBlocks", wireType)
 			}
 			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
@@ -11068,43 +14541,7 @@ func (m *HTTPFaultInjection_Abort) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.ErrorType = &HTTPFaultInjection_Abort_Http2Error{string(dAtA[iNdEx:postIndex])}
-			iNdEx = postIndex
-		case 5:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Percentage", wireType)
-			}
-			var msglen int
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowVirtualService
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				msglen |= int(b&0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-			if msglen < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			postIndex := iNdEx + msglen
-			if postIndex < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			if m.Percentage == nil {
-				m.Percentage = &Percent{}
-			}
-			if err := m.Percentage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
+			m.NotRemoteIpBlocks = append(m.NotRemoteIpBlocks, string(dAtA[iNdEx:postIndex]))
 			iNdEx = postIndex
 		default:
 			iNdEx = preIndex
@@ -11128,7 +14565,7 @@ func (m *HTTPFaultInjection_Abort) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
-func (m *PortSelector) Unmarshal(dAtA []byte) error {
+func (m *LocalRateLimit) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
 	for iNdEx < l {
@@ -11151,17 +14588,53 @@ func (m *PortSelector) Unmarshal(dAtA []byte) error {
 		fieldNum := int32(wire >> 3)
 		wireType := int(wire & 0x7)
 		if wireType == 4 {
-			return fmt.Errorf("proto: PortSelector: wiretype end group for non-group")
+			return fmt.Errorf("proto: LocalRateLimit: wiretype end group for non-group")
 		}
 		if fieldNum <= 0 {
-			return fmt.Errorf("proto: PortSelector: illegal tag %d (wire type %d)", fieldNum, wire)
+			return fmt.Errorf("proto: LocalRateLimit: illegal tag %d (wire type %d)", fieldNum, wire)
 		}
 		switch fieldNum {
 		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field TokenBucket", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.TokenBucket == nil {
+				m.TokenBucket = &TokenBucket{}
+			}
+			if err := m.TokenBucket.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 2:
 			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field PerDownstreamConnection", wireType)
 			}
-			m.Number = 0
+			var v int
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowVirtualService
@@ -11171,7 +14644,27 @@ func (m *PortSelector) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				m.Number |= uint32(b&0x7F) << shift
+				v |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			m.PerDownstreamConnection = bool(v != 0)
+		case 3:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field StatusCode", wireType)
+			}
+			m.StatusCode = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.StatusCode |= uint32(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
@@ -11198,7 +14691,7 @@ func (m *PortSelector) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
-func (m *Percent) Unmarshal(dAtA []byte) error {
+func (m *TokenBucket) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
 	for iNdEx < l {
@@ -11221,23 +14714,86 @@ func (m *Percent) Unmarshal(dAtA []byte) error {
 		fieldNum := int32(wire >> 3)
 		wireType := int(wire & 0x7)
 		if wireType == 4 {
-			return fmt.Errorf("proto: Percent: wiretype end group for non-group")
+			return fmt.Errorf("proto: TokenBucket: wiretype end group for non-group")
 		}
 		if fieldNum <= 0 {
-			return fmt.Errorf("proto: Percent: illegal tag %d (wire type %d)", fieldNum, wire)
+			return fmt.Errorf("proto: TokenBucket: illegal tag %d (wire type %d)", fieldNum, wire)
 		}
 		switch fieldNum {
 		case 1:
-			if wireType != 1 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field MaxTokens", wireType)
 			}
-			var v uint64
-			if (iNdEx + 8) > l {
+			m.MaxTokens = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.MaxTokens |= uint32(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		case 2:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field TokensPefFill", wireType)
+			}
+			m.TokensPefFill = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.TokensPefFill |= uint32(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		case 3:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field FillInterval", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
-			iNdEx += 8
-			m.Value = float64(math.Float64frombits(v))
+			if m.FillInterval == nil {
+				m.FillInterval = &types.Duration{}
+			}
+			if err := m.FillInterval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
 		default:
 			iNdEx = preIndex
 			skippy, err := skipVirtualService(dAtA[iNdEx:])
diff --git a/networking/v1alpha3/virtual_service.pb.html b/networking/v1alpha3/virtual_service.pb.html
index a047878e..9f7eccb9 100644
--- a/networking/v1alpha3/virtual_service.pb.html
+++ b/networking/v1alpha3/virtual_service.pb.html
@@ -6,7 +6,7 @@ layout: protoc-gen-docs
 generator: protoc-gen-docs
 schema: istio.networking.v1alpha3.VirtualService
 aliases: [/docs/reference/config/networking/v1alpha3/virtual-service]
-number_of_entries: 25
+number_of_entries: 33
 ---
 <p>Configuration affecting traffic routing. Here are a few terms useful to define
 in the context of traffic routing.</p>
@@ -229,6 +229,17 @@ sidecars in the mesh. If a list of gateway names is provided, the
 rules will apply only to the gateways. To apply the rules to both
 gateways and sidecars, specify <code>mesh</code> as one of the gateway names.</p>
 
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="VirtualService-hostHTTPFilters">
+<td><code>hostHTTPFilters</code></td>
+<td><code><a href="#HTTPFilter">HTTPFilter[]</a></code></td>
+<td>
+<p>HTTP Filters for host scope.</p>
+
 </td>
 <td>
 No
@@ -672,6 +683,17 @@ forwarding target can be one of several versions of a service (see
 glossary in beginning of document). Weights associated with the
 service version determine the proportion of traffic it receives.</p>
 
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="HTTPRoute-routeHTTPFilters">
+<td><code>routeHTTPFilters</code></td>
+<td><code><a href="#HTTPFilter">HTTPFilter[]</a></code></td>
+<td>
+<p>HTTP Filters for route scope.</p>
+
 </td>
 <td>
 No
@@ -686,6 +708,31 @@ traffic passthrough option is specified in the rule,
 route/redirect will be ignored. The redirect primitive can be used to
 send a HTTP 301 redirect to a different URI or Authority.</p>
 
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="HTTPRoute-internal_active_redirect">
+<td><code>internalActiveRedirect</code></td>
+<td><code><a href="#HTTPInternalActiveRedirect">HTTPInternalActiveRedirect</a></code></td>
+<td>
+<p>Added by ingress
+This policy will trigger an internal redirect according to the response code
+without notifying downstream.</p>
+
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="HTTPRoute-direct_response">
+<td><code>directResponse</code></td>
+<td><code><a href="#HTTPDirectResponse">HTTPDirectResponse</a></code></td>
+<td>
+<p>Added by ingress
+Return an arbitrary HTTP response directly, without proxying.</p>
+
 </td>
 <td>
 No
@@ -1710,6 +1757,17 @@ No
 <td>
 <p>Header manipulation rules</p>
 
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="HTTPRouteDestination-fallback_clusters">
+<td><code>fallbackClusters</code></td>
+<td><code><a href="#Destination">Destination[]</a></code></td>
+<td>
+<p>Added by ingress</p>
+
 </td>
 <td>
 No
@@ -2072,6 +2130,162 @@ No
 <p>On a redirect, Specifies the HTTP status code to use in the redirect
 response. The default response code is MOVED_PERMANENTLY (301).</p>
 
+</td>
+<td>
+No
+</td>
+</tr>
+</tbody>
+</table>
+</section>
+<h2 id="HTTPInternalActiveRedirect">HTTPInternalActiveRedirect</h2>
+<section>
+<p>More detail information, please see envoy document about InternalRedirectPolicy.
+The only difference is that this redirect policy allow user to specify how to control the redirect url.</p>
+
+<table class="message-fields">
+<thead>
+<tr>
+<th>Field</th>
+<th>Type</th>
+<th>Description</th>
+<th>Required</th>
+</tr>
+</thead>
+<tbody>
+<tr id="HTTPInternalActiveRedirect-max_internal_redirects">
+<td><code>maxInternalRedirects</code></td>
+<td><code>uint32</code></td>
+<td>
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="HTTPInternalActiveRedirect-redirect_response_codes">
+<td><code>redirectResponseCodes</code></td>
+<td><code>uint32[]</code></td>
+<td>
+<p>Invalid code is in [200, 301, 302, 303, 304, 307, 308]</p>
+
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="HTTPInternalActiveRedirect-redirect_url" class="oneof oneof-start">
+<td><code>redirectUrl</code></td>
+<td><code>string (oneof)</code></td>
+<td>
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="HTTPInternalActiveRedirect-redirect_url_rewrite_regex" class="oneof">
+<td><code>redirectUrlRewriteRegex</code></td>
+<td><code><a href="#RegexMatchAndSubstitute">RegexMatchAndSubstitute (oneof)</a></code></td>
+<td>
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="HTTPInternalActiveRedirect-allow_cross_scheme">
+<td><code>allowCrossScheme</code></td>
+<td><code>bool</code></td>
+<td>
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="HTTPInternalActiveRedirect-headers">
+<td><code>headers</code></td>
+<td><code><a href="#Headers">Headers</a></code></td>
+<td>
+<p>Currently, only support for the add operation for request header.</p>
+
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="HTTPInternalActiveRedirect-authority">
+<td><code>authority</code></td>
+<td><code>string</code></td>
+<td>
+<p>During internal redirect, rewrite the Authority/Host header with this value.</p>
+
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="HTTPInternalActiveRedirect-forced_use_original_host">
+<td><code>forcedUseOriginalHost</code></td>
+<td><code>bool</code></td>
+<td>
+<p>If true, the host name in the downstream request is used for redirection.</p>
+
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="HTTPInternalActiveRedirect-forced_add_header_before_route_matcher">
+<td><code>forcedAddHeaderBeforeRouteMatcher</code></td>
+<td><code>bool</code></td>
+<td>
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="HTTPInternalActiveRedirect-policies">
+<td><code>policies</code></td>
+<td><code><a href="#HTTPInternalActiveRedirect-RedirectPolicy">RedirectPolicy[]</a></code></td>
+<td>
+</td>
+<td>
+No
+</td>
+</tr>
+</tbody>
+</table>
+</section>
+<h2 id="HTTPDirectResponse">HTTPDirectResponse</h2>
+<section>
+<p>Added by ingress
+Return an arbitrary HTTP response directly, without proxying.</p>
+
+<table class="message-fields">
+<thead>
+<tr>
+<th>Field</th>
+<th>Type</th>
+<th>Description</th>
+<th>Required</th>
+</tr>
+</thead>
+<tbody>
+<tr id="HTTPDirectResponse-response_code">
+<td><code>responseCode</code></td>
+<td><code>uint32</code></td>
+<td>
+<p>Response code for downstream client.</p>
+
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="HTTPDirectResponse-body">
+<td><code>body</code></td>
+<td><code>string</code></td>
+<td>
+<p>TODO Support filename, bytes or not</p>
+
 </td>
 <td>
 No
@@ -2165,6 +2379,60 @@ No
 <td>
 <p>rewrite the Authority/Host header with this value.</p>
 
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="HTTPRewrite-uri_regex">
+<td><code>uriRegex</code></td>
+<td><code><a href="#RegexMatchAndSubstitute">RegexMatchAndSubstitute</a></code></td>
+<td>
+<p>uri_regex can be used for rewriting portions of path that match the
+pattern during forwarding the request
+RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).</p>
+
+</td>
+<td>
+No
+</td>
+</tr>
+</tbody>
+</table>
+</section>
+<h2 id="RegexMatchAndSubstitute">RegexMatchAndSubstitute</h2>
+<section>
+<p>Describes how to match a string and then produce a new string using a regular
+expression and a substitution string.</p>
+
+<table class="message-fields">
+<thead>
+<tr>
+<th>Field</th>
+<th>Type</th>
+<th>Description</th>
+<th>Required</th>
+</tr>
+</thead>
+<tbody>
+<tr id="RegexMatchAndSubstitute-pattern">
+<td><code>pattern</code></td>
+<td><code>string</code></td>
+<td>
+<p>RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).</p>
+
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="RegexMatchAndSubstitute-substitution">
+<td><code>substitution</code></td>
+<td><code>string</code></td>
+<td>
+<p>The string that should be substituted into matching portions of the
+subject string during a substitution operation to produce a new string.</p>
+
 </td>
 <td>
 No
@@ -2605,6 +2873,185 @@ No
 </tbody>
 </table>
 </section>
+<h2 id="HTTPFilter">HTTPFilter</h2>
+<section>
+<table class="message-fields">
+<thead>
+<tr>
+<th>Field</th>
+<th>Type</th>
+<th>Description</th>
+<th>Required</th>
+</tr>
+</thead>
+<tbody>
+<tr id="HTTPFilter-name">
+<td><code>name</code></td>
+<td><code>string</code></td>
+<td>
+<p>The http filter name should be meaningful.
+E.g. ip-access-control, jwt, rbac, cors.</p>
+
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="HTTPFilter-disable">
+<td><code>disable</code></td>
+<td><code>bool</code></td>
+<td>
+<p>Disable this filter and all request will pass.</p>
+
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="HTTPFilter-ip_access_control" class="oneof oneof-start">
+<td><code>ipAccessControl</code></td>
+<td><code><a href="#IPAccessControl">IPAccessControl (oneof)</a></code></td>
+<td>
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="HTTPFilter-local_rate_limit" class="oneof">
+<td><code>localRateLimit</code></td>
+<td><code><a href="#LocalRateLimit">LocalRateLimit (oneof)</a></code></td>
+<td>
+</td>
+<td>
+No
+</td>
+</tr>
+</tbody>
+</table>
+</section>
+<h2 id="IPAccessControl">IPAccessControl</h2>
+<section>
+<table class="message-fields">
+<thead>
+<tr>
+<th>Field</th>
+<th>Type</th>
+<th>Description</th>
+<th>Required</th>
+</tr>
+</thead>
+<tbody>
+<tr id="IPAccessControl-remote_ip_blocks">
+<td><code>remoteIpBlocks</code></td>
+<td><code>string[]</code></td>
+<td>
+<p>Used for white ip access control</p>
+
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="IPAccessControl-not_remote_ip_blocks">
+<td><code>notRemoteIpBlocks</code></td>
+<td><code>string[]</code></td>
+<td>
+<p>Used for black ip access control</p>
+
+</td>
+<td>
+No
+</td>
+</tr>
+</tbody>
+</table>
+</section>
+<h2 id="LocalRateLimit">LocalRateLimit</h2>
+<section>
+<table class="message-fields">
+<thead>
+<tr>
+<th>Field</th>
+<th>Type</th>
+<th>Description</th>
+<th>Required</th>
+</tr>
+</thead>
+<tbody>
+<tr id="LocalRateLimit-token_bucket">
+<td><code>tokenBucket</code></td>
+<td><code><a href="#TokenBucket">TokenBucket</a></code></td>
+<td>
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="LocalRateLimit-per_downstream_connection">
+<td><code>perDownstreamConnection</code></td>
+<td><code>bool</code></td>
+<td>
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="LocalRateLimit-status_code">
+<td><code>statusCode</code></td>
+<td><code>uint32</code></td>
+<td>
+<p>Default rate limit status code is 429.</p>
+
+</td>
+<td>
+No
+</td>
+</tr>
+</tbody>
+</table>
+</section>
+<h2 id="TokenBucket">TokenBucket</h2>
+<section>
+<table class="message-fields">
+<thead>
+<tr>
+<th>Field</th>
+<th>Type</th>
+<th>Description</th>
+<th>Required</th>
+</tr>
+</thead>
+<tbody>
+<tr id="TokenBucket-max_tokens">
+<td><code>maxTokens</code></td>
+<td><code>uint32</code></td>
+<td>
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="TokenBucket-tokens_pef_fill">
+<td><code>tokensPefFill</code></td>
+<td><code>uint32</code></td>
+<td>
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="TokenBucket-fill_interval">
+<td><code>fillInterval</code></td>
+<td><code><a href="https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#duration">Duration</a></code></td>
+<td>
+</td>
+<td>
+No
+</td>
+</tr>
+</tbody>
+</table>
+</section>
 <h2 id="Headers-HeaderOperations">Headers.HeaderOperations</h2>
 <section>
 <p>HeaderOperations Describes the header manipulations to apply</p>
@@ -2648,6 +3095,110 @@ No
 <td>
 <p>Remove the specified headers</p>
 
+</td>
+<td>
+No
+</td>
+</tr>
+</tbody>
+</table>
+</section>
+<h2 id="HTTPInternalActiveRedirect-RedirectPolicy">HTTPInternalActiveRedirect.RedirectPolicy</h2>
+<section>
+<table class="message-fields">
+<thead>
+<tr>
+<th>Field</th>
+<th>Type</th>
+<th>Description</th>
+<th>Required</th>
+</tr>
+</thead>
+<tbody>
+<tr id="HTTPInternalActiveRedirect-RedirectPolicy-max_internal_redirects">
+<td><code>maxInternalRedirects</code></td>
+<td><code>uint32</code></td>
+<td>
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="HTTPInternalActiveRedirect-RedirectPolicy-redirect_response_codes">
+<td><code>redirectResponseCodes</code></td>
+<td><code>uint32[]</code></td>
+<td>
+<p>Invalid code is in [200, 301, 302, 303, 304, 307, 308]</p>
+
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="HTTPInternalActiveRedirect-RedirectPolicy-redirect_url" class="oneof oneof-start">
+<td><code>redirectUrl</code></td>
+<td><code>string (oneof)</code></td>
+<td>
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="HTTPInternalActiveRedirect-RedirectPolicy-redirect_url_rewrite_regex" class="oneof">
+<td><code>redirectUrlRewriteRegex</code></td>
+<td><code><a href="#RegexMatchAndSubstitute">RegexMatchAndSubstitute (oneof)</a></code></td>
+<td>
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="HTTPInternalActiveRedirect-RedirectPolicy-allow_cross_scheme">
+<td><code>allowCrossScheme</code></td>
+<td><code>bool</code></td>
+<td>
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="HTTPInternalActiveRedirect-RedirectPolicy-headers">
+<td><code>headers</code></td>
+<td><code><a href="#Headers">Headers</a></code></td>
+<td>
+<p>Currently, only support for the add operation for request header.</p>
+
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="HTTPInternalActiveRedirect-RedirectPolicy-authority">
+<td><code>authority</code></td>
+<td><code>string</code></td>
+<td>
+<p>During internal redirect, rewrite the Authority/Host header with this value.</p>
+
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="HTTPInternalActiveRedirect-RedirectPolicy-forced_use_original_host">
+<td><code>forcedUseOriginalHost</code></td>
+<td><code>bool</code></td>
+<td>
+<p>If true, the host name in the downstream request is used for redirection.</p>
+
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="HTTPInternalActiveRedirect-RedirectPolicy-forced_add_header_before_route_matcher">
+<td><code>forcedAddHeaderBeforeRouteMatcher</code></td>
+<td><code>bool</code></td>
+<td>
 </td>
 <td>
 No
diff --git a/networking/v1alpha3/virtual_service.proto b/networking/v1alpha3/virtual_service.proto
index 7ee9f58f..1fbed62e 100644
--- a/networking/v1alpha3/virtual_service.proto
+++ b/networking/v1alpha3/virtual_service.proto
@@ -252,6 +252,9 @@ message VirtualService {
   // gateways and sidecars, specify `mesh` as one of the gateway names.
   repeated string gateways = 2;
 
+  // HTTP Filters for host scope.
+  repeated HTTPFilter hostHTTPFilters = 1000;
+
   // An ordered list of route rules for HTTP traffic. HTTP routes will be
   // applied to platform service ports named 'http-*'/'http2-*'/'grpc-*', gateway
   // ports with protocol HTTP/HTTP2/GRPC/ TLS-terminated-HTTPS and service
@@ -580,12 +583,24 @@ message HTTPRoute {
   // service version determine the proportion of traffic it receives.
   repeated HTTPRouteDestination route = 2;
 
+  // HTTP Filters for route scope.
+  repeated HTTPFilter routeHTTPFilters = 1000;
+
   // A HTTP rule can either redirect or forward (default) traffic. If
   // traffic passthrough option is specified in the rule,
   // route/redirect will be ignored. The redirect primitive can be used to
   // send a HTTP 301 redirect to a different URI or Authority.
   HTTPRedirect redirect = 3;
 
+  // Added by ingress
+  // This policy will trigger an internal redirect according to the response code
+  // without notifying downstream.
+  HTTPInternalActiveRedirect internal_active_redirect = 25;
+
+  // Added by ingress
+  // Return an arbitrary HTTP response directly, without proxying.
+  HTTPDirectResponse direct_response = 26;
+
   // Delegate is used to specify the particular VirtualService which
   // can be used to define delegate HTTPRoute.
   //
@@ -1269,6 +1284,9 @@ message HTTPRouteDestination {
 
   // Header manipulation rules
   Headers headers = 7;
+
+  // Added by ingress
+  repeated Destination fallback_clusters = 100;
 }
 
 // L4 routing rule weighted destination.
@@ -1437,6 +1455,61 @@ message HTTPRedirect {
   uint32 redirect_code = 3;
 }
 
+
+// More detail information, please see envoy document about InternalRedirectPolicy.
+// The only difference is that this redirect policy allow user to specify how to control the redirect url.
+message HTTPInternalActiveRedirect {
+  uint32 max_internal_redirects = 1;
+  // Invalid code is in [200, 301, 302, 303, 304, 307, 308]
+  repeated uint32 redirect_response_codes = 2;
+  oneof redirect_url_rewrite_specifier {
+    string redirect_url = 3;
+    RegexMatchAndSubstitute redirect_url_rewrite_regex = 4;
+  }
+  bool allow_cross_scheme = 5;
+  // Currently, only support for the add operation for request header.
+  Headers headers = 6;
+
+  // During internal redirect, rewrite the Authority/Host header with this value.
+  string authority = 7;
+
+  // If true, the host name in the downstream request is used for redirection.
+  bool forced_use_original_host = 16;
+
+  bool forced_add_header_before_route_matcher = 17;
+
+  message RedirectPolicy {
+    uint32 max_internal_redirects = 8;
+    // Invalid code is in [200, 301, 302, 303, 304, 307, 308]
+    repeated uint32 redirect_response_codes = 9;
+    oneof redirect_url_rewrite_specifier {
+      string redirect_url = 10;
+      RegexMatchAndSubstitute redirect_url_rewrite_regex = 11;
+    }
+    bool allow_cross_scheme = 12;
+    // Currently, only support for the add operation for request header.
+    Headers headers = 13;
+
+    // During internal redirect, rewrite the Authority/Host header with this value.
+    string authority = 14;
+
+    // If true, the host name in the downstream request is used for redirection.
+    bool forced_use_original_host = 17;
+
+    bool forced_add_header_before_route_matcher = 18;
+  }
+  repeated RedirectPolicy policies = 15;
+}
+
+// Added by ingress
+// Return an arbitrary HTTP response directly, without proxying.
+message HTTPDirectResponse {
+  // Response code for downstream client.
+  uint32 response_code = 1;
+  // TODO Support filename, bytes or not
+  string body = 2;
+}
+
 // HTTPRewrite can be used to rewrite specific parts of a HTTP request
 // before forwarding the request to the destination. Rewrite primitive can
 // be used only with HTTPRouteDestination. The following example
@@ -1497,6 +1570,21 @@ message HTTPRewrite {
 
   // rewrite the Authority/Host header with this value.
   string authority = 2;
+
+  // uri_regex can be used for rewriting portions of path that match the
+  // pattern during forwarding the request
+  // RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
+  RegexMatchAndSubstitute uri_regex = 3;
+}
+
+// Describes how to match a string and then produce a new string using a regular
+// expression and a substitution string.
+message RegexMatchAndSubstitute {
+  // RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
+  string pattern = 1;
+  // The string that should be substituted into matching portions of the
+  // subject string during a substitution operation to produce a new string.
+  string substitution = 2;
 }
 
 // Describes how to match a given string in HTTP headers. Match is
@@ -1873,3 +1961,39 @@ message PortSelector {
 message Percent {
   double value = 1;
 }
+
+message HTTPFilter {
+  // The http filter name should be meaningful.
+  // E.g. ip-access-control, jwt, rbac, cors.
+  string name = 1;
+
+  // Disable this filter and all request will pass.
+  bool disable = 2;
+
+  oneof Filter {
+    IPAccessControl ip_access_control = 3;
+
+    LocalRateLimit local_rate_limit = 4;
+  }
+}
+
+message IPAccessControl {
+  // Used for white ip access control
+  repeated string remote_ip_blocks = 1;
+
+  // Used for black ip access control
+  repeated string not_remote_ip_blocks = 2;
+}
+
+message LocalRateLimit {
+  TokenBucket token_bucket = 1;
+  bool per_downstream_connection = 2;
+  // Default rate limit status code is 429.
+  uint32 status_code = 3;
+}
+
+message TokenBucket {
+  uint32 max_tokens = 1;
+  uint32 tokens_pef_fill = 2;
+  google.protobuf.Duration fill_interval = 3;
+}
diff --git a/networking/v1alpha3/virtual_service_deepcopy.gen.go b/networking/v1alpha3/virtual_service_deepcopy.gen.go
index dfca279b..c19a88e3 100644
--- a/networking/v1alpha3/virtual_service_deepcopy.gen.go
+++ b/networking/v1alpha3/virtual_service_deepcopy.gen.go
@@ -458,6 +458,69 @@ func (in *HTTPRedirect) DeepCopyInterface() interface{} {
 	return in.DeepCopy()
 }
 
+// DeepCopyInto supports using HTTPInternalActiveRedirect within kubernetes types, where deepcopy-gen is used.
+func (in *HTTPInternalActiveRedirect) DeepCopyInto(out *HTTPInternalActiveRedirect) {
+	p := proto.Clone(in).(*HTTPInternalActiveRedirect)
+	*out = *p
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new HTTPInternalActiveRedirect. Required by controller-gen.
+func (in *HTTPInternalActiveRedirect) DeepCopy() *HTTPInternalActiveRedirect {
+	if in == nil {
+		return nil
+	}
+	out := new(HTTPInternalActiveRedirect)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInterface is an autogenerated deepcopy function, copying the receiver, creating a new HTTPInternalActiveRedirect. Required by controller-gen.
+func (in *HTTPInternalActiveRedirect) DeepCopyInterface() interface{} {
+	return in.DeepCopy()
+}
+
+// DeepCopyInto supports using HTTPInternalActiveRedirect_RedirectPolicy within kubernetes types, where deepcopy-gen is used.
+func (in *HTTPInternalActiveRedirect_RedirectPolicy) DeepCopyInto(out *HTTPInternalActiveRedirect_RedirectPolicy) {
+	p := proto.Clone(in).(*HTTPInternalActiveRedirect_RedirectPolicy)
+	*out = *p
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new HTTPInternalActiveRedirect_RedirectPolicy. Required by controller-gen.
+func (in *HTTPInternalActiveRedirect_RedirectPolicy) DeepCopy() *HTTPInternalActiveRedirect_RedirectPolicy {
+	if in == nil {
+		return nil
+	}
+	out := new(HTTPInternalActiveRedirect_RedirectPolicy)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInterface is an autogenerated deepcopy function, copying the receiver, creating a new HTTPInternalActiveRedirect_RedirectPolicy. Required by controller-gen.
+func (in *HTTPInternalActiveRedirect_RedirectPolicy) DeepCopyInterface() interface{} {
+	return in.DeepCopy()
+}
+
+// DeepCopyInto supports using HTTPDirectResponse within kubernetes types, where deepcopy-gen is used.
+func (in *HTTPDirectResponse) DeepCopyInto(out *HTTPDirectResponse) {
+	p := proto.Clone(in).(*HTTPDirectResponse)
+	*out = *p
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new HTTPDirectResponse. Required by controller-gen.
+func (in *HTTPDirectResponse) DeepCopy() *HTTPDirectResponse {
+	if in == nil {
+		return nil
+	}
+	out := new(HTTPDirectResponse)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInterface is an autogenerated deepcopy function, copying the receiver, creating a new HTTPDirectResponse. Required by controller-gen.
+func (in *HTTPDirectResponse) DeepCopyInterface() interface{} {
+	return in.DeepCopy()
+}
+
 // DeepCopyInto supports using HTTPRewrite within kubernetes types, where deepcopy-gen is used.
 func (in *HTTPRewrite) DeepCopyInto(out *HTTPRewrite) {
 	p := proto.Clone(in).(*HTTPRewrite)
@@ -479,6 +542,27 @@ func (in *HTTPRewrite) DeepCopyInterface() interface{} {
 	return in.DeepCopy()
 }
 
+// DeepCopyInto supports using RegexMatchAndSubstitute within kubernetes types, where deepcopy-gen is used.
+func (in *RegexMatchAndSubstitute) DeepCopyInto(out *RegexMatchAndSubstitute) {
+	p := proto.Clone(in).(*RegexMatchAndSubstitute)
+	*out = *p
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RegexMatchAndSubstitute. Required by controller-gen.
+func (in *RegexMatchAndSubstitute) DeepCopy() *RegexMatchAndSubstitute {
+	if in == nil {
+		return nil
+	}
+	out := new(RegexMatchAndSubstitute)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInterface is an autogenerated deepcopy function, copying the receiver, creating a new RegexMatchAndSubstitute. Required by controller-gen.
+func (in *RegexMatchAndSubstitute) DeepCopyInterface() interface{} {
+	return in.DeepCopy()
+}
+
 // DeepCopyInto supports using StringMatch within kubernetes types, where deepcopy-gen is used.
 func (in *StringMatch) DeepCopyInto(out *StringMatch) {
 	p := proto.Clone(in).(*StringMatch)
@@ -646,3 +730,87 @@ func (in *Percent) DeepCopy() *Percent {
 func (in *Percent) DeepCopyInterface() interface{} {
 	return in.DeepCopy()
 }
+
+// DeepCopyInto supports using HTTPFilter within kubernetes types, where deepcopy-gen is used.
+func (in *HTTPFilter) DeepCopyInto(out *HTTPFilter) {
+	p := proto.Clone(in).(*HTTPFilter)
+	*out = *p
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new HTTPFilter. Required by controller-gen.
+func (in *HTTPFilter) DeepCopy() *HTTPFilter {
+	if in == nil {
+		return nil
+	}
+	out := new(HTTPFilter)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInterface is an autogenerated deepcopy function, copying the receiver, creating a new HTTPFilter. Required by controller-gen.
+func (in *HTTPFilter) DeepCopyInterface() interface{} {
+	return in.DeepCopy()
+}
+
+// DeepCopyInto supports using IPAccessControl within kubernetes types, where deepcopy-gen is used.
+func (in *IPAccessControl) DeepCopyInto(out *IPAccessControl) {
+	p := proto.Clone(in).(*IPAccessControl)
+	*out = *p
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new IPAccessControl. Required by controller-gen.
+func (in *IPAccessControl) DeepCopy() *IPAccessControl {
+	if in == nil {
+		return nil
+	}
+	out := new(IPAccessControl)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInterface is an autogenerated deepcopy function, copying the receiver, creating a new IPAccessControl. Required by controller-gen.
+func (in *IPAccessControl) DeepCopyInterface() interface{} {
+	return in.DeepCopy()
+}
+
+// DeepCopyInto supports using LocalRateLimit within kubernetes types, where deepcopy-gen is used.
+func (in *LocalRateLimit) DeepCopyInto(out *LocalRateLimit) {
+	p := proto.Clone(in).(*LocalRateLimit)
+	*out = *p
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalRateLimit. Required by controller-gen.
+func (in *LocalRateLimit) DeepCopy() *LocalRateLimit {
+	if in == nil {
+		return nil
+	}
+	out := new(LocalRateLimit)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInterface is an autogenerated deepcopy function, copying the receiver, creating a new LocalRateLimit. Required by controller-gen.
+func (in *LocalRateLimit) DeepCopyInterface() interface{} {
+	return in.DeepCopy()
+}
+
+// DeepCopyInto supports using TokenBucket within kubernetes types, where deepcopy-gen is used.
+func (in *TokenBucket) DeepCopyInto(out *TokenBucket) {
+	p := proto.Clone(in).(*TokenBucket)
+	*out = *p
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new TokenBucket. Required by controller-gen.
+func (in *TokenBucket) DeepCopy() *TokenBucket {
+	if in == nil {
+		return nil
+	}
+	out := new(TokenBucket)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInterface is an autogenerated deepcopy function, copying the receiver, creating a new TokenBucket. Required by controller-gen.
+func (in *TokenBucket) DeepCopyInterface() interface{} {
+	return in.DeepCopy()
+}
diff --git a/networking/v1alpha3/virtual_service_json.gen.go b/networking/v1alpha3/virtual_service_json.gen.go
index 474f22a8..58311ff3 100644
--- a/networking/v1alpha3/virtual_service_json.gen.go
+++ b/networking/v1alpha3/virtual_service_json.gen.go
@@ -320,6 +320,39 @@ func (this *HTTPRedirect) UnmarshalJSON(b []byte) error {
 	return VirtualServiceUnmarshaler.Unmarshal(bytes.NewReader(b), this)
 }
 
+// MarshalJSON is a custom marshaler for HTTPInternalActiveRedirect
+func (this *HTTPInternalActiveRedirect) MarshalJSON() ([]byte, error) {
+	str, err := VirtualServiceMarshaler.MarshalToString(this)
+	return []byte(str), err
+}
+
+// UnmarshalJSON is a custom unmarshaler for HTTPInternalActiveRedirect
+func (this *HTTPInternalActiveRedirect) UnmarshalJSON(b []byte) error {
+	return VirtualServiceUnmarshaler.Unmarshal(bytes.NewReader(b), this)
+}
+
+// MarshalJSON is a custom marshaler for HTTPInternalActiveRedirect_RedirectPolicy
+func (this *HTTPInternalActiveRedirect_RedirectPolicy) MarshalJSON() ([]byte, error) {
+	str, err := VirtualServiceMarshaler.MarshalToString(this)
+	return []byte(str), err
+}
+
+// UnmarshalJSON is a custom unmarshaler for HTTPInternalActiveRedirect_RedirectPolicy
+func (this *HTTPInternalActiveRedirect_RedirectPolicy) UnmarshalJSON(b []byte) error {
+	return VirtualServiceUnmarshaler.Unmarshal(bytes.NewReader(b), this)
+}
+
+// MarshalJSON is a custom marshaler for HTTPDirectResponse
+func (this *HTTPDirectResponse) MarshalJSON() ([]byte, error) {
+	str, err := VirtualServiceMarshaler.MarshalToString(this)
+	return []byte(str), err
+}
+
+// UnmarshalJSON is a custom unmarshaler for HTTPDirectResponse
+func (this *HTTPDirectResponse) UnmarshalJSON(b []byte) error {
+	return VirtualServiceUnmarshaler.Unmarshal(bytes.NewReader(b), this)
+}
+
 // MarshalJSON is a custom marshaler for HTTPRewrite
 func (this *HTTPRewrite) MarshalJSON() ([]byte, error) {
 	str, err := VirtualServiceMarshaler.MarshalToString(this)
@@ -331,6 +364,17 @@ func (this *HTTPRewrite) UnmarshalJSON(b []byte) error {
 	return VirtualServiceUnmarshaler.Unmarshal(bytes.NewReader(b), this)
 }
 
+// MarshalJSON is a custom marshaler for RegexMatchAndSubstitute
+func (this *RegexMatchAndSubstitute) MarshalJSON() ([]byte, error) {
+	str, err := VirtualServiceMarshaler.MarshalToString(this)
+	return []byte(str), err
+}
+
+// UnmarshalJSON is a custom unmarshaler for RegexMatchAndSubstitute
+func (this *RegexMatchAndSubstitute) UnmarshalJSON(b []byte) error {
+	return VirtualServiceUnmarshaler.Unmarshal(bytes.NewReader(b), this)
+}
+
 // MarshalJSON is a custom marshaler for StringMatch
 func (this *StringMatch) MarshalJSON() ([]byte, error) {
 	str, err := VirtualServiceMarshaler.MarshalToString(this)
@@ -419,6 +463,50 @@ func (this *Percent) UnmarshalJSON(b []byte) error {
 	return VirtualServiceUnmarshaler.Unmarshal(bytes.NewReader(b), this)
 }
 
+// MarshalJSON is a custom marshaler for HTTPFilter
+func (this *HTTPFilter) MarshalJSON() ([]byte, error) {
+	str, err := VirtualServiceMarshaler.MarshalToString(this)
+	return []byte(str), err
+}
+
+// UnmarshalJSON is a custom unmarshaler for HTTPFilter
+func (this *HTTPFilter) UnmarshalJSON(b []byte) error {
+	return VirtualServiceUnmarshaler.Unmarshal(bytes.NewReader(b), this)
+}
+
+// MarshalJSON is a custom marshaler for IPAccessControl
+func (this *IPAccessControl) MarshalJSON() ([]byte, error) {
+	str, err := VirtualServiceMarshaler.MarshalToString(this)
+	return []byte(str), err
+}
+
+// UnmarshalJSON is a custom unmarshaler for IPAccessControl
+func (this *IPAccessControl) UnmarshalJSON(b []byte) error {
+	return VirtualServiceUnmarshaler.Unmarshal(bytes.NewReader(b), this)
+}
+
+// MarshalJSON is a custom marshaler for LocalRateLimit
+func (this *LocalRateLimit) MarshalJSON() ([]byte, error) {
+	str, err := VirtualServiceMarshaler.MarshalToString(this)
+	return []byte(str), err
+}
+
+// UnmarshalJSON is a custom unmarshaler for LocalRateLimit
+func (this *LocalRateLimit) UnmarshalJSON(b []byte) error {
+	return VirtualServiceUnmarshaler.Unmarshal(bytes.NewReader(b), this)
+}
+
+// MarshalJSON is a custom marshaler for TokenBucket
+func (this *TokenBucket) MarshalJSON() ([]byte, error) {
+	str, err := VirtualServiceMarshaler.MarshalToString(this)
+	return []byte(str), err
+}
+
+// UnmarshalJSON is a custom unmarshaler for TokenBucket
+func (this *TokenBucket) UnmarshalJSON(b []byte) error {
+	return VirtualServiceUnmarshaler.Unmarshal(bytes.NewReader(b), this)
+}
+
 var (
 	VirtualServiceMarshaler   = &github_com_gogo_protobuf_jsonpb.Marshaler{}
 	VirtualServiceUnmarshaler = &github_com_gogo_protobuf_jsonpb.Unmarshaler{AllowUnknownFields: true}
diff --git a/networking/v1beta1/destination_rule.gen.json b/networking/v1beta1/destination_rule.gen.json
index 208b0db6..311fe9f1 100644
--- a/networking/v1beta1/destination_rule.gen.json
+++ b/networking/v1beta1/destination_rule.gen.json
@@ -178,12 +178,297 @@
           }
         }
       },
+      "istio.networking.v1beta1.HealthCheck": {
+        "description": "[#next-free-field: 25]",
+        "type": "object",
+        "properties": {
+          "timeout": {
+            "description": "The time to wait for a health check response. If the timeout is reached the health check attempt will be considered a failure.",
+            "type": "string"
+          },
+          "interval": {
+            "description": "The interval between health checks.",
+            "type": "string"
+          },
+          "initialJitter": {
+            "description": "An optional jitter amount in milliseconds. If specified, Envoy will start health checking after for a random time in ms between 0 and initial_jitter. This only applies to the first health check.",
+            "type": "string"
+          },
+          "intervalJitter": {
+            "description": "An optional jitter amount in milliseconds. If specified, during every interval Envoy will add interval_jitter to the wait time.",
+            "type": "string"
+          },
+          "intervalJitterPercent": {
+            "description": "An optional jitter amount as a percentage of interval_ms. If specified, during every interval Envoy will add interval_ms * interval_jitter_percent / 100 to the wait time.",
+            "type": "integer"
+          },
+          "unhealthyThreshold": {
+            "description": "The number of unhealthy health checks required before a host is marked unhealthy. Note that for *http* health checking if a host responds with a code not in",
+            "type": "integer",
+            "nullable": true
+          },
+          "healthyThreshold": {
+            "description": "The number of healthy health checks required before a host is marked healthy. Note that during startup, only a single successful health check is required to mark a host healthy.",
+            "type": "integer",
+            "nullable": true
+          },
+          "altPort": {
+            "type": "integer",
+            "nullable": true
+          },
+          "reuseConnection": {
+            "type": "boolean",
+            "nullable": true
+          },
+          "noTrafficInterval": {
+            "description": "The default value for \"no traffic interval\" is 60 seconds.",
+            "type": "string"
+          },
+          "noTrafficHealthyInterval": {
+            "description": "If no_traffic_healthy_interval is not set, it will default to the no traffic interval and send that interval regardless of health state.",
+            "type": "string"
+          },
+          "unhealthyInterval": {
+            "description": "The default value for \"unhealthy interval\" is the same as \"interval\".",
+            "type": "string"
+          },
+          "unhealthyEdgeInterval": {
+            "description": "The default value for \"unhealthy edge interval\" is the same as \"unhealthy interval\".",
+            "type": "string"
+          },
+          "healthyEdgeInterval": {
+            "description": "The default value for \"healthy edge interval\" is the same as the default interval.",
+            "type": "string"
+          },
+          "eventLogPath": {
+            "description": "Specifies the path to the :ref:`health check event log \u003carch_overview_health_check_logging\u003e`. If empty, no event log will be written.",
+            "type": "string"
+          },
+          "alwaysLogHealthCheckFailures": {
+            "type": "boolean"
+          },
+          "tlsOptions": {
+            "$ref": "#/components/schemas/istio.networking.v1beta1.HealthCheck.TlsOptions"
+          }
+        },
+        "oneOf": [
+          {
+            "not": {
+              "anyOf": [
+                {
+                  "required": [
+                    "httpHealthCheck"
+                  ],
+                  "properties": {
+                    "httpHealthCheck": {
+                      "$ref": "#/components/schemas/istio.networking.v1beta1.HealthCheck.HttpHealthCheck"
+                    }
+                  }
+                },
+                {
+                  "required": [
+                    "tcpHealthCheck"
+                  ],
+                  "properties": {
+                    "tcpHealthCheck": {
+                      "$ref": "#/components/schemas/istio.networking.v1beta1.HealthCheck.TcpHealthCheck"
+                    }
+                  }
+                },
+                {
+                  "required": [
+                    "grpcHealthCheck"
+                  ],
+                  "properties": {
+                    "grpcHealthCheck": {
+                      "$ref": "#/components/schemas/istio.networking.v1beta1.HealthCheck.GrpcHealthCheck"
+                    }
+                  }
+                },
+                {
+                  "required": [
+                    "customHealthCheck"
+                  ],
+                  "properties": {
+                    "customHealthCheck": {
+                      "$ref": "#/components/schemas/istio.networking.v1beta1.HealthCheck.CustomHealthCheck"
+                    }
+                  }
+                }
+              ]
+            }
+          },
+          {
+            "required": [
+              "httpHealthCheck"
+            ],
+            "properties": {
+              "httpHealthCheck": {
+                "$ref": "#/components/schemas/istio.networking.v1beta1.HealthCheck.HttpHealthCheck"
+              }
+            }
+          },
+          {
+            "required": [
+              "tcpHealthCheck"
+            ],
+            "properties": {
+              "tcpHealthCheck": {
+                "$ref": "#/components/schemas/istio.networking.v1beta1.HealthCheck.TcpHealthCheck"
+              }
+            }
+          },
+          {
+            "required": [
+              "grpcHealthCheck"
+            ],
+            "properties": {
+              "grpcHealthCheck": {
+                "$ref": "#/components/schemas/istio.networking.v1beta1.HealthCheck.GrpcHealthCheck"
+              }
+            }
+          },
+          {
+            "required": [
+              "customHealthCheck"
+            ],
+            "properties": {
+              "customHealthCheck": {
+                "$ref": "#/components/schemas/istio.networking.v1beta1.HealthCheck.CustomHealthCheck"
+              }
+            }
+          }
+        ]
+      },
+      "istio.networking.v1beta1.HealthCheck.CustomHealthCheck": {
+        "description": "Custom health check.",
+        "type": "object",
+        "properties": {
+          "name": {
+            "description": "The registered name of the custom health checker.",
+            "type": "string"
+          }
+        }
+      },
+      "istio.networking.v1beta1.HealthCheck.GrpcHealthCheck": {
+        "type": "object",
+        "properties": {
+          "serviceName": {
+            "type": "string"
+          },
+          "authority": {
+            "type": "string"
+          }
+        }
+      },
+      "istio.networking.v1beta1.HealthCheck.HttpHealthCheck": {
+        "description": "[#next-free-field: 13]",
+        "type": "object",
+        "properties": {
+          "host": {
+            "type": "string"
+          },
+          "path": {
+            "description": "Specifies the HTTP path that will be requested during health checking.",
+            "type": "string"
+          },
+          "send": {
+            "$ref": "#/components/schemas/istio.networking.v1beta1.Payload"
+          },
+          "receive": {
+            "$ref": "#/components/schemas/istio.networking.v1beta1.Payload"
+          },
+          "expectedStatuses": {
+            "description": "Specifies a list of HTTP response statuses considered healthy. If provided, replaces default 200-only policy - 200 must be included explicitly as needed. Ranges follow half-open semantics of :ref:`Int64Range \u003cenvoy_v3_api_msg_type.v3.Int64Range\u003e`. The start and end of each range are required. Only statuses in the range [100, 600) are allowed.",
+            "type": "array",
+            "items": {
+              "$ref": "#/components/schemas/istio.networking.v1beta1.Int64Range"
+            }
+          },
+          "retriableStatuses": {
+            "type": "array",
+            "items": {
+              "$ref": "#/components/schemas/istio.networking.v1beta1.Int64Range"
+            }
+          }
+        }
+      },
+      "istio.networking.v1beta1.HealthCheck.TcpHealthCheck": {
+        "type": "object",
+        "properties": {
+          "send": {
+            "$ref": "#/components/schemas/istio.networking.v1beta1.Payload"
+          },
+          "receive": {
+            "type": "array",
+            "items": {
+              "$ref": "#/components/schemas/istio.networking.v1beta1.Payload"
+            }
+          }
+        }
+      },
+      "istio.networking.v1beta1.HealthCheck.TlsOptions": {
+        "description": "Health checks occur over the transport socket specified for the cluster. This implies that if a cluster is using a TLS-enabled transport socket, the health check will also occur over TLS.",
+        "type": "object",
+        "properties": {
+          "alpnProtocols": {
+            "type": "array",
+            "items": {
+              "type": "string"
+            }
+          }
+        }
+      },
+      "istio.networking.v1beta1.HealthStatus": {
+        "description": "Endpoint health status.",
+        "type": "string",
+        "enum": [
+          "UNKNOWN",
+          "HEALTHY",
+          "UNHEALTHY",
+          "DRAINING",
+          "TIMEOUT",
+          "DEGRADED"
+        ]
+      },
+      "istio.networking.v1beta1.HealthStatusSet": {
+        "type": "object",
+        "properties": {
+          "statuses": {
+            "description": "An order-independent set of health status.",
+            "type": "array",
+            "items": {
+              "$ref": "#/components/schemas/istio.networking.v1beta1.HealthStatus"
+            }
+          }
+        }
+      },
+      "istio.networking.v1beta1.Int64Range": {
+        "description": "Added by Ingress",
+        "type": "object",
+        "properties": {
+          "start": {
+            "description": "start of the range (inclusive)",
+            "type": "integer",
+            "format": "int64"
+          },
+          "end": {
+            "description": "end of the range (exclusive)",
+            "type": "integer",
+            "format": "int64"
+          }
+        }
+      },
       "istio.networking.v1beta1.LoadBalancerSettings": {
         "description": "Load balancing policies to apply for a specific destination. See Envoy's load balancing [documentation](https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/upstream/load_balancing/load_balancing) for more details.",
         "type": "object",
         "properties": {
           "localityLbSetting": {
             "$ref": "#/components/schemas/istio.networking.v1beta1.LocalityLoadBalancerSetting"
+          },
+          "warmupDurationSecs": {
+            "description": "Represents the warmup duration of Service. If set, the newly created endpoint of service remains in warmup mode starting from its creation time for the duration of this window and Istio progressively increases amount of traffic for that endpoint instead of sending proportional amount of traffic. This should be enabled for services that require warm up time to serve full production load with reasonable latency. Currently this is only supported for ROUND_ROBIN and LEAST_CONN load balancers.",
+            "type": "string"
           }
         },
         "oneOf": [
@@ -479,6 +764,59 @@
           }
         }
       },
+      "istio.networking.v1beta1.Payload": {
+        "type": "object",
+        "oneOf": [
+          {
+            "not": {
+              "anyOf": [
+                {
+                  "required": [
+                    "text"
+                  ],
+                  "properties": {
+                    "text": {
+                      "type": "string"
+                    }
+                  }
+                },
+                {
+                  "required": [
+                    "binary"
+                  ],
+                  "properties": {
+                    "binary": {
+                      "type": "string",
+                      "format": "binary"
+                    }
+                  }
+                }
+              ]
+            }
+          },
+          {
+            "required": [
+              "text"
+            ],
+            "properties": {
+              "text": {
+                "type": "string"
+              }
+            }
+          },
+          {
+            "required": [
+              "binary"
+            ],
+            "properties": {
+              "binary": {
+                "type": "string",
+                "format": "binary"
+              }
+            }
+          }
+        ]
+      },
       "istio.networking.v1beta1.PortSelector": {
         "description": "PortSelector specifies the number of a port to be used for matching or selection for final routing.",
         "type": "object",
@@ -531,6 +869,12 @@
             "items": {
               "$ref": "#/components/schemas/istio.networking.v1beta1.TrafficPolicy.PortTrafficPolicy"
             }
+          },
+          "healthChecks": {
+            "type": "array",
+            "items": {
+              "$ref": "#/components/schemas/istio.networking.v1beta1.HealthCheck"
+            }
           }
         }
       },
@@ -552,6 +896,12 @@
           },
           "tls": {
             "$ref": "#/components/schemas/istio.networking.v1beta1.ClientTLSSettings"
+          },
+          "healthChecks": {
+            "type": "array",
+            "items": {
+              "$ref": "#/components/schemas/istio.networking.v1beta1.HealthCheck"
+            }
           }
         }
       }
diff --git a/networking/v1beta1/destination_rule.pb.go b/networking/v1beta1/destination_rule.pb.go
index 85d5ca5b..25ba617f 100644
--- a/networking/v1beta1/destination_rule.pb.go
+++ b/networking/v1beta1/destination_rule.pb.go
@@ -165,6 +165,47 @@ var _ = math.Inf
 // proto package needs to be updated.
 const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package
 
+// Endpoint health status.
+type HealthStatus int32
+
+const (
+	// The health status is not known. This is interpreted by Envoy as *HEALTHY*.
+	HealthStatus_UNKNOWN HealthStatus = 0
+	// Healthy.
+	HealthStatus_HEALTHY HealthStatus = 1
+	// Unhealthy.
+	HealthStatus_UNHEALTHY HealthStatus = 2
+	HealthStatus_DRAINING  HealthStatus = 3
+	HealthStatus_TIMEOUT   HealthStatus = 4
+	HealthStatus_DEGRADED  HealthStatus = 5
+)
+
+var HealthStatus_name = map[int32]string{
+	0: "UNKNOWN",
+	1: "HEALTHY",
+	2: "UNHEALTHY",
+	3: "DRAINING",
+	4: "TIMEOUT",
+	5: "DEGRADED",
+}
+
+var HealthStatus_value = map[string]int32{
+	"UNKNOWN":   0,
+	"HEALTHY":   1,
+	"UNHEALTHY": 2,
+	"DRAINING":  3,
+	"TIMEOUT":   4,
+	"DEGRADED":  5,
+}
+
+func (x HealthStatus) String() string {
+	return proto.EnumName(HealthStatus_name, int32(x))
+}
+
+func (HealthStatus) EnumDescriptor() ([]byte, []int) {
+	return fileDescriptor_31054629b619ca4b, []int{0}
+}
+
 // Standard load balancing algorithms that require no tuning.
 type LoadBalancerSettings_SimpleLB int32
 
@@ -434,6 +475,7 @@ type TrafficPolicy struct {
 	// overridden by port-level settings, i.e. default values will be applied
 	// to fields omitted in port-level traffic policies.
 	PortLevelSettings    []*TrafficPolicy_PortTrafficPolicy `protobuf:"bytes,5,rep,name=port_level_settings,json=portLevelSettings,proto3" json:"port_level_settings,omitempty"`
+	HealthChecks         []*HealthCheck                     `protobuf:"bytes,101,rep,name=health_checks,json=healthChecks,proto3" json:"health_checks,omitempty"`
 	XXX_NoUnkeyedLiteral struct{}                           `json:"-"`
 	XXX_unrecognized     []byte                             `json:"-"`
 	XXX_sizecache        int32                              `json:"-"`
@@ -507,6 +549,13 @@ func (m *TrafficPolicy) GetPortLevelSettings() []*TrafficPolicy_PortTrafficPolic
 	return nil
 }
 
+func (m *TrafficPolicy) GetHealthChecks() []*HealthCheck {
+	if m != nil {
+		return m.HealthChecks
+	}
+	return nil
+}
+
 // Traffic policies that apply to specific ports of the service
 type TrafficPolicy_PortTrafficPolicy struct {
 	// Specifies the number of a port on the destination service
@@ -521,6 +570,7 @@ type TrafficPolicy_PortTrafficPolicy struct {
 	OutlierDetection *OutlierDetection `protobuf:"bytes,4,opt,name=outlier_detection,json=outlierDetection,proto3" json:"outlier_detection,omitempty"`
 	// TLS related settings for connections to the upstream service.
 	Tls                  *ClientTLSSettings `protobuf:"bytes,5,opt,name=tls,proto3" json:"tls,omitempty"`
+	HealthChecks         []*HealthCheck     `protobuf:"bytes,101,rep,name=health_checks,json=healthChecks,proto3" json:"health_checks,omitempty"`
 	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
 	XXX_unrecognized     []byte             `json:"-"`
 	XXX_sizecache        int32              `json:"-"`
@@ -594,6 +644,13 @@ func (m *TrafficPolicy_PortTrafficPolicy) GetTls() *ClientTLSSettings {
 	return nil
 }
 
+func (m *TrafficPolicy_PortTrafficPolicy) GetHealthChecks() []*HealthCheck {
+	if m != nil {
+		return m.HealthChecks
+	}
+	return nil
+}
+
 // A subset of endpoints of a service. Subsets can be used for scenarios
 // like A/B testing, or routing to a specific version of a service. Refer
 // to [VirtualService](https://istio.io/docs/reference/config/networking/virtual-service/#VirtualService) documentation for examples of using
@@ -813,10 +870,16 @@ type LoadBalancerSettings struct {
 	LbPolicy isLoadBalancerSettings_LbPolicy `protobuf_oneof:"lb_policy"`
 	// Locality load balancer settings, this will override mesh wide settings in entirety, meaning no merging would be performed
 	// between this object and the object one in MeshConfig
-	LocalityLbSetting    *LocalityLoadBalancerSetting `protobuf:"bytes,3,opt,name=locality_lb_setting,json=localityLbSetting,proto3" json:"locality_lb_setting,omitempty"`
-	XXX_NoUnkeyedLiteral struct{}                     `json:"-"`
-	XXX_unrecognized     []byte                       `json:"-"`
-	XXX_sizecache        int32                        `json:"-"`
+	LocalityLbSetting *LocalityLoadBalancerSetting `protobuf:"bytes,3,opt,name=locality_lb_setting,json=localityLbSetting,proto3" json:"locality_lb_setting,omitempty"`
+	// Represents the warmup duration of Service. If set, the newly created endpoint of service
+	// remains in warmup mode starting from its creation time for the duration of this window and
+	// Istio progressively increases amount of traffic for that endpoint instead of sending proportional amount of traffic.
+	// This should be enabled for services that require warm up time to serve full production load with reasonable latency.
+	// Currently this is only supported for ROUND_ROBIN and LEAST_CONN load balancers.
+	WarmupDurationSecs   *types.Duration `protobuf:"bytes,4,opt,name=warmup_duration_secs,json=warmupDurationSecs,proto3" json:"warmup_duration_secs,omitempty"`
+	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
+	XXX_unrecognized     []byte          `json:"-"`
+	XXX_sizecache        int32           `json:"-"`
 }
 
 func (m *LoadBalancerSettings) Reset()         { *m = LoadBalancerSettings{} }
@@ -896,6 +959,13 @@ func (m *LoadBalancerSettings) GetLocalityLbSetting() *LocalityLoadBalancerSetti
 	return nil
 }
 
+func (m *LoadBalancerSettings) GetWarmupDurationSecs() *types.Duration {
+	if m != nil {
+		return m.WarmupDurationSecs
+	}
+	return nil
+}
+
 // XXX_OneofWrappers is for the internal use of the proto package.
 func (*LoadBalancerSettings) XXX_OneofWrappers() []interface{} {
 	return []interface{}{
@@ -2270,763 +2340,1051 @@ func (m *LocalityLoadBalancerSetting_Failover) GetTo() string {
 	return ""
 }
 
-func init() {
-	proto.RegisterEnum("istio.networking.v1beta1.LoadBalancerSettings_SimpleLB", LoadBalancerSettings_SimpleLB_name, LoadBalancerSettings_SimpleLB_value)
-	proto.RegisterEnum("istio.networking.v1beta1.ConnectionPoolSettings_HTTPSettings_H2UpgradePolicy", ConnectionPoolSettings_HTTPSettings_H2UpgradePolicy_name, ConnectionPoolSettings_HTTPSettings_H2UpgradePolicy_value)
-	proto.RegisterEnum("istio.networking.v1beta1.ClientTLSSettings_TLSmode", ClientTLSSettings_TLSmode_name, ClientTLSSettings_TLSmode_value)
-	proto.RegisterType((*DestinationRule)(nil), "istio.networking.v1beta1.DestinationRule")
-	proto.RegisterType((*TrafficPolicy)(nil), "istio.networking.v1beta1.TrafficPolicy")
-	proto.RegisterType((*TrafficPolicy_PortTrafficPolicy)(nil), "istio.networking.v1beta1.TrafficPolicy.PortTrafficPolicy")
-	proto.RegisterType((*Subset)(nil), "istio.networking.v1beta1.Subset")
-	proto.RegisterMapType((map[string]string)(nil), "istio.networking.v1beta1.Subset.LabelsEntry")
-	proto.RegisterType((*LoadBalancerSettings)(nil), "istio.networking.v1beta1.LoadBalancerSettings")
-	proto.RegisterType((*LoadBalancerSettings_ConsistentHashLB)(nil), "istio.networking.v1beta1.LoadBalancerSettings.ConsistentHashLB")
-	proto.RegisterType((*LoadBalancerSettings_ConsistentHashLB_HTTPCookie)(nil), "istio.networking.v1beta1.LoadBalancerSettings.ConsistentHashLB.HTTPCookie")
-	proto.RegisterType((*ConnectionPoolSettings)(nil), "istio.networking.v1beta1.ConnectionPoolSettings")
-	proto.RegisterType((*ConnectionPoolSettings_TCPSettings)(nil), "istio.networking.v1beta1.ConnectionPoolSettings.TCPSettings")
-	proto.RegisterType((*ConnectionPoolSettings_TCPSettings_TcpKeepalive)(nil), "istio.networking.v1beta1.ConnectionPoolSettings.TCPSettings.TcpKeepalive")
-	proto.RegisterType((*ConnectionPoolSettings_HTTPSettings)(nil), "istio.networking.v1beta1.ConnectionPoolSettings.HTTPSettings")
-	proto.RegisterType((*OutlierDetection)(nil), "istio.networking.v1beta1.OutlierDetection")
-	proto.RegisterType((*ClientTLSSettings)(nil), "istio.networking.v1beta1.ClientTLSSettings")
-	proto.RegisterType((*LocalityLoadBalancerSetting)(nil), "istio.networking.v1beta1.LocalityLoadBalancerSetting")
-	proto.RegisterType((*LocalityLoadBalancerSetting_Distribute)(nil), "istio.networking.v1beta1.LocalityLoadBalancerSetting.Distribute")
-	proto.RegisterMapType((map[string]uint32)(nil), "istio.networking.v1beta1.LocalityLoadBalancerSetting.Distribute.ToEntry")
-	proto.RegisterType((*LocalityLoadBalancerSetting_Failover)(nil), "istio.networking.v1beta1.LocalityLoadBalancerSetting.Failover")
+// Added by Ingress
+type Int64Range struct {
+	// start of the range (inclusive)
+	Start int64 `protobuf:"varint,1,opt,name=start,proto3" json:"start,omitempty"`
+	// end of the range (exclusive)
+	End                  int64    `protobuf:"varint,2,opt,name=end,proto3" json:"end,omitempty"`
+	XXX_NoUnkeyedLiteral struct{} `json:"-"`
+	XXX_unrecognized     []byte   `json:"-"`
+	XXX_sizecache        int32    `json:"-"`
 }
 
-func init() {
-	proto.RegisterFile("networking/v1beta1/destination_rule.proto", fileDescriptor_31054629b619ca4b)
+func (m *Int64Range) Reset()         { *m = Int64Range{} }
+func (m *Int64Range) String() string { return proto.CompactTextString(m) }
+func (*Int64Range) ProtoMessage()    {}
+func (*Int64Range) Descriptor() ([]byte, []int) {
+	return fileDescriptor_31054629b619ca4b, []int{8}
+}
+func (m *Int64Range) XXX_Unmarshal(b []byte) error {
+	return m.Unmarshal(b)
+}
+func (m *Int64Range) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	if deterministic {
+		return xxx_messageInfo_Int64Range.Marshal(b, m, deterministic)
+	} else {
+		b = b[:cap(b)]
+		n, err := m.MarshalToSizedBuffer(b)
+		if err != nil {
+			return nil, err
+		}
+		return b[:n], nil
+	}
+}
+func (m *Int64Range) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_Int64Range.Merge(m, src)
+}
+func (m *Int64Range) XXX_Size() int {
+	return m.Size()
+}
+func (m *Int64Range) XXX_DiscardUnknown() {
+	xxx_messageInfo_Int64Range.DiscardUnknown(m)
 }
 
-var fileDescriptor_31054629b619ca4b = []byte{
-	// 1938 bytes of a gzipped FileDescriptorProto
-	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x58, 0xcd, 0x73, 0x1b, 0xb7,
-	0x15, 0x17, 0x3f, 0x25, 0x3e, 0xea, 0x83, 0x84, 0x35, 0x2e, 0x43, 0x77, 0x64, 0x97, 0xd3, 0x69,
-	0x54, 0x27, 0x5e, 0x45, 0x74, 0x35, 0x6d, 0x9c, 0xb8, 0x89, 0x28, 0xca, 0xa6, 0x12, 0x4a, 0xa4,
-	0x97, 0x54, 0xda, 0xfa, 0xb2, 0x05, 0x97, 0x10, 0x89, 0x68, 0xb9, 0xd8, 0x60, 0xb1, 0x34, 0x99,
-	0x6b, 0x6f, 0x9d, 0xde, 0x7b, 0xef, 0x7f, 0xd0, 0x53, 0x4f, 0xbd, 0xf7, 0xd2, 0x99, 0x4e, 0xa7,
-	0xc7, 0x1e, 0x3a, 0xfe, 0x17, 0x7a, 0xea, 0xad, 0x03, 0x2c, 0x96, 0x5c, 0x59, 0x5f, 0x96, 0x95,
-	0xdc, 0x80, 0xf7, 0x7e, 0xef, 0x07, 0xe0, 0xbd, 0x87, 0x87, 0xb7, 0x0b, 0x3f, 0x75, 0x89, 0x78,
-	0xc5, 0xf8, 0x29, 0x75, 0x07, 0x5b, 0xe3, 0xed, 0x1e, 0x11, 0x78, 0x7b, 0xab, 0x4f, 0x7c, 0x41,
-	0x5d, 0x2c, 0x28, 0x73, 0x2d, 0x1e, 0x38, 0xc4, 0xf0, 0x38, 0x13, 0x0c, 0x95, 0xa8, 0x2f, 0x28,
-	0x33, 0xe6, 0x06, 0x86, 0x36, 0x28, 0xdf, 0x1f, 0x30, 0x36, 0x70, 0xc8, 0x16, 0xf6, 0xe8, 0xd6,
-	0x09, 0x25, 0x4e, 0xdf, 0xea, 0x91, 0x21, 0x1e, 0x53, 0xc6, 0x43, 0xd3, 0xf2, 0x86, 0x06, 0xa8,
-	0x59, 0x2f, 0x38, 0xd9, 0xea, 0x07, 0x5c, 0xf1, 0x5f, 0xa6, 0x7f, 0xc5, 0xb1, 0xe7, 0x11, 0xee,
-	0x6b, 0xfd, 0xe6, 0x05, 0xbb, 0x1c, 0x53, 0x2e, 0x02, 0xec, 0x58, 0x3e, 0xe1, 0x63, 0x6a, 0xeb,
-	0x4d, 0x96, 0xd7, 0x07, 0x6c, 0xc0, 0xd4, 0x70, 0x4b, 0x8e, 0x42, 0x69, 0xe5, 0x5f, 0x09, 0x58,
-	0xab, 0xcf, 0x4f, 0x65, 0x06, 0x0e, 0x41, 0x25, 0x48, 0x0f, 0x99, 0x2f, 0x4a, 0x89, 0x07, 0x89,
-	0xcd, 0x5c, 0x2d, 0xfd, 0x7a, 0x37, 0x91, 0x34, 0x95, 0x04, 0x1d, 0xc1, 0xaa, 0xe0, 0xf8, 0xe4,
-	0x84, 0xda, 0x96, 0xc7, 0x1c, 0x6a, 0x4f, 0x4b, 0xc9, 0x07, 0x89, 0xcd, 0x7c, 0xf5, 0x7d, 0xe3,
-	0x32, 0x0f, 0x18, 0xdd, 0x10, 0xdf, 0x56, 0x70, 0x73, 0x45, 0xc4, 0xa7, 0xe8, 0x09, 0x2c, 0xfa,
-	0x41, 0xcf, 0x27, 0xc2, 0x2f, 0xa5, 0x1e, 0xa4, 0x36, 0xf3, 0xd5, 0x07, 0x97, 0x13, 0x75, 0x14,
-	0xd0, 0x8c, 0x0c, 0xd0, 0x3d, 0xc8, 0x91, 0x89, 0xc7, 0xb8, 0xb0, 0x04, 0x2b, 0xa5, 0x1f, 0xa4,
-	0x36, 0x73, 0xe6, 0x52, 0x28, 0xe8, 0xb2, 0xca, 0xbf, 0xb3, 0xb0, 0x72, 0x66, 0x65, 0xd4, 0x81,
-	0x15, 0x87, 0xe1, 0xbe, 0xd5, 0xc3, 0x0e, 0x76, 0x6d, 0xc2, 0xd5, 0xe9, 0xf2, 0x55, 0xe3, 0xf2,
-	0x05, 0x9b, 0x0c, 0xf7, 0x6b, 0x1a, 0xdd, 0x21, 0x42, 0x50, 0x77, 0xe0, 0x9b, 0xcb, 0x4e, 0x4c,
-	0x8a, 0x7e, 0x03, 0x6b, 0x36, 0x73, 0x5d, 0x62, 0xab, 0x8c, 0xf0, 0x18, 0x73, 0xb4, 0x43, 0x3e,
-	0xba, 0x9c, 0x76, 0x6f, 0x66, 0xd0, 0x66, 0xcc, 0x99, 0x11, 0xaf, 0xda, 0x67, 0xe4, 0xe8, 0x57,
-	0x50, 0x64, 0x81, 0x70, 0x28, 0xe1, 0x56, 0x9f, 0x88, 0x50, 0x51, 0x4a, 0x29, 0xf2, 0x87, 0x97,
-	0x93, 0xb7, 0x42, 0x93, 0x7a, 0x64, 0x61, 0x16, 0xd8, 0x1b, 0x12, 0xf4, 0x14, 0x52, 0xc2, 0xf1,
-	0x4b, 0x69, 0x45, 0xf5, 0xc1, 0x15, 0xfb, 0x74, 0x28, 0x71, 0x45, 0xb7, 0xd9, 0x99, 0x6d, 0x51,
-	0xda, 0x21, 0x0a, 0x77, 0x94, 0xd3, 0x1d, 0x32, 0x26, 0x32, 0xc5, 0x42, 0x5d, 0x29, 0xa3, 0xc2,
-	0xf7, 0xf1, 0x5b, 0xe6, 0x81, 0xd1, 0x96, 0x61, 0x3a, 0x93, 0x19, 0x45, 0xc9, 0xda, 0x94, 0xa4,
-	0xd1, 0x7a, 0xe5, 0x3f, 0xa6, 0xa0, 0x78, 0x0e, 0x88, 0x9e, 0x40, 0x5a, 0x42, 0x75, 0xfc, 0x7e,
-	0x72, 0xf9, 0x8a, 0xd2, 0xb4, 0x43, 0x1c, 0x62, 0x0b, 0xc6, 0x4d, 0x65, 0x73, 0x3e, 0x09, 0x92,
-	0xdf, 0x4f, 0x12, 0xa4, 0xbe, 0xcf, 0x24, 0x48, 0x7f, 0x77, 0x49, 0x90, 0x79, 0xb7, 0x24, 0xa8,
-	0xfc, 0x37, 0x01, 0xd9, 0xf0, 0x3e, 0xca, 0x62, 0xe1, 0xe2, 0x11, 0x39, 0x5b, 0x2c, 0xa4, 0x04,
-	0xd5, 0x21, 0xeb, 0xe0, 0x1e, 0x71, 0xfc, 0x52, 0x52, 0x25, 0xc7, 0x87, 0xd7, 0xdd, 0x6d, 0xa3,
-	0xa9, 0xe0, 0xfb, 0xae, 0xe0, 0x53, 0x53, 0xdb, 0x5e, 0x50, 0x72, 0x52, 0xb7, 0x29, 0x39, 0xe5,
-	0x8f, 0x21, 0x1f, 0x5b, 0x06, 0x15, 0x20, 0x75, 0x4a, 0xa6, 0xe1, 0xee, 0x4d, 0x39, 0x44, 0xeb,
-	0x90, 0x19, 0x63, 0x27, 0x20, 0x2a, 0x37, 0x72, 0x66, 0x38, 0x79, 0x92, 0xfc, 0x45, 0xa2, 0xf2,
-	0xf7, 0x2c, 0xac, 0x5f, 0x94, 0x0f, 0xe8, 0x05, 0x64, 0x7d, 0x3a, 0xf2, 0x9c, 0xd0, 0x0b, 0xab,
-	0xd5, 0x9f, 0xdf, 0x2c, 0x9f, 0x8c, 0x8e, 0x32, 0x6e, 0xd6, 0x1a, 0x0b, 0xa6, 0x26, 0x42, 0x5f,
-	0xab, 0xa4, 0xf2, 0xa9, 0x2f, 0x88, 0x2b, 0xac, 0x21, 0xf6, 0x87, 0x3a, 0x57, 0x3f, 0xbb, 0x21,
-	0xf7, 0xde, 0x8c, 0xa5, 0x81, 0xfd, 0xa1, 0x5a, 0x63, 0xd5, 0x3e, 0x23, 0x43, 0x04, 0xee, 0x38,
-	0xcc, 0xc6, 0x0e, 0x15, 0x53, 0xcb, 0xe9, 0x45, 0x77, 0x5a, 0xfb, 0x79, 0xe7, 0xaa, 0xf5, 0x42,
-	0xa3, 0x0b, 0xd6, 0x35, 0x8b, 0x11, 0x63, 0xb3, 0xa7, 0x45, 0xe5, 0xbf, 0xa4, 0xa0, 0xf0, 0xe6,
-	0x6e, 0xd0, 0x43, 0x28, 0x0c, 0x85, 0xf0, 0xac, 0x21, 0xc1, 0x7d, 0xc2, 0xad, 0x79, 0x2a, 0xc9,
-	0x7d, 0x4a, 0x4d, 0x43, 0x29, 0x8e, 0x64, 0x42, 0x8d, 0x20, 0xaf, 0xb0, 0x36, 0x63, 0xa7, 0x94,
-	0x68, 0x7f, 0x7c, 0x71, 0x4b, 0x7f, 0x18, 0x8d, 0x6e, 0xb7, 0xbd, 0xa7, 0x18, 0x1b, 0x0b, 0x26,
-	0xc8, 0x05, 0xc2, 0x19, 0xfa, 0x31, 0xac, 0x04, 0x3e, 0xb1, 0x7c, 0x16, 0x70, 0x9b, 0x58, 0xd4,
-	0x53, 0x0e, 0x59, 0x6a, 0x2c, 0x98, 0xf9, 0xc0, 0x27, 0x1d, 0x25, 0x3d, 0xf0, 0xd0, 0x27, 0xf0,
-	0x9e, 0xda, 0xd4, 0x37, 0x01, 0xe1, 0x53, 0xcb, 0xc3, 0x1c, 0x8f, 0x88, 0x88, 0x4e, 0x92, 0xd1,
-	0x27, 0xb9, 0x2b, 0x21, 0x2f, 0x24, 0xa2, 0x1d, 0x01, 0xd4, 0x89, 0x1e, 0x42, 0x71, 0x44, 0x5d,
-	0x3a, 0x0a, 0x46, 0x16, 0xa7, 0xee, 0xc0, 0xf2, 0xe9, 0xb7, 0x44, 0xdd, 0xef, 0xb4, 0xb9, 0xa6,
-	0x15, 0x26, 0x75, 0x07, 0x1d, 0xfa, 0x2d, 0x29, 0x8f, 0x00, 0xe6, 0x5b, 0xbd, 0xe2, 0xda, 0x21,
-	0x48, 0x7b, 0x58, 0x0c, 0x75, 0xfa, 0xaa, 0x31, 0xda, 0x86, 0x94, 0x10, 0x51, 0x59, 0x7a, 0xcf,
-	0x08, 0x7b, 0x0a, 0x23, 0xea, 0x29, 0x8c, 0xba, 0xee, 0x39, 0x34, 0x8f, 0xc4, 0xd6, 0x00, 0x96,
-	0x64, 0xd6, 0x59, 0xa7, 0x64, 0x5a, 0x69, 0xc0, 0x52, 0x94, 0xa2, 0x68, 0x0d, 0xf2, 0x66, 0xeb,
-	0xf8, 0xa8, 0x6e, 0x99, 0xad, 0xda, 0xc1, 0x51, 0x61, 0x01, 0xad, 0x02, 0x34, 0xf7, 0x77, 0x3b,
-	0x5d, 0x6b, 0xaf, 0x75, 0x74, 0x54, 0x48, 0x20, 0x80, 0xac, 0xb9, 0x7b, 0x54, 0x6f, 0x1d, 0x16,
-	0x92, 0x12, 0xdc, 0xde, 0xed, 0x74, 0xba, 0x0d, 0xb3, 0x75, 0xfc, 0xbc, 0x51, 0x48, 0xd5, 0xf2,
-	0x90, 0x73, 0x7a, 0xfa, 0x22, 0x57, 0xfe, 0xba, 0x04, 0x77, 0x2f, 0x2e, 0x84, 0xe8, 0x08, 0x52,
-	0xc2, 0xf6, 0x74, 0x8d, 0xff, 0xf4, 0xa6, 0x75, 0xd4, 0xe8, 0xee, 0xb5, 0x63, 0x05, 0xcb, 0xf6,
-	0xd0, 0x0b, 0x48, 0xcb, 0x10, 0xe8, 0x9c, 0x79, 0x7a, 0x63, 0x42, 0xe9, 0xf9, 0x19, 0xa3, 0xa2,
-	0x2a, 0xff, 0x2f, 0x09, 0xf9, 0xd8, 0x3a, 0xe8, 0x7d, 0x58, 0x1b, 0xe1, 0x89, 0x35, 0xaf, 0xe0,
-	0xbe, 0xda, 0x7e, 0xc6, 0x5c, 0x1d, 0xe1, 0xc9, 0x9c, 0xd6, 0x47, 0xb5, 0xd9, 0x7b, 0x61, 0x09,
-	0x3a, 0x22, 0x2c, 0x10, 0x7a, 0x5b, 0x97, 0x07, 0x66, 0xf6, 0x30, 0x74, 0x43, 0x03, 0xe4, 0xc2,
-	0x8a, 0xb0, 0x3d, 0xeb, 0x94, 0x10, 0x0f, 0x3b, 0x74, 0x4c, 0x74, 0x68, 0x0f, 0x6e, 0xe3, 0x29,
-	0xa3, 0x6b, 0x7b, 0x5f, 0x46, 0x84, 0xe6, 0xb2, 0x88, 0xcd, 0xca, 0x7f, 0x48, 0xc0, 0x72, 0x5c,
-	0x8d, 0xee, 0x42, 0xd6, 0xe3, 0xac, 0x47, 0xc2, 0x43, 0xae, 0x98, 0x7a, 0x86, 0x1e, 0x41, 0x5a,
-	0x1e, 0xea, 0xfa, 0x13, 0x29, 0x18, 0xda, 0x81, 0x25, 0xea, 0x0a, 0xc2, 0xc7, 0xf8, 0xfa, 0xec,
-	0x34, 0x67, 0xd0, 0xf2, 0xef, 0xd2, 0xb0, 0x1c, 0x0f, 0x09, 0xfa, 0x04, 0xca, 0x32, 0x28, 0xdb,
-	0x96, 0x0c, 0x81, 0x47, 0xdc, 0xbe, 0xbc, 0x4d, 0x9c, 0x7c, 0x13, 0x10, 0x5f, 0x44, 0x71, 0xf8,
-	0x81, 0x42, 0x1c, 0xe2, 0x49, 0x3b, 0xd4, 0x9b, 0x5a, 0x8d, 0x3e, 0x04, 0x24, 0x55, 0x55, 0x65,
-	0x3c, 0x33, 0x4a, 0x2a, 0x23, 0x55, 0x9d, 0xaa, 0x87, 0x78, 0x32, 0x43, 0x3f, 0x85, 0x7b, 0x71,
-	0x9c, 0xe5, 0x11, 0x1e, 0x0b, 0xba, 0x3a, 0x45, 0xc6, 0x2c, 0x8d, 0xe6, 0x16, 0x6d, 0xc2, 0xe7,
-	0xce, 0x47, 0xf7, 0x21, 0x1f, 0x9a, 0x0b, 0x4e, 0x49, 0xd8, 0x86, 0x65, 0x4c, 0x50, 0x70, 0x25,
-	0x41, 0x9f, 0xc2, 0x32, 0xed, 0x3b, 0x64, 0x96, 0x1b, 0x99, 0xeb, 0xdc, 0x92, 0x97, 0xf0, 0x28,
-	0x31, 0xa6, 0x50, 0x1c, 0x56, 0xad, 0xc0, 0x1b, 0x70, 0xdc, 0x27, 0xd1, 0x8b, 0x99, 0x55, 0xaf,
-	0xd2, 0xe1, 0xad, 0xb2, 0xde, 0x68, 0x54, 0x8f, 0x43, 0x56, 0xfd, 0xae, 0xae, 0x0d, 0xcf, 0x0a,
-	0x90, 0x01, 0x77, 0x64, 0xbd, 0xb4, 0x55, 0xcb, 0x60, 0xa9, 0x7d, 0xda, 0xcc, 0x29, 0x2d, 0xca,
-	0xaa, 0x69, 0x16, 0x03, 0x9f, 0x84, 0xcd, 0x44, 0x5b, 0x2b, 0x2a, 0x9f, 0xc1, 0xda, 0x1b, 0x9c,
-	0x28, 0x0f, 0x8b, 0xf5, 0xfd, 0x67, 0xbb, 0xc7, 0xcd, 0x6e, 0x61, 0x01, 0x21, 0x58, 0xad, 0xb7,
-	0xac, 0xa3, 0x56, 0xd7, 0x3a, 0x6e, 0x3f, 0x37, 0x77, 0xeb, 0xfb, 0x85, 0x84, 0x04, 0x44, 0x93,
-	0x64, 0xe5, 0xf7, 0x19, 0x28, 0xbc, 0xd9, 0xeb, 0xa0, 0x6d, 0x40, 0xf2, 0x79, 0x23, 0x76, 0x20,
-	0xe8, 0x98, 0x58, 0x84, 0x73, 0xc6, 0x75, 0x06, 0xd4, 0x92, 0xa5, 0x84, 0x59, 0x8c, 0x69, 0xf7,
-	0x95, 0x12, 0x7d, 0x01, 0x15, 0xdf, 0x73, 0xa8, 0xb0, 0xc8, 0x44, 0x10, 0xee, 0x62, 0xc7, 0x52,
-	0x8f, 0x97, 0xc5, 0x38, 0x1d, 0x50, 0x37, 0xa2, 0x58, 0x52, 0xe7, 0xd8, 0x50, 0xc8, 0x7d, 0x0d,
-	0x54, 0x2f, 0x60, 0x4b, 0xc1, 0x34, 0xd7, 0x00, 0x7e, 0x14, 0x5f, 0xfe, 0x0c, 0xd1, 0x09, 0xa6,
-	0x4e, 0xc0, 0x89, 0x5f, 0xca, 0xa9, 0x90, 0xfe, 0xf0, 0x5c, 0x48, 0x8f, 0x0f, 0x5c, 0xf1, 0xb8,
-	0xfa, 0x95, 0x6c, 0x38, 0xcc, 0x8d, 0x18, 0x4d, 0x6c, 0x99, 0x67, 0x9a, 0x03, 0xbd, 0x84, 0x72,
-	0x7c, 0xa1, 0x01, 0x16, 0xe4, 0x15, 0x9e, 0x46, 0x9b, 0xcd, 0xbe, 0xc5, 0x0a, 0xa5, 0x98, 0xfd,
-	0xf3, 0xd0, 0x5c, 0x1f, 0xc2, 0x84, 0xbb, 0x71, 0xee, 0x9d, 0xc9, 0x24, 0xe2, 0x5d, 0x7c, 0x0b,
-	0xde, 0xf5, 0x98, 0xed, 0xce, 0x64, 0xa2, 0x39, 0xe3, 0x37, 0x3d, 0xf9, 0xd6, 0x37, 0x1d, 0x3d,
-	0x07, 0xd4, 0xc3, 0x3e, 0xb1, 0xc8, 0xd7, 0xba, 0xbf, 0x56, 0xd5, 0xe5, 0xda, 0x52, 0x51, 0x90,
-	0x46, 0xfb, 0xda, 0x46, 0xde, 0x0d, 0xf4, 0x11, 0xac, 0xcb, 0x7b, 0x37, 0xe3, 0xf1, 0x08, 0xb7,
-	0x89, 0x2b, 0xf4, 0x05, 0x44, 0x23, 0x3c, 0x89, 0xe0, 0xed, 0x50, 0x23, 0xcb, 0xc2, 0x88, 0xba,
-	0xb2, 0x33, 0x71, 0xc4, 0x70, 0x86, 0xcf, 0x84, 0x65, 0x61, 0x44, 0xdd, 0x86, 0x52, 0x68, 0x74,
-	0xe5, 0x9f, 0x29, 0x28, 0x9e, 0xeb, 0x96, 0xd1, 0x21, 0xa4, 0x47, 0xac, 0x1f, 0xf5, 0x85, 0x8f,
-	0x6f, 0xd0, 0x68, 0x1b, 0xdd, 0x66, 0x47, 0x9a, 0x46, 0x6f, 0xbb, 0x1c, 0xa3, 0x47, 0x80, 0xf4,
-	0xf5, 0xb2, 0x09, 0x17, 0xf4, 0x84, 0xda, 0x58, 0x44, 0x8d, 0x6a, 0x31, 0xd4, 0xec, 0xcd, 0x15,
-	0xb2, 0xd6, 0x78, 0x9c, 0x8e, 0xb1, 0x20, 0xf2, 0x19, 0x57, 0x5e, 0xcb, 0x99, 0xa0, 0x45, 0x5f,
-	0x92, 0xa9, 0x7c, 0xb3, 0x6c, 0x1c, 0xe7, 0x0a, 0x0b, 0x52, 0xce, 0x5c, 0xb5, 0x71, 0x8c, 0x48,
-	0x3d, 0x6e, 0x36, 0x27, 0x7d, 0xe2, 0x0a, 0x8a, 0x9d, 0xb0, 0xb7, 0x59, 0xd4, 0xc0, 0x99, 0x38,
-	0xea, 0x68, 0xfc, 0xa0, 0x27, 0x3d, 0x69, 0x61, 0x47, 0x28, 0x64, 0xf8, 0x71, 0x98, 0x33, 0xd7,
-	0xb4, 0x62, 0xd7, 0x11, 0x12, 0xea, 0xcb, 0xde, 0xdb, 0x77, 0xa9, 0xca, 0xd5, 0x9c, 0x29, 0x87,
-	0xa8, 0x09, 0xeb, 0x54, 0xe5, 0x0e, 0x27, 0x96, 0x7f, 0x4a, 0x3d, 0x6b, 0x4c, 0x38, 0x3d, 0x99,
-	0xaa, 0xbb, 0x97, 0xaf, 0x96, 0xcf, 0xc5, 0xbb, 0xc6, 0x98, 0x13, 0x26, 0x1d, 0x8a, 0xec, 0x3a,
-	0xa7, 0xd4, 0xfb, 0x4a, 0x59, 0x55, 0x3e, 0x87, 0x45, 0xed, 0x44, 0x55, 0x58, 0x0e, 0x3a, 0xbb,
-	0xb5, 0xe6, 0x7e, 0x61, 0x41, 0x76, 0x28, 0x9d, 0x83, 0xc3, 0x76, 0x73, 0x3f, 0xec, 0x56, 0x0e,
-	0x8f, 0xbb, 0xc7, 0xbb, 0xcd, 0x42, 0x12, 0x15, 0x60, 0xf9, 0xa0, 0xd3, 0x3d, 0x68, 0x59, 0x5a,
-	0x92, 0xaa, 0xfc, 0x29, 0x0d, 0xf7, 0xae, 0xe8, 0x72, 0xd1, 0x6f, 0x01, 0xfa, 0xd4, 0x17, 0x9c,
-	0xf6, 0x02, 0x21, 0x83, 0x2c, 0x3f, 0x73, 0x3e, 0x7f, 0xa7, 0x86, 0xd9, 0xa8, 0xcf, 0x78, 0xcc,
-	0x18, 0x27, 0x7a, 0x09, 0x4b, 0xb2, 0x6c, 0xb0, 0xb1, 0xfa, 0x58, 0x95, 0xfc, 0xbf, 0x7c, 0x37,
-	0xfe, 0x67, 0x9a, 0xc5, 0x9c, 0xf1, 0xa1, 0x0f, 0xa0, 0x18, 0x8d, 0x2d, 0x8f, 0x53, 0xc6, 0xa9,
-	0x98, 0xea, 0x3f, 0x29, 0x85, 0x48, 0xd1, 0xd6, 0x72, 0xf4, 0x33, 0x58, 0x24, 0x2e, 0xee, 0x39,
-	0xa4, 0xaf, 0x6f, 0xdf, 0x55, 0xd1, 0x88, 0xa0, 0xe5, 0x3f, 0x27, 0x00, 0xe6, 0x27, 0x93, 0xbd,
-	0xe9, 0x09, 0x67, 0x23, 0xfd, 0xb9, 0xa5, 0xc6, 0xe8, 0xd7, 0x90, 0x14, 0x4c, 0x9f, 0xad, 0x71,
-	0x5b, 0xdf, 0x19, 0x5d, 0x16, 0x7e, 0x3e, 0x26, 0x05, 0x2b, 0xef, 0xc0, 0xa2, 0x9e, 0x5e, 0xf7,
-	0x99, 0xb7, 0x12, 0xfb, 0xcc, 0x2b, 0x1b, 0xb0, 0x14, 0x39, 0xeb, 0xc2, 0x0d, 0xaf, 0xea, 0x0d,
-	0x4b, 0x49, 0x52, 0xb0, 0xda, 0xa3, 0xbf, 0xbd, 0xde, 0x48, 0xfc, 0xe3, 0xf5, 0x46, 0xe2, 0x3f,
-	0xaf, 0x37, 0x12, 0x2f, 0xef, 0x87, 0x27, 0xa0, 0x4c, 0xfd, 0xf3, 0x3b, 0xff, 0x77, 0xae, 0x97,
-	0x55, 0xfe, 0x7a, 0xfc, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x2e, 0xe9, 0x6d, 0x99, 0x60, 0x14,
-	0x00, 0x00,
+var xxx_messageInfo_Int64Range proto.InternalMessageInfo
+
+func (m *Int64Range) GetStart() int64 {
+	if m != nil {
+		return m.Start
+	}
+	return 0
 }
 
-func (m *DestinationRule) Marshal() (dAtA []byte, err error) {
-	size := m.Size()
-	dAtA = make([]byte, size)
-	n, err := m.MarshalToSizedBuffer(dAtA[:size])
-	if err != nil {
-		return nil, err
+func (m *Int64Range) GetEnd() int64 {
+	if m != nil {
+		return m.End
 	}
-	return dAtA[:n], nil
+	return 0
 }
 
-func (m *DestinationRule) MarshalTo(dAtA []byte) (int, error) {
-	size := m.Size()
-	return m.MarshalToSizedBuffer(dAtA[:size])
+type HealthStatusSet struct {
+	// An order-independent set of health status.
+	Statuses             []HealthStatus `protobuf:"varint,1,rep,packed,name=statuses,proto3,enum=istio.networking.v1beta1.HealthStatus" json:"statuses,omitempty"`
+	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
+	XXX_unrecognized     []byte         `json:"-"`
+	XXX_sizecache        int32          `json:"-"`
 }
 
-func (m *DestinationRule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
-	i := len(dAtA)
-	_ = i
-	var l int
-	_ = l
-	if m.XXX_unrecognized != nil {
-		i -= len(m.XXX_unrecognized)
-		copy(dAtA[i:], m.XXX_unrecognized)
-	}
-	if len(m.ExportTo) > 0 {
-		for iNdEx := len(m.ExportTo) - 1; iNdEx >= 0; iNdEx-- {
-			i -= len(m.ExportTo[iNdEx])
-			copy(dAtA[i:], m.ExportTo[iNdEx])
-			i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.ExportTo[iNdEx])))
-			i--
-			dAtA[i] = 0x22
+func (m *HealthStatusSet) Reset()         { *m = HealthStatusSet{} }
+func (m *HealthStatusSet) String() string { return proto.CompactTextString(m) }
+func (*HealthStatusSet) ProtoMessage()    {}
+func (*HealthStatusSet) Descriptor() ([]byte, []int) {
+	return fileDescriptor_31054629b619ca4b, []int{9}
+}
+func (m *HealthStatusSet) XXX_Unmarshal(b []byte) error {
+	return m.Unmarshal(b)
+}
+func (m *HealthStatusSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	if deterministic {
+		return xxx_messageInfo_HealthStatusSet.Marshal(b, m, deterministic)
+	} else {
+		b = b[:cap(b)]
+		n, err := m.MarshalToSizedBuffer(b)
+		if err != nil {
+			return nil, err
 		}
+		return b[:n], nil
 	}
-	if len(m.Subsets) > 0 {
-		for iNdEx := len(m.Subsets) - 1; iNdEx >= 0; iNdEx-- {
-			{
-				size, err := m.Subsets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
-				if err != nil {
-					return 0, err
-				}
-				i -= size
-				i = encodeVarintDestinationRule(dAtA, i, uint64(size))
-			}
-			i--
-			dAtA[i] = 0x1a
-		}
+}
+func (m *HealthStatusSet) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_HealthStatusSet.Merge(m, src)
+}
+func (m *HealthStatusSet) XXX_Size() int {
+	return m.Size()
+}
+func (m *HealthStatusSet) XXX_DiscardUnknown() {
+	xxx_messageInfo_HealthStatusSet.DiscardUnknown(m)
+}
+
+var xxx_messageInfo_HealthStatusSet proto.InternalMessageInfo
+
+func (m *HealthStatusSet) GetStatuses() []HealthStatus {
+	if m != nil {
+		return m.Statuses
 	}
-	if m.TrafficPolicy != nil {
-		{
-			size, err := m.TrafficPolicy.MarshalToSizedBuffer(dAtA[:i])
-			if err != nil {
-				return 0, err
-			}
-			i -= size
-			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+	return nil
+}
+
+type Payload struct {
+	// Types that are valid to be assigned to Payload:
+	//	*Payload_Text
+	//	*Payload_Binary
+	Payload              isPayload_Payload `protobuf_oneof:"payload"`
+	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
+	XXX_unrecognized     []byte            `json:"-"`
+	XXX_sizecache        int32             `json:"-"`
+}
+
+func (m *Payload) Reset()         { *m = Payload{} }
+func (m *Payload) String() string { return proto.CompactTextString(m) }
+func (*Payload) ProtoMessage()    {}
+func (*Payload) Descriptor() ([]byte, []int) {
+	return fileDescriptor_31054629b619ca4b, []int{10}
+}
+func (m *Payload) XXX_Unmarshal(b []byte) error {
+	return m.Unmarshal(b)
+}
+func (m *Payload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	if deterministic {
+		return xxx_messageInfo_Payload.Marshal(b, m, deterministic)
+	} else {
+		b = b[:cap(b)]
+		n, err := m.MarshalToSizedBuffer(b)
+		if err != nil {
+			return nil, err
 		}
-		i--
-		dAtA[i] = 0x12
-	}
-	if len(m.Host) > 0 {
-		i -= len(m.Host)
-		copy(dAtA[i:], m.Host)
-		i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.Host)))
-		i--
-		dAtA[i] = 0xa
+		return b[:n], nil
 	}
-	return len(dAtA) - i, nil
+}
+func (m *Payload) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_Payload.Merge(m, src)
+}
+func (m *Payload) XXX_Size() int {
+	return m.Size()
+}
+func (m *Payload) XXX_DiscardUnknown() {
+	xxx_messageInfo_Payload.DiscardUnknown(m)
 }
 
-func (m *TrafficPolicy) Marshal() (dAtA []byte, err error) {
-	size := m.Size()
-	dAtA = make([]byte, size)
-	n, err := m.MarshalToSizedBuffer(dAtA[:size])
-	if err != nil {
-		return nil, err
+var xxx_messageInfo_Payload proto.InternalMessageInfo
+
+type isPayload_Payload interface {
+	isPayload_Payload()
+	MarshalTo([]byte) (int, error)
+	Size() int
+}
+
+type Payload_Text struct {
+	Text string `protobuf:"bytes,1,opt,name=text,proto3,oneof" json:"text,omitempty"`
+}
+type Payload_Binary struct {
+	Binary []byte `protobuf:"bytes,2,opt,name=binary,proto3,oneof" json:"binary,omitempty"`
+}
+
+func (*Payload_Text) isPayload_Payload()   {}
+func (*Payload_Binary) isPayload_Payload() {}
+
+func (m *Payload) GetPayload() isPayload_Payload {
+	if m != nil {
+		return m.Payload
 	}
-	return dAtA[:n], nil
+	return nil
 }
 
-func (m *TrafficPolicy) MarshalTo(dAtA []byte) (int, error) {
-	size := m.Size()
-	return m.MarshalToSizedBuffer(dAtA[:size])
+func (m *Payload) GetText() string {
+	if x, ok := m.GetPayload().(*Payload_Text); ok {
+		return x.Text
+	}
+	return ""
 }
 
-func (m *TrafficPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
-	i := len(dAtA)
-	_ = i
-	var l int
-	_ = l
-	if m.XXX_unrecognized != nil {
-		i -= len(m.XXX_unrecognized)
-		copy(dAtA[i:], m.XXX_unrecognized)
+func (m *Payload) GetBinary() []byte {
+	if x, ok := m.GetPayload().(*Payload_Binary); ok {
+		return x.Binary
 	}
-	if len(m.PortLevelSettings) > 0 {
-		for iNdEx := len(m.PortLevelSettings) - 1; iNdEx >= 0; iNdEx-- {
-			{
-				size, err := m.PortLevelSettings[iNdEx].MarshalToSizedBuffer(dAtA[:i])
-				if err != nil {
-					return 0, err
-				}
-				i -= size
-				i = encodeVarintDestinationRule(dAtA, i, uint64(size))
-			}
-			i--
-			dAtA[i] = 0x2a
-		}
+	return nil
+}
+
+// XXX_OneofWrappers is for the internal use of the proto package.
+func (*Payload) XXX_OneofWrappers() []interface{} {
+	return []interface{}{
+		(*Payload_Text)(nil),
+		(*Payload_Binary)(nil),
 	}
-	if m.Tls != nil {
-		{
-			size, err := m.Tls.MarshalToSizedBuffer(dAtA[:i])
-			if err != nil {
-				return 0, err
-			}
-			i -= size
-			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+}
+
+// [#next-free-field: 25]
+type HealthCheck struct {
+	// The time to wait for a health check response. If the timeout is reached the
+	// health check attempt will be considered a failure.
+	Timeout *types.Duration `protobuf:"bytes,1,opt,name=timeout,proto3" json:"timeout,omitempty"`
+	// The interval between health checks.
+	Interval *types.Duration `protobuf:"bytes,2,opt,name=interval,proto3" json:"interval,omitempty"`
+	// An optional jitter amount in milliseconds. If specified, Envoy will start health
+	// checking after for a random time in ms between 0 and initial_jitter. This only
+	// applies to the first health check.
+	InitialJitter *types.Duration `protobuf:"bytes,20,opt,name=initial_jitter,json=initialJitter,proto3" json:"initial_jitter,omitempty"`
+	// An optional jitter amount in milliseconds. If specified, during every
+	// interval Envoy will add interval_jitter to the wait time.
+	IntervalJitter *types.Duration `protobuf:"bytes,3,opt,name=interval_jitter,json=intervalJitter,proto3" json:"interval_jitter,omitempty"`
+	// An optional jitter amount as a percentage of interval_ms. If specified,
+	// during every interval Envoy will add interval_ms *
+	// interval_jitter_percent / 100 to the wait time.
+	//
+	// If interval_jitter_ms and interval_jitter_percent are both set, both of
+	// them will be used to increase the wait time.
+	IntervalJitterPercent uint32 `protobuf:"varint,18,opt,name=interval_jitter_percent,json=intervalJitterPercent,proto3" json:"interval_jitter_percent,omitempty"`
+	// The number of unhealthy health checks required before a host is marked
+	// unhealthy. Note that for *http* health checking if a host responds with a code not in
+	UnhealthyThreshold *types.UInt32Value `protobuf:"bytes,4,opt,name=unhealthy_threshold,json=unhealthyThreshold,proto3" json:"unhealthy_threshold,omitempty"`
+	// The number of healthy health checks required before a host is marked
+	// healthy. Note that during startup, only a single successful health check is
+	// required to mark a host healthy.
+	HealthyThreshold *types.UInt32Value `protobuf:"bytes,5,opt,name=healthy_threshold,json=healthyThreshold,proto3" json:"healthy_threshold,omitempty"`
+	AltPort          *types.UInt32Value `protobuf:"bytes,6,opt,name=alt_port,json=altPort,proto3" json:"alt_port,omitempty"`
+	ReuseConnection  *types.BoolValue   `protobuf:"bytes,7,opt,name=reuse_connection,json=reuseConnection,proto3" json:"reuse_connection,omitempty"`
+	// Types that are valid to be assigned to HealthChecker:
+	//	*HealthCheck_HttpHealthCheck_
+	//	*HealthCheck_TcpHealthCheck_
+	//	*HealthCheck_GrpcHealthCheck_
+	//	*HealthCheck_CustomHealthCheck_
+	HealthChecker isHealthCheck_HealthChecker `protobuf_oneof:"health_checker"`
+	// The default value for "no traffic interval" is 60 seconds.
+	NoTrafficInterval *types.Duration `protobuf:"bytes,12,opt,name=no_traffic_interval,json=noTrafficInterval,proto3" json:"no_traffic_interval,omitempty"`
+	// If no_traffic_healthy_interval is not set, it will default to the
+	// no traffic interval and send that interval regardless of health state.
+	NoTrafficHealthyInterval *types.Duration `protobuf:"bytes,24,opt,name=no_traffic_healthy_interval,json=noTrafficHealthyInterval,proto3" json:"no_traffic_healthy_interval,omitempty"`
+	// The default value for "unhealthy interval" is the same as "interval".
+	UnhealthyInterval *types.Duration `protobuf:"bytes,14,opt,name=unhealthy_interval,json=unhealthyInterval,proto3" json:"unhealthy_interval,omitempty"`
+	// The default value for "unhealthy edge interval" is the same as "unhealthy interval".
+	UnhealthyEdgeInterval *types.Duration `protobuf:"bytes,15,opt,name=unhealthy_edge_interval,json=unhealthyEdgeInterval,proto3" json:"unhealthy_edge_interval,omitempty"`
+	// The default value for "healthy edge interval" is the same as the default interval.
+	HealthyEdgeInterval *types.Duration `protobuf:"bytes,16,opt,name=healthy_edge_interval,json=healthyEdgeInterval,proto3" json:"healthy_edge_interval,omitempty"`
+	// Specifies the path to the :ref:`health check event log <arch_overview_health_check_logging>`.
+	// If empty, no event log will be written.
+	EventLogPath                 string `protobuf:"bytes,17,opt,name=event_log_path,json=eventLogPath,proto3" json:"event_log_path,omitempty"`
+	AlwaysLogHealthCheckFailures bool   `protobuf:"varint,19,opt,name=always_log_health_check_failures,json=alwaysLogHealthCheckFailures,proto3" json:"always_log_health_check_failures,omitempty"`
+	// This allows overriding the cluster TLS settings, just for health check connections.
+	TlsOptions           *HealthCheck_TlsOptions `protobuf:"bytes,21,opt,name=tls_options,json=tlsOptions,proto3" json:"tls_options,omitempty"`
+	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
+	XXX_unrecognized     []byte                  `json:"-"`
+	XXX_sizecache        int32                   `json:"-"`
+}
+
+func (m *HealthCheck) Reset()         { *m = HealthCheck{} }
+func (m *HealthCheck) String() string { return proto.CompactTextString(m) }
+func (*HealthCheck) ProtoMessage()    {}
+func (*HealthCheck) Descriptor() ([]byte, []int) {
+	return fileDescriptor_31054629b619ca4b, []int{11}
+}
+func (m *HealthCheck) XXX_Unmarshal(b []byte) error {
+	return m.Unmarshal(b)
+}
+func (m *HealthCheck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	if deterministic {
+		return xxx_messageInfo_HealthCheck.Marshal(b, m, deterministic)
+	} else {
+		b = b[:cap(b)]
+		n, err := m.MarshalToSizedBuffer(b)
+		if err != nil {
+			return nil, err
 		}
-		i--
-		dAtA[i] = 0x22
+		return b[:n], nil
 	}
-	if m.OutlierDetection != nil {
-		{
-			size, err := m.OutlierDetection.MarshalToSizedBuffer(dAtA[:i])
-			if err != nil {
-				return 0, err
-			}
-			i -= size
-			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
-		}
-		i--
-		dAtA[i] = 0x1a
+}
+func (m *HealthCheck) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_HealthCheck.Merge(m, src)
+}
+func (m *HealthCheck) XXX_Size() int {
+	return m.Size()
+}
+func (m *HealthCheck) XXX_DiscardUnknown() {
+	xxx_messageInfo_HealthCheck.DiscardUnknown(m)
+}
+
+var xxx_messageInfo_HealthCheck proto.InternalMessageInfo
+
+type isHealthCheck_HealthChecker interface {
+	isHealthCheck_HealthChecker()
+	MarshalTo([]byte) (int, error)
+	Size() int
+}
+
+type HealthCheck_HttpHealthCheck_ struct {
+	HttpHealthCheck *HealthCheck_HttpHealthCheck `protobuf:"bytes,8,opt,name=http_health_check,json=httpHealthCheck,proto3,oneof" json:"http_health_check,omitempty"`
+}
+type HealthCheck_TcpHealthCheck_ struct {
+	TcpHealthCheck *HealthCheck_TcpHealthCheck `protobuf:"bytes,9,opt,name=tcp_health_check,json=tcpHealthCheck,proto3,oneof" json:"tcp_health_check,omitempty"`
+}
+type HealthCheck_GrpcHealthCheck_ struct {
+	GrpcHealthCheck *HealthCheck_GrpcHealthCheck `protobuf:"bytes,11,opt,name=grpc_health_check,json=grpcHealthCheck,proto3,oneof" json:"grpc_health_check,omitempty"`
+}
+type HealthCheck_CustomHealthCheck_ struct {
+	CustomHealthCheck *HealthCheck_CustomHealthCheck `protobuf:"bytes,13,opt,name=custom_health_check,json=customHealthCheck,proto3,oneof" json:"custom_health_check,omitempty"`
+}
+
+func (*HealthCheck_HttpHealthCheck_) isHealthCheck_HealthChecker()   {}
+func (*HealthCheck_TcpHealthCheck_) isHealthCheck_HealthChecker()    {}
+func (*HealthCheck_GrpcHealthCheck_) isHealthCheck_HealthChecker()   {}
+func (*HealthCheck_CustomHealthCheck_) isHealthCheck_HealthChecker() {}
+
+func (m *HealthCheck) GetHealthChecker() isHealthCheck_HealthChecker {
+	if m != nil {
+		return m.HealthChecker
 	}
-	if m.ConnectionPool != nil {
-		{
-			size, err := m.ConnectionPool.MarshalToSizedBuffer(dAtA[:i])
-			if err != nil {
-				return 0, err
-			}
-			i -= size
-			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
-		}
-		i--
-		dAtA[i] = 0x12
+	return nil
+}
+
+func (m *HealthCheck) GetTimeout() *types.Duration {
+	if m != nil {
+		return m.Timeout
 	}
-	if m.LoadBalancer != nil {
-		{
-			size, err := m.LoadBalancer.MarshalToSizedBuffer(dAtA[:i])
-			if err != nil {
-				return 0, err
-			}
-			i -= size
-			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
-		}
-		i--
-		dAtA[i] = 0xa
+	return nil
+}
+
+func (m *HealthCheck) GetInterval() *types.Duration {
+	if m != nil {
+		return m.Interval
 	}
-	return len(dAtA) - i, nil
+	return nil
 }
 
-func (m *TrafficPolicy_PortTrafficPolicy) Marshal() (dAtA []byte, err error) {
-	size := m.Size()
-	dAtA = make([]byte, size)
-	n, err := m.MarshalToSizedBuffer(dAtA[:size])
-	if err != nil {
-		return nil, err
+func (m *HealthCheck) GetInitialJitter() *types.Duration {
+	if m != nil {
+		return m.InitialJitter
 	}
-	return dAtA[:n], nil
+	return nil
 }
 
-func (m *TrafficPolicy_PortTrafficPolicy) MarshalTo(dAtA []byte) (int, error) {
-	size := m.Size()
-	return m.MarshalToSizedBuffer(dAtA[:size])
+func (m *HealthCheck) GetIntervalJitter() *types.Duration {
+	if m != nil {
+		return m.IntervalJitter
+	}
+	return nil
 }
 
-func (m *TrafficPolicy_PortTrafficPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
-	i := len(dAtA)
-	_ = i
-	var l int
-	_ = l
-	if m.XXX_unrecognized != nil {
-		i -= len(m.XXX_unrecognized)
-		copy(dAtA[i:], m.XXX_unrecognized)
+func (m *HealthCheck) GetIntervalJitterPercent() uint32 {
+	if m != nil {
+		return m.IntervalJitterPercent
 	}
-	if m.Tls != nil {
-		{
-			size, err := m.Tls.MarshalToSizedBuffer(dAtA[:i])
-			if err != nil {
-				return 0, err
-			}
-			i -= size
-			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
-		}
-		i--
-		dAtA[i] = 0x2a
+	return 0
+}
+
+func (m *HealthCheck) GetUnhealthyThreshold() *types.UInt32Value {
+	if m != nil {
+		return m.UnhealthyThreshold
 	}
-	if m.OutlierDetection != nil {
-		{
-			size, err := m.OutlierDetection.MarshalToSizedBuffer(dAtA[:i])
-			if err != nil {
-				return 0, err
-			}
-			i -= size
-			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
-		}
-		i--
-		dAtA[i] = 0x22
+	return nil
+}
+
+func (m *HealthCheck) GetHealthyThreshold() *types.UInt32Value {
+	if m != nil {
+		return m.HealthyThreshold
 	}
-	if m.ConnectionPool != nil {
-		{
-			size, err := m.ConnectionPool.MarshalToSizedBuffer(dAtA[:i])
-			if err != nil {
-				return 0, err
-			}
-			i -= size
-			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
-		}
-		i--
-		dAtA[i] = 0x1a
+	return nil
+}
+
+func (m *HealthCheck) GetAltPort() *types.UInt32Value {
+	if m != nil {
+		return m.AltPort
 	}
-	if m.LoadBalancer != nil {
-		{
-			size, err := m.LoadBalancer.MarshalToSizedBuffer(dAtA[:i])
-			if err != nil {
-				return 0, err
-			}
-			i -= size
-			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
-		}
-		i--
-		dAtA[i] = 0x12
+	return nil
+}
+
+func (m *HealthCheck) GetReuseConnection() *types.BoolValue {
+	if m != nil {
+		return m.ReuseConnection
 	}
-	if m.Port != nil {
-		{
-			size, err := m.Port.MarshalToSizedBuffer(dAtA[:i])
-			if err != nil {
-				return 0, err
-			}
-			i -= size
-			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
-		}
-		i--
-		dAtA[i] = 0xa
+	return nil
+}
+
+func (m *HealthCheck) GetHttpHealthCheck() *HealthCheck_HttpHealthCheck {
+	if x, ok := m.GetHealthChecker().(*HealthCheck_HttpHealthCheck_); ok {
+		return x.HttpHealthCheck
 	}
-	return len(dAtA) - i, nil
+	return nil
 }
 
-func (m *Subset) Marshal() (dAtA []byte, err error) {
-	size := m.Size()
-	dAtA = make([]byte, size)
-	n, err := m.MarshalToSizedBuffer(dAtA[:size])
-	if err != nil {
-		return nil, err
+func (m *HealthCheck) GetTcpHealthCheck() *HealthCheck_TcpHealthCheck {
+	if x, ok := m.GetHealthChecker().(*HealthCheck_TcpHealthCheck_); ok {
+		return x.TcpHealthCheck
 	}
-	return dAtA[:n], nil
+	return nil
 }
 
-func (m *Subset) MarshalTo(dAtA []byte) (int, error) {
-	size := m.Size()
-	return m.MarshalToSizedBuffer(dAtA[:size])
+func (m *HealthCheck) GetGrpcHealthCheck() *HealthCheck_GrpcHealthCheck {
+	if x, ok := m.GetHealthChecker().(*HealthCheck_GrpcHealthCheck_); ok {
+		return x.GrpcHealthCheck
+	}
+	return nil
 }
 
-func (m *Subset) MarshalToSizedBuffer(dAtA []byte) (int, error) {
-	i := len(dAtA)
-	_ = i
-	var l int
-	_ = l
-	if m.XXX_unrecognized != nil {
-		i -= len(m.XXX_unrecognized)
-		copy(dAtA[i:], m.XXX_unrecognized)
+func (m *HealthCheck) GetCustomHealthCheck() *HealthCheck_CustomHealthCheck {
+	if x, ok := m.GetHealthChecker().(*HealthCheck_CustomHealthCheck_); ok {
+		return x.CustomHealthCheck
 	}
-	if m.TrafficPolicy != nil {
-		{
-			size, err := m.TrafficPolicy.MarshalToSizedBuffer(dAtA[:i])
-			if err != nil {
-				return 0, err
-			}
-			i -= size
-			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
-		}
-		i--
-		dAtA[i] = 0x1a
+	return nil
+}
+
+func (m *HealthCheck) GetNoTrafficInterval() *types.Duration {
+	if m != nil {
+		return m.NoTrafficInterval
 	}
-	if len(m.Labels) > 0 {
-		for k := range m.Labels {
-			v := m.Labels[k]
-			baseI := i
-			i -= len(v)
-			copy(dAtA[i:], v)
-			i = encodeVarintDestinationRule(dAtA, i, uint64(len(v)))
-			i--
-			dAtA[i] = 0x12
-			i -= len(k)
-			copy(dAtA[i:], k)
-			i = encodeVarintDestinationRule(dAtA, i, uint64(len(k)))
-			i--
-			dAtA[i] = 0xa
-			i = encodeVarintDestinationRule(dAtA, i, uint64(baseI-i))
-			i--
-			dAtA[i] = 0x12
-		}
+	return nil
+}
+
+func (m *HealthCheck) GetNoTrafficHealthyInterval() *types.Duration {
+	if m != nil {
+		return m.NoTrafficHealthyInterval
 	}
-	if len(m.Name) > 0 {
-		i -= len(m.Name)
-		copy(dAtA[i:], m.Name)
-		i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.Name)))
-		i--
-		dAtA[i] = 0xa
+	return nil
+}
+
+func (m *HealthCheck) GetUnhealthyInterval() *types.Duration {
+	if m != nil {
+		return m.UnhealthyInterval
 	}
-	return len(dAtA) - i, nil
+	return nil
 }
 
-func (m *LoadBalancerSettings) Marshal() (dAtA []byte, err error) {
-	size := m.Size()
-	dAtA = make([]byte, size)
-	n, err := m.MarshalToSizedBuffer(dAtA[:size])
-	if err != nil {
-		return nil, err
+func (m *HealthCheck) GetUnhealthyEdgeInterval() *types.Duration {
+	if m != nil {
+		return m.UnhealthyEdgeInterval
 	}
-	return dAtA[:n], nil
+	return nil
 }
 
-func (m *LoadBalancerSettings) MarshalTo(dAtA []byte) (int, error) {
-	size := m.Size()
-	return m.MarshalToSizedBuffer(dAtA[:size])
+func (m *HealthCheck) GetHealthyEdgeInterval() *types.Duration {
+	if m != nil {
+		return m.HealthyEdgeInterval
+	}
+	return nil
 }
 
-func (m *LoadBalancerSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
-	i := len(dAtA)
-	_ = i
-	var l int
-	_ = l
-	if m.XXX_unrecognized != nil {
-		i -= len(m.XXX_unrecognized)
-		copy(dAtA[i:], m.XXX_unrecognized)
+func (m *HealthCheck) GetEventLogPath() string {
+	if m != nil {
+		return m.EventLogPath
 	}
-	if m.LocalityLbSetting != nil {
-		{
-			size, err := m.LocalityLbSetting.MarshalToSizedBuffer(dAtA[:i])
-			if err != nil {
-				return 0, err
-			}
-			i -= size
-			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
-		}
-		i--
-		dAtA[i] = 0x1a
-	}
-	if m.LbPolicy != nil {
-		{
-			size := m.LbPolicy.Size()
-			i -= size
-			if _, err := m.LbPolicy.MarshalTo(dAtA[i:]); err != nil {
-				return 0, err
-			}
-		}
-	}
-	return len(dAtA) - i, nil
+	return ""
 }
 
-func (m *LoadBalancerSettings_Simple) MarshalTo(dAtA []byte) (int, error) {
-	size := m.Size()
-	return m.MarshalToSizedBuffer(dAtA[:size])
+func (m *HealthCheck) GetAlwaysLogHealthCheckFailures() bool {
+	if m != nil {
+		return m.AlwaysLogHealthCheckFailures
+	}
+	return false
 }
 
-func (m *LoadBalancerSettings_Simple) MarshalToSizedBuffer(dAtA []byte) (int, error) {
-	i := len(dAtA)
-	i = encodeVarintDestinationRule(dAtA, i, uint64(m.Simple))
-	i--
-	dAtA[i] = 0x8
-	return len(dAtA) - i, nil
+func (m *HealthCheck) GetTlsOptions() *HealthCheck_TlsOptions {
+	if m != nil {
+		return m.TlsOptions
+	}
+	return nil
 }
-func (m *LoadBalancerSettings_ConsistentHash) MarshalTo(dAtA []byte) (int, error) {
-	size := m.Size()
-	return m.MarshalToSizedBuffer(dAtA[:size])
+
+// XXX_OneofWrappers is for the internal use of the proto package.
+func (*HealthCheck) XXX_OneofWrappers() []interface{} {
+	return []interface{}{
+		(*HealthCheck_HttpHealthCheck_)(nil),
+		(*HealthCheck_TcpHealthCheck_)(nil),
+		(*HealthCheck_GrpcHealthCheck_)(nil),
+		(*HealthCheck_CustomHealthCheck_)(nil),
+	}
 }
 
-func (m *LoadBalancerSettings_ConsistentHash) MarshalToSizedBuffer(dAtA []byte) (int, error) {
-	i := len(dAtA)
-	if m.ConsistentHash != nil {
-		{
-			size, err := m.ConsistentHash.MarshalToSizedBuffer(dAtA[:i])
-			if err != nil {
-				return 0, err
-			}
-			i -= size
-			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+// [#next-free-field: 13]
+type HealthCheck_HttpHealthCheck struct {
+	Host string `protobuf:"bytes,1,opt,name=host,proto3" json:"host,omitempty"`
+	// Specifies the HTTP path that will be requested during health checking.
+	Path    string   `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
+	Send    *Payload `protobuf:"bytes,3,opt,name=send,proto3" json:"send,omitempty"`
+	Receive *Payload `protobuf:"bytes,4,opt,name=receive,proto3" json:"receive,omitempty"`
+	// Specifies a list of HTTP response statuses considered healthy. If provided, replaces default
+	// 200-only policy - 200 must be included explicitly as needed. Ranges follow half-open
+	// semantics of :ref:`Int64Range <envoy_v3_api_msg_type.v3.Int64Range>`. The start and end of each
+	// range are required. Only statuses in the range [100, 600) are allowed.
+	ExpectedStatuses     []*Int64Range `protobuf:"bytes,9,rep,name=expected_statuses,json=expectedStatuses,proto3" json:"expected_statuses,omitempty"`
+	RetriableStatuses    []*Int64Range `protobuf:"bytes,12,rep,name=retriable_statuses,json=retriableStatuses,proto3" json:"retriable_statuses,omitempty"`
+	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
+	XXX_unrecognized     []byte        `json:"-"`
+	XXX_sizecache        int32         `json:"-"`
+}
+
+func (m *HealthCheck_HttpHealthCheck) Reset()         { *m = HealthCheck_HttpHealthCheck{} }
+func (m *HealthCheck_HttpHealthCheck) String() string { return proto.CompactTextString(m) }
+func (*HealthCheck_HttpHealthCheck) ProtoMessage()    {}
+func (*HealthCheck_HttpHealthCheck) Descriptor() ([]byte, []int) {
+	return fileDescriptor_31054629b619ca4b, []int{11, 0}
+}
+func (m *HealthCheck_HttpHealthCheck) XXX_Unmarshal(b []byte) error {
+	return m.Unmarshal(b)
+}
+func (m *HealthCheck_HttpHealthCheck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	if deterministic {
+		return xxx_messageInfo_HealthCheck_HttpHealthCheck.Marshal(b, m, deterministic)
+	} else {
+		b = b[:cap(b)]
+		n, err := m.MarshalToSizedBuffer(b)
+		if err != nil {
+			return nil, err
 		}
-		i--
-		dAtA[i] = 0x12
+		return b[:n], nil
 	}
-	return len(dAtA) - i, nil
 }
-func (m *LoadBalancerSettings_ConsistentHashLB) Marshal() (dAtA []byte, err error) {
-	size := m.Size()
-	dAtA = make([]byte, size)
-	n, err := m.MarshalToSizedBuffer(dAtA[:size])
-	if err != nil {
-		return nil, err
-	}
-	return dAtA[:n], nil
+func (m *HealthCheck_HttpHealthCheck) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_HealthCheck_HttpHealthCheck.Merge(m, src)
 }
-
-func (m *LoadBalancerSettings_ConsistentHashLB) MarshalTo(dAtA []byte) (int, error) {
-	size := m.Size()
-	return m.MarshalToSizedBuffer(dAtA[:size])
+func (m *HealthCheck_HttpHealthCheck) XXX_Size() int {
+	return m.Size()
+}
+func (m *HealthCheck_HttpHealthCheck) XXX_DiscardUnknown() {
+	xxx_messageInfo_HealthCheck_HttpHealthCheck.DiscardUnknown(m)
 }
 
-func (m *LoadBalancerSettings_ConsistentHashLB) MarshalToSizedBuffer(dAtA []byte) (int, error) {
-	i := len(dAtA)
-	_ = i
-	var l int
-	_ = l
-	if m.XXX_unrecognized != nil {
-		i -= len(m.XXX_unrecognized)
-		copy(dAtA[i:], m.XXX_unrecognized)
-	}
-	if m.HashKey != nil {
-		{
-			size := m.HashKey.Size()
-			i -= size
-			if _, err := m.HashKey.MarshalTo(dAtA[i:]); err != nil {
-				return 0, err
-			}
-		}
+var xxx_messageInfo_HealthCheck_HttpHealthCheck proto.InternalMessageInfo
+
+func (m *HealthCheck_HttpHealthCheck) GetHost() string {
+	if m != nil {
+		return m.Host
 	}
-	if m.MinimumRingSize != 0 {
-		i = encodeVarintDestinationRule(dAtA, i, uint64(m.MinimumRingSize))
-		i--
-		dAtA[i] = 0x20
+	return ""
+}
+
+func (m *HealthCheck_HttpHealthCheck) GetPath() string {
+	if m != nil {
+		return m.Path
 	}
-	return len(dAtA) - i, nil
+	return ""
 }
 
-func (m *LoadBalancerSettings_ConsistentHashLB_HttpHeaderName) MarshalTo(dAtA []byte) (int, error) {
-	size := m.Size()
-	return m.MarshalToSizedBuffer(dAtA[:size])
+func (m *HealthCheck_HttpHealthCheck) GetSend() *Payload {
+	if m != nil {
+		return m.Send
+	}
+	return nil
 }
 
-func (m *LoadBalancerSettings_ConsistentHashLB_HttpHeaderName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
-	i := len(dAtA)
-	i -= len(m.HttpHeaderName)
-	copy(dAtA[i:], m.HttpHeaderName)
-	i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.HttpHeaderName)))
-	i--
-	dAtA[i] = 0xa
-	return len(dAtA) - i, nil
+func (m *HealthCheck_HttpHealthCheck) GetReceive() *Payload {
+	if m != nil {
+		return m.Receive
+	}
+	return nil
 }
-func (m *LoadBalancerSettings_ConsistentHashLB_HttpCookie) MarshalTo(dAtA []byte) (int, error) {
-	size := m.Size()
-	return m.MarshalToSizedBuffer(dAtA[:size])
+
+func (m *HealthCheck_HttpHealthCheck) GetExpectedStatuses() []*Int64Range {
+	if m != nil {
+		return m.ExpectedStatuses
+	}
+	return nil
 }
 
-func (m *LoadBalancerSettings_ConsistentHashLB_HttpCookie) MarshalToSizedBuffer(dAtA []byte) (int, error) {
-	i := len(dAtA)
-	if m.HttpCookie != nil {
-		{
-			size, err := m.HttpCookie.MarshalToSizedBuffer(dAtA[:i])
-			if err != nil {
-				return 0, err
-			}
-			i -= size
-			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
-		}
-		i--
-		dAtA[i] = 0x12
+func (m *HealthCheck_HttpHealthCheck) GetRetriableStatuses() []*Int64Range {
+	if m != nil {
+		return m.RetriableStatuses
 	}
-	return len(dAtA) - i, nil
+	return nil
 }
-func (m *LoadBalancerSettings_ConsistentHashLB_UseSourceIp) MarshalTo(dAtA []byte) (int, error) {
-	size := m.Size()
-	return m.MarshalToSizedBuffer(dAtA[:size])
+
+type HealthCheck_TcpHealthCheck struct {
+	// Empty payloads imply a connect-only health check.
+	Send                 *Payload   `protobuf:"bytes,1,opt,name=send,proto3" json:"send,omitempty"`
+	Receive              []*Payload `protobuf:"bytes,2,rep,name=receive,proto3" json:"receive,omitempty"`
+	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
+	XXX_unrecognized     []byte     `json:"-"`
+	XXX_sizecache        int32      `json:"-"`
 }
 
-func (m *LoadBalancerSettings_ConsistentHashLB_UseSourceIp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
-	i := len(dAtA)
-	i--
-	if m.UseSourceIp {
-		dAtA[i] = 1
+func (m *HealthCheck_TcpHealthCheck) Reset()         { *m = HealthCheck_TcpHealthCheck{} }
+func (m *HealthCheck_TcpHealthCheck) String() string { return proto.CompactTextString(m) }
+func (*HealthCheck_TcpHealthCheck) ProtoMessage()    {}
+func (*HealthCheck_TcpHealthCheck) Descriptor() ([]byte, []int) {
+	return fileDescriptor_31054629b619ca4b, []int{11, 1}
+}
+func (m *HealthCheck_TcpHealthCheck) XXX_Unmarshal(b []byte) error {
+	return m.Unmarshal(b)
+}
+func (m *HealthCheck_TcpHealthCheck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	if deterministic {
+		return xxx_messageInfo_HealthCheck_TcpHealthCheck.Marshal(b, m, deterministic)
 	} else {
-		dAtA[i] = 0
+		b = b[:cap(b)]
+		n, err := m.MarshalToSizedBuffer(b)
+		if err != nil {
+			return nil, err
+		}
+		return b[:n], nil
 	}
-	i--
-	dAtA[i] = 0x18
-	return len(dAtA) - i, nil
 }
-func (m *LoadBalancerSettings_ConsistentHashLB_HttpQueryParameterName) MarshalTo(dAtA []byte) (int, error) {
-	size := m.Size()
-	return m.MarshalToSizedBuffer(dAtA[:size])
+func (m *HealthCheck_TcpHealthCheck) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_HealthCheck_TcpHealthCheck.Merge(m, src)
 }
-
-func (m *LoadBalancerSettings_ConsistentHashLB_HttpQueryParameterName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
-	i := len(dAtA)
-	i -= len(m.HttpQueryParameterName)
-	copy(dAtA[i:], m.HttpQueryParameterName)
-	i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.HttpQueryParameterName)))
-	i--
-	dAtA[i] = 0x2a
-	return len(dAtA) - i, nil
+func (m *HealthCheck_TcpHealthCheck) XXX_Size() int {
+	return m.Size()
 }
-func (m *LoadBalancerSettings_ConsistentHashLB_HTTPCookie) Marshal() (dAtA []byte, err error) {
-	size := m.Size()
-	dAtA = make([]byte, size)
-	n, err := m.MarshalToSizedBuffer(dAtA[:size])
-	if err != nil {
-		return nil, err
-	}
-	return dAtA[:n], nil
+func (m *HealthCheck_TcpHealthCheck) XXX_DiscardUnknown() {
+	xxx_messageInfo_HealthCheck_TcpHealthCheck.DiscardUnknown(m)
 }
 
-func (m *LoadBalancerSettings_ConsistentHashLB_HTTPCookie) MarshalTo(dAtA []byte) (int, error) {
-	size := m.Size()
-	return m.MarshalToSizedBuffer(dAtA[:size])
-}
+var xxx_messageInfo_HealthCheck_TcpHealthCheck proto.InternalMessageInfo
 
-func (m *LoadBalancerSettings_ConsistentHashLB_HTTPCookie) MarshalToSizedBuffer(dAtA []byte) (int, error) {
-	i := len(dAtA)
-	_ = i
-	var l int
-	_ = l
-	if m.XXX_unrecognized != nil {
-		i -= len(m.XXX_unrecognized)
-		copy(dAtA[i:], m.XXX_unrecognized)
-	}
-	if m.Ttl != nil {
-		{
-			size, err := m.Ttl.MarshalToSizedBuffer(dAtA[:i])
-			if err != nil {
-				return 0, err
-			}
-			i -= size
-			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
-		}
-		i--
-		dAtA[i] = 0x1a
-	}
-	if len(m.Path) > 0 {
-		i -= len(m.Path)
-		copy(dAtA[i:], m.Path)
-		i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.Path)))
-		i--
-		dAtA[i] = 0x12
-	}
-	if len(m.Name) > 0 {
-		i -= len(m.Name)
-		copy(dAtA[i:], m.Name)
-		i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.Name)))
-		i--
-		dAtA[i] = 0xa
+func (m *HealthCheck_TcpHealthCheck) GetSend() *Payload {
+	if m != nil {
+		return m.Send
 	}
-	return len(dAtA) - i, nil
+	return nil
 }
 
-func (m *ConnectionPoolSettings) Marshal() (dAtA []byte, err error) {
-	size := m.Size()
-	dAtA = make([]byte, size)
-	n, err := m.MarshalToSizedBuffer(dAtA[:size])
-	if err != nil {
-		return nil, err
+func (m *HealthCheck_TcpHealthCheck) GetReceive() []*Payload {
+	if m != nil {
+		return m.Receive
 	}
-	return dAtA[:n], nil
+	return nil
 }
 
-func (m *ConnectionPoolSettings) MarshalTo(dAtA []byte) (int, error) {
-	size := m.Size()
-	return m.MarshalToSizedBuffer(dAtA[:size])
+type HealthCheck_RedisHealthCheck struct {
+	Key                  string   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
+	XXX_NoUnkeyedLiteral struct{} `json:"-"`
+	XXX_unrecognized     []byte   `json:"-"`
+	XXX_sizecache        int32    `json:"-"`
 }
 
-func (m *ConnectionPoolSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
-	i := len(dAtA)
-	_ = i
-	var l int
-	_ = l
-	if m.XXX_unrecognized != nil {
-		i -= len(m.XXX_unrecognized)
-		copy(dAtA[i:], m.XXX_unrecognized)
+func (m *HealthCheck_RedisHealthCheck) Reset()         { *m = HealthCheck_RedisHealthCheck{} }
+func (m *HealthCheck_RedisHealthCheck) String() string { return proto.CompactTextString(m) }
+func (*HealthCheck_RedisHealthCheck) ProtoMessage()    {}
+func (*HealthCheck_RedisHealthCheck) Descriptor() ([]byte, []int) {
+	return fileDescriptor_31054629b619ca4b, []int{11, 2}
+}
+func (m *HealthCheck_RedisHealthCheck) XXX_Unmarshal(b []byte) error {
+	return m.Unmarshal(b)
+}
+func (m *HealthCheck_RedisHealthCheck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	if deterministic {
+		return xxx_messageInfo_HealthCheck_RedisHealthCheck.Marshal(b, m, deterministic)
+	} else {
+		b = b[:cap(b)]
+		n, err := m.MarshalToSizedBuffer(b)
+		if err != nil {
+			return nil, err
+		}
+		return b[:n], nil
 	}
-	if m.Http != nil {
-		{
-			size, err := m.Http.MarshalToSizedBuffer(dAtA[:i])
-			if err != nil {
-				return 0, err
-			}
-			i -= size
-			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+}
+func (m *HealthCheck_RedisHealthCheck) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_HealthCheck_RedisHealthCheck.Merge(m, src)
+}
+func (m *HealthCheck_RedisHealthCheck) XXX_Size() int {
+	return m.Size()
+}
+func (m *HealthCheck_RedisHealthCheck) XXX_DiscardUnknown() {
+	xxx_messageInfo_HealthCheck_RedisHealthCheck.DiscardUnknown(m)
+}
+
+var xxx_messageInfo_HealthCheck_RedisHealthCheck proto.InternalMessageInfo
+
+func (m *HealthCheck_RedisHealthCheck) GetKey() string {
+	if m != nil {
+		return m.Key
+	}
+	return ""
+}
+
+type HealthCheck_GrpcHealthCheck struct {
+	ServiceName          string   `protobuf:"bytes,1,opt,name=service_name,json=serviceName,proto3" json:"service_name,omitempty"`
+	Authority            string   `protobuf:"bytes,2,opt,name=authority,proto3" json:"authority,omitempty"`
+	XXX_NoUnkeyedLiteral struct{} `json:"-"`
+	XXX_unrecognized     []byte   `json:"-"`
+	XXX_sizecache        int32    `json:"-"`
+}
+
+func (m *HealthCheck_GrpcHealthCheck) Reset()         { *m = HealthCheck_GrpcHealthCheck{} }
+func (m *HealthCheck_GrpcHealthCheck) String() string { return proto.CompactTextString(m) }
+func (*HealthCheck_GrpcHealthCheck) ProtoMessage()    {}
+func (*HealthCheck_GrpcHealthCheck) Descriptor() ([]byte, []int) {
+	return fileDescriptor_31054629b619ca4b, []int{11, 3}
+}
+func (m *HealthCheck_GrpcHealthCheck) XXX_Unmarshal(b []byte) error {
+	return m.Unmarshal(b)
+}
+func (m *HealthCheck_GrpcHealthCheck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	if deterministic {
+		return xxx_messageInfo_HealthCheck_GrpcHealthCheck.Marshal(b, m, deterministic)
+	} else {
+		b = b[:cap(b)]
+		n, err := m.MarshalToSizedBuffer(b)
+		if err != nil {
+			return nil, err
 		}
-		i--
-		dAtA[i] = 0x12
+		return b[:n], nil
 	}
-	if m.Tcp != nil {
-		{
-			size, err := m.Tcp.MarshalToSizedBuffer(dAtA[:i])
-			if err != nil {
-				return 0, err
-			}
-			i -= size
-			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+}
+func (m *HealthCheck_GrpcHealthCheck) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_HealthCheck_GrpcHealthCheck.Merge(m, src)
+}
+func (m *HealthCheck_GrpcHealthCheck) XXX_Size() int {
+	return m.Size()
+}
+func (m *HealthCheck_GrpcHealthCheck) XXX_DiscardUnknown() {
+	xxx_messageInfo_HealthCheck_GrpcHealthCheck.DiscardUnknown(m)
+}
+
+var xxx_messageInfo_HealthCheck_GrpcHealthCheck proto.InternalMessageInfo
+
+func (m *HealthCheck_GrpcHealthCheck) GetServiceName() string {
+	if m != nil {
+		return m.ServiceName
+	}
+	return ""
+}
+
+func (m *HealthCheck_GrpcHealthCheck) GetAuthority() string {
+	if m != nil {
+		return m.Authority
+	}
+	return ""
+}
+
+// Custom health check.
+type HealthCheck_CustomHealthCheck struct {
+	// The registered name of the custom health checker.
+	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
+	XXX_NoUnkeyedLiteral struct{} `json:"-"`
+	XXX_unrecognized     []byte   `json:"-"`
+	XXX_sizecache        int32    `json:"-"`
+}
+
+func (m *HealthCheck_CustomHealthCheck) Reset()         { *m = HealthCheck_CustomHealthCheck{} }
+func (m *HealthCheck_CustomHealthCheck) String() string { return proto.CompactTextString(m) }
+func (*HealthCheck_CustomHealthCheck) ProtoMessage()    {}
+func (*HealthCheck_CustomHealthCheck) Descriptor() ([]byte, []int) {
+	return fileDescriptor_31054629b619ca4b, []int{11, 4}
+}
+func (m *HealthCheck_CustomHealthCheck) XXX_Unmarshal(b []byte) error {
+	return m.Unmarshal(b)
+}
+func (m *HealthCheck_CustomHealthCheck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	if deterministic {
+		return xxx_messageInfo_HealthCheck_CustomHealthCheck.Marshal(b, m, deterministic)
+	} else {
+		b = b[:cap(b)]
+		n, err := m.MarshalToSizedBuffer(b)
+		if err != nil {
+			return nil, err
 		}
-		i--
-		dAtA[i] = 0xa
+		return b[:n], nil
 	}
-	return len(dAtA) - i, nil
+}
+func (m *HealthCheck_CustomHealthCheck) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_HealthCheck_CustomHealthCheck.Merge(m, src)
+}
+func (m *HealthCheck_CustomHealthCheck) XXX_Size() int {
+	return m.Size()
+}
+func (m *HealthCheck_CustomHealthCheck) XXX_DiscardUnknown() {
+	xxx_messageInfo_HealthCheck_CustomHealthCheck.DiscardUnknown(m)
 }
 
-func (m *ConnectionPoolSettings_TCPSettings) Marshal() (dAtA []byte, err error) {
+var xxx_messageInfo_HealthCheck_CustomHealthCheck proto.InternalMessageInfo
+
+func (m *HealthCheck_CustomHealthCheck) GetName() string {
+	if m != nil {
+		return m.Name
+	}
+	return ""
+}
+
+// Health checks occur over the transport socket specified for the cluster. This implies that if a
+// cluster is using a TLS-enabled transport socket, the health check will also occur over TLS.
+//
+// This allows overriding the cluster TLS settings, just for health check connections.
+type HealthCheck_TlsOptions struct {
+	AlpnProtocols        []string `protobuf:"bytes,1,rep,name=alpn_protocols,json=alpnProtocols,proto3" json:"alpn_protocols,omitempty"`
+	XXX_NoUnkeyedLiteral struct{} `json:"-"`
+	XXX_unrecognized     []byte   `json:"-"`
+	XXX_sizecache        int32    `json:"-"`
+}
+
+func (m *HealthCheck_TlsOptions) Reset()         { *m = HealthCheck_TlsOptions{} }
+func (m *HealthCheck_TlsOptions) String() string { return proto.CompactTextString(m) }
+func (*HealthCheck_TlsOptions) ProtoMessage()    {}
+func (*HealthCheck_TlsOptions) Descriptor() ([]byte, []int) {
+	return fileDescriptor_31054629b619ca4b, []int{11, 5}
+}
+func (m *HealthCheck_TlsOptions) XXX_Unmarshal(b []byte) error {
+	return m.Unmarshal(b)
+}
+func (m *HealthCheck_TlsOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	if deterministic {
+		return xxx_messageInfo_HealthCheck_TlsOptions.Marshal(b, m, deterministic)
+	} else {
+		b = b[:cap(b)]
+		n, err := m.MarshalToSizedBuffer(b)
+		if err != nil {
+			return nil, err
+		}
+		return b[:n], nil
+	}
+}
+func (m *HealthCheck_TlsOptions) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_HealthCheck_TlsOptions.Merge(m, src)
+}
+func (m *HealthCheck_TlsOptions) XXX_Size() int {
+	return m.Size()
+}
+func (m *HealthCheck_TlsOptions) XXX_DiscardUnknown() {
+	xxx_messageInfo_HealthCheck_TlsOptions.DiscardUnknown(m)
+}
+
+var xxx_messageInfo_HealthCheck_TlsOptions proto.InternalMessageInfo
+
+func (m *HealthCheck_TlsOptions) GetAlpnProtocols() []string {
+	if m != nil {
+		return m.AlpnProtocols
+	}
+	return nil
+}
+
+func init() {
+	proto.RegisterEnum("istio.networking.v1beta1.HealthStatus", HealthStatus_name, HealthStatus_value)
+	proto.RegisterEnum("istio.networking.v1beta1.LoadBalancerSettings_SimpleLB", LoadBalancerSettings_SimpleLB_name, LoadBalancerSettings_SimpleLB_value)
+	proto.RegisterEnum("istio.networking.v1beta1.ConnectionPoolSettings_HTTPSettings_H2UpgradePolicy", ConnectionPoolSettings_HTTPSettings_H2UpgradePolicy_name, ConnectionPoolSettings_HTTPSettings_H2UpgradePolicy_value)
+	proto.RegisterEnum("istio.networking.v1beta1.ClientTLSSettings_TLSmode", ClientTLSSettings_TLSmode_name, ClientTLSSettings_TLSmode_value)
+	proto.RegisterType((*DestinationRule)(nil), "istio.networking.v1beta1.DestinationRule")
+	proto.RegisterType((*TrafficPolicy)(nil), "istio.networking.v1beta1.TrafficPolicy")
+	proto.RegisterType((*TrafficPolicy_PortTrafficPolicy)(nil), "istio.networking.v1beta1.TrafficPolicy.PortTrafficPolicy")
+	proto.RegisterType((*Subset)(nil), "istio.networking.v1beta1.Subset")
+	proto.RegisterMapType((map[string]string)(nil), "istio.networking.v1beta1.Subset.LabelsEntry")
+	proto.RegisterType((*LoadBalancerSettings)(nil), "istio.networking.v1beta1.LoadBalancerSettings")
+	proto.RegisterType((*LoadBalancerSettings_ConsistentHashLB)(nil), "istio.networking.v1beta1.LoadBalancerSettings.ConsistentHashLB")
+	proto.RegisterType((*LoadBalancerSettings_ConsistentHashLB_HTTPCookie)(nil), "istio.networking.v1beta1.LoadBalancerSettings.ConsistentHashLB.HTTPCookie")
+	proto.RegisterType((*ConnectionPoolSettings)(nil), "istio.networking.v1beta1.ConnectionPoolSettings")
+	proto.RegisterType((*ConnectionPoolSettings_TCPSettings)(nil), "istio.networking.v1beta1.ConnectionPoolSettings.TCPSettings")
+	proto.RegisterType((*ConnectionPoolSettings_TCPSettings_TcpKeepalive)(nil), "istio.networking.v1beta1.ConnectionPoolSettings.TCPSettings.TcpKeepalive")
+	proto.RegisterType((*ConnectionPoolSettings_HTTPSettings)(nil), "istio.networking.v1beta1.ConnectionPoolSettings.HTTPSettings")
+	proto.RegisterType((*OutlierDetection)(nil), "istio.networking.v1beta1.OutlierDetection")
+	proto.RegisterType((*ClientTLSSettings)(nil), "istio.networking.v1beta1.ClientTLSSettings")
+	proto.RegisterType((*LocalityLoadBalancerSetting)(nil), "istio.networking.v1beta1.LocalityLoadBalancerSetting")
+	proto.RegisterType((*LocalityLoadBalancerSetting_Distribute)(nil), "istio.networking.v1beta1.LocalityLoadBalancerSetting.Distribute")
+	proto.RegisterMapType((map[string]uint32)(nil), "istio.networking.v1beta1.LocalityLoadBalancerSetting.Distribute.ToEntry")
+	proto.RegisterType((*LocalityLoadBalancerSetting_Failover)(nil), "istio.networking.v1beta1.LocalityLoadBalancerSetting.Failover")
+	proto.RegisterType((*Int64Range)(nil), "istio.networking.v1beta1.Int64Range")
+	proto.RegisterType((*HealthStatusSet)(nil), "istio.networking.v1beta1.HealthStatusSet")
+	proto.RegisterType((*Payload)(nil), "istio.networking.v1beta1.Payload")
+	proto.RegisterType((*HealthCheck)(nil), "istio.networking.v1beta1.HealthCheck")
+	proto.RegisterType((*HealthCheck_HttpHealthCheck)(nil), "istio.networking.v1beta1.HealthCheck.HttpHealthCheck")
+	proto.RegisterType((*HealthCheck_TcpHealthCheck)(nil), "istio.networking.v1beta1.HealthCheck.TcpHealthCheck")
+	proto.RegisterType((*HealthCheck_RedisHealthCheck)(nil), "istio.networking.v1beta1.HealthCheck.RedisHealthCheck")
+	proto.RegisterType((*HealthCheck_GrpcHealthCheck)(nil), "istio.networking.v1beta1.HealthCheck.GrpcHealthCheck")
+	proto.RegisterType((*HealthCheck_CustomHealthCheck)(nil), "istio.networking.v1beta1.HealthCheck.CustomHealthCheck")
+	proto.RegisterType((*HealthCheck_TlsOptions)(nil), "istio.networking.v1beta1.HealthCheck.TlsOptions")
+}
+
+func init() {
+	proto.RegisterFile("networking/v1beta1/destination_rule.proto", fileDescriptor_31054629b619ca4b)
+}
+
+var fileDescriptor_31054629b619ca4b = []byte{
+	// 2822 bytes of a gzipped FileDescriptorProto
+	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x59, 0x4b, 0x73, 0x1b, 0xc7,
+	0xf1, 0x27, 0x1e, 0x24, 0x80, 0x06, 0x09, 0x2e, 0x86, 0x94, 0x04, 0x43, 0x2e, 0x59, 0x46, 0xc9,
+	0x7f, 0xeb, 0x2f, 0xdb, 0x90, 0x45, 0x89, 0x76, 0xfc, 0x8a, 0x4d, 0x90, 0x90, 0x00, 0x0a, 0x04,
+	0xa1, 0x05, 0xe8, 0xd7, 0x65, 0x3d, 0x58, 0x0c, 0x81, 0x31, 0x17, 0x3b, 0xeb, 0xdd, 0x01, 0x44,
+	0xf8, 0x9a, 0x54, 0x0e, 0xa9, 0x7c, 0x82, 0x1c, 0xf3, 0x0d, 0x72, 0xca, 0x29, 0xf7, 0x1c, 0x53,
+	0x29, 0x7f, 0x80, 0x94, 0xf2, 0x11, 0x92, 0x4b, 0x6e, 0xa9, 0x99, 0x9d, 0x5d, 0x2c, 0xf8, 0x02,
+	0x29, 0xd9, 0xb7, 0x9d, 0x9e, 0xfe, 0xfd, 0x7a, 0x1e, 0x3d, 0xdd, 0x3d, 0xb3, 0xf0, 0xff, 0x36,
+	0xe1, 0xcf, 0x99, 0x7b, 0x44, 0xed, 0xfe, 0xfd, 0xf1, 0x83, 0x2e, 0xe1, 0xf8, 0xc1, 0xfd, 0x1e,
+	0xf1, 0x38, 0xb5, 0x31, 0xa7, 0xcc, 0x36, 0xdc, 0x91, 0x45, 0xca, 0x8e, 0xcb, 0x38, 0x43, 0x05,
+	0xea, 0x71, 0xca, 0xca, 0x53, 0x40, 0x59, 0x01, 0x8a, 0x6f, 0xf4, 0x19, 0xeb, 0x5b, 0xe4, 0x3e,
+	0x76, 0xe8, 0xfd, 0x43, 0x4a, 0xac, 0x9e, 0xd1, 0x25, 0x03, 0x3c, 0xa6, 0xcc, 0xf5, 0xa1, 0xc5,
+	0x5b, 0x4a, 0x41, 0xb6, 0xba, 0xa3, 0xc3, 0xfb, 0xbd, 0x91, 0x2b, 0xf9, 0xcf, 0xeb, 0x7f, 0xee,
+	0x62, 0xc7, 0x21, 0xae, 0xa7, 0xfa, 0xef, 0x9e, 0x31, 0xca, 0x31, 0x75, 0xf9, 0x08, 0x5b, 0x86,
+	0x47, 0xdc, 0x31, 0x35, 0xd5, 0x20, 0x8b, 0xeb, 0x7d, 0xd6, 0x67, 0xf2, 0xf3, 0xbe, 0xf8, 0xf2,
+	0xa5, 0xa5, 0x9f, 0x62, 0xb0, 0xba, 0x33, 0x9d, 0x95, 0x3e, 0xb2, 0x08, 0x2a, 0x40, 0x72, 0xc0,
+	0x3c, 0x5e, 0x88, 0xdd, 0x8e, 0xdd, 0xcd, 0x54, 0x92, 0x2f, 0xb6, 0x62, 0x71, 0x5d, 0x4a, 0x50,
+	0x13, 0x72, 0xdc, 0xc5, 0x87, 0x87, 0xd4, 0x34, 0x1c, 0x66, 0x51, 0x73, 0x52, 0x88, 0xdf, 0x8e,
+	0xdd, 0xcd, 0x6e, 0xbc, 0x5d, 0x3e, 0x6f, 0x05, 0xca, 0x1d, 0x5f, 0xbf, 0x25, 0xd5, 0xf5, 0x15,
+	0x1e, 0x6d, 0xa2, 0x8f, 0x21, 0xe5, 0x8d, 0xba, 0x1e, 0xe1, 0x5e, 0x21, 0x71, 0x3b, 0x71, 0x37,
+	0xbb, 0x71, 0xfb, 0x7c, 0xa2, 0xb6, 0x54, 0xd4, 0x03, 0x00, 0xba, 0x09, 0x19, 0x72, 0xec, 0x30,
+	0x97, 0x1b, 0x9c, 0x15, 0x92, 0xb7, 0x13, 0x77, 0x33, 0x7a, 0xda, 0x17, 0x74, 0x58, 0xe9, 0x3f,
+	0x29, 0x58, 0x99, 0xb1, 0x8c, 0xda, 0xb0, 0x62, 0x31, 0xdc, 0x33, 0xba, 0xd8, 0xc2, 0xb6, 0x49,
+	0x5c, 0x39, 0xbb, 0xec, 0x46, 0xf9, 0x7c, 0x83, 0x0d, 0x86, 0x7b, 0x15, 0xa5, 0xdd, 0x26, 0x9c,
+	0x53, 0xbb, 0xef, 0xe9, 0xcb, 0x56, 0x44, 0x8a, 0xbe, 0x81, 0x55, 0x93, 0xd9, 0x36, 0x31, 0xa5,
+	0x47, 0x38, 0x8c, 0x59, 0x6a, 0x41, 0xde, 0x3f, 0x9f, 0x76, 0x3b, 0x04, 0xb4, 0x18, 0xb3, 0x42,
+	0xe2, 0x9c, 0x39, 0x23, 0x47, 0x5f, 0x41, 0x9e, 0x8d, 0xb8, 0x45, 0x89, 0x6b, 0xf4, 0x08, 0xf7,
+	0x3b, 0x0a, 0x09, 0x49, 0x7e, 0xef, 0x7c, 0xf2, 0x7d, 0x1f, 0xb2, 0x13, 0x20, 0x74, 0x8d, 0x9d,
+	0x90, 0xa0, 0xcf, 0x20, 0xc1, 0x2d, 0xaf, 0x90, 0x94, 0x54, 0xef, 0x5c, 0x30, 0x4e, 0x8b, 0x12,
+	0x9b, 0x77, 0x1a, 0xed, 0x70, 0x88, 0x02, 0x87, 0x28, 0xac, 0xc9, 0x45, 0xb7, 0xc8, 0x98, 0x08,
+	0x17, 0xf3, 0xfb, 0x0a, 0x8b, 0x72, 0xfb, 0x3e, 0xba, 0xa4, 0x1f, 0x94, 0x5b, 0x62, 0x9b, 0x66,
+	0x3c, 0x23, 0x2f, 0x58, 0x1b, 0x82, 0x34, 0xb0, 0x87, 0x76, 0x61, 0x65, 0x40, 0xb0, 0xc5, 0x07,
+	0x86, 0x39, 0x20, 0xe6, 0x91, 0x57, 0x20, 0xd2, 0xc8, 0x5b, 0xe7, 0x1b, 0xa9, 0x49, 0xf5, 0x6d,
+	0xa1, 0xad, 0x2f, 0x0f, 0xa6, 0x0d, 0xaf, 0xf8, 0xaf, 0x04, 0xe4, 0x4f, 0x19, 0x45, 0x1f, 0x43,
+	0x52, 0x98, 0x55, 0xbe, 0xf0, 0x7f, 0xe7, 0x13, 0x0b, 0x68, 0x9b, 0x58, 0xc4, 0xe4, 0xcc, 0xd5,
+	0x25, 0xe6, 0xb4, 0x43, 0xc5, 0x7f, 0x19, 0x87, 0x4a, 0xfc, 0x92, 0x0e, 0x95, 0xfc, 0xf9, 0x1c,
+	0x6a, 0xf1, 0x25, 0x1d, 0xea, 0x67, 0xdc, 0xe5, 0xd2, 0xbf, 0x63, 0xb0, 0xe4, 0xc7, 0x09, 0x11,
+	0xc4, 0x6c, 0x3c, 0x24, 0xb3, 0x41, 0x4c, 0x48, 0xd0, 0x0e, 0x2c, 0x59, 0xb8, 0x4b, 0x2c, 0xaf,
+	0x10, 0x97, 0x96, 0xde, 0x9d, 0x17, 0x73, 0xca, 0x0d, 0xa9, 0x5e, 0xb5, 0xb9, 0x3b, 0xd1, 0x15,
+	0xf6, 0x8c, 0x50, 0x98, 0x78, 0x95, 0x50, 0x58, 0xfc, 0x08, 0xb2, 0x11, 0x33, 0x48, 0x83, 0xc4,
+	0x11, 0x99, 0xf8, 0xa3, 0xd7, 0xc5, 0x27, 0x5a, 0x87, 0xc5, 0x31, 0xb6, 0x46, 0x44, 0xfa, 0x59,
+	0x46, 0xf7, 0x1b, 0x1f, 0xc7, 0x7f, 0x15, 0x2b, 0xfd, 0x31, 0x05, 0xeb, 0x67, 0xf9, 0x16, 0x7a,
+	0x06, 0x4b, 0x1e, 0x1d, 0x3a, 0x96, 0xbf, 0x0a, 0xb9, 0x8d, 0x0f, 0xaf, 0xe6, 0x9b, 0xe5, 0xb6,
+	0x04, 0x37, 0x2a, 0xb5, 0x05, 0x5d, 0x11, 0xa1, 0xef, 0xa5, 0x83, 0x7a, 0xd4, 0xe3, 0xc4, 0xe6,
+	0xc6, 0x00, 0x7b, 0x03, 0xe5, 0xf7, 0x9f, 0x5f, 0x91, 0x7b, 0x3b, 0x64, 0xa9, 0x61, 0x6f, 0x20,
+	0x6d, 0xe4, 0xcc, 0x19, 0x19, 0x22, 0xb0, 0x66, 0x31, 0x13, 0x5b, 0x94, 0x4f, 0x0c, 0xab, 0x1b,
+	0xc4, 0x1a, 0xb5, 0xce, 0x9b, 0x17, 0xd9, 0xf3, 0x41, 0x67, 0xd8, 0xd5, 0xf3, 0x01, 0x63, 0xa3,
+	0xab, 0x44, 0xe8, 0x29, 0xac, 0x3f, 0xc7, 0xee, 0x70, 0xe4, 0x18, 0x41, 0xee, 0x35, 0x3c, 0x62,
+	0x06, 0x11, 0xf2, 0xb5, 0xb2, 0x9f, 0x81, 0xcb, 0x41, 0x06, 0x2e, 0xef, 0x28, 0x2d, 0x1d, 0xf9,
+	0xb0, 0xa0, 0xdd, 0x26, 0xa6, 0x57, 0xfc, 0x4b, 0x02, 0xb4, 0x93, 0x53, 0x43, 0xf7, 0x40, 0x1b,
+	0x70, 0xee, 0x18, 0x03, 0x82, 0x7b, 0xc4, 0x35, 0xa6, 0x7e, 0x29, 0x26, 0x2d, 0x7a, 0x6a, 0xb2,
+	0xa3, 0x29, 0xbc, 0x73, 0x08, 0x59, 0xa9, 0x6b, 0x32, 0x76, 0x44, 0x89, 0x5a, 0xdc, 0xdd, 0x57,
+	0x5c, 0xdc, 0x72, 0xad, 0xd3, 0x69, 0x6d, 0x4b, 0xc6, 0xda, 0x82, 0x0e, 0xc2, 0x80, 0xdf, 0x42,
+	0x77, 0x60, 0x65, 0xe4, 0x11, 0xc3, 0x63, 0x23, 0xd7, 0x24, 0x06, 0x75, 0xe4, 0xea, 0xa6, 0x6b,
+	0x0b, 0x7a, 0x76, 0xe4, 0x91, 0xb6, 0x94, 0xd6, 0x1d, 0xf4, 0x09, 0xbc, 0x26, 0x07, 0xf5, 0xc3,
+	0x88, 0xb8, 0x13, 0xc3, 0xc1, 0x2e, 0x1e, 0x12, 0x1e, 0xcc, 0x64, 0x51, 0xcd, 0xe4, 0xba, 0x50,
+	0x79, 0x26, 0x34, 0x5a, 0x81, 0x82, 0x9c, 0xd1, 0x3d, 0xc8, 0x0f, 0xa9, 0x4d, 0x87, 0xa3, 0xa1,
+	0xe1, 0x52, 0xbb, 0x6f, 0x78, 0xf4, 0x47, 0x22, 0x17, 0x37, 0xa9, 0xaf, 0xaa, 0x0e, 0x9d, 0xda,
+	0xfd, 0x36, 0xfd, 0x91, 0x14, 0x87, 0x00, 0xd3, 0xa1, 0x5e, 0x70, 0x86, 0x11, 0x24, 0x1d, 0xcc,
+	0x07, 0xea, 0x2c, 0xc8, 0x6f, 0xf4, 0x00, 0x12, 0x9c, 0x07, 0xf1, 0xf2, 0xfc, 0x6d, 0x53, 0x3c,
+	0x42, 0xb7, 0x02, 0x90, 0x16, 0x2e, 0x6c, 0x1c, 0x91, 0x49, 0xa9, 0x06, 0xe9, 0xc0, 0xdf, 0xd1,
+	0x2a, 0x64, 0xf5, 0xfd, 0x83, 0xe6, 0x8e, 0xa1, 0xef, 0x57, 0xea, 0x4d, 0x6d, 0x01, 0xe5, 0x00,
+	0x1a, 0xd5, 0xad, 0x76, 0xc7, 0xd8, 0xde, 0x6f, 0x36, 0xb5, 0x18, 0x02, 0x58, 0xd2, 0xb7, 0x9a,
+	0x3b, 0xfb, 0x7b, 0x5a, 0x5c, 0x28, 0xb7, 0xb6, 0xda, 0xed, 0x4e, 0x4d, 0xdf, 0x3f, 0x78, 0x52,
+	0xd3, 0x12, 0x95, 0x2c, 0x64, 0xac, 0xae, 0x8a, 0x0a, 0xa5, 0xbf, 0xa6, 0xe1, 0xfa, 0xd9, 0x11,
+	0x1a, 0x35, 0x21, 0xc1, 0x4d, 0x47, 0x25, 0x9f, 0x4f, 0xaf, 0x1a, 0xe0, 0xcb, 0x9d, 0xed, 0x56,
+	0x24, 0x92, 0x9a, 0x0e, 0x7a, 0x06, 0x49, 0xb1, 0x05, 0xca, 0x67, 0x3e, 0xbb, 0x32, 0xa1, 0x58,
+	0xf9, 0x90, 0x51, 0x52, 0x15, 0xff, 0x1b, 0x87, 0x6c, 0xc4, 0x0e, 0x7a, 0x1b, 0x56, 0x87, 0xf8,
+	0xd8, 0x98, 0xa6, 0x16, 0x4f, 0x0e, 0x7f, 0x51, 0xcf, 0x0d, 0xf1, 0xf1, 0x94, 0xd6, 0x43, 0x95,
+	0x30, 0x91, 0x19, 0x9c, 0x0e, 0x09, 0x1b, 0x71, 0x35, 0xac, 0x0b, 0xce, 0x53, 0x90, 0xb1, 0x3a,
+	0x3e, 0x00, 0xd9, 0xb0, 0xc2, 0x4d, 0xc7, 0x38, 0x22, 0xc4, 0xc1, 0x16, 0x1d, 0x13, 0xb5, 0xb5,
+	0xf5, 0x57, 0x59, 0xa9, 0x72, 0xc7, 0x74, 0x9e, 0x06, 0x84, 0xfa, 0x32, 0x8f, 0xb4, 0x8a, 0x7f,
+	0x88, 0xc1, 0x72, 0xb4, 0x1b, 0x5d, 0x87, 0x25, 0xc7, 0x65, 0x5d, 0xe2, 0x4f, 0x72, 0x45, 0x57,
+	0x2d, 0xf4, 0x1e, 0x24, 0xc5, 0xa4, 0xe6, 0xcf, 0x48, 0xaa, 0xa1, 0x4d, 0x48, 0x53, 0x9b, 0x13,
+	0x77, 0x8c, 0xe7, 0x7b, 0xa7, 0x1e, 0xaa, 0x16, 0x7f, 0x93, 0x84, 0xe5, 0xe8, 0x96, 0xa0, 0x4f,
+	0xa0, 0x28, 0x36, 0xe5, 0x81, 0x21, 0xb6, 0xc0, 0x21, 0x76, 0x4f, 0x9c, 0x26, 0x97, 0xfc, 0x30,
+	0x22, 0x1e, 0x0f, 0xf6, 0xe1, 0x86, 0xd4, 0xd8, 0xc3, 0xc7, 0x2d, 0xbf, 0x5f, 0x57, 0xdd, 0xe8,
+	0x5d, 0x40, 0xa2, 0x6b, 0x43, 0x82, 0x43, 0x50, 0x5c, 0x82, 0x64, 0x74, 0xda, 0xd8, 0xc3, 0xc7,
+	0xa1, 0xf6, 0x67, 0x70, 0x33, 0xaa, 0x67, 0x38, 0xc4, 0x8d, 0x6c, 0xba, 0x9c, 0xc5, 0xa2, 0x5e,
+	0x18, 0x4e, 0x11, 0x2d, 0xe2, 0x4e, 0x17, 0x1f, 0xbd, 0x01, 0x59, 0x1f, 0xce, 0x5d, 0x4a, 0xfc,
+	0x48, 0xba, 0xa8, 0x83, 0x54, 0x97, 0x12, 0xf4, 0x29, 0x2c, 0xd3, 0x9e, 0x45, 0x42, 0xdf, 0x58,
+	0x9c, 0xb7, 0x2c, 0x59, 0xa1, 0x1e, 0x38, 0xc6, 0x04, 0xf2, 0x83, 0x0d, 0x63, 0xe4, 0xf4, 0x5d,
+	0xdc, 0x23, 0x41, 0xfa, 0x5d, 0x92, 0x29, 0x6e, 0xef, 0x95, 0xbc, 0xbe, 0x5c, 0xdb, 0x38, 0xf0,
+	0x59, 0x55, 0x92, 0x5e, 0x1d, 0xcc, 0x0a, 0x50, 0x19, 0xd6, 0x44, 0xbc, 0x34, 0x65, 0x2d, 0x63,
+	0xc8, 0x71, 0x9a, 0xcc, 0x2a, 0xa4, 0x44, 0xd4, 0xd4, 0xf3, 0x23, 0x8f, 0xf8, 0x55, 0x4e, 0x4b,
+	0x75, 0x94, 0x3e, 0x87, 0xd5, 0x13, 0x9c, 0x28, 0x0b, 0xa9, 0x9d, 0xea, 0xe3, 0xad, 0x83, 0x46,
+	0x47, 0x5b, 0x40, 0x08, 0x72, 0x3b, 0xfb, 0x46, 0x73, 0xbf, 0x63, 0x1c, 0xb4, 0x9e, 0xe8, 0x5b,
+	0x3b, 0x55, 0x2d, 0x26, 0x14, 0x82, 0x46, 0xbc, 0xf4, 0xfb, 0x45, 0xd0, 0x4e, 0x16, 0x61, 0xe8,
+	0x01, 0x20, 0x91, 0x2b, 0x89, 0x39, 0xe2, 0x74, 0x4c, 0x0c, 0xe2, 0xba, 0xcc, 0x55, 0x1e, 0x50,
+	0x89, 0x17, 0x62, 0x7a, 0x3e, 0xd2, 0x5b, 0x95, 0x9d, 0x68, 0x17, 0x4a, 0x9e, 0x63, 0x51, 0x6e,
+	0x90, 0x63, 0x4e, 0x5c, 0x1b, 0x5b, 0x86, 0xcc, 0x84, 0x06, 0x73, 0x69, 0x9f, 0xda, 0x01, 0x45,
+	0x5a, 0xce, 0xe3, 0x96, 0xd4, 0xac, 0x2a, 0x45, 0x99, 0x4e, 0xf7, 0xa5, 0x9a, 0xe2, 0xea, 0xc3,
+	0x9b, 0x51, 0xf3, 0x33, 0x44, 0x87, 0x98, 0x5a, 0x23, 0x97, 0x78, 0x85, 0x8c, 0xdc, 0xd2, 0xd7,
+	0x4f, 0x6d, 0xe9, 0x41, 0xdd, 0xe6, 0x0f, 0x37, 0xbe, 0x14, 0xd5, 0x8b, 0x7e, 0x2b, 0x42, 0x13,
+	0x31, 0xf3, 0x58, 0x71, 0xa0, 0x6f, 0xa1, 0x18, 0x35, 0xd4, 0xc7, 0x9c, 0x3c, 0xc7, 0x93, 0x60,
+	0xb0, 0x4b, 0x97, 0xb0, 0x50, 0x88, 0xe0, 0x9f, 0xf8, 0x70, 0x35, 0x09, 0x1d, 0xae, 0x47, 0xb9,
+	0x37, 0x8f, 0x8f, 0x03, 0xde, 0xd4, 0x25, 0x78, 0xd7, 0x23, 0xd8, 0xcd, 0xe3, 0x63, 0xc5, 0x19,
+	0x3d, 0xe9, 0xf1, 0x4b, 0x9f, 0x74, 0xf4, 0x04, 0x50, 0x17, 0x7b, 0xc4, 0x20, 0xdf, 0xab, 0xc2,
+	0x5f, 0x46, 0x97, 0xb9, 0xa1, 0x42, 0x13, 0xa0, 0xaa, 0xc2, 0x88, 0xb3, 0x81, 0xde, 0x87, 0x75,
+	0x71, 0xee, 0x42, 0x1e, 0x87, 0xb8, 0x26, 0xb1, 0xb9, 0x3a, 0x80, 0x68, 0x88, 0x8f, 0x03, 0xf5,
+	0x96, 0xdf, 0x23, 0xc2, 0xc2, 0x90, 0xda, 0x86, 0xaa, 0xc0, 0x03, 0xfd, 0x45, 0x3f, 0x2c, 0x0c,
+	0xa9, 0xed, 0xd7, 0xda, 0x4a, 0xbb, 0xf4, 0x8f, 0x04, 0xe4, 0x4f, 0x95, 0xf1, 0x68, 0x0f, 0x92,
+	0x43, 0xd6, 0x0b, 0x8a, 0xcc, 0x87, 0x57, 0xb8, 0x01, 0x94, 0x3b, 0x8d, 0xb6, 0x80, 0x06, 0xb9,
+	0x5d, 0x7c, 0xa3, 0xf7, 0x00, 0xa9, 0xe3, 0x65, 0x12, 0x97, 0xd3, 0x43, 0x6a, 0x62, 0x1e, 0x54,
+	0xbd, 0x79, 0xbf, 0x67, 0x7b, 0xda, 0x21, 0x62, 0x8d, 0xe3, 0xd2, 0x31, 0xe6, 0x44, 0xa4, 0x71,
+	0xb9, 0x6a, 0x19, 0x1d, 0x94, 0xe8, 0x29, 0x99, 0x88, 0x9c, 0x65, 0xe2, 0x28, 0x97, 0x1f, 0x90,
+	0x32, 0x7a, 0xce, 0xc4, 0x11, 0x22, 0x99, 0xdc, 0x4c, 0x97, 0xf4, 0x88, 0xcd, 0x29, 0xb6, 0xfc,
+	0xda, 0x26, 0xa5, 0x14, 0x43, 0x71, 0x50, 0xd1, 0x78, 0xa3, 0xae, 0x58, 0x49, 0x03, 0x5b, 0x5c,
+	0x6a, 0xfa, 0x37, 0xe0, 0x8c, 0xbe, 0xaa, 0x3a, 0xb6, 0x2c, 0x2e, 0x54, 0x3d, 0x51, 0xc8, 0x7b,
+	0x36, 0x95, 0xbe, 0x9a, 0xd1, 0xc5, 0x27, 0x6a, 0xc0, 0x3a, 0x95, 0xbe, 0xe3, 0x12, 0xc3, 0x3b,
+	0xa2, 0x8e, 0x31, 0x26, 0x2e, 0x3d, 0x9c, 0xc8, 0xb3, 0x97, 0xdd, 0x28, 0x9e, 0xda, 0xef, 0x0a,
+	0x63, 0x96, 0xef, 0x74, 0x28, 0xc0, 0xb5, 0x8f, 0xa8, 0xf3, 0xa5, 0x44, 0x95, 0xbe, 0x80, 0x94,
+	0x5a, 0x44, 0x19, 0x58, 0xea, 0xed, 0xad, 0x4a, 0xa3, 0xaa, 0x2d, 0x88, 0x0a, 0xa5, 0x5d, 0xdf,
+	0x6b, 0x35, 0xaa, 0x7e, 0xb5, 0xb2, 0x77, 0xd0, 0x39, 0xd8, 0x6a, 0x68, 0x71, 0xa4, 0xc1, 0x72,
+	0xbd, 0xdd, 0xa9, 0xef, 0x1b, 0x4a, 0x92, 0x28, 0xfd, 0x29, 0x09, 0x37, 0x2f, 0x28, 0x99, 0xd1,
+	0x77, 0x00, 0x3d, 0xea, 0x71, 0x97, 0x76, 0x47, 0x5c, 0x6c, 0xb2, 0xb8, 0x33, 0x7d, 0xf1, 0x52,
+	0xd5, 0x77, 0x79, 0x27, 0xe4, 0xd1, 0x23, 0x9c, 0xe8, 0x5b, 0x48, 0x8b, 0xb0, 0xc1, 0xc6, 0xf2,
+	0x16, 0x2d, 0xf8, 0x7f, 0xfd, 0x72, 0xfc, 0x8f, 0x15, 0x8b, 0x1e, 0xf2, 0xa1, 0x77, 0x20, 0x1f,
+	0x7c, 0x1b, 0x8e, 0x4b, 0x99, 0x4b, 0xf9, 0x44, 0x3d, 0x17, 0x69, 0x41, 0x47, 0x4b, 0xc9, 0xd1,
+	0x23, 0x48, 0x11, 0x1b, 0x77, 0x2d, 0xd2, 0x53, 0xa7, 0xef, 0xa2, 0xdd, 0x08, 0x54, 0x8b, 0x7f,
+	0x8e, 0x01, 0x4c, 0x67, 0x26, 0x6a, 0xd3, 0x43, 0x97, 0x0d, 0xd5, 0xdd, 0x4d, 0x7e, 0xa3, 0xaf,
+	0x21, 0xce, 0x99, 0x9a, 0x5b, 0xed, 0x55, 0xd7, 0xae, 0xdc, 0x61, 0xfe, 0x5d, 0x34, 0xce, 0x59,
+	0x71, 0x13, 0x52, 0xaa, 0x39, 0xef, 0xce, 0xb8, 0x12, 0xb9, 0x33, 0x16, 0xcb, 0x90, 0x0e, 0x16,
+	0xeb, 0xcc, 0x01, 0xe7, 0xd4, 0x80, 0x85, 0x24, 0xce, 0x59, 0xe9, 0x11, 0x40, 0xdd, 0xe6, 0x1f,
+	0x3c, 0xd2, 0xb1, 0xdd, 0x27, 0x82, 0xd7, 0xe3, 0x58, 0x3d, 0x9c, 0x24, 0x74, 0xbf, 0x21, 0xec,
+	0x13, 0xbb, 0x27, 0x41, 0x09, 0x5d, 0x7c, 0x96, 0x0e, 0x60, 0xd5, 0x0f, 0x20, 0x6d, 0x8e, 0xf9,
+	0xc8, 0x6b, 0x13, 0x8e, 0x2a, 0x90, 0xf6, 0x64, 0x43, 0x56, 0x55, 0x89, 0xbb, 0xb9, 0x8b, 0x9e,
+	0x5d, 0xa2, 0x60, 0x3d, 0xc4, 0x95, 0x76, 0x20, 0xd5, 0xc2, 0x13, 0x8b, 0xe1, 0x1e, 0x5a, 0x87,
+	0x24, 0x27, 0xc7, 0x3c, 0xbc, 0x4e, 0xc9, 0x16, 0x2a, 0xc0, 0x52, 0x97, 0xda, 0xd8, 0xf5, 0xdf,
+	0x27, 0x97, 0xc5, 0xfd, 0xd5, 0x6f, 0x57, 0x32, 0x90, 0x72, 0x7c, 0x68, 0xe9, 0x27, 0x04, 0xd9,
+	0xc8, 0x53, 0x02, 0x7a, 0x08, 0xa9, 0xa0, 0x1c, 0x89, 0xcd, 0x0b, 0xbd, 0x81, 0xe6, 0xcb, 0x46,
+	0xfc, 0x2f, 0x20, 0x47, 0x6d, 0x2a, 0xe3, 0xcc, 0xf7, 0x94, 0x73, 0xe2, 0x16, 0xd6, 0xe7, 0x81,
+	0x57, 0x14, 0x60, 0x57, 0xea, 0x8b, 0x02, 0x3b, 0x60, 0x0b, 0x28, 0xe6, 0x26, 0x8c, 0x5c, 0x80,
+	0x50, 0x1c, 0x1f, 0xc0, 0x8d, 0x13, 0x1c, 0x61, 0x06, 0x40, 0xd2, 0x61, 0xae, 0xcd, 0x02, 0x82,
+	0xa4, 0xb1, 0x07, 0x6b, 0x23, 0xdb, 0x4f, 0x19, 0x13, 0x83, 0x0f, 0x5c, 0xe2, 0x0d, 0x98, 0xd5,
+	0x53, 0x17, 0xe6, 0x8b, 0xf3, 0x26, 0x0a, 0x81, 0x9d, 0x00, 0x87, 0xea, 0x90, 0x3f, 0x4d, 0xb6,
+	0x78, 0x09, 0x32, 0xed, 0x14, 0xd5, 0x87, 0x90, 0x16, 0x11, 0x59, 0x3e, 0xea, 0x5d, 0xa6, 0x3c,
+	0x48, 0x61, 0x8b, 0xb7, 0x98, 0xcb, 0x51, 0x15, 0x34, 0x97, 0xc8, 0xca, 0x6e, 0x5a, 0xe5, 0xa6,
+	0xe6, 0x86, 0x80, 0x55, 0x89, 0x89, 0x14, 0xbe, 0x26, 0xe4, 0x83, 0x9b, 0x7e, 0xf8, 0xa2, 0xa5,
+	0x02, 0xfb, 0xe6, 0xa5, 0x1e, 0xb4, 0xca, 0x35, 0xff, 0x39, 0x20, 0x68, 0xd7, 0x16, 0xf4, 0xd5,
+	0xc1, 0xac, 0x08, 0x7d, 0x07, 0x9a, 0xb8, 0x17, 0xcd, 0xd8, 0xf0, 0xab, 0xad, 0x47, 0x97, 0xb3,
+	0xd1, 0x31, 0x4f, 0x98, 0xc8, 0xf1, 0x19, 0x89, 0x98, 0x46, 0xdf, 0x75, 0xcc, 0x59, 0x13, 0xd9,
+	0xab, 0x4c, 0xe3, 0x89, 0xeb, 0x98, 0x27, 0xa6, 0xd1, 0x9f, 0x15, 0x21, 0x0a, 0x6b, 0xe6, 0xc8,
+	0xe3, 0x6c, 0x38, 0x6b, 0x66, 0x45, 0x9a, 0xf9, 0xf0, 0x72, 0x66, 0xb6, 0x25, 0xc1, 0xac, 0xa1,
+	0xbc, 0x79, 0x52, 0x88, 0xea, 0xb0, 0x66, 0x33, 0x23, 0x78, 0xaf, 0x0b, 0x0f, 0xec, 0xf2, 0xbc,
+	0x03, 0x93, 0xb7, 0x99, 0x7a, 0xb4, 0xab, 0x07, 0x27, 0xf7, 0x6b, 0xb8, 0x19, 0xa1, 0x0a, 0xfc,
+	0x36, 0xa4, 0x2c, 0xcc, 0xa3, 0x2c, 0x84, 0x94, 0xfe, 0x00, 0x27, 0x21, 0x73, 0x0d, 0xa6, 0x87,
+	0x63, 0x4a, 0x98, 0x9b, 0x3b, 0xc6, 0x10, 0x14, 0x32, 0x3d, 0x83, 0x1b, 0x53, 0x26, 0xd2, 0xeb,
+	0x93, 0x29, 0xdd, 0xea, 0x3c, 0xba, 0x6b, 0x21, 0xb2, 0xda, 0xeb, 0x93, 0x90, 0x72, 0x0f, 0xae,
+	0x9d, 0x4d, 0xa8, 0xcd, 0x23, 0x5c, 0x3b, 0x8b, 0xee, 0x0e, 0xe4, 0xc8, 0x58, 0x94, 0x78, 0x16,
+	0xeb, 0x1b, 0xf2, 0x25, 0x27, 0x2f, 0x53, 0xcd, 0xb2, 0x94, 0x36, 0x58, 0xbf, 0x85, 0xf9, 0x00,
+	0x3d, 0x86, 0xdb, 0xd8, 0x7a, 0x8e, 0x27, 0x9e, 0x54, 0x8b, 0x7a, 0xc9, 0xf4, 0x9a, 0xb1, 0x26,
+	0x6f, 0x2c, 0xaf, 0xfb, 0x7a, 0x0d, 0xd6, 0x8f, 0x6c, 0x7b, 0x78, 0x8d, 0x78, 0x06, 0x59, 0x6e,
+	0x79, 0x06, 0x73, 0xfc, 0x17, 0x8b, 0x6b, 0xf3, 0x5e, 0xd4, 0x67, 0xce, 0x8a, 0xe5, 0xed, 0xfb,
+	0x38, 0x1d, 0x78, 0xf8, 0x5d, 0xfc, 0x5d, 0x02, 0x56, 0x4f, 0x1c, 0x55, 0x91, 0x47, 0xa7, 0xff,
+	0xcd, 0xd4, 0x1f, 0xb3, 0xb3, 0x1e, 0xaa, 0x36, 0x21, 0xe9, 0x89, 0x44, 0xe9, 0xc7, 0xeb, 0x37,
+	0x2f, 0xf8, 0xeb, 0xe0, 0x67, 0x2a, 0x5d, 0xaa, 0xa3, 0x4f, 0x20, 0xe5, 0x12, 0x93, 0xd0, 0x31,
+	0x51, 0x91, 0xf6, 0x12, 0xc8, 0x00, 0x81, 0x9e, 0x41, 0x9e, 0x1c, 0x3b, 0xc4, 0xe4, 0xa4, 0x67,
+	0x84, 0xf9, 0x37, 0x23, 0xeb, 0x91, 0x3b, 0xe7, 0xd3, 0x4c, 0x53, 0xbe, 0xae, 0x05, 0xf0, 0xb6,
+	0x42, 0xa3, 0x36, 0x20, 0x79, 0xc1, 0x17, 0x45, 0xd0, 0x94, 0x73, 0xf9, 0x0a, 0x9c, 0xf9, 0x10,
+	0x1f, 0x90, 0xee, 0x26, 0xd3, 0x8b, 0xda, 0xd2, 0x6e, 0x32, 0x9d, 0xd2, 0xd2, 0xbb, 0xc9, 0xf4,
+	0x92, 0x96, 0xda, 0x4d, 0xa6, 0xd3, 0x5a, 0x46, 0x5f, 0x56, 0x3f, 0x33, 0x65, 0xb1, 0xad, 0x67,
+	0x44, 0xa4, 0x96, 0x8f, 0x16, 0xc5, 0xdf, 0xc6, 0x20, 0x37, 0x1b, 0xcf, 0xc2, 0xf5, 0x8d, 0xbd,
+	0xf4, 0xfa, 0xfa, 0x85, 0xda, 0x15, 0xd6, 0xb7, 0x78, 0x07, 0x34, 0x9d, 0xf4, 0xa8, 0x17, 0x1d,
+	0xc7, 0xa9, 0x7a, 0xac, 0xf8, 0x35, 0xac, 0x9e, 0x08, 0x8c, 0xe8, 0x4d, 0x98, 0x99, 0x9a, 0xd2,
+	0xce, 0x2a, 0x99, 0xbc, 0x6e, 0xbc, 0x0e, 0x19, 0x3c, 0xe2, 0x03, 0xbf, 0x74, 0xf5, 0x1d, 0x69,
+	0x2a, 0xd8, 0x4d, 0xa6, 0x13, 0x5a, 0xb2, 0xb8, 0x09, 0xf9, 0x53, 0xb1, 0x50, 0x38, 0x5f, 0x84,
+	0x53, 0x7e, 0xef, 0x26, 0xd3, 0x71, 0x2d, 0xa1, 0x2f, 0x99, 0xcc, 0x3e, 0xa4, 0xfd, 0xe2, 0x43,
+	0x80, 0xa9, 0x83, 0xa3, 0xb7, 0x20, 0x87, 0x2d, 0xc7, 0x0e, 0x9f, 0x35, 0xfc, 0x0a, 0x2d, 0xa3,
+	0xaf, 0x08, 0x69, 0xf0, 0xa4, 0xe1, 0x55, 0x34, 0xc8, 0x45, 0xcf, 0x22, 0x71, 0x77, 0x93, 0x69,
+	0xd0, 0xb2, 0xbb, 0xc9, 0xf4, 0x75, 0xed, 0xc6, 0xbd, 0xef, 0x60, 0x39, 0x5a, 0xb6, 0xc9, 0xd7,
+	0x8c, 0xe6, 0xd3, 0xe6, 0xfe, 0x57, 0x4d, 0x6d, 0x41, 0x34, 0x6a, 0xd5, 0xad, 0x46, 0xa7, 0xf6,
+	0x8d, 0x16, 0x43, 0x2b, 0x90, 0x39, 0x68, 0x06, 0xcd, 0x38, 0x5a, 0x86, 0xf4, 0x8e, 0xbe, 0x55,
+	0x6f, 0xd6, 0x9b, 0x4f, 0xb4, 0x84, 0xd0, 0xec, 0xd4, 0xf7, 0xaa, 0xfb, 0x07, 0x1d, 0x2d, 0x29,
+	0xbb, 0xaa, 0xf2, 0x45, 0x64, 0x47, 0x5b, 0xac, 0xbc, 0xf7, 0xb7, 0x17, 0xb7, 0x62, 0x7f, 0x7f,
+	0x71, 0x2b, 0xf6, 0xcf, 0x17, 0xb7, 0x62, 0xdf, 0xbe, 0xe1, 0x6f, 0x12, 0x65, 0xf2, 0x27, 0xfb,
+	0xe9, 0xdf, 0xe1, 0xdd, 0x25, 0x39, 0x9d, 0x87, 0xff, 0x0b, 0x00, 0x00, 0xff, 0xff, 0x18, 0x1c,
+	0x62, 0x53, 0xd1, 0x1f, 0x00, 0x00,
+}
+
+func (m *DestinationRule) Marshal() (dAtA []byte, err error) {
 	size := m.Size()
 	dAtA = make([]byte, size)
 	n, err := m.MarshalToSizedBuffer(dAtA[:size])
@@ -3036,12 +3394,12 @@ func (m *ConnectionPoolSettings_TCPSettings) Marshal() (dAtA []byte, err error)
 	return dAtA[:n], nil
 }
 
-func (m *ConnectionPoolSettings_TCPSettings) MarshalTo(dAtA []byte) (int, error) {
+func (m *DestinationRule) MarshalTo(dAtA []byte) (int, error) {
 	size := m.Size()
 	return m.MarshalToSizedBuffer(dAtA[:size])
 }
 
-func (m *ConnectionPoolSettings_TCPSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+func (m *DestinationRule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 	i := len(dAtA)
 	_ = i
 	var l int
@@ -3050,21 +3408,32 @@ func (m *ConnectionPoolSettings_TCPSettings) MarshalToSizedBuffer(dAtA []byte) (
 		i -= len(m.XXX_unrecognized)
 		copy(dAtA[i:], m.XXX_unrecognized)
 	}
-	if m.TcpKeepalive != nil {
-		{
-			size, err := m.TcpKeepalive.MarshalToSizedBuffer(dAtA[:i])
-			if err != nil {
-				return 0, err
+	if len(m.ExportTo) > 0 {
+		for iNdEx := len(m.ExportTo) - 1; iNdEx >= 0; iNdEx-- {
+			i -= len(m.ExportTo[iNdEx])
+			copy(dAtA[i:], m.ExportTo[iNdEx])
+			i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.ExportTo[iNdEx])))
+			i--
+			dAtA[i] = 0x22
+		}
+	}
+	if len(m.Subsets) > 0 {
+		for iNdEx := len(m.Subsets) - 1; iNdEx >= 0; iNdEx-- {
+			{
+				size, err := m.Subsets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
+				if err != nil {
+					return 0, err
+				}
+				i -= size
+				i = encodeVarintDestinationRule(dAtA, i, uint64(size))
 			}
-			i -= size
-			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+			i--
+			dAtA[i] = 0x1a
 		}
-		i--
-		dAtA[i] = 0x1a
 	}
-	if m.ConnectTimeout != nil {
+	if m.TrafficPolicy != nil {
 		{
-			size, err := m.ConnectTimeout.MarshalToSizedBuffer(dAtA[:i])
+			size, err := m.TrafficPolicy.MarshalToSizedBuffer(dAtA[:i])
 			if err != nil {
 				return 0, err
 			}
@@ -3074,15 +3443,17 @@ func (m *ConnectionPoolSettings_TCPSettings) MarshalToSizedBuffer(dAtA []byte) (
 		i--
 		dAtA[i] = 0x12
 	}
-	if m.MaxConnections != 0 {
-		i = encodeVarintDestinationRule(dAtA, i, uint64(m.MaxConnections))
+	if len(m.Host) > 0 {
+		i -= len(m.Host)
+		copy(dAtA[i:], m.Host)
+		i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.Host)))
 		i--
-		dAtA[i] = 0x8
+		dAtA[i] = 0xa
 	}
 	return len(dAtA) - i, nil
 }
 
-func (m *ConnectionPoolSettings_TCPSettings_TcpKeepalive) Marshal() (dAtA []byte, err error) {
+func (m *TrafficPolicy) Marshal() (dAtA []byte, err error) {
 	size := m.Size()
 	dAtA = make([]byte, size)
 	n, err := m.MarshalToSizedBuffer(dAtA[:size])
@@ -3092,12 +3463,12 @@ func (m *ConnectionPoolSettings_TCPSettings_TcpKeepalive) Marshal() (dAtA []byte
 	return dAtA[:n], nil
 }
 
-func (m *ConnectionPoolSettings_TCPSettings_TcpKeepalive) MarshalTo(dAtA []byte) (int, error) {
+func (m *TrafficPolicy) MarshalTo(dAtA []byte) (int, error) {
 	size := m.Size()
 	return m.MarshalToSizedBuffer(dAtA[:size])
 }
 
-func (m *ConnectionPoolSettings_TCPSettings_TcpKeepalive) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+func (m *TrafficPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 	i := len(dAtA)
 	_ = i
 	var l int
@@ -3106,9 +3477,39 @@ func (m *ConnectionPoolSettings_TCPSettings_TcpKeepalive) MarshalToSizedBuffer(d
 		i -= len(m.XXX_unrecognized)
 		copy(dAtA[i:], m.XXX_unrecognized)
 	}
-	if m.Interval != nil {
+	if len(m.HealthChecks) > 0 {
+		for iNdEx := len(m.HealthChecks) - 1; iNdEx >= 0; iNdEx-- {
+			{
+				size, err := m.HealthChecks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
+				if err != nil {
+					return 0, err
+				}
+				i -= size
+				i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+			}
+			i--
+			dAtA[i] = 0x6
+			i--
+			dAtA[i] = 0xaa
+		}
+	}
+	if len(m.PortLevelSettings) > 0 {
+		for iNdEx := len(m.PortLevelSettings) - 1; iNdEx >= 0; iNdEx-- {
+			{
+				size, err := m.PortLevelSettings[iNdEx].MarshalToSizedBuffer(dAtA[:i])
+				if err != nil {
+					return 0, err
+				}
+				i -= size
+				i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+			}
+			i--
+			dAtA[i] = 0x2a
+		}
+	}
+	if m.Tls != nil {
 		{
-			size, err := m.Interval.MarshalToSizedBuffer(dAtA[:i])
+			size, err := m.Tls.MarshalToSizedBuffer(dAtA[:i])
 			if err != nil {
 				return 0, err
 			}
@@ -3116,11 +3517,11 @@ func (m *ConnectionPoolSettings_TCPSettings_TcpKeepalive) MarshalToSizedBuffer(d
 			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
 		}
 		i--
-		dAtA[i] = 0x1a
+		dAtA[i] = 0x22
 	}
-	if m.Time != nil {
+	if m.OutlierDetection != nil {
 		{
-			size, err := m.Time.MarshalToSizedBuffer(dAtA[:i])
+			size, err := m.OutlierDetection.MarshalToSizedBuffer(dAtA[:i])
 			if err != nil {
 				return 0, err
 			}
@@ -3128,58 +3529,23 @@ func (m *ConnectionPoolSettings_TCPSettings_TcpKeepalive) MarshalToSizedBuffer(d
 			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
 		}
 		i--
-		dAtA[i] = 0x12
+		dAtA[i] = 0x1a
 	}
-	if m.Probes != 0 {
-		i = encodeVarintDestinationRule(dAtA, i, uint64(m.Probes))
-		i--
-		dAtA[i] = 0x8
-	}
-	return len(dAtA) - i, nil
-}
-
-func (m *ConnectionPoolSettings_HTTPSettings) Marshal() (dAtA []byte, err error) {
-	size := m.Size()
-	dAtA = make([]byte, size)
-	n, err := m.MarshalToSizedBuffer(dAtA[:size])
-	if err != nil {
-		return nil, err
-	}
-	return dAtA[:n], nil
-}
-
-func (m *ConnectionPoolSettings_HTTPSettings) MarshalTo(dAtA []byte) (int, error) {
-	size := m.Size()
-	return m.MarshalToSizedBuffer(dAtA[:size])
-}
-
-func (m *ConnectionPoolSettings_HTTPSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
-	i := len(dAtA)
-	_ = i
-	var l int
-	_ = l
-	if m.XXX_unrecognized != nil {
-		i -= len(m.XXX_unrecognized)
-		copy(dAtA[i:], m.XXX_unrecognized)
-	}
-	if m.UseClientProtocol {
-		i--
-		if m.UseClientProtocol {
-			dAtA[i] = 1
-		} else {
-			dAtA[i] = 0
+	if m.ConnectionPool != nil {
+		{
+			size, err := m.ConnectionPool.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
 		}
 		i--
-		dAtA[i] = 0x38
-	}
-	if m.H2UpgradePolicy != 0 {
-		i = encodeVarintDestinationRule(dAtA, i, uint64(m.H2UpgradePolicy))
-		i--
-		dAtA[i] = 0x30
+		dAtA[i] = 0x12
 	}
-	if m.IdleTimeout != nil {
+	if m.LoadBalancer != nil {
 		{
-			size, err := m.IdleTimeout.MarshalToSizedBuffer(dAtA[:i])
+			size, err := m.LoadBalancer.MarshalToSizedBuffer(dAtA[:i])
 			if err != nil {
 				return 0, err
 			}
@@ -3187,32 +3553,12 @@ func (m *ConnectionPoolSettings_HTTPSettings) MarshalToSizedBuffer(dAtA []byte)
 			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
 		}
 		i--
-		dAtA[i] = 0x2a
-	}
-	if m.MaxRetries != 0 {
-		i = encodeVarintDestinationRule(dAtA, i, uint64(m.MaxRetries))
-		i--
-		dAtA[i] = 0x20
-	}
-	if m.MaxRequestsPerConnection != 0 {
-		i = encodeVarintDestinationRule(dAtA, i, uint64(m.MaxRequestsPerConnection))
-		i--
-		dAtA[i] = 0x18
-	}
-	if m.Http2MaxRequests != 0 {
-		i = encodeVarintDestinationRule(dAtA, i, uint64(m.Http2MaxRequests))
-		i--
-		dAtA[i] = 0x10
-	}
-	if m.Http1MaxPendingRequests != 0 {
-		i = encodeVarintDestinationRule(dAtA, i, uint64(m.Http1MaxPendingRequests))
-		i--
-		dAtA[i] = 0x8
+		dAtA[i] = 0xa
 	}
 	return len(dAtA) - i, nil
 }
 
-func (m *OutlierDetection) Marshal() (dAtA []byte, err error) {
+func (m *TrafficPolicy_PortTrafficPolicy) Marshal() (dAtA []byte, err error) {
 	size := m.Size()
 	dAtA = make([]byte, size)
 	n, err := m.MarshalToSizedBuffer(dAtA[:size])
@@ -3222,12 +3568,12 @@ func (m *OutlierDetection) Marshal() (dAtA []byte, err error) {
 	return dAtA[:n], nil
 }
 
-func (m *OutlierDetection) MarshalTo(dAtA []byte) (int, error) {
+func (m *TrafficPolicy_PortTrafficPolicy) MarshalTo(dAtA []byte) (int, error) {
 	size := m.Size()
 	return m.MarshalToSizedBuffer(dAtA[:size])
 }
 
-func (m *OutlierDetection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+func (m *TrafficPolicy_PortTrafficPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 	i := len(dAtA)
 	_ = i
 	var l int
@@ -3236,9 +3582,25 @@ func (m *OutlierDetection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 		i -= len(m.XXX_unrecognized)
 		copy(dAtA[i:], m.XXX_unrecognized)
 	}
-	if m.ConsecutiveLocalOriginFailures != nil {
+	if len(m.HealthChecks) > 0 {
+		for iNdEx := len(m.HealthChecks) - 1; iNdEx >= 0; iNdEx-- {
+			{
+				size, err := m.HealthChecks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
+				if err != nil {
+					return 0, err
+				}
+				i -= size
+				i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+			}
+			i--
+			dAtA[i] = 0x6
+			i--
+			dAtA[i] = 0xaa
+		}
+	}
+	if m.Tls != nil {
 		{
-			size, err := m.ConsecutiveLocalOriginFailures.MarshalToSizedBuffer(dAtA[:i])
+			size, err := m.Tls.MarshalToSizedBuffer(dAtA[:i])
 			if err != nil {
 				return 0, err
 			}
@@ -3246,21 +3608,11 @@ func (m *OutlierDetection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
 		}
 		i--
-		dAtA[i] = 0x4a
-	}
-	if m.SplitExternalLocalOriginErrors {
-		i--
-		if m.SplitExternalLocalOriginErrors {
-			dAtA[i] = 1
-		} else {
-			dAtA[i] = 0
-		}
-		i--
-		dAtA[i] = 0x40
+		dAtA[i] = 0x2a
 	}
-	if m.Consecutive_5XxErrors != nil {
+	if m.OutlierDetection != nil {
 		{
-			size, err := m.Consecutive_5XxErrors.MarshalToSizedBuffer(dAtA[:i])
+			size, err := m.OutlierDetection.MarshalToSizedBuffer(dAtA[:i])
 			if err != nil {
 				return 0, err
 			}
@@ -3268,11 +3620,11 @@ func (m *OutlierDetection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
 		}
 		i--
-		dAtA[i] = 0x3a
+		dAtA[i] = 0x22
 	}
-	if m.ConsecutiveGatewayErrors != nil {
+	if m.ConnectionPool != nil {
 		{
-			size, err := m.ConsecutiveGatewayErrors.MarshalToSizedBuffer(dAtA[:i])
+			size, err := m.ConnectionPool.MarshalToSizedBuffer(dAtA[:i])
 			if err != nil {
 				return 0, err
 			}
@@ -3280,21 +3632,11 @@ func (m *OutlierDetection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
 		}
 		i--
-		dAtA[i] = 0x32
-	}
-	if m.MinHealthPercent != 0 {
-		i = encodeVarintDestinationRule(dAtA, i, uint64(m.MinHealthPercent))
-		i--
-		dAtA[i] = 0x28
-	}
-	if m.MaxEjectionPercent != 0 {
-		i = encodeVarintDestinationRule(dAtA, i, uint64(m.MaxEjectionPercent))
-		i--
-		dAtA[i] = 0x20
+		dAtA[i] = 0x1a
 	}
-	if m.BaseEjectionTime != nil {
+	if m.LoadBalancer != nil {
 		{
-			size, err := m.BaseEjectionTime.MarshalToSizedBuffer(dAtA[:i])
+			size, err := m.LoadBalancer.MarshalToSizedBuffer(dAtA[:i])
 			if err != nil {
 				return 0, err
 			}
@@ -3302,11 +3644,11 @@ func (m *OutlierDetection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
 		}
 		i--
-		dAtA[i] = 0x1a
+		dAtA[i] = 0x12
 	}
-	if m.Interval != nil {
+	if m.Port != nil {
 		{
-			size, err := m.Interval.MarshalToSizedBuffer(dAtA[:i])
+			size, err := m.Port.MarshalToSizedBuffer(dAtA[:i])
 			if err != nil {
 				return 0, err
 			}
@@ -3314,17 +3656,12 @@ func (m *OutlierDetection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
 		}
 		i--
-		dAtA[i] = 0x12
-	}
-	if m.ConsecutiveErrors != 0 {
-		i = encodeVarintDestinationRule(dAtA, i, uint64(m.ConsecutiveErrors))
-		i--
-		dAtA[i] = 0x8
+		dAtA[i] = 0xa
 	}
 	return len(dAtA) - i, nil
 }
 
-func (m *ClientTLSSettings) Marshal() (dAtA []byte, err error) {
+func (m *Subset) Marshal() (dAtA []byte, err error) {
 	size := m.Size()
 	dAtA = make([]byte, size)
 	n, err := m.MarshalToSizedBuffer(dAtA[:size])
@@ -3334,12 +3671,12 @@ func (m *ClientTLSSettings) Marshal() (dAtA []byte, err error) {
 	return dAtA[:n], nil
 }
 
-func (m *ClientTLSSettings) MarshalTo(dAtA []byte) (int, error) {
+func (m *Subset) MarshalTo(dAtA []byte) (int, error) {
 	size := m.Size()
 	return m.MarshalToSizedBuffer(dAtA[:size])
 }
 
-func (m *ClientTLSSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+func (m *Subset) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 	i := len(dAtA)
 	_ = i
 	var l int
@@ -3348,9 +3685,9 @@ func (m *ClientTLSSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 		i -= len(m.XXX_unrecognized)
 		copy(dAtA[i:], m.XXX_unrecognized)
 	}
-	if m.InsecureSkipVerify != nil {
+	if m.TrafficPolicy != nil {
 		{
-			size, err := m.InsecureSkipVerify.MarshalToSizedBuffer(dAtA[:i])
+			size, err := m.TrafficPolicy.MarshalToSizedBuffer(dAtA[:i])
 			if err != nil {
 				return 0, err
 			}
@@ -3358,61 +3695,38 @@ func (m *ClientTLSSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
 		}
 		i--
-		dAtA[i] = 0x42
-	}
-	if len(m.CredentialName) > 0 {
-		i -= len(m.CredentialName)
-		copy(dAtA[i:], m.CredentialName)
-		i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.CredentialName)))
-		i--
-		dAtA[i] = 0x3a
-	}
-	if len(m.Sni) > 0 {
-		i -= len(m.Sni)
-		copy(dAtA[i:], m.Sni)
-		i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.Sni)))
-		i--
-		dAtA[i] = 0x32
+		dAtA[i] = 0x1a
 	}
-	if len(m.SubjectAltNames) > 0 {
-		for iNdEx := len(m.SubjectAltNames) - 1; iNdEx >= 0; iNdEx-- {
-			i -= len(m.SubjectAltNames[iNdEx])
-			copy(dAtA[i:], m.SubjectAltNames[iNdEx])
-			i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.SubjectAltNames[iNdEx])))
+	if len(m.Labels) > 0 {
+		for k := range m.Labels {
+			v := m.Labels[k]
+			baseI := i
+			i -= len(v)
+			copy(dAtA[i:], v)
+			i = encodeVarintDestinationRule(dAtA, i, uint64(len(v)))
 			i--
-			dAtA[i] = 0x2a
+			dAtA[i] = 0x12
+			i -= len(k)
+			copy(dAtA[i:], k)
+			i = encodeVarintDestinationRule(dAtA, i, uint64(len(k)))
+			i--
+			dAtA[i] = 0xa
+			i = encodeVarintDestinationRule(dAtA, i, uint64(baseI-i))
+			i--
+			dAtA[i] = 0x12
 		}
 	}
-	if len(m.CaCertificates) > 0 {
-		i -= len(m.CaCertificates)
-		copy(dAtA[i:], m.CaCertificates)
-		i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.CaCertificates)))
-		i--
-		dAtA[i] = 0x22
-	}
-	if len(m.PrivateKey) > 0 {
-		i -= len(m.PrivateKey)
-		copy(dAtA[i:], m.PrivateKey)
-		i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.PrivateKey)))
-		i--
-		dAtA[i] = 0x1a
-	}
-	if len(m.ClientCertificate) > 0 {
-		i -= len(m.ClientCertificate)
-		copy(dAtA[i:], m.ClientCertificate)
-		i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.ClientCertificate)))
-		i--
-		dAtA[i] = 0x12
-	}
-	if m.Mode != 0 {
-		i = encodeVarintDestinationRule(dAtA, i, uint64(m.Mode))
+	if len(m.Name) > 0 {
+		i -= len(m.Name)
+		copy(dAtA[i:], m.Name)
+		i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.Name)))
 		i--
-		dAtA[i] = 0x8
+		dAtA[i] = 0xa
 	}
 	return len(dAtA) - i, nil
 }
 
-func (m *LocalityLoadBalancerSetting) Marshal() (dAtA []byte, err error) {
+func (m *LoadBalancerSettings) Marshal() (dAtA []byte, err error) {
 	size := m.Size()
 	dAtA = make([]byte, size)
 	n, err := m.MarshalToSizedBuffer(dAtA[:size])
@@ -3422,12 +3736,12 @@ func (m *LocalityLoadBalancerSetting) Marshal() (dAtA []byte, err error) {
 	return dAtA[:n], nil
 }
 
-func (m *LocalityLoadBalancerSetting) MarshalTo(dAtA []byte) (int, error) {
+func (m *LoadBalancerSettings) MarshalTo(dAtA []byte) (int, error) {
 	size := m.Size()
 	return m.MarshalToSizedBuffer(dAtA[:size])
 }
 
-func (m *LocalityLoadBalancerSetting) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+func (m *LoadBalancerSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 	i := len(dAtA)
 	_ = i
 	var l int
@@ -3436,18 +3750,21 @@ func (m *LocalityLoadBalancerSetting) MarshalToSizedBuffer(dAtA []byte) (int, er
 		i -= len(m.XXX_unrecognized)
 		copy(dAtA[i:], m.XXX_unrecognized)
 	}
-	if len(m.FailoverPriority) > 0 {
-		for iNdEx := len(m.FailoverPriority) - 1; iNdEx >= 0; iNdEx-- {
-			i -= len(m.FailoverPriority[iNdEx])
-			copy(dAtA[i:], m.FailoverPriority[iNdEx])
-			i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.FailoverPriority[iNdEx])))
-			i--
-			dAtA[i] = 0x22
+	if m.WarmupDurationSecs != nil {
+		{
+			size, err := m.WarmupDurationSecs.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
 		}
+		i--
+		dAtA[i] = 0x22
 	}
-	if m.Enabled != nil {
+	if m.LocalityLbSetting != nil {
 		{
-			size, err := m.Enabled.MarshalToSizedBuffer(dAtA[:i])
+			size, err := m.LocalityLbSetting.MarshalToSizedBuffer(dAtA[:i])
 			if err != nil {
 				return 0, err
 			}
@@ -3457,38 +3774,52 @@ func (m *LocalityLoadBalancerSetting) MarshalToSizedBuffer(dAtA []byte) (int, er
 		i--
 		dAtA[i] = 0x1a
 	}
-	if len(m.Failover) > 0 {
-		for iNdEx := len(m.Failover) - 1; iNdEx >= 0; iNdEx-- {
-			{
-				size, err := m.Failover[iNdEx].MarshalToSizedBuffer(dAtA[:i])
-				if err != nil {
-					return 0, err
-				}
-				i -= size
-				i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+	if m.LbPolicy != nil {
+		{
+			size := m.LbPolicy.Size()
+			i -= size
+			if _, err := m.LbPolicy.MarshalTo(dAtA[i:]); err != nil {
+				return 0, err
 			}
-			i--
-			dAtA[i] = 0x12
 		}
 	}
-	if len(m.Distribute) > 0 {
-		for iNdEx := len(m.Distribute) - 1; iNdEx >= 0; iNdEx-- {
-			{
-				size, err := m.Distribute[iNdEx].MarshalToSizedBuffer(dAtA[:i])
-				if err != nil {
-					return 0, err
-				}
-				i -= size
-				i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+	return len(dAtA) - i, nil
+}
+
+func (m *LoadBalancerSettings_Simple) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *LoadBalancerSettings_Simple) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	i = encodeVarintDestinationRule(dAtA, i, uint64(m.Simple))
+	i--
+	dAtA[i] = 0x8
+	return len(dAtA) - i, nil
+}
+func (m *LoadBalancerSettings_ConsistentHash) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *LoadBalancerSettings_ConsistentHash) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	if m.ConsistentHash != nil {
+		{
+			size, err := m.ConsistentHash.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
 			}
-			i--
-			dAtA[i] = 0xa
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
 		}
+		i--
+		dAtA[i] = 0x12
 	}
 	return len(dAtA) - i, nil
 }
-
-func (m *LocalityLoadBalancerSetting_Distribute) Marshal() (dAtA []byte, err error) {
+func (m *LoadBalancerSettings_ConsistentHashLB) Marshal() (dAtA []byte, err error) {
 	size := m.Size()
 	dAtA = make([]byte, size)
 	n, err := m.MarshalToSizedBuffer(dAtA[:size])
@@ -3498,12 +3829,12 @@ func (m *LocalityLoadBalancerSetting_Distribute) Marshal() (dAtA []byte, err err
 	return dAtA[:n], nil
 }
 
-func (m *LocalityLoadBalancerSetting_Distribute) MarshalTo(dAtA []byte) (int, error) {
+func (m *LoadBalancerSettings_ConsistentHashLB) MarshalTo(dAtA []byte) (int, error) {
 	size := m.Size()
 	return m.MarshalToSizedBuffer(dAtA[:size])
 }
 
-func (m *LocalityLoadBalancerSetting_Distribute) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+func (m *LoadBalancerSettings_ConsistentHashLB) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 	i := len(dAtA)
 	_ = i
 	var l int
@@ -3512,34 +3843,90 @@ func (m *LocalityLoadBalancerSetting_Distribute) MarshalToSizedBuffer(dAtA []byt
 		i -= len(m.XXX_unrecognized)
 		copy(dAtA[i:], m.XXX_unrecognized)
 	}
-	if len(m.To) > 0 {
-		for k := range m.To {
-			v := m.To[k]
-			baseI := i
-			i = encodeVarintDestinationRule(dAtA, i, uint64(v))
-			i--
-			dAtA[i] = 0x10
-			i -= len(k)
-			copy(dAtA[i:], k)
-			i = encodeVarintDestinationRule(dAtA, i, uint64(len(k)))
-			i--
-			dAtA[i] = 0xa
-			i = encodeVarintDestinationRule(dAtA, i, uint64(baseI-i))
-			i--
-			dAtA[i] = 0x12
+	if m.HashKey != nil {
+		{
+			size := m.HashKey.Size()
+			i -= size
+			if _, err := m.HashKey.MarshalTo(dAtA[i:]); err != nil {
+				return 0, err
+			}
 		}
 	}
-	if len(m.From) > 0 {
-		i -= len(m.From)
-		copy(dAtA[i:], m.From)
-		i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.From)))
+	if m.MinimumRingSize != 0 {
+		i = encodeVarintDestinationRule(dAtA, i, uint64(m.MinimumRingSize))
 		i--
-		dAtA[i] = 0xa
+		dAtA[i] = 0x20
 	}
 	return len(dAtA) - i, nil
 }
 
-func (m *LocalityLoadBalancerSetting_Failover) Marshal() (dAtA []byte, err error) {
+func (m *LoadBalancerSettings_ConsistentHashLB_HttpHeaderName) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *LoadBalancerSettings_ConsistentHashLB_HttpHeaderName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	i -= len(m.HttpHeaderName)
+	copy(dAtA[i:], m.HttpHeaderName)
+	i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.HttpHeaderName)))
+	i--
+	dAtA[i] = 0xa
+	return len(dAtA) - i, nil
+}
+func (m *LoadBalancerSettings_ConsistentHashLB_HttpCookie) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *LoadBalancerSettings_ConsistentHashLB_HttpCookie) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	if m.HttpCookie != nil {
+		{
+			size, err := m.HttpCookie.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x12
+	}
+	return len(dAtA) - i, nil
+}
+func (m *LoadBalancerSettings_ConsistentHashLB_UseSourceIp) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *LoadBalancerSettings_ConsistentHashLB_UseSourceIp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	i--
+	if m.UseSourceIp {
+		dAtA[i] = 1
+	} else {
+		dAtA[i] = 0
+	}
+	i--
+	dAtA[i] = 0x18
+	return len(dAtA) - i, nil
+}
+func (m *LoadBalancerSettings_ConsistentHashLB_HttpQueryParameterName) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *LoadBalancerSettings_ConsistentHashLB_HttpQueryParameterName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	i -= len(m.HttpQueryParameterName)
+	copy(dAtA[i:], m.HttpQueryParameterName)
+	i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.HttpQueryParameterName)))
+	i--
+	dAtA[i] = 0x2a
+	return len(dAtA) - i, nil
+}
+func (m *LoadBalancerSettings_ConsistentHashLB_HTTPCookie) Marshal() (dAtA []byte, err error) {
 	size := m.Size()
 	dAtA = make([]byte, size)
 	n, err := m.MarshalToSizedBuffer(dAtA[:size])
@@ -3549,12 +3936,12 @@ func (m *LocalityLoadBalancerSetting_Failover) Marshal() (dAtA []byte, err error
 	return dAtA[:n], nil
 }
 
-func (m *LocalityLoadBalancerSetting_Failover) MarshalTo(dAtA []byte) (int, error) {
+func (m *LoadBalancerSettings_ConsistentHashLB_HTTPCookie) MarshalTo(dAtA []byte) (int, error) {
 	size := m.Size()
 	return m.MarshalToSizedBuffer(dAtA[:size])
 }
 
-func (m *LocalityLoadBalancerSetting_Failover) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+func (m *LoadBalancerSettings_ConsistentHashLB_HTTPCookie) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 	i := len(dAtA)
 	_ = i
 	var l int
@@ -3563,493 +3950,1889 @@ func (m *LocalityLoadBalancerSetting_Failover) MarshalToSizedBuffer(dAtA []byte)
 		i -= len(m.XXX_unrecognized)
 		copy(dAtA[i:], m.XXX_unrecognized)
 	}
-	if len(m.To) > 0 {
-		i -= len(m.To)
-		copy(dAtA[i:], m.To)
-		i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.To)))
+	if m.Ttl != nil {
+		{
+			size, err := m.Ttl.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x1a
+	}
+	if len(m.Path) > 0 {
+		i -= len(m.Path)
+		copy(dAtA[i:], m.Path)
+		i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.Path)))
 		i--
 		dAtA[i] = 0x12
 	}
-	if len(m.From) > 0 {
-		i -= len(m.From)
-		copy(dAtA[i:], m.From)
-		i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.From)))
+	if len(m.Name) > 0 {
+		i -= len(m.Name)
+		copy(dAtA[i:], m.Name)
+		i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.Name)))
 		i--
 		dAtA[i] = 0xa
 	}
 	return len(dAtA) - i, nil
 }
 
-func encodeVarintDestinationRule(dAtA []byte, offset int, v uint64) int {
-	offset -= sovDestinationRule(v)
-	base := offset
-	for v >= 1<<7 {
-		dAtA[offset] = uint8(v&0x7f | 0x80)
-		v >>= 7
-		offset++
+func (m *ConnectionPoolSettings) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
 	}
-	dAtA[offset] = uint8(v)
-	return base
+	return dAtA[:n], nil
 }
-func (m *DestinationRule) Size() (n int) {
-	if m == nil {
-		return 0
-	}
+
+func (m *ConnectionPoolSettings) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *ConnectionPoolSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
 	var l int
 	_ = l
-	l = len(m.Host)
-	if l > 0 {
-		n += 1 + l + sovDestinationRule(uint64(l))
+	if m.XXX_unrecognized != nil {
+		i -= len(m.XXX_unrecognized)
+		copy(dAtA[i:], m.XXX_unrecognized)
 	}
-	if m.TrafficPolicy != nil {
-		l = m.TrafficPolicy.Size()
-		n += 1 + l + sovDestinationRule(uint64(l))
+	if m.Http != nil {
+		{
+			size, err := m.Http.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x12
 	}
-	if len(m.Subsets) > 0 {
-		for _, e := range m.Subsets {
-			l = e.Size()
-			n += 1 + l + sovDestinationRule(uint64(l))
+	if m.Tcp != nil {
+		{
+			size, err := m.Tcp.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
 		}
+		i--
+		dAtA[i] = 0xa
 	}
-	if len(m.ExportTo) > 0 {
-		for _, s := range m.ExportTo {
-			l = len(s)
-			n += 1 + l + sovDestinationRule(uint64(l))
-		}
-	}
-	if m.XXX_unrecognized != nil {
-		n += len(m.XXX_unrecognized)
-	}
-	return n
+	return len(dAtA) - i, nil
 }
 
-func (m *TrafficPolicy) Size() (n int) {
-	if m == nil {
-		return 0
+func (m *ConnectionPoolSettings_TCPSettings) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
 	}
+	return dAtA[:n], nil
+}
+
+func (m *ConnectionPoolSettings_TCPSettings) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *ConnectionPoolSettings_TCPSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
 	var l int
 	_ = l
-	if m.LoadBalancer != nil {
-		l = m.LoadBalancer.Size()
-		n += 1 + l + sovDestinationRule(uint64(l))
-	}
-	if m.ConnectionPool != nil {
-		l = m.ConnectionPool.Size()
-		n += 1 + l + sovDestinationRule(uint64(l))
-	}
-	if m.OutlierDetection != nil {
-		l = m.OutlierDetection.Size()
-		n += 1 + l + sovDestinationRule(uint64(l))
+	if m.XXX_unrecognized != nil {
+		i -= len(m.XXX_unrecognized)
+		copy(dAtA[i:], m.XXX_unrecognized)
 	}
-	if m.Tls != nil {
-		l = m.Tls.Size()
-		n += 1 + l + sovDestinationRule(uint64(l))
+	if m.TcpKeepalive != nil {
+		{
+			size, err := m.TcpKeepalive.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x1a
 	}
-	if len(m.PortLevelSettings) > 0 {
-		for _, e := range m.PortLevelSettings {
-			l = e.Size()
-			n += 1 + l + sovDestinationRule(uint64(l))
+	if m.ConnectTimeout != nil {
+		{
+			size, err := m.ConnectTimeout.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
 		}
+		i--
+		dAtA[i] = 0x12
 	}
-	if m.XXX_unrecognized != nil {
-		n += len(m.XXX_unrecognized)
+	if m.MaxConnections != 0 {
+		i = encodeVarintDestinationRule(dAtA, i, uint64(m.MaxConnections))
+		i--
+		dAtA[i] = 0x8
 	}
-	return n
+	return len(dAtA) - i, nil
 }
 
-func (m *TrafficPolicy_PortTrafficPolicy) Size() (n int) {
-	if m == nil {
-		return 0
+func (m *ConnectionPoolSettings_TCPSettings_TcpKeepalive) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
 	}
+	return dAtA[:n], nil
+}
+
+func (m *ConnectionPoolSettings_TCPSettings_TcpKeepalive) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *ConnectionPoolSettings_TCPSettings_TcpKeepalive) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
 	var l int
 	_ = l
-	if m.Port != nil {
-		l = m.Port.Size()
-		n += 1 + l + sovDestinationRule(uint64(l))
-	}
-	if m.LoadBalancer != nil {
-		l = m.LoadBalancer.Size()
-		n += 1 + l + sovDestinationRule(uint64(l))
-	}
-	if m.ConnectionPool != nil {
-		l = m.ConnectionPool.Size()
-		n += 1 + l + sovDestinationRule(uint64(l))
+	if m.XXX_unrecognized != nil {
+		i -= len(m.XXX_unrecognized)
+		copy(dAtA[i:], m.XXX_unrecognized)
 	}
-	if m.OutlierDetection != nil {
-		l = m.OutlierDetection.Size()
-		n += 1 + l + sovDestinationRule(uint64(l))
+	if m.Interval != nil {
+		{
+			size, err := m.Interval.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x1a
 	}
-	if m.Tls != nil {
-		l = m.Tls.Size()
-		n += 1 + l + sovDestinationRule(uint64(l))
+	if m.Time != nil {
+		{
+			size, err := m.Time.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x12
 	}
-	if m.XXX_unrecognized != nil {
-		n += len(m.XXX_unrecognized)
+	if m.Probes != 0 {
+		i = encodeVarintDestinationRule(dAtA, i, uint64(m.Probes))
+		i--
+		dAtA[i] = 0x8
 	}
-	return n
+	return len(dAtA) - i, nil
 }
 
-func (m *Subset) Size() (n int) {
-	if m == nil {
-		return 0
+func (m *ConnectionPoolSettings_HTTPSettings) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
 	}
+	return dAtA[:n], nil
+}
+
+func (m *ConnectionPoolSettings_HTTPSettings) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *ConnectionPoolSettings_HTTPSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
 	var l int
 	_ = l
-	l = len(m.Name)
-	if l > 0 {
-		n += 1 + l + sovDestinationRule(uint64(l))
+	if m.XXX_unrecognized != nil {
+		i -= len(m.XXX_unrecognized)
+		copy(dAtA[i:], m.XXX_unrecognized)
 	}
-	if len(m.Labels) > 0 {
-		for k, v := range m.Labels {
-			_ = k
-			_ = v
-			mapEntrySize := 1 + len(k) + sovDestinationRule(uint64(len(k))) + 1 + len(v) + sovDestinationRule(uint64(len(v)))
-			n += mapEntrySize + 1 + sovDestinationRule(uint64(mapEntrySize))
+	if m.UseClientProtocol {
+		i--
+		if m.UseClientProtocol {
+			dAtA[i] = 1
+		} else {
+			dAtA[i] = 0
 		}
+		i--
+		dAtA[i] = 0x38
 	}
-	if m.TrafficPolicy != nil {
-		l = m.TrafficPolicy.Size()
-		n += 1 + l + sovDestinationRule(uint64(l))
+	if m.H2UpgradePolicy != 0 {
+		i = encodeVarintDestinationRule(dAtA, i, uint64(m.H2UpgradePolicy))
+		i--
+		dAtA[i] = 0x30
 	}
-	if m.XXX_unrecognized != nil {
-		n += len(m.XXX_unrecognized)
+	if m.IdleTimeout != nil {
+		{
+			size, err := m.IdleTimeout.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x2a
 	}
-	return n
-}
-
-func (m *LoadBalancerSettings) Size() (n int) {
-	if m == nil {
-		return 0
+	if m.MaxRetries != 0 {
+		i = encodeVarintDestinationRule(dAtA, i, uint64(m.MaxRetries))
+		i--
+		dAtA[i] = 0x20
 	}
-	var l int
-	_ = l
-	if m.LbPolicy != nil {
-		n += m.LbPolicy.Size()
+	if m.MaxRequestsPerConnection != 0 {
+		i = encodeVarintDestinationRule(dAtA, i, uint64(m.MaxRequestsPerConnection))
+		i--
+		dAtA[i] = 0x18
 	}
-	if m.LocalityLbSetting != nil {
-		l = m.LocalityLbSetting.Size()
-		n += 1 + l + sovDestinationRule(uint64(l))
+	if m.Http2MaxRequests != 0 {
+		i = encodeVarintDestinationRule(dAtA, i, uint64(m.Http2MaxRequests))
+		i--
+		dAtA[i] = 0x10
 	}
-	if m.XXX_unrecognized != nil {
-		n += len(m.XXX_unrecognized)
+	if m.Http1MaxPendingRequests != 0 {
+		i = encodeVarintDestinationRule(dAtA, i, uint64(m.Http1MaxPendingRequests))
+		i--
+		dAtA[i] = 0x8
 	}
-	return n
+	return len(dAtA) - i, nil
 }
 
-func (m *LoadBalancerSettings_Simple) Size() (n int) {
-	if m == nil {
-		return 0
+func (m *OutlierDetection) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
 	}
-	var l int
-	_ = l
-	n += 1 + sovDestinationRule(uint64(m.Simple))
-	return n
+	return dAtA[:n], nil
 }
-func (m *LoadBalancerSettings_ConsistentHash) Size() (n int) {
-	if m == nil {
-		return 0
-	}
-	var l int
-	_ = l
-	if m.ConsistentHash != nil {
-		l = m.ConsistentHash.Size()
-		n += 1 + l + sovDestinationRule(uint64(l))
-	}
-	return n
+
+func (m *OutlierDetection) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
 }
-func (m *LoadBalancerSettings_ConsistentHashLB) Size() (n int) {
-	if m == nil {
-		return 0
-	}
+
+func (m *OutlierDetection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
 	var l int
 	_ = l
-	if m.HashKey != nil {
-		n += m.HashKey.Size()
-	}
-	if m.MinimumRingSize != 0 {
-		n += 1 + sovDestinationRule(uint64(m.MinimumRingSize))
-	}
 	if m.XXX_unrecognized != nil {
-		n += len(m.XXX_unrecognized)
-	}
-	return n
-}
-
-func (m *LoadBalancerSettings_ConsistentHashLB_HttpHeaderName) Size() (n int) {
-	if m == nil {
-		return 0
+		i -= len(m.XXX_unrecognized)
+		copy(dAtA[i:], m.XXX_unrecognized)
 	}
-	var l int
-	_ = l
-	l = len(m.HttpHeaderName)
-	n += 1 + l + sovDestinationRule(uint64(l))
-	return n
-}
-func (m *LoadBalancerSettings_ConsistentHashLB_HttpCookie) Size() (n int) {
-	if m == nil {
-		return 0
+	if m.ConsecutiveLocalOriginFailures != nil {
+		{
+			size, err := m.ConsecutiveLocalOriginFailures.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x4a
 	}
-	var l int
-	_ = l
-	if m.HttpCookie != nil {
-		l = m.HttpCookie.Size()
-		n += 1 + l + sovDestinationRule(uint64(l))
+	if m.SplitExternalLocalOriginErrors {
+		i--
+		if m.SplitExternalLocalOriginErrors {
+			dAtA[i] = 1
+		} else {
+			dAtA[i] = 0
+		}
+		i--
+		dAtA[i] = 0x40
 	}
-	return n
-}
-func (m *LoadBalancerSettings_ConsistentHashLB_UseSourceIp) Size() (n int) {
-	if m == nil {
-		return 0
+	if m.Consecutive_5XxErrors != nil {
+		{
+			size, err := m.Consecutive_5XxErrors.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x3a
 	}
-	var l int
-	_ = l
-	n += 2
-	return n
-}
-func (m *LoadBalancerSettings_ConsistentHashLB_HttpQueryParameterName) Size() (n int) {
-	if m == nil {
-		return 0
+	if m.ConsecutiveGatewayErrors != nil {
+		{
+			size, err := m.ConsecutiveGatewayErrors.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x32
 	}
-	var l int
-	_ = l
-	l = len(m.HttpQueryParameterName)
-	n += 1 + l + sovDestinationRule(uint64(l))
-	return n
-}
-func (m *LoadBalancerSettings_ConsistentHashLB_HTTPCookie) Size() (n int) {
-	if m == nil {
-		return 0
+	if m.MinHealthPercent != 0 {
+		i = encodeVarintDestinationRule(dAtA, i, uint64(m.MinHealthPercent))
+		i--
+		dAtA[i] = 0x28
 	}
-	var l int
-	_ = l
-	l = len(m.Name)
-	if l > 0 {
-		n += 1 + l + sovDestinationRule(uint64(l))
+	if m.MaxEjectionPercent != 0 {
+		i = encodeVarintDestinationRule(dAtA, i, uint64(m.MaxEjectionPercent))
+		i--
+		dAtA[i] = 0x20
 	}
-	l = len(m.Path)
-	if l > 0 {
-		n += 1 + l + sovDestinationRule(uint64(l))
+	if m.BaseEjectionTime != nil {
+		{
+			size, err := m.BaseEjectionTime.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x1a
 	}
-	if m.Ttl != nil {
-		l = m.Ttl.Size()
-		n += 1 + l + sovDestinationRule(uint64(l))
+	if m.Interval != nil {
+		{
+			size, err := m.Interval.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x12
 	}
-	if m.XXX_unrecognized != nil {
-		n += len(m.XXX_unrecognized)
+	if m.ConsecutiveErrors != 0 {
+		i = encodeVarintDestinationRule(dAtA, i, uint64(m.ConsecutiveErrors))
+		i--
+		dAtA[i] = 0x8
 	}
-	return n
+	return len(dAtA) - i, nil
 }
 
-func (m *ConnectionPoolSettings) Size() (n int) {
-	if m == nil {
-		return 0
-	}
-	var l int
-	_ = l
-	if m.Tcp != nil {
-		l = m.Tcp.Size()
-		n += 1 + l + sovDestinationRule(uint64(l))
-	}
-	if m.Http != nil {
-		l = m.Http.Size()
-		n += 1 + l + sovDestinationRule(uint64(l))
-	}
-	if m.XXX_unrecognized != nil {
-		n += len(m.XXX_unrecognized)
+func (m *ClientTLSSettings) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
 	}
-	return n
+	return dAtA[:n], nil
 }
 
-func (m *ConnectionPoolSettings_TCPSettings) Size() (n int) {
-	if m == nil {
-		return 0
-	}
-	var l int
-	_ = l
-	if m.MaxConnections != 0 {
-		n += 1 + sovDestinationRule(uint64(m.MaxConnections))
-	}
-	if m.ConnectTimeout != nil {
-		l = m.ConnectTimeout.Size()
-		n += 1 + l + sovDestinationRule(uint64(l))
-	}
-	if m.TcpKeepalive != nil {
-		l = m.TcpKeepalive.Size()
-		n += 1 + l + sovDestinationRule(uint64(l))
-	}
-	if m.XXX_unrecognized != nil {
-		n += len(m.XXX_unrecognized)
-	}
-	return n
+func (m *ClientTLSSettings) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
 }
 
-func (m *ConnectionPoolSettings_TCPSettings_TcpKeepalive) Size() (n int) {
-	if m == nil {
-		return 0
-	}
+func (m *ClientTLSSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
 	var l int
 	_ = l
-	if m.Probes != 0 {
-		n += 1 + sovDestinationRule(uint64(m.Probes))
-	}
-	if m.Time != nil {
-		l = m.Time.Size()
-		n += 1 + l + sovDestinationRule(uint64(l))
-	}
-	if m.Interval != nil {
-		l = m.Interval.Size()
-		n += 1 + l + sovDestinationRule(uint64(l))
-	}
 	if m.XXX_unrecognized != nil {
-		n += len(m.XXX_unrecognized)
+		i -= len(m.XXX_unrecognized)
+		copy(dAtA[i:], m.XXX_unrecognized)
 	}
-	return n
-}
-
-func (m *ConnectionPoolSettings_HTTPSettings) Size() (n int) {
-	if m == nil {
-		return 0
+	if m.InsecureSkipVerify != nil {
+		{
+			size, err := m.InsecureSkipVerify.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x42
 	}
-	var l int
-	_ = l
-	if m.Http1MaxPendingRequests != 0 {
-		n += 1 + sovDestinationRule(uint64(m.Http1MaxPendingRequests))
-	}
-	if m.Http2MaxRequests != 0 {
-		n += 1 + sovDestinationRule(uint64(m.Http2MaxRequests))
+	if len(m.CredentialName) > 0 {
+		i -= len(m.CredentialName)
+		copy(dAtA[i:], m.CredentialName)
+		i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.CredentialName)))
+		i--
+		dAtA[i] = 0x3a
 	}
-	if m.MaxRequestsPerConnection != 0 {
-		n += 1 + sovDestinationRule(uint64(m.MaxRequestsPerConnection))
+	if len(m.Sni) > 0 {
+		i -= len(m.Sni)
+		copy(dAtA[i:], m.Sni)
+		i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.Sni)))
+		i--
+		dAtA[i] = 0x32
 	}
-	if m.MaxRetries != 0 {
-		n += 1 + sovDestinationRule(uint64(m.MaxRetries))
+	if len(m.SubjectAltNames) > 0 {
+		for iNdEx := len(m.SubjectAltNames) - 1; iNdEx >= 0; iNdEx-- {
+			i -= len(m.SubjectAltNames[iNdEx])
+			copy(dAtA[i:], m.SubjectAltNames[iNdEx])
+			i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.SubjectAltNames[iNdEx])))
+			i--
+			dAtA[i] = 0x2a
+		}
 	}
-	if m.IdleTimeout != nil {
-		l = m.IdleTimeout.Size()
-		n += 1 + l + sovDestinationRule(uint64(l))
+	if len(m.CaCertificates) > 0 {
+		i -= len(m.CaCertificates)
+		copy(dAtA[i:], m.CaCertificates)
+		i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.CaCertificates)))
+		i--
+		dAtA[i] = 0x22
 	}
-	if m.H2UpgradePolicy != 0 {
-		n += 1 + sovDestinationRule(uint64(m.H2UpgradePolicy))
+	if len(m.PrivateKey) > 0 {
+		i -= len(m.PrivateKey)
+		copy(dAtA[i:], m.PrivateKey)
+		i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.PrivateKey)))
+		i--
+		dAtA[i] = 0x1a
 	}
-	if m.UseClientProtocol {
-		n += 2
+	if len(m.ClientCertificate) > 0 {
+		i -= len(m.ClientCertificate)
+		copy(dAtA[i:], m.ClientCertificate)
+		i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.ClientCertificate)))
+		i--
+		dAtA[i] = 0x12
 	}
-	if m.XXX_unrecognized != nil {
-		n += len(m.XXX_unrecognized)
+	if m.Mode != 0 {
+		i = encodeVarintDestinationRule(dAtA, i, uint64(m.Mode))
+		i--
+		dAtA[i] = 0x8
 	}
-	return n
+	return len(dAtA) - i, nil
 }
 
-func (m *OutlierDetection) Size() (n int) {
-	if m == nil {
-		return 0
-	}
-	var l int
-	_ = l
-	if m.ConsecutiveErrors != 0 {
-		n += 1 + sovDestinationRule(uint64(m.ConsecutiveErrors))
-	}
-	if m.Interval != nil {
-		l = m.Interval.Size()
-		n += 1 + l + sovDestinationRule(uint64(l))
-	}
-	if m.BaseEjectionTime != nil {
-		l = m.BaseEjectionTime.Size()
-		n += 1 + l + sovDestinationRule(uint64(l))
-	}
-	if m.MaxEjectionPercent != 0 {
-		n += 1 + sovDestinationRule(uint64(m.MaxEjectionPercent))
-	}
-	if m.MinHealthPercent != 0 {
-		n += 1 + sovDestinationRule(uint64(m.MinHealthPercent))
-	}
-	if m.ConsecutiveGatewayErrors != nil {
-		l = m.ConsecutiveGatewayErrors.Size()
-		n += 1 + l + sovDestinationRule(uint64(l))
-	}
-	if m.Consecutive_5XxErrors != nil {
-		l = m.Consecutive_5XxErrors.Size()
-		n += 1 + l + sovDestinationRule(uint64(l))
-	}
-	if m.SplitExternalLocalOriginErrors {
-		n += 2
-	}
-	if m.ConsecutiveLocalOriginFailures != nil {
-		l = m.ConsecutiveLocalOriginFailures.Size()
-		n += 1 + l + sovDestinationRule(uint64(l))
-	}
-	if m.XXX_unrecognized != nil {
-		n += len(m.XXX_unrecognized)
+func (m *LocalityLoadBalancerSetting) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
 	}
-	return n
+	return dAtA[:n], nil
 }
 
-func (m *ClientTLSSettings) Size() (n int) {
-	if m == nil {
-		return 0
-	}
+func (m *LocalityLoadBalancerSetting) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *LocalityLoadBalancerSetting) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
 	var l int
 	_ = l
-	if m.Mode != 0 {
-		n += 1 + sovDestinationRule(uint64(m.Mode))
-	}
-	l = len(m.ClientCertificate)
-	if l > 0 {
-		n += 1 + l + sovDestinationRule(uint64(l))
-	}
-	l = len(m.PrivateKey)
-	if l > 0 {
-		n += 1 + l + sovDestinationRule(uint64(l))
-	}
-	l = len(m.CaCertificates)
-	if l > 0 {
-		n += 1 + l + sovDestinationRule(uint64(l))
+	if m.XXX_unrecognized != nil {
+		i -= len(m.XXX_unrecognized)
+		copy(dAtA[i:], m.XXX_unrecognized)
 	}
-	if len(m.SubjectAltNames) > 0 {
-		for _, s := range m.SubjectAltNames {
-			l = len(s)
-			n += 1 + l + sovDestinationRule(uint64(l))
+	if len(m.FailoverPriority) > 0 {
+		for iNdEx := len(m.FailoverPriority) - 1; iNdEx >= 0; iNdEx-- {
+			i -= len(m.FailoverPriority[iNdEx])
+			copy(dAtA[i:], m.FailoverPriority[iNdEx])
+			i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.FailoverPriority[iNdEx])))
+			i--
+			dAtA[i] = 0x22
 		}
 	}
-	l = len(m.Sni)
-	if l > 0 {
-		n += 1 + l + sovDestinationRule(uint64(l))
-	}
-	l = len(m.CredentialName)
-	if l > 0 {
-		n += 1 + l + sovDestinationRule(uint64(l))
+	if m.Enabled != nil {
+		{
+			size, err := m.Enabled.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x1a
 	}
-	if m.InsecureSkipVerify != nil {
-		l = m.InsecureSkipVerify.Size()
-		n += 1 + l + sovDestinationRule(uint64(l))
+	if len(m.Failover) > 0 {
+		for iNdEx := len(m.Failover) - 1; iNdEx >= 0; iNdEx-- {
+			{
+				size, err := m.Failover[iNdEx].MarshalToSizedBuffer(dAtA[:i])
+				if err != nil {
+					return 0, err
+				}
+				i -= size
+				i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+			}
+			i--
+			dAtA[i] = 0x12
+		}
 	}
-	if m.XXX_unrecognized != nil {
-		n += len(m.XXX_unrecognized)
+	if len(m.Distribute) > 0 {
+		for iNdEx := len(m.Distribute) - 1; iNdEx >= 0; iNdEx-- {
+			{
+				size, err := m.Distribute[iNdEx].MarshalToSizedBuffer(dAtA[:i])
+				if err != nil {
+					return 0, err
+				}
+				i -= size
+				i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+			}
+			i--
+			dAtA[i] = 0xa
+		}
 	}
-	return n
+	return len(dAtA) - i, nil
 }
 
-func (m *LocalityLoadBalancerSetting) Size() (n int) {
-	if m == nil {
-		return 0
+func (m *LocalityLoadBalancerSetting_Distribute) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
 	}
+	return dAtA[:n], nil
+}
+
+func (m *LocalityLoadBalancerSetting_Distribute) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *LocalityLoadBalancerSetting_Distribute) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
 	var l int
 	_ = l
-	if len(m.Distribute) > 0 {
-		for _, e := range m.Distribute {
-			l = e.Size()
-			n += 1 + l + sovDestinationRule(uint64(l))
-		}
+	if m.XXX_unrecognized != nil {
+		i -= len(m.XXX_unrecognized)
+		copy(dAtA[i:], m.XXX_unrecognized)
 	}
-	if len(m.Failover) > 0 {
-		for _, e := range m.Failover {
-			l = e.Size()
-			n += 1 + l + sovDestinationRule(uint64(l))
+	if len(m.To) > 0 {
+		for k := range m.To {
+			v := m.To[k]
+			baseI := i
+			i = encodeVarintDestinationRule(dAtA, i, uint64(v))
+			i--
+			dAtA[i] = 0x10
+			i -= len(k)
+			copy(dAtA[i:], k)
+			i = encodeVarintDestinationRule(dAtA, i, uint64(len(k)))
+			i--
+			dAtA[i] = 0xa
+			i = encodeVarintDestinationRule(dAtA, i, uint64(baseI-i))
+			i--
+			dAtA[i] = 0x12
 		}
 	}
-	if m.Enabled != nil {
-		l = m.Enabled.Size()
-		n += 1 + l + sovDestinationRule(uint64(l))
+	if len(m.From) > 0 {
+		i -= len(m.From)
+		copy(dAtA[i:], m.From)
+		i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.From)))
+		i--
+		dAtA[i] = 0xa
+	}
+	return len(dAtA) - i, nil
+}
+
+func (m *LocalityLoadBalancerSetting_Failover) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *LocalityLoadBalancerSetting_Failover) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *LocalityLoadBalancerSetting_Failover) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
+	var l int
+	_ = l
+	if m.XXX_unrecognized != nil {
+		i -= len(m.XXX_unrecognized)
+		copy(dAtA[i:], m.XXX_unrecognized)
+	}
+	if len(m.To) > 0 {
+		i -= len(m.To)
+		copy(dAtA[i:], m.To)
+		i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.To)))
+		i--
+		dAtA[i] = 0x12
+	}
+	if len(m.From) > 0 {
+		i -= len(m.From)
+		copy(dAtA[i:], m.From)
+		i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.From)))
+		i--
+		dAtA[i] = 0xa
+	}
+	return len(dAtA) - i, nil
+}
+
+func (m *Int64Range) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *Int64Range) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *Int64Range) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
+	var l int
+	_ = l
+	if m.XXX_unrecognized != nil {
+		i -= len(m.XXX_unrecognized)
+		copy(dAtA[i:], m.XXX_unrecognized)
+	}
+	if m.End != 0 {
+		i = encodeVarintDestinationRule(dAtA, i, uint64(m.End))
+		i--
+		dAtA[i] = 0x10
+	}
+	if m.Start != 0 {
+		i = encodeVarintDestinationRule(dAtA, i, uint64(m.Start))
+		i--
+		dAtA[i] = 0x8
+	}
+	return len(dAtA) - i, nil
+}
+
+func (m *HealthStatusSet) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *HealthStatusSet) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *HealthStatusSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
+	var l int
+	_ = l
+	if m.XXX_unrecognized != nil {
+		i -= len(m.XXX_unrecognized)
+		copy(dAtA[i:], m.XXX_unrecognized)
+	}
+	if len(m.Statuses) > 0 {
+		dAtA32 := make([]byte, len(m.Statuses)*10)
+		var j31 int
+		for _, num := range m.Statuses {
+			for num >= 1<<7 {
+				dAtA32[j31] = uint8(uint64(num)&0x7f | 0x80)
+				num >>= 7
+				j31++
+			}
+			dAtA32[j31] = uint8(num)
+			j31++
+		}
+		i -= j31
+		copy(dAtA[i:], dAtA32[:j31])
+		i = encodeVarintDestinationRule(dAtA, i, uint64(j31))
+		i--
+		dAtA[i] = 0xa
+	}
+	return len(dAtA) - i, nil
+}
+
+func (m *Payload) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *Payload) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *Payload) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
+	var l int
+	_ = l
+	if m.XXX_unrecognized != nil {
+		i -= len(m.XXX_unrecognized)
+		copy(dAtA[i:], m.XXX_unrecognized)
+	}
+	if m.Payload != nil {
+		{
+			size := m.Payload.Size()
+			i -= size
+			if _, err := m.Payload.MarshalTo(dAtA[i:]); err != nil {
+				return 0, err
+			}
+		}
+	}
+	return len(dAtA) - i, nil
+}
+
+func (m *Payload_Text) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *Payload_Text) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	i -= len(m.Text)
+	copy(dAtA[i:], m.Text)
+	i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.Text)))
+	i--
+	dAtA[i] = 0xa
+	return len(dAtA) - i, nil
+}
+func (m *Payload_Binary) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *Payload_Binary) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	if m.Binary != nil {
+		i -= len(m.Binary)
+		copy(dAtA[i:], m.Binary)
+		i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.Binary)))
+		i--
+		dAtA[i] = 0x12
+	}
+	return len(dAtA) - i, nil
+}
+func (m *HealthCheck) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *HealthCheck) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *HealthCheck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
+	var l int
+	_ = l
+	if m.XXX_unrecognized != nil {
+		i -= len(m.XXX_unrecognized)
+		copy(dAtA[i:], m.XXX_unrecognized)
+	}
+	if m.NoTrafficHealthyInterval != nil {
+		{
+			size, err := m.NoTrafficHealthyInterval.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x1
+		i--
+		dAtA[i] = 0xc2
+	}
+	if m.TlsOptions != nil {
+		{
+			size, err := m.TlsOptions.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x1
+		i--
+		dAtA[i] = 0xaa
+	}
+	if m.InitialJitter != nil {
+		{
+			size, err := m.InitialJitter.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x1
+		i--
+		dAtA[i] = 0xa2
+	}
+	if m.AlwaysLogHealthCheckFailures {
+		i--
+		if m.AlwaysLogHealthCheckFailures {
+			dAtA[i] = 1
+		} else {
+			dAtA[i] = 0
+		}
+		i--
+		dAtA[i] = 0x1
+		i--
+		dAtA[i] = 0x98
+	}
+	if m.IntervalJitterPercent != 0 {
+		i = encodeVarintDestinationRule(dAtA, i, uint64(m.IntervalJitterPercent))
+		i--
+		dAtA[i] = 0x1
+		i--
+		dAtA[i] = 0x90
+	}
+	if len(m.EventLogPath) > 0 {
+		i -= len(m.EventLogPath)
+		copy(dAtA[i:], m.EventLogPath)
+		i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.EventLogPath)))
+		i--
+		dAtA[i] = 0x1
+		i--
+		dAtA[i] = 0x8a
+	}
+	if m.HealthyEdgeInterval != nil {
+		{
+			size, err := m.HealthyEdgeInterval.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x1
+		i--
+		dAtA[i] = 0x82
+	}
+	if m.UnhealthyEdgeInterval != nil {
+		{
+			size, err := m.UnhealthyEdgeInterval.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x7a
+	}
+	if m.UnhealthyInterval != nil {
+		{
+			size, err := m.UnhealthyInterval.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x72
+	}
+	if m.HealthChecker != nil {
+		{
+			size := m.HealthChecker.Size()
+			i -= size
+			if _, err := m.HealthChecker.MarshalTo(dAtA[i:]); err != nil {
+				return 0, err
+			}
+		}
+	}
+	if m.NoTrafficInterval != nil {
+		{
+			size, err := m.NoTrafficInterval.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x62
+	}
+	if m.ReuseConnection != nil {
+		{
+			size, err := m.ReuseConnection.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x3a
+	}
+	if m.AltPort != nil {
+		{
+			size, err := m.AltPort.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x32
+	}
+	if m.HealthyThreshold != nil {
+		{
+			size, err := m.HealthyThreshold.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x2a
+	}
+	if m.UnhealthyThreshold != nil {
+		{
+			size, err := m.UnhealthyThreshold.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x22
+	}
+	if m.IntervalJitter != nil {
+		{
+			size, err := m.IntervalJitter.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x1a
+	}
+	if m.Interval != nil {
+		{
+			size, err := m.Interval.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x12
+	}
+	if m.Timeout != nil {
+		{
+			size, err := m.Timeout.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0xa
+	}
+	return len(dAtA) - i, nil
+}
+
+func (m *HealthCheck_HttpHealthCheck_) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *HealthCheck_HttpHealthCheck_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	if m.HttpHealthCheck != nil {
+		{
+			size, err := m.HttpHealthCheck.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x42
+	}
+	return len(dAtA) - i, nil
+}
+func (m *HealthCheck_TcpHealthCheck_) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *HealthCheck_TcpHealthCheck_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	if m.TcpHealthCheck != nil {
+		{
+			size, err := m.TcpHealthCheck.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x4a
+	}
+	return len(dAtA) - i, nil
+}
+func (m *HealthCheck_GrpcHealthCheck_) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *HealthCheck_GrpcHealthCheck_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	if m.GrpcHealthCheck != nil {
+		{
+			size, err := m.GrpcHealthCheck.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x5a
+	}
+	return len(dAtA) - i, nil
+}
+func (m *HealthCheck_CustomHealthCheck_) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *HealthCheck_CustomHealthCheck_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	if m.CustomHealthCheck != nil {
+		{
+			size, err := m.CustomHealthCheck.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x6a
+	}
+	return len(dAtA) - i, nil
+}
+func (m *HealthCheck_HttpHealthCheck) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *HealthCheck_HttpHealthCheck) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *HealthCheck_HttpHealthCheck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
+	var l int
+	_ = l
+	if m.XXX_unrecognized != nil {
+		i -= len(m.XXX_unrecognized)
+		copy(dAtA[i:], m.XXX_unrecognized)
+	}
+	if len(m.RetriableStatuses) > 0 {
+		for iNdEx := len(m.RetriableStatuses) - 1; iNdEx >= 0; iNdEx-- {
+			{
+				size, err := m.RetriableStatuses[iNdEx].MarshalToSizedBuffer(dAtA[:i])
+				if err != nil {
+					return 0, err
+				}
+				i -= size
+				i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+			}
+			i--
+			dAtA[i] = 0x62
+		}
+	}
+	if len(m.ExpectedStatuses) > 0 {
+		for iNdEx := len(m.ExpectedStatuses) - 1; iNdEx >= 0; iNdEx-- {
+			{
+				size, err := m.ExpectedStatuses[iNdEx].MarshalToSizedBuffer(dAtA[:i])
+				if err != nil {
+					return 0, err
+				}
+				i -= size
+				i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+			}
+			i--
+			dAtA[i] = 0x4a
+		}
+	}
+	if m.Receive != nil {
+		{
+			size, err := m.Receive.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x22
+	}
+	if m.Send != nil {
+		{
+			size, err := m.Send.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x1a
+	}
+	if len(m.Path) > 0 {
+		i -= len(m.Path)
+		copy(dAtA[i:], m.Path)
+		i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.Path)))
+		i--
+		dAtA[i] = 0x12
+	}
+	if len(m.Host) > 0 {
+		i -= len(m.Host)
+		copy(dAtA[i:], m.Host)
+		i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.Host)))
+		i--
+		dAtA[i] = 0xa
+	}
+	return len(dAtA) - i, nil
+}
+
+func (m *HealthCheck_TcpHealthCheck) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *HealthCheck_TcpHealthCheck) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *HealthCheck_TcpHealthCheck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
+	var l int
+	_ = l
+	if m.XXX_unrecognized != nil {
+		i -= len(m.XXX_unrecognized)
+		copy(dAtA[i:], m.XXX_unrecognized)
+	}
+	if len(m.Receive) > 0 {
+		for iNdEx := len(m.Receive) - 1; iNdEx >= 0; iNdEx-- {
+			{
+				size, err := m.Receive[iNdEx].MarshalToSizedBuffer(dAtA[:i])
+				if err != nil {
+					return 0, err
+				}
+				i -= size
+				i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+			}
+			i--
+			dAtA[i] = 0x12
+		}
+	}
+	if m.Send != nil {
+		{
+			size, err := m.Send.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintDestinationRule(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0xa
+	}
+	return len(dAtA) - i, nil
+}
+
+func (m *HealthCheck_RedisHealthCheck) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *HealthCheck_RedisHealthCheck) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *HealthCheck_RedisHealthCheck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
+	var l int
+	_ = l
+	if m.XXX_unrecognized != nil {
+		i -= len(m.XXX_unrecognized)
+		copy(dAtA[i:], m.XXX_unrecognized)
+	}
+	if len(m.Key) > 0 {
+		i -= len(m.Key)
+		copy(dAtA[i:], m.Key)
+		i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.Key)))
+		i--
+		dAtA[i] = 0xa
+	}
+	return len(dAtA) - i, nil
+}
+
+func (m *HealthCheck_GrpcHealthCheck) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *HealthCheck_GrpcHealthCheck) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *HealthCheck_GrpcHealthCheck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
+	var l int
+	_ = l
+	if m.XXX_unrecognized != nil {
+		i -= len(m.XXX_unrecognized)
+		copy(dAtA[i:], m.XXX_unrecognized)
+	}
+	if len(m.Authority) > 0 {
+		i -= len(m.Authority)
+		copy(dAtA[i:], m.Authority)
+		i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.Authority)))
+		i--
+		dAtA[i] = 0x12
+	}
+	if len(m.ServiceName) > 0 {
+		i -= len(m.ServiceName)
+		copy(dAtA[i:], m.ServiceName)
+		i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.ServiceName)))
+		i--
+		dAtA[i] = 0xa
+	}
+	return len(dAtA) - i, nil
+}
+
+func (m *HealthCheck_CustomHealthCheck) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *HealthCheck_CustomHealthCheck) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *HealthCheck_CustomHealthCheck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
+	var l int
+	_ = l
+	if m.XXX_unrecognized != nil {
+		i -= len(m.XXX_unrecognized)
+		copy(dAtA[i:], m.XXX_unrecognized)
+	}
+	if len(m.Name) > 0 {
+		i -= len(m.Name)
+		copy(dAtA[i:], m.Name)
+		i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.Name)))
+		i--
+		dAtA[i] = 0xa
+	}
+	return len(dAtA) - i, nil
+}
+
+func (m *HealthCheck_TlsOptions) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *HealthCheck_TlsOptions) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *HealthCheck_TlsOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
+	var l int
+	_ = l
+	if m.XXX_unrecognized != nil {
+		i -= len(m.XXX_unrecognized)
+		copy(dAtA[i:], m.XXX_unrecognized)
+	}
+	if len(m.AlpnProtocols) > 0 {
+		for iNdEx := len(m.AlpnProtocols) - 1; iNdEx >= 0; iNdEx-- {
+			i -= len(m.AlpnProtocols[iNdEx])
+			copy(dAtA[i:], m.AlpnProtocols[iNdEx])
+			i = encodeVarintDestinationRule(dAtA, i, uint64(len(m.AlpnProtocols[iNdEx])))
+			i--
+			dAtA[i] = 0xa
+		}
+	}
+	return len(dAtA) - i, nil
+}
+
+func encodeVarintDestinationRule(dAtA []byte, offset int, v uint64) int {
+	offset -= sovDestinationRule(v)
+	base := offset
+	for v >= 1<<7 {
+		dAtA[offset] = uint8(v&0x7f | 0x80)
+		v >>= 7
+		offset++
+	}
+	dAtA[offset] = uint8(v)
+	return base
+}
+func (m *DestinationRule) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	l = len(m.Host)
+	if l > 0 {
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.TrafficPolicy != nil {
+		l = m.TrafficPolicy.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if len(m.Subsets) > 0 {
+		for _, e := range m.Subsets {
+			l = e.Size()
+			n += 1 + l + sovDestinationRule(uint64(l))
+		}
+	}
+	if len(m.ExportTo) > 0 {
+		for _, s := range m.ExportTo {
+			l = len(s)
+			n += 1 + l + sovDestinationRule(uint64(l))
+		}
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *TrafficPolicy) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if m.LoadBalancer != nil {
+		l = m.LoadBalancer.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.ConnectionPool != nil {
+		l = m.ConnectionPool.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.OutlierDetection != nil {
+		l = m.OutlierDetection.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.Tls != nil {
+		l = m.Tls.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if len(m.PortLevelSettings) > 0 {
+		for _, e := range m.PortLevelSettings {
+			l = e.Size()
+			n += 1 + l + sovDestinationRule(uint64(l))
+		}
+	}
+	if len(m.HealthChecks) > 0 {
+		for _, e := range m.HealthChecks {
+			l = e.Size()
+			n += 2 + l + sovDestinationRule(uint64(l))
+		}
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *TrafficPolicy_PortTrafficPolicy) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if m.Port != nil {
+		l = m.Port.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.LoadBalancer != nil {
+		l = m.LoadBalancer.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.ConnectionPool != nil {
+		l = m.ConnectionPool.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.OutlierDetection != nil {
+		l = m.OutlierDetection.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.Tls != nil {
+		l = m.Tls.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if len(m.HealthChecks) > 0 {
+		for _, e := range m.HealthChecks {
+			l = e.Size()
+			n += 2 + l + sovDestinationRule(uint64(l))
+		}
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *Subset) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	l = len(m.Name)
+	if l > 0 {
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if len(m.Labels) > 0 {
+		for k, v := range m.Labels {
+			_ = k
+			_ = v
+			mapEntrySize := 1 + len(k) + sovDestinationRule(uint64(len(k))) + 1 + len(v) + sovDestinationRule(uint64(len(v)))
+			n += mapEntrySize + 1 + sovDestinationRule(uint64(mapEntrySize))
+		}
+	}
+	if m.TrafficPolicy != nil {
+		l = m.TrafficPolicy.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *LoadBalancerSettings) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if m.LbPolicy != nil {
+		n += m.LbPolicy.Size()
+	}
+	if m.LocalityLbSetting != nil {
+		l = m.LocalityLbSetting.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.WarmupDurationSecs != nil {
+		l = m.WarmupDurationSecs.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *LoadBalancerSettings_Simple) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	n += 1 + sovDestinationRule(uint64(m.Simple))
+	return n
+}
+func (m *LoadBalancerSettings_ConsistentHash) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if m.ConsistentHash != nil {
+		l = m.ConsistentHash.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	return n
+}
+func (m *LoadBalancerSettings_ConsistentHashLB) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if m.HashKey != nil {
+		n += m.HashKey.Size()
+	}
+	if m.MinimumRingSize != 0 {
+		n += 1 + sovDestinationRule(uint64(m.MinimumRingSize))
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *LoadBalancerSettings_ConsistentHashLB_HttpHeaderName) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	l = len(m.HttpHeaderName)
+	n += 1 + l + sovDestinationRule(uint64(l))
+	return n
+}
+func (m *LoadBalancerSettings_ConsistentHashLB_HttpCookie) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if m.HttpCookie != nil {
+		l = m.HttpCookie.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	return n
+}
+func (m *LoadBalancerSettings_ConsistentHashLB_UseSourceIp) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	n += 2
+	return n
+}
+func (m *LoadBalancerSettings_ConsistentHashLB_HttpQueryParameterName) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	l = len(m.HttpQueryParameterName)
+	n += 1 + l + sovDestinationRule(uint64(l))
+	return n
+}
+func (m *LoadBalancerSettings_ConsistentHashLB_HTTPCookie) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	l = len(m.Name)
+	if l > 0 {
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	l = len(m.Path)
+	if l > 0 {
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.Ttl != nil {
+		l = m.Ttl.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *ConnectionPoolSettings) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if m.Tcp != nil {
+		l = m.Tcp.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.Http != nil {
+		l = m.Http.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *ConnectionPoolSettings_TCPSettings) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if m.MaxConnections != 0 {
+		n += 1 + sovDestinationRule(uint64(m.MaxConnections))
+	}
+	if m.ConnectTimeout != nil {
+		l = m.ConnectTimeout.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.TcpKeepalive != nil {
+		l = m.TcpKeepalive.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *ConnectionPoolSettings_TCPSettings_TcpKeepalive) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if m.Probes != 0 {
+		n += 1 + sovDestinationRule(uint64(m.Probes))
+	}
+	if m.Time != nil {
+		l = m.Time.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.Interval != nil {
+		l = m.Interval.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *ConnectionPoolSettings_HTTPSettings) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if m.Http1MaxPendingRequests != 0 {
+		n += 1 + sovDestinationRule(uint64(m.Http1MaxPendingRequests))
+	}
+	if m.Http2MaxRequests != 0 {
+		n += 1 + sovDestinationRule(uint64(m.Http2MaxRequests))
+	}
+	if m.MaxRequestsPerConnection != 0 {
+		n += 1 + sovDestinationRule(uint64(m.MaxRequestsPerConnection))
+	}
+	if m.MaxRetries != 0 {
+		n += 1 + sovDestinationRule(uint64(m.MaxRetries))
+	}
+	if m.IdleTimeout != nil {
+		l = m.IdleTimeout.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.H2UpgradePolicy != 0 {
+		n += 1 + sovDestinationRule(uint64(m.H2UpgradePolicy))
+	}
+	if m.UseClientProtocol {
+		n += 2
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *OutlierDetection) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if m.ConsecutiveErrors != 0 {
+		n += 1 + sovDestinationRule(uint64(m.ConsecutiveErrors))
+	}
+	if m.Interval != nil {
+		l = m.Interval.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.BaseEjectionTime != nil {
+		l = m.BaseEjectionTime.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.MaxEjectionPercent != 0 {
+		n += 1 + sovDestinationRule(uint64(m.MaxEjectionPercent))
+	}
+	if m.MinHealthPercent != 0 {
+		n += 1 + sovDestinationRule(uint64(m.MinHealthPercent))
+	}
+	if m.ConsecutiveGatewayErrors != nil {
+		l = m.ConsecutiveGatewayErrors.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.Consecutive_5XxErrors != nil {
+		l = m.Consecutive_5XxErrors.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.SplitExternalLocalOriginErrors {
+		n += 2
+	}
+	if m.ConsecutiveLocalOriginFailures != nil {
+		l = m.ConsecutiveLocalOriginFailures.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *ClientTLSSettings) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if m.Mode != 0 {
+		n += 1 + sovDestinationRule(uint64(m.Mode))
+	}
+	l = len(m.ClientCertificate)
+	if l > 0 {
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	l = len(m.PrivateKey)
+	if l > 0 {
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	l = len(m.CaCertificates)
+	if l > 0 {
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if len(m.SubjectAltNames) > 0 {
+		for _, s := range m.SubjectAltNames {
+			l = len(s)
+			n += 1 + l + sovDestinationRule(uint64(l))
+		}
+	}
+	l = len(m.Sni)
+	if l > 0 {
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	l = len(m.CredentialName)
+	if l > 0 {
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.InsecureSkipVerify != nil {
+		l = m.InsecureSkipVerify.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *LocalityLoadBalancerSetting) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if len(m.Distribute) > 0 {
+		for _, e := range m.Distribute {
+			l = e.Size()
+			n += 1 + l + sovDestinationRule(uint64(l))
+		}
+	}
+	if len(m.Failover) > 0 {
+		for _, e := range m.Failover {
+			l = e.Size()
+			n += 1 + l + sovDestinationRule(uint64(l))
+		}
+	}
+	if m.Enabled != nil {
+		l = m.Enabled.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
 	}
 	if len(m.FailoverPriority) > 0 {
 		for _, s := range m.FailoverPriority {
@@ -4057,63 +5840,2283 @@ func (m *LocalityLoadBalancerSetting) Size() (n int) {
 			n += 1 + l + sovDestinationRule(uint64(l))
 		}
 	}
-	if m.XXX_unrecognized != nil {
-		n += len(m.XXX_unrecognized)
-	}
-	return n
-}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *LocalityLoadBalancerSetting_Distribute) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	l = len(m.From)
+	if l > 0 {
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if len(m.To) > 0 {
+		for k, v := range m.To {
+			_ = k
+			_ = v
+			mapEntrySize := 1 + len(k) + sovDestinationRule(uint64(len(k))) + 1 + sovDestinationRule(uint64(v))
+			n += mapEntrySize + 1 + sovDestinationRule(uint64(mapEntrySize))
+		}
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *LocalityLoadBalancerSetting_Failover) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	l = len(m.From)
+	if l > 0 {
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	l = len(m.To)
+	if l > 0 {
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *Int64Range) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if m.Start != 0 {
+		n += 1 + sovDestinationRule(uint64(m.Start))
+	}
+	if m.End != 0 {
+		n += 1 + sovDestinationRule(uint64(m.End))
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *HealthStatusSet) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if len(m.Statuses) > 0 {
+		l = 0
+		for _, e := range m.Statuses {
+			l += sovDestinationRule(uint64(e))
+		}
+		n += 1 + sovDestinationRule(uint64(l)) + l
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *Payload) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if m.Payload != nil {
+		n += m.Payload.Size()
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *Payload_Text) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	l = len(m.Text)
+	n += 1 + l + sovDestinationRule(uint64(l))
+	return n
+}
+func (m *Payload_Binary) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if m.Binary != nil {
+		l = len(m.Binary)
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	return n
+}
+func (m *HealthCheck) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if m.Timeout != nil {
+		l = m.Timeout.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.Interval != nil {
+		l = m.Interval.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.IntervalJitter != nil {
+		l = m.IntervalJitter.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.UnhealthyThreshold != nil {
+		l = m.UnhealthyThreshold.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.HealthyThreshold != nil {
+		l = m.HealthyThreshold.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.AltPort != nil {
+		l = m.AltPort.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.ReuseConnection != nil {
+		l = m.ReuseConnection.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.HealthChecker != nil {
+		n += m.HealthChecker.Size()
+	}
+	if m.NoTrafficInterval != nil {
+		l = m.NoTrafficInterval.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.UnhealthyInterval != nil {
+		l = m.UnhealthyInterval.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.UnhealthyEdgeInterval != nil {
+		l = m.UnhealthyEdgeInterval.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.HealthyEdgeInterval != nil {
+		l = m.HealthyEdgeInterval.Size()
+		n += 2 + l + sovDestinationRule(uint64(l))
+	}
+	l = len(m.EventLogPath)
+	if l > 0 {
+		n += 2 + l + sovDestinationRule(uint64(l))
+	}
+	if m.IntervalJitterPercent != 0 {
+		n += 2 + sovDestinationRule(uint64(m.IntervalJitterPercent))
+	}
+	if m.AlwaysLogHealthCheckFailures {
+		n += 3
+	}
+	if m.InitialJitter != nil {
+		l = m.InitialJitter.Size()
+		n += 2 + l + sovDestinationRule(uint64(l))
+	}
+	if m.TlsOptions != nil {
+		l = m.TlsOptions.Size()
+		n += 2 + l + sovDestinationRule(uint64(l))
+	}
+	if m.NoTrafficHealthyInterval != nil {
+		l = m.NoTrafficHealthyInterval.Size()
+		n += 2 + l + sovDestinationRule(uint64(l))
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *HealthCheck_HttpHealthCheck_) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if m.HttpHealthCheck != nil {
+		l = m.HttpHealthCheck.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	return n
+}
+func (m *HealthCheck_TcpHealthCheck_) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if m.TcpHealthCheck != nil {
+		l = m.TcpHealthCheck.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	return n
+}
+func (m *HealthCheck_GrpcHealthCheck_) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if m.GrpcHealthCheck != nil {
+		l = m.GrpcHealthCheck.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	return n
+}
+func (m *HealthCheck_CustomHealthCheck_) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if m.CustomHealthCheck != nil {
+		l = m.CustomHealthCheck.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	return n
+}
+func (m *HealthCheck_HttpHealthCheck) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	l = len(m.Host)
+	if l > 0 {
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	l = len(m.Path)
+	if l > 0 {
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.Send != nil {
+		l = m.Send.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.Receive != nil {
+		l = m.Receive.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if len(m.ExpectedStatuses) > 0 {
+		for _, e := range m.ExpectedStatuses {
+			l = e.Size()
+			n += 1 + l + sovDestinationRule(uint64(l))
+		}
+	}
+	if len(m.RetriableStatuses) > 0 {
+		for _, e := range m.RetriableStatuses {
+			l = e.Size()
+			n += 1 + l + sovDestinationRule(uint64(l))
+		}
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *HealthCheck_TcpHealthCheck) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if m.Send != nil {
+		l = m.Send.Size()
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if len(m.Receive) > 0 {
+		for _, e := range m.Receive {
+			l = e.Size()
+			n += 1 + l + sovDestinationRule(uint64(l))
+		}
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *HealthCheck_RedisHealthCheck) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	l = len(m.Key)
+	if l > 0 {
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *HealthCheck_GrpcHealthCheck) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	l = len(m.ServiceName)
+	if l > 0 {
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	l = len(m.Authority)
+	if l > 0 {
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *HealthCheck_CustomHealthCheck) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	l = len(m.Name)
+	if l > 0 {
+		n += 1 + l + sovDestinationRule(uint64(l))
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *HealthCheck_TlsOptions) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if len(m.AlpnProtocols) > 0 {
+		for _, s := range m.AlpnProtocols {
+			l = len(s)
+			n += 1 + l + sovDestinationRule(uint64(l))
+		}
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func sovDestinationRule(x uint64) (n int) {
+	return (math_bits.Len64(x|1) + 6) / 7
+}
+func sozDestinationRule(x uint64) (n int) {
+	return sovDestinationRule(uint64((x << 1) ^ uint64((int64(x) >> 63))))
+}
+func (m *DestinationRule) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowDestinationRule
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: DestinationRule: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: DestinationRule: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Host = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field TrafficPolicy", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.TrafficPolicy == nil {
+				m.TrafficPolicy = &TrafficPolicy{}
+			}
+			if err := m.TrafficPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 3:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Subsets", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Subsets = append(m.Subsets, &Subset{})
+			if err := m.Subsets[len(m.Subsets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 4:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field ExportTo", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.ExportTo = append(m.ExportTo, string(dAtA[iNdEx:postIndex]))
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipDestinationRule(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *TrafficPolicy) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowDestinationRule
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: TrafficPolicy: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: TrafficPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field LoadBalancer", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.LoadBalancer == nil {
+				m.LoadBalancer = &LoadBalancerSettings{}
+			}
+			if err := m.LoadBalancer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionPool", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.ConnectionPool == nil {
+				m.ConnectionPool = &ConnectionPoolSettings{}
+			}
+			if err := m.ConnectionPool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 3:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field OutlierDetection", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.OutlierDetection == nil {
+				m.OutlierDetection = &OutlierDetection{}
+			}
+			if err := m.OutlierDetection.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 4:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Tls", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.Tls == nil {
+				m.Tls = &ClientTLSSettings{}
+			}
+			if err := m.Tls.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 5:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field PortLevelSettings", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.PortLevelSettings = append(m.PortLevelSettings, &TrafficPolicy_PortTrafficPolicy{})
+			if err := m.PortLevelSettings[len(m.PortLevelSettings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 101:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field HealthChecks", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.HealthChecks = append(m.HealthChecks, &HealthCheck{})
+			if err := m.HealthChecks[len(m.HealthChecks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipDestinationRule(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *TrafficPolicy_PortTrafficPolicy) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowDestinationRule
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: PortTrafficPolicy: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: PortTrafficPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.Port == nil {
+				m.Port = &PortSelector{}
+			}
+			if err := m.Port.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field LoadBalancer", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.LoadBalancer == nil {
+				m.LoadBalancer = &LoadBalancerSettings{}
+			}
+			if err := m.LoadBalancer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 3:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionPool", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.ConnectionPool == nil {
+				m.ConnectionPool = &ConnectionPoolSettings{}
+			}
+			if err := m.ConnectionPool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 4:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field OutlierDetection", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.OutlierDetection == nil {
+				m.OutlierDetection = &OutlierDetection{}
+			}
+			if err := m.OutlierDetection.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 5:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Tls", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.Tls == nil {
+				m.Tls = &ClientTLSSettings{}
+			}
+			if err := m.Tls.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 101:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field HealthChecks", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.HealthChecks = append(m.HealthChecks, &HealthCheck{})
+			if err := m.HealthChecks[len(m.HealthChecks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipDestinationRule(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *Subset) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowDestinationRule
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: Subset: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: Subset: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Name = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.Labels == nil {
+				m.Labels = make(map[string]string)
+			}
+			var mapkey string
+			var mapvalue string
+			for iNdEx < postIndex {
+				entryPreIndex := iNdEx
+				var wire uint64
+				for shift := uint(0); ; shift += 7 {
+					if shift >= 64 {
+						return ErrIntOverflowDestinationRule
+					}
+					if iNdEx >= l {
+						return io.ErrUnexpectedEOF
+					}
+					b := dAtA[iNdEx]
+					iNdEx++
+					wire |= uint64(b&0x7F) << shift
+					if b < 0x80 {
+						break
+					}
+				}
+				fieldNum := int32(wire >> 3)
+				if fieldNum == 1 {
+					var stringLenmapkey uint64
+					for shift := uint(0); ; shift += 7 {
+						if shift >= 64 {
+							return ErrIntOverflowDestinationRule
+						}
+						if iNdEx >= l {
+							return io.ErrUnexpectedEOF
+						}
+						b := dAtA[iNdEx]
+						iNdEx++
+						stringLenmapkey |= uint64(b&0x7F) << shift
+						if b < 0x80 {
+							break
+						}
+					}
+					intStringLenmapkey := int(stringLenmapkey)
+					if intStringLenmapkey < 0 {
+						return ErrInvalidLengthDestinationRule
+					}
+					postStringIndexmapkey := iNdEx + intStringLenmapkey
+					if postStringIndexmapkey < 0 {
+						return ErrInvalidLengthDestinationRule
+					}
+					if postStringIndexmapkey > l {
+						return io.ErrUnexpectedEOF
+					}
+					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
+					iNdEx = postStringIndexmapkey
+				} else if fieldNum == 2 {
+					var stringLenmapvalue uint64
+					for shift := uint(0); ; shift += 7 {
+						if shift >= 64 {
+							return ErrIntOverflowDestinationRule
+						}
+						if iNdEx >= l {
+							return io.ErrUnexpectedEOF
+						}
+						b := dAtA[iNdEx]
+						iNdEx++
+						stringLenmapvalue |= uint64(b&0x7F) << shift
+						if b < 0x80 {
+							break
+						}
+					}
+					intStringLenmapvalue := int(stringLenmapvalue)
+					if intStringLenmapvalue < 0 {
+						return ErrInvalidLengthDestinationRule
+					}
+					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
+					if postStringIndexmapvalue < 0 {
+						return ErrInvalidLengthDestinationRule
+					}
+					if postStringIndexmapvalue > l {
+						return io.ErrUnexpectedEOF
+					}
+					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
+					iNdEx = postStringIndexmapvalue
+				} else {
+					iNdEx = entryPreIndex
+					skippy, err := skipDestinationRule(dAtA[iNdEx:])
+					if err != nil {
+						return err
+					}
+					if (skippy < 0) || (iNdEx+skippy) < 0 {
+						return ErrInvalidLengthDestinationRule
+					}
+					if (iNdEx + skippy) > postIndex {
+						return io.ErrUnexpectedEOF
+					}
+					iNdEx += skippy
+				}
+			}
+			m.Labels[mapkey] = mapvalue
+			iNdEx = postIndex
+		case 3:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field TrafficPolicy", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.TrafficPolicy == nil {
+				m.TrafficPolicy = &TrafficPolicy{}
+			}
+			if err := m.TrafficPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipDestinationRule(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *LoadBalancerSettings) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowDestinationRule
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: LoadBalancerSettings: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: LoadBalancerSettings: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Simple", wireType)
+			}
+			var v LoadBalancerSettings_SimpleLB
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				v |= LoadBalancerSettings_SimpleLB(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			m.LbPolicy = &LoadBalancerSettings_Simple{v}
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field ConsistentHash", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			v := &LoadBalancerSettings_ConsistentHashLB{}
+			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			m.LbPolicy = &LoadBalancerSettings_ConsistentHash{v}
+			iNdEx = postIndex
+		case 3:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field LocalityLbSetting", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.LocalityLbSetting == nil {
+				m.LocalityLbSetting = &LocalityLoadBalancerSetting{}
+			}
+			if err := m.LocalityLbSetting.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 4:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field WarmupDurationSecs", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.WarmupDurationSecs == nil {
+				m.WarmupDurationSecs = &types.Duration{}
+			}
+			if err := m.WarmupDurationSecs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipDestinationRule(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *LoadBalancerSettings_ConsistentHashLB) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowDestinationRule
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: ConsistentHashLB: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: ConsistentHashLB: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field HttpHeaderName", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.HashKey = &LoadBalancerSettings_ConsistentHashLB_HttpHeaderName{string(dAtA[iNdEx:postIndex])}
+			iNdEx = postIndex
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field HttpCookie", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			v := &LoadBalancerSettings_ConsistentHashLB_HTTPCookie{}
+			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			m.HashKey = &LoadBalancerSettings_ConsistentHashLB_HttpCookie{v}
+			iNdEx = postIndex
+		case 3:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field UseSourceIp", wireType)
+			}
+			var v int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				v |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			b := bool(v != 0)
+			m.HashKey = &LoadBalancerSettings_ConsistentHashLB_UseSourceIp{b}
+		case 4:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field MinimumRingSize", wireType)
+			}
+			m.MinimumRingSize = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.MinimumRingSize |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		case 5:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field HttpQueryParameterName", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.HashKey = &LoadBalancerSettings_ConsistentHashLB_HttpQueryParameterName{string(dAtA[iNdEx:postIndex])}
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipDestinationRule(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *LoadBalancerSettings_ConsistentHashLB_HTTPCookie) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowDestinationRule
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: HTTPCookie: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: HTTPCookie: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Name = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Path = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 3:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Ttl", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.Ttl == nil {
+				m.Ttl = &types.Duration{}
+			}
+			if err := m.Ttl.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipDestinationRule(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *ConnectionPoolSettings) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowDestinationRule
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: ConnectionPoolSettings: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: ConnectionPoolSettings: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Tcp", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.Tcp == nil {
+				m.Tcp = &ConnectionPoolSettings_TCPSettings{}
+			}
+			if err := m.Tcp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Http", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.Http == nil {
+				m.Http = &ConnectionPoolSettings_HTTPSettings{}
+			}
+			if err := m.Http.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipDestinationRule(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *ConnectionPoolSettings_TCPSettings) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowDestinationRule
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: TCPSettings: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: TCPSettings: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field MaxConnections", wireType)
+			}
+			m.MaxConnections = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.MaxConnections |= int32(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field ConnectTimeout", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.ConnectTimeout == nil {
+				m.ConnectTimeout = &types.Duration{}
+			}
+			if err := m.ConnectTimeout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 3:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field TcpKeepalive", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.TcpKeepalive == nil {
+				m.TcpKeepalive = &ConnectionPoolSettings_TCPSettings_TcpKeepalive{}
+			}
+			if err := m.TcpKeepalive.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipDestinationRule(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
+			iNdEx += skippy
+		}
+	}
 
-func (m *LocalityLoadBalancerSetting_Distribute) Size() (n int) {
-	if m == nil {
-		return 0
-	}
-	var l int
-	_ = l
-	l = len(m.From)
-	if l > 0 {
-		n += 1 + l + sovDestinationRule(uint64(l))
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
 	}
-	if len(m.To) > 0 {
-		for k, v := range m.To {
-			_ = k
-			_ = v
-			mapEntrySize := 1 + len(k) + sovDestinationRule(uint64(len(k))) + 1 + sovDestinationRule(uint64(v))
-			n += mapEntrySize + 1 + sovDestinationRule(uint64(mapEntrySize))
+	return nil
+}
+func (m *ConnectionPoolSettings_TCPSettings_TcpKeepalive) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowDestinationRule
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: TcpKeepalive: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: TcpKeepalive: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Probes", wireType)
+			}
+			m.Probes = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.Probes |= uint32(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.Time == nil {
+				m.Time = &types.Duration{}
+			}
+			if err := m.Time.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 3:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.Interval == nil {
+				m.Interval = &types.Duration{}
+			}
+			if err := m.Interval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipDestinationRule(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
+			iNdEx += skippy
 		}
 	}
-	if m.XXX_unrecognized != nil {
-		n += len(m.XXX_unrecognized)
-	}
-	return n
-}
 
-func (m *LocalityLoadBalancerSetting_Failover) Size() (n int) {
-	if m == nil {
-		return 0
-	}
-	var l int
-	_ = l
-	l = len(m.From)
-	if l > 0 {
-		n += 1 + l + sovDestinationRule(uint64(l))
-	}
-	l = len(m.To)
-	if l > 0 {
-		n += 1 + l + sovDestinationRule(uint64(l))
-	}
-	if m.XXX_unrecognized != nil {
-		n += len(m.XXX_unrecognized)
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
 	}
-	return n
-}
-
-func sovDestinationRule(x uint64) (n int) {
-	return (math_bits.Len64(x|1) + 6) / 7
-}
-func sozDestinationRule(x uint64) (n int) {
-	return sovDestinationRule(uint64((x << 1) ^ uint64((int64(x) >> 63))))
+	return nil
 }
-func (m *DestinationRule) Unmarshal(dAtA []byte) error {
+func (m *ConnectionPoolSettings_HTTPSettings) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
 	for iNdEx < l {
@@ -4136,17 +8139,74 @@ func (m *DestinationRule) Unmarshal(dAtA []byte) error {
 		fieldNum := int32(wire >> 3)
 		wireType := int(wire & 0x7)
 		if wireType == 4 {
-			return fmt.Errorf("proto: DestinationRule: wiretype end group for non-group")
+			return fmt.Errorf("proto: HTTPSettings: wiretype end group for non-group")
 		}
 		if fieldNum <= 0 {
-			return fmt.Errorf("proto: DestinationRule: illegal tag %d (wire type %d)", fieldNum, wire)
+			return fmt.Errorf("proto: HTTPSettings: illegal tag %d (wire type %d)", fieldNum, wire)
 		}
 		switch fieldNum {
 		case 1:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Http1MaxPendingRequests", wireType)
+			}
+			m.Http1MaxPendingRequests = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.Http1MaxPendingRequests |= int32(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		case 2:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Http2MaxRequests", wireType)
+			}
+			m.Http2MaxRequests = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.Http2MaxRequests |= int32(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		case 3:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field MaxRequestsPerConnection", wireType)
+			}
+			m.MaxRequestsPerConnection = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.MaxRequestsPerConnection |= int32(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		case 4:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field MaxRetries", wireType)
 			}
-			var stringLen uint64
+			m.MaxRetries = 0
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowDestinationRule
@@ -4156,27 +8216,14 @@ func (m *DestinationRule) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				stringLen |= uint64(b&0x7F) << shift
+				m.MaxRetries |= int32(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			intStringLen := int(stringLen)
-			if intStringLen < 0 {
-				return ErrInvalidLengthDestinationRule
-			}
-			postIndex := iNdEx + intStringLen
-			if postIndex < 0 {
-				return ErrInvalidLengthDestinationRule
-			}
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			m.Host = string(dAtA[iNdEx:postIndex])
-			iNdEx = postIndex
-		case 2:
+		case 5:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field TrafficPolicy", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field IdleTimeout", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -4203,18 +8250,18 @@ func (m *DestinationRule) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.TrafficPolicy == nil {
-				m.TrafficPolicy = &TrafficPolicy{}
+			if m.IdleTimeout == nil {
+				m.IdleTimeout = &types.Duration{}
 			}
-			if err := m.TrafficPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+			if err := m.IdleTimeout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
 			iNdEx = postIndex
-		case 3:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Subsets", wireType)
+		case 6:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field H2UpgradePolicy", wireType)
 			}
-			var msglen int
+			m.H2UpgradePolicy = 0
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowDestinationRule
@@ -4224,31 +8271,16 @@ func (m *DestinationRule) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				msglen |= int(b&0x7F) << shift
+				m.H2UpgradePolicy |= ConnectionPoolSettings_HTTPSettings_H2UpgradePolicy(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			if msglen < 0 {
-				return ErrInvalidLengthDestinationRule
-			}
-			postIndex := iNdEx + msglen
-			if postIndex < 0 {
-				return ErrInvalidLengthDestinationRule
-			}
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			m.Subsets = append(m.Subsets, &Subset{})
-			if err := m.Subsets[len(m.Subsets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
-			iNdEx = postIndex
-		case 4:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field ExportTo", wireType)
+		case 7:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field UseClientProtocol", wireType)
 			}
-			var stringLen uint64
+			var v int
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowDestinationRule
@@ -4258,24 +8290,12 @@ func (m *DestinationRule) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				stringLen |= uint64(b&0x7F) << shift
+				v |= int(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			intStringLen := int(stringLen)
-			if intStringLen < 0 {
-				return ErrInvalidLengthDestinationRule
-			}
-			postIndex := iNdEx + intStringLen
-			if postIndex < 0 {
-				return ErrInvalidLengthDestinationRule
-			}
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			m.ExportTo = append(m.ExportTo, string(dAtA[iNdEx:postIndex]))
-			iNdEx = postIndex
+			m.UseClientProtocol = bool(v != 0)
 		default:
 			iNdEx = preIndex
 			skippy, err := skipDestinationRule(dAtA[iNdEx:])
@@ -4298,7 +8318,7 @@ func (m *DestinationRule) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
-func (m *TrafficPolicy) Unmarshal(dAtA []byte) error {
+func (m *OutlierDetection) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
 	for iNdEx < l {
@@ -4321,15 +8341,34 @@ func (m *TrafficPolicy) Unmarshal(dAtA []byte) error {
 		fieldNum := int32(wire >> 3)
 		wireType := int(wire & 0x7)
 		if wireType == 4 {
-			return fmt.Errorf("proto: TrafficPolicy: wiretype end group for non-group")
+			return fmt.Errorf("proto: OutlierDetection: wiretype end group for non-group")
 		}
 		if fieldNum <= 0 {
-			return fmt.Errorf("proto: TrafficPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
+			return fmt.Errorf("proto: OutlierDetection: illegal tag %d (wire type %d)", fieldNum, wire)
 		}
 		switch fieldNum {
 		case 1:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field ConsecutiveErrors", wireType)
+			}
+			m.ConsecutiveErrors = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.ConsecutiveErrors |= int32(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		case 2:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field LoadBalancer", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -4356,16 +8395,16 @@ func (m *TrafficPolicy) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.LoadBalancer == nil {
-				m.LoadBalancer = &LoadBalancerSettings{}
+			if m.Interval == nil {
+				m.Interval = &types.Duration{}
 			}
-			if err := m.LoadBalancer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+			if err := m.Interval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
 			iNdEx = postIndex
-		case 2:
+		case 3:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionPool", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field BaseEjectionTime", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -4392,16 +8431,54 @@ func (m *TrafficPolicy) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.ConnectionPool == nil {
-				m.ConnectionPool = &ConnectionPoolSettings{}
+			if m.BaseEjectionTime == nil {
+				m.BaseEjectionTime = &types.Duration{}
 			}
-			if err := m.ConnectionPool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+			if err := m.BaseEjectionTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
 			iNdEx = postIndex
-		case 3:
+		case 4:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field MaxEjectionPercent", wireType)
+			}
+			m.MaxEjectionPercent = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.MaxEjectionPercent |= int32(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		case 5:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field MinHealthPercent", wireType)
+			}
+			m.MinHealthPercent = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.MinHealthPercent |= int32(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		case 6:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field OutlierDetection", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field ConsecutiveGatewayErrors", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -4428,16 +8505,16 @@ func (m *TrafficPolicy) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.OutlierDetection == nil {
-				m.OutlierDetection = &OutlierDetection{}
+			if m.ConsecutiveGatewayErrors == nil {
+				m.ConsecutiveGatewayErrors = &types.UInt32Value{}
 			}
-			if err := m.OutlierDetection.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+			if err := m.ConsecutiveGatewayErrors.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
 			iNdEx = postIndex
-		case 4:
+		case 7:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Tls", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Consecutive_5XxErrors", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -4464,16 +8541,36 @@ func (m *TrafficPolicy) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.Tls == nil {
-				m.Tls = &ClientTLSSettings{}
+			if m.Consecutive_5XxErrors == nil {
+				m.Consecutive_5XxErrors = &types.UInt32Value{}
 			}
-			if err := m.Tls.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+			if err := m.Consecutive_5XxErrors.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
 			iNdEx = postIndex
-		case 5:
+		case 8:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field SplitExternalLocalOriginErrors", wireType)
+			}
+			var v int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				v |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			m.SplitExternalLocalOriginErrors = bool(v != 0)
+		case 9:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field PortLevelSettings", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field ConsecutiveLocalOriginFailures", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -4500,8 +8597,10 @@ func (m *TrafficPolicy) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.PortLevelSettings = append(m.PortLevelSettings, &TrafficPolicy_PortTrafficPolicy{})
-			if err := m.PortLevelSettings[len(m.PortLevelSettings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+			if m.ConsecutiveLocalOriginFailures == nil {
+				m.ConsecutiveLocalOriginFailures = &types.UInt32Value{}
+			}
+			if err := m.ConsecutiveLocalOriginFailures.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
 			iNdEx = postIndex
@@ -4527,7 +8626,7 @@ func (m *TrafficPolicy) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
-func (m *TrafficPolicy_PortTrafficPolicy) Unmarshal(dAtA []byte) error {
+func (m *ClientTLSSettings) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
 	for iNdEx < l {
@@ -4550,53 +8649,17 @@ func (m *TrafficPolicy_PortTrafficPolicy) Unmarshal(dAtA []byte) error {
 		fieldNum := int32(wire >> 3)
 		wireType := int(wire & 0x7)
 		if wireType == 4 {
-			return fmt.Errorf("proto: PortTrafficPolicy: wiretype end group for non-group")
-		}
-		if fieldNum <= 0 {
-			return fmt.Errorf("proto: PortTrafficPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
+			return fmt.Errorf("proto: ClientTLSSettings: wiretype end group for non-group")
 		}
-		switch fieldNum {
-		case 1:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
-			}
-			var msglen int
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowDestinationRule
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				msglen |= int(b&0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-			if msglen < 0 {
-				return ErrInvalidLengthDestinationRule
-			}
-			postIndex := iNdEx + msglen
-			if postIndex < 0 {
-				return ErrInvalidLengthDestinationRule
-			}
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			if m.Port == nil {
-				m.Port = &PortSelector{}
-			}
-			if err := m.Port.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
-			iNdEx = postIndex
-		case 2:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field LoadBalancer", wireType)
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: ClientTLSSettings: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
 			}
-			var msglen int
+			m.Mode = 0
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowDestinationRule
@@ -4606,33 +8669,16 @@ func (m *TrafficPolicy_PortTrafficPolicy) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				msglen |= int(b&0x7F) << shift
+				m.Mode |= ClientTLSSettings_TLSmode(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			if msglen < 0 {
-				return ErrInvalidLengthDestinationRule
-			}
-			postIndex := iNdEx + msglen
-			if postIndex < 0 {
-				return ErrInvalidLengthDestinationRule
-			}
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			if m.LoadBalancer == nil {
-				m.LoadBalancer = &LoadBalancerSettings{}
-			}
-			if err := m.LoadBalancer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
-			iNdEx = postIndex
-		case 3:
+		case 2:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionPool", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field ClientCertificate", wireType)
 			}
-			var msglen int
+			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowDestinationRule
@@ -4642,33 +8688,29 @@ func (m *TrafficPolicy_PortTrafficPolicy) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				msglen |= int(b&0x7F) << shift
+				stringLen |= uint64(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			if msglen < 0 {
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
 				return ErrInvalidLengthDestinationRule
 			}
-			postIndex := iNdEx + msglen
+			postIndex := iNdEx + intStringLen
 			if postIndex < 0 {
 				return ErrInvalidLengthDestinationRule
 			}
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.ConnectionPool == nil {
-				m.ConnectionPool = &ConnectionPoolSettings{}
-			}
-			if err := m.ConnectionPool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
+			m.ClientCertificate = string(dAtA[iNdEx:postIndex])
 			iNdEx = postIndex
-		case 4:
+		case 3:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field OutlierDetection", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field PrivateKey", wireType)
 			}
-			var msglen int
+			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowDestinationRule
@@ -4678,33 +8720,29 @@ func (m *TrafficPolicy_PortTrafficPolicy) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				msglen |= int(b&0x7F) << shift
+				stringLen |= uint64(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			if msglen < 0 {
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
 				return ErrInvalidLengthDestinationRule
 			}
-			postIndex := iNdEx + msglen
+			postIndex := iNdEx + intStringLen
 			if postIndex < 0 {
 				return ErrInvalidLengthDestinationRule
 			}
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.OutlierDetection == nil {
-				m.OutlierDetection = &OutlierDetection{}
-			}
-			if err := m.OutlierDetection.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
+			m.PrivateKey = string(dAtA[iNdEx:postIndex])
 			iNdEx = postIndex
-		case 5:
+		case 4:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Tls", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field CaCertificates", wireType)
 			}
-			var msglen int
+			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowDestinationRule
@@ -4714,82 +8752,27 @@ func (m *TrafficPolicy_PortTrafficPolicy) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				msglen |= int(b&0x7F) << shift
+				stringLen |= uint64(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			if msglen < 0 {
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
 				return ErrInvalidLengthDestinationRule
 			}
-			postIndex := iNdEx + msglen
+			postIndex := iNdEx + intStringLen
 			if postIndex < 0 {
 				return ErrInvalidLengthDestinationRule
 			}
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.Tls == nil {
-				m.Tls = &ClientTLSSettings{}
-			}
-			if err := m.Tls.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
+			m.CaCertificates = string(dAtA[iNdEx:postIndex])
 			iNdEx = postIndex
-		default:
-			iNdEx = preIndex
-			skippy, err := skipDestinationRule(dAtA[iNdEx:])
-			if err != nil {
-				return err
-			}
-			if (skippy < 0) || (iNdEx+skippy) < 0 {
-				return ErrInvalidLengthDestinationRule
-			}
-			if (iNdEx + skippy) > l {
-				return io.ErrUnexpectedEOF
-			}
-			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
-			iNdEx += skippy
-		}
-	}
-
-	if iNdEx > l {
-		return io.ErrUnexpectedEOF
-	}
-	return nil
-}
-func (m *Subset) Unmarshal(dAtA []byte) error {
-	l := len(dAtA)
-	iNdEx := 0
-	for iNdEx < l {
-		preIndex := iNdEx
-		var wire uint64
-		for shift := uint(0); ; shift += 7 {
-			if shift >= 64 {
-				return ErrIntOverflowDestinationRule
-			}
-			if iNdEx >= l {
-				return io.ErrUnexpectedEOF
-			}
-			b := dAtA[iNdEx]
-			iNdEx++
-			wire |= uint64(b&0x7F) << shift
-			if b < 0x80 {
-				break
-			}
-		}
-		fieldNum := int32(wire >> 3)
-		wireType := int(wire & 0x7)
-		if wireType == 4 {
-			return fmt.Errorf("proto: Subset: wiretype end group for non-group")
-		}
-		if fieldNum <= 0 {
-			return fmt.Errorf("proto: Subset: illegal tag %d (wire type %d)", fieldNum, wire)
-		}
-		switch fieldNum {
-		case 1:
+		case 5:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field SubjectAltNames", wireType)
 			}
 			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
@@ -4817,13 +8800,13 @@ func (m *Subset) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.Name = string(dAtA[iNdEx:postIndex])
+			m.SubjectAltNames = append(m.SubjectAltNames, string(dAtA[iNdEx:postIndex]))
 			iNdEx = postIndex
-		case 2:
+		case 6:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Sni", wireType)
 			}
-			var msglen int
+			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowDestinationRule
@@ -4833,122 +8816,59 @@ func (m *Subset) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				msglen |= int(b&0x7F) << shift
+				stringLen |= uint64(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			if msglen < 0 {
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
 				return ErrInvalidLengthDestinationRule
 			}
-			postIndex := iNdEx + msglen
+			postIndex := iNdEx + intStringLen
 			if postIndex < 0 {
 				return ErrInvalidLengthDestinationRule
 			}
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.Labels == nil {
-				m.Labels = make(map[string]string)
+			m.Sni = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 7:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field CredentialName", wireType)
 			}
-			var mapkey string
-			var mapvalue string
-			for iNdEx < postIndex {
-				entryPreIndex := iNdEx
-				var wire uint64
-				for shift := uint(0); ; shift += 7 {
-					if shift >= 64 {
-						return ErrIntOverflowDestinationRule
-					}
-					if iNdEx >= l {
-						return io.ErrUnexpectedEOF
-					}
-					b := dAtA[iNdEx]
-					iNdEx++
-					wire |= uint64(b&0x7F) << shift
-					if b < 0x80 {
-						break
-					}
-				}
-				fieldNum := int32(wire >> 3)
-				if fieldNum == 1 {
-					var stringLenmapkey uint64
-					for shift := uint(0); ; shift += 7 {
-						if shift >= 64 {
-							return ErrIntOverflowDestinationRule
-						}
-						if iNdEx >= l {
-							return io.ErrUnexpectedEOF
-						}
-						b := dAtA[iNdEx]
-						iNdEx++
-						stringLenmapkey |= uint64(b&0x7F) << shift
-						if b < 0x80 {
-							break
-						}
-					}
-					intStringLenmapkey := int(stringLenmapkey)
-					if intStringLenmapkey < 0 {
-						return ErrInvalidLengthDestinationRule
-					}
-					postStringIndexmapkey := iNdEx + intStringLenmapkey
-					if postStringIndexmapkey < 0 {
-						return ErrInvalidLengthDestinationRule
-					}
-					if postStringIndexmapkey > l {
-						return io.ErrUnexpectedEOF
-					}
-					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
-					iNdEx = postStringIndexmapkey
-				} else if fieldNum == 2 {
-					var stringLenmapvalue uint64
-					for shift := uint(0); ; shift += 7 {
-						if shift >= 64 {
-							return ErrIntOverflowDestinationRule
-						}
-						if iNdEx >= l {
-							return io.ErrUnexpectedEOF
-						}
-						b := dAtA[iNdEx]
-						iNdEx++
-						stringLenmapvalue |= uint64(b&0x7F) << shift
-						if b < 0x80 {
-							break
-						}
-					}
-					intStringLenmapvalue := int(stringLenmapvalue)
-					if intStringLenmapvalue < 0 {
-						return ErrInvalidLengthDestinationRule
-					}
-					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
-					if postStringIndexmapvalue < 0 {
-						return ErrInvalidLengthDestinationRule
-					}
-					if postStringIndexmapvalue > l {
-						return io.ErrUnexpectedEOF
-					}
-					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
-					iNdEx = postStringIndexmapvalue
-				} else {
-					iNdEx = entryPreIndex
-					skippy, err := skipDestinationRule(dAtA[iNdEx:])
-					if err != nil {
-						return err
-					}
-					if (skippy < 0) || (iNdEx+skippy) < 0 {
-						return ErrInvalidLengthDestinationRule
-					}
-					if (iNdEx + skippy) > postIndex {
-						return io.ErrUnexpectedEOF
-					}
-					iNdEx += skippy
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
 				}
 			}
-			m.Labels[mapkey] = mapvalue
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.CredentialName = string(dAtA[iNdEx:postIndex])
 			iNdEx = postIndex
-		case 3:
+		case 8:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field TrafficPolicy", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field InsecureSkipVerify", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -4975,10 +8895,10 @@ func (m *Subset) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.TrafficPolicy == nil {
-				m.TrafficPolicy = &TrafficPolicy{}
+			if m.InsecureSkipVerify == nil {
+				m.InsecureSkipVerify = &types.BoolValue{}
 			}
-			if err := m.TrafficPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+			if err := m.InsecureSkipVerify.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
 			iNdEx = postIndex
@@ -5004,7 +8924,7 @@ func (m *Subset) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
-func (m *LoadBalancerSettings) Unmarshal(dAtA []byte) error {
+func (m *LocalityLoadBalancerSetting) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
 	for iNdEx < l {
@@ -5027,17 +8947,17 @@ func (m *LoadBalancerSettings) Unmarshal(dAtA []byte) error {
 		fieldNum := int32(wire >> 3)
 		wireType := int(wire & 0x7)
 		if wireType == 4 {
-			return fmt.Errorf("proto: LoadBalancerSettings: wiretype end group for non-group")
+			return fmt.Errorf("proto: LocalityLoadBalancerSetting: wiretype end group for non-group")
 		}
 		if fieldNum <= 0 {
-			return fmt.Errorf("proto: LoadBalancerSettings: illegal tag %d (wire type %d)", fieldNum, wire)
+			return fmt.Errorf("proto: LocalityLoadBalancerSetting: illegal tag %d (wire type %d)", fieldNum, wire)
 		}
 		switch fieldNum {
 		case 1:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Simple", wireType)
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Distribute", wireType)
 			}
-			var v LoadBalancerSettings_SimpleLB
+			var msglen int
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowDestinationRule
@@ -5047,15 +8967,29 @@ func (m *LoadBalancerSettings) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				v |= LoadBalancerSettings_SimpleLB(b&0x7F) << shift
+				msglen |= int(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			m.LbPolicy = &LoadBalancerSettings_Simple{v}
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Distribute = append(m.Distribute, &LocalityLoadBalancerSetting_Distribute{})
+			if err := m.Distribute[len(m.Distribute)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
 		case 2:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field ConsistentHash", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Failover", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -5082,15 +9016,14 @@ func (m *LoadBalancerSettings) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			v := &LoadBalancerSettings_ConsistentHashLB{}
-			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+			m.Failover = append(m.Failover, &LocalityLoadBalancerSetting_Failover{})
+			if err := m.Failover[len(m.Failover)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
-			m.LbPolicy = &LoadBalancerSettings_ConsistentHash{v}
 			iNdEx = postIndex
 		case 3:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field LocalityLbSetting", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -5117,13 +9050,45 @@ func (m *LoadBalancerSettings) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.LocalityLbSetting == nil {
-				m.LocalityLbSetting = &LocalityLoadBalancerSetting{}
+			if m.Enabled == nil {
+				m.Enabled = &types.BoolValue{}
 			}
-			if err := m.LocalityLbSetting.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+			if err := m.Enabled.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
 			iNdEx = postIndex
+		case 4:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field FailoverPriority", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowDestinationRule
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.FailoverPriority = append(m.FailoverPriority, string(dAtA[iNdEx:postIndex]))
+			iNdEx = postIndex
 		default:
 			iNdEx = preIndex
 			skippy, err := skipDestinationRule(dAtA[iNdEx:])
@@ -5146,7 +9111,7 @@ func (m *LoadBalancerSettings) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
-func (m *LoadBalancerSettings_ConsistentHashLB) Unmarshal(dAtA []byte) error {
+func (m *LocalityLoadBalancerSetting_Distribute) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
 	for iNdEx < l {
@@ -5169,15 +9134,15 @@ func (m *LoadBalancerSettings_ConsistentHashLB) Unmarshal(dAtA []byte) error {
 		fieldNum := int32(wire >> 3)
 		wireType := int(wire & 0x7)
 		if wireType == 4 {
-			return fmt.Errorf("proto: ConsistentHashLB: wiretype end group for non-group")
+			return fmt.Errorf("proto: Distribute: wiretype end group for non-group")
 		}
 		if fieldNum <= 0 {
-			return fmt.Errorf("proto: ConsistentHashLB: illegal tag %d (wire type %d)", fieldNum, wire)
+			return fmt.Errorf("proto: Distribute: illegal tag %d (wire type %d)", fieldNum, wire)
 		}
 		switch fieldNum {
 		case 1:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field HttpHeaderName", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
 			}
 			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
@@ -5205,11 +9170,11 @@ func (m *LoadBalancerSettings_ConsistentHashLB) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.HashKey = &LoadBalancerSettings_ConsistentHashLB_HttpHeaderName{string(dAtA[iNdEx:postIndex])}
+			m.From = string(dAtA[iNdEx:postIndex])
 			iNdEx = postIndex
 		case 2:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field HttpCookie", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -5236,17 +9201,146 @@ func (m *LoadBalancerSettings_ConsistentHashLB) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			v := &LoadBalancerSettings_ConsistentHashLB_HTTPCookie{}
-			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
+			if m.To == nil {
+				m.To = make(map[string]uint32)
 			}
-			m.HashKey = &LoadBalancerSettings_ConsistentHashLB_HttpCookie{v}
+			var mapkey string
+			var mapvalue uint32
+			for iNdEx < postIndex {
+				entryPreIndex := iNdEx
+				var wire uint64
+				for shift := uint(0); ; shift += 7 {
+					if shift >= 64 {
+						return ErrIntOverflowDestinationRule
+					}
+					if iNdEx >= l {
+						return io.ErrUnexpectedEOF
+					}
+					b := dAtA[iNdEx]
+					iNdEx++
+					wire |= uint64(b&0x7F) << shift
+					if b < 0x80 {
+						break
+					}
+				}
+				fieldNum := int32(wire >> 3)
+				if fieldNum == 1 {
+					var stringLenmapkey uint64
+					for shift := uint(0); ; shift += 7 {
+						if shift >= 64 {
+							return ErrIntOverflowDestinationRule
+						}
+						if iNdEx >= l {
+							return io.ErrUnexpectedEOF
+						}
+						b := dAtA[iNdEx]
+						iNdEx++
+						stringLenmapkey |= uint64(b&0x7F) << shift
+						if b < 0x80 {
+							break
+						}
+					}
+					intStringLenmapkey := int(stringLenmapkey)
+					if intStringLenmapkey < 0 {
+						return ErrInvalidLengthDestinationRule
+					}
+					postStringIndexmapkey := iNdEx + intStringLenmapkey
+					if postStringIndexmapkey < 0 {
+						return ErrInvalidLengthDestinationRule
+					}
+					if postStringIndexmapkey > l {
+						return io.ErrUnexpectedEOF
+					}
+					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
+					iNdEx = postStringIndexmapkey
+				} else if fieldNum == 2 {
+					for shift := uint(0); ; shift += 7 {
+						if shift >= 64 {
+							return ErrIntOverflowDestinationRule
+						}
+						if iNdEx >= l {
+							return io.ErrUnexpectedEOF
+						}
+						b := dAtA[iNdEx]
+						iNdEx++
+						mapvalue |= uint32(b&0x7F) << shift
+						if b < 0x80 {
+							break
+						}
+					}
+				} else {
+					iNdEx = entryPreIndex
+					skippy, err := skipDestinationRule(dAtA[iNdEx:])
+					if err != nil {
+						return err
+					}
+					if (skippy < 0) || (iNdEx+skippy) < 0 {
+						return ErrInvalidLengthDestinationRule
+					}
+					if (iNdEx + skippy) > postIndex {
+						return io.ErrUnexpectedEOF
+					}
+					iNdEx += skippy
+				}
+			}
+			m.To[mapkey] = mapvalue
 			iNdEx = postIndex
-		case 3:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field UseSourceIp", wireType)
+		default:
+			iNdEx = preIndex
+			skippy, err := skipDestinationRule(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *LocalityLoadBalancerSetting_Failover) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowDestinationRule
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: Failover: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: Failover: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
 			}
-			var v int
+			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowDestinationRule
@@ -5256,35 +9350,27 @@ func (m *LoadBalancerSettings_ConsistentHashLB) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				v |= int(b&0x7F) << shift
+				stringLen |= uint64(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			b := bool(v != 0)
-			m.HashKey = &LoadBalancerSettings_ConsistentHashLB_UseSourceIp{b}
-		case 4:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field MinimumRingSize", wireType)
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthDestinationRule
 			}
-			m.MinimumRingSize = 0
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowDestinationRule
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				m.MinimumRingSize |= uint64(b&0x7F) << shift
-				if b < 0x80 {
-					break
-				}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
 			}
-		case 5:
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.From = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 2:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field HttpQueryParameterName", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
 			}
 			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
@@ -5312,7 +9398,7 @@ func (m *LoadBalancerSettings_ConsistentHashLB) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.HashKey = &LoadBalancerSettings_ConsistentHashLB_HttpQueryParameterName{string(dAtA[iNdEx:postIndex])}
+			m.To = string(dAtA[iNdEx:postIndex])
 			iNdEx = postIndex
 		default:
 			iNdEx = preIndex
@@ -5336,7 +9422,7 @@ func (m *LoadBalancerSettings_ConsistentHashLB) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
-func (m *LoadBalancerSettings_ConsistentHashLB_HTTPCookie) Unmarshal(dAtA []byte) error {
+func (m *Int64Range) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
 	for iNdEx < l {
@@ -5359,17 +9445,17 @@ func (m *LoadBalancerSettings_ConsistentHashLB_HTTPCookie) Unmarshal(dAtA []byte
 		fieldNum := int32(wire >> 3)
 		wireType := int(wire & 0x7)
 		if wireType == 4 {
-			return fmt.Errorf("proto: HTTPCookie: wiretype end group for non-group")
+			return fmt.Errorf("proto: Int64Range: wiretype end group for non-group")
 		}
 		if fieldNum <= 0 {
-			return fmt.Errorf("proto: HTTPCookie: illegal tag %d (wire type %d)", fieldNum, wire)
+			return fmt.Errorf("proto: Int64Range: illegal tag %d (wire type %d)", fieldNum, wire)
 		}
 		switch fieldNum {
 		case 1:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
 			}
-			var stringLen uint64
+			m.Start = 0
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowDestinationRule
@@ -5379,29 +9465,16 @@ func (m *LoadBalancerSettings_ConsistentHashLB_HTTPCookie) Unmarshal(dAtA []byte
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				stringLen |= uint64(b&0x7F) << shift
+				m.Start |= int64(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			intStringLen := int(stringLen)
-			if intStringLen < 0 {
-				return ErrInvalidLengthDestinationRule
-			}
-			postIndex := iNdEx + intStringLen
-			if postIndex < 0 {
-				return ErrInvalidLengthDestinationRule
-			}
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			m.Name = string(dAtA[iNdEx:postIndex])
-			iNdEx = postIndex
 		case 2:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
 			}
-			var stringLen uint64
+			m.End = 0
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowDestinationRule
@@ -5411,60 +9484,131 @@ func (m *LoadBalancerSettings_ConsistentHashLB_HTTPCookie) Unmarshal(dAtA []byte
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				stringLen |= uint64(b&0x7F) << shift
+				m.End |= int64(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			intStringLen := int(stringLen)
-			if intStringLen < 0 {
-				return ErrInvalidLengthDestinationRule
+		default:
+			iNdEx = preIndex
+			skippy, err := skipDestinationRule(dAtA[iNdEx:])
+			if err != nil {
+				return err
 			}
-			postIndex := iNdEx + intStringLen
-			if postIndex < 0 {
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
 				return ErrInvalidLengthDestinationRule
 			}
-			if postIndex > l {
+			if (iNdEx + skippy) > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.Path = string(dAtA[iNdEx:postIndex])
-			iNdEx = postIndex
-		case 3:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Ttl", wireType)
+			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *HealthStatusSet) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowDestinationRule
 			}
-			var msglen int
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowDestinationRule
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: HealthStatusSet: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: HealthStatusSet: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType == 0 {
+				var v HealthStatus
+				for shift := uint(0); ; shift += 7 {
+					if shift >= 64 {
+						return ErrIntOverflowDestinationRule
+					}
+					if iNdEx >= l {
+						return io.ErrUnexpectedEOF
+					}
+					b := dAtA[iNdEx]
+					iNdEx++
+					v |= HealthStatus(b&0x7F) << shift
+					if b < 0x80 {
+						break
+					}
 				}
-				if iNdEx >= l {
+				m.Statuses = append(m.Statuses, v)
+			} else if wireType == 2 {
+				var packedLen int
+				for shift := uint(0); ; shift += 7 {
+					if shift >= 64 {
+						return ErrIntOverflowDestinationRule
+					}
+					if iNdEx >= l {
+						return io.ErrUnexpectedEOF
+					}
+					b := dAtA[iNdEx]
+					iNdEx++
+					packedLen |= int(b&0x7F) << shift
+					if b < 0x80 {
+						break
+					}
+				}
+				if packedLen < 0 {
+					return ErrInvalidLengthDestinationRule
+				}
+				postIndex := iNdEx + packedLen
+				if postIndex < 0 {
+					return ErrInvalidLengthDestinationRule
+				}
+				if postIndex > l {
 					return io.ErrUnexpectedEOF
 				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				msglen |= int(b&0x7F) << shift
-				if b < 0x80 {
-					break
+				var elementCount int
+				if elementCount != 0 && len(m.Statuses) == 0 {
+					m.Statuses = make([]HealthStatus, 0, elementCount)
 				}
+				for iNdEx < postIndex {
+					var v HealthStatus
+					for shift := uint(0); ; shift += 7 {
+						if shift >= 64 {
+							return ErrIntOverflowDestinationRule
+						}
+						if iNdEx >= l {
+							return io.ErrUnexpectedEOF
+						}
+						b := dAtA[iNdEx]
+						iNdEx++
+						v |= HealthStatus(b&0x7F) << shift
+						if b < 0x80 {
+							break
+						}
+					}
+					m.Statuses = append(m.Statuses, v)
+				}
+			} else {
+				return fmt.Errorf("proto: wrong wireType = %d for field Statuses", wireType)
 			}
-			if msglen < 0 {
-				return ErrInvalidLengthDestinationRule
-			}
-			postIndex := iNdEx + msglen
-			if postIndex < 0 {
-				return ErrInvalidLengthDestinationRule
-			}
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			if m.Ttl == nil {
-				m.Ttl = &types.Duration{}
-			}
-			if err := m.Ttl.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
-			iNdEx = postIndex
 		default:
 			iNdEx = preIndex
 			skippy, err := skipDestinationRule(dAtA[iNdEx:])
@@ -5487,7 +9631,7 @@ func (m *LoadBalancerSettings_ConsistentHashLB_HTTPCookie) Unmarshal(dAtA []byte
 	}
 	return nil
 }
-func (m *ConnectionPoolSettings) Unmarshal(dAtA []byte) error {
+func (m *Payload) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
 	for iNdEx < l {
@@ -5510,17 +9654,17 @@ func (m *ConnectionPoolSettings) Unmarshal(dAtA []byte) error {
 		fieldNum := int32(wire >> 3)
 		wireType := int(wire & 0x7)
 		if wireType == 4 {
-			return fmt.Errorf("proto: ConnectionPoolSettings: wiretype end group for non-group")
+			return fmt.Errorf("proto: Payload: wiretype end group for non-group")
 		}
 		if fieldNum <= 0 {
-			return fmt.Errorf("proto: ConnectionPoolSettings: illegal tag %d (wire type %d)", fieldNum, wire)
+			return fmt.Errorf("proto: Payload: illegal tag %d (wire type %d)", fieldNum, wire)
 		}
 		switch fieldNum {
 		case 1:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Tcp", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
 			}
-			var msglen int
+			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowDestinationRule
@@ -5530,33 +9674,29 @@ func (m *ConnectionPoolSettings) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				msglen |= int(b&0x7F) << shift
+				stringLen |= uint64(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			if msglen < 0 {
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
 				return ErrInvalidLengthDestinationRule
 			}
-			postIndex := iNdEx + msglen
+			postIndex := iNdEx + intStringLen
 			if postIndex < 0 {
 				return ErrInvalidLengthDestinationRule
 			}
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.Tcp == nil {
-				m.Tcp = &ConnectionPoolSettings_TCPSettings{}
-			}
-			if err := m.Tcp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
+			m.Payload = &Payload_Text{string(dAtA[iNdEx:postIndex])}
 			iNdEx = postIndex
 		case 2:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Http", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Binary", wireType)
 			}
-			var msglen int
+			var byteLen int
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowDestinationRule
@@ -5566,27 +9706,24 @@ func (m *ConnectionPoolSettings) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				msglen |= int(b&0x7F) << shift
+				byteLen |= int(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			if msglen < 0 {
+			if byteLen < 0 {
 				return ErrInvalidLengthDestinationRule
 			}
-			postIndex := iNdEx + msglen
+			postIndex := iNdEx + byteLen
 			if postIndex < 0 {
 				return ErrInvalidLengthDestinationRule
 			}
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.Http == nil {
-				m.Http = &ConnectionPoolSettings_HTTPSettings{}
-			}
-			if err := m.Http.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
+			v := make([]byte, postIndex-iNdEx)
+			copy(v, dAtA[iNdEx:postIndex])
+			m.Payload = &Payload_Binary{v}
 			iNdEx = postIndex
 		default:
 			iNdEx = preIndex
@@ -5610,7 +9747,7 @@ func (m *ConnectionPoolSettings) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
-func (m *ConnectionPoolSettings_TCPSettings) Unmarshal(dAtA []byte) error {
+func (m *HealthCheck) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
 	for iNdEx < l {
@@ -5633,17 +9770,17 @@ func (m *ConnectionPoolSettings_TCPSettings) Unmarshal(dAtA []byte) error {
 		fieldNum := int32(wire >> 3)
 		wireType := int(wire & 0x7)
 		if wireType == 4 {
-			return fmt.Errorf("proto: TCPSettings: wiretype end group for non-group")
+			return fmt.Errorf("proto: HealthCheck: wiretype end group for non-group")
 		}
 		if fieldNum <= 0 {
-			return fmt.Errorf("proto: TCPSettings: illegal tag %d (wire type %d)", fieldNum, wire)
+			return fmt.Errorf("proto: HealthCheck: illegal tag %d (wire type %d)", fieldNum, wire)
 		}
 		switch fieldNum {
 		case 1:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field MaxConnections", wireType)
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
 			}
-			m.MaxConnections = 0
+			var msglen int
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowDestinationRule
@@ -5653,14 +9790,31 @@ func (m *ConnectionPoolSettings_TCPSettings) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				m.MaxConnections |= int32(b&0x7F) << shift
+				msglen |= int(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.Timeout == nil {
+				m.Timeout = &types.Duration{}
+			}
+			if err := m.Timeout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
 		case 2:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field ConnectTimeout", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -5687,16 +9841,16 @@ func (m *ConnectionPoolSettings_TCPSettings) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.ConnectTimeout == nil {
-				m.ConnectTimeout = &types.Duration{}
+			if m.Interval == nil {
+				m.Interval = &types.Duration{}
 			}
-			if err := m.ConnectTimeout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+			if err := m.Interval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
 			iNdEx = postIndex
 		case 3:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field TcpKeepalive", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field IntervalJitter", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -5723,69 +9877,18 @@ func (m *ConnectionPoolSettings_TCPSettings) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.TcpKeepalive == nil {
-				m.TcpKeepalive = &ConnectionPoolSettings_TCPSettings_TcpKeepalive{}
+			if m.IntervalJitter == nil {
+				m.IntervalJitter = &types.Duration{}
 			}
-			if err := m.TcpKeepalive.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+			if err := m.IntervalJitter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
 			iNdEx = postIndex
-		default:
-			iNdEx = preIndex
-			skippy, err := skipDestinationRule(dAtA[iNdEx:])
-			if err != nil {
-				return err
-			}
-			if (skippy < 0) || (iNdEx+skippy) < 0 {
-				return ErrInvalidLengthDestinationRule
-			}
-			if (iNdEx + skippy) > l {
-				return io.ErrUnexpectedEOF
-			}
-			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
-			iNdEx += skippy
-		}
-	}
-
-	if iNdEx > l {
-		return io.ErrUnexpectedEOF
-	}
-	return nil
-}
-func (m *ConnectionPoolSettings_TCPSettings_TcpKeepalive) Unmarshal(dAtA []byte) error {
-	l := len(dAtA)
-	iNdEx := 0
-	for iNdEx < l {
-		preIndex := iNdEx
-		var wire uint64
-		for shift := uint(0); ; shift += 7 {
-			if shift >= 64 {
-				return ErrIntOverflowDestinationRule
-			}
-			if iNdEx >= l {
-				return io.ErrUnexpectedEOF
-			}
-			b := dAtA[iNdEx]
-			iNdEx++
-			wire |= uint64(b&0x7F) << shift
-			if b < 0x80 {
-				break
-			}
-		}
-		fieldNum := int32(wire >> 3)
-		wireType := int(wire & 0x7)
-		if wireType == 4 {
-			return fmt.Errorf("proto: TcpKeepalive: wiretype end group for non-group")
-		}
-		if fieldNum <= 0 {
-			return fmt.Errorf("proto: TcpKeepalive: illegal tag %d (wire type %d)", fieldNum, wire)
-		}
-		switch fieldNum {
-		case 1:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Probes", wireType)
+		case 4:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field UnhealthyThreshold", wireType)
 			}
-			m.Probes = 0
+			var msglen int
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowDestinationRule
@@ -5795,14 +9898,31 @@ func (m *ConnectionPoolSettings_TCPSettings_TcpKeepalive) Unmarshal(dAtA []byte)
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				m.Probes |= uint32(b&0x7F) << shift
+				msglen |= int(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-		case 2:
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.UnhealthyThreshold == nil {
+				m.UnhealthyThreshold = &types.UInt32Value{}
+			}
+			if err := m.UnhealthyThreshold.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 5:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field HealthyThreshold", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -5829,16 +9949,16 @@ func (m *ConnectionPoolSettings_TCPSettings_TcpKeepalive) Unmarshal(dAtA []byte)
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.Time == nil {
-				m.Time = &types.Duration{}
+			if m.HealthyThreshold == nil {
+				m.HealthyThreshold = &types.UInt32Value{}
 			}
-			if err := m.Time.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+			if err := m.HealthyThreshold.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
 			iNdEx = postIndex
-		case 3:
+		case 6:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field AltPort", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -5865,69 +9985,18 @@ func (m *ConnectionPoolSettings_TCPSettings_TcpKeepalive) Unmarshal(dAtA []byte)
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.Interval == nil {
-				m.Interval = &types.Duration{}
+			if m.AltPort == nil {
+				m.AltPort = &types.UInt32Value{}
 			}
-			if err := m.Interval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+			if err := m.AltPort.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
 			iNdEx = postIndex
-		default:
-			iNdEx = preIndex
-			skippy, err := skipDestinationRule(dAtA[iNdEx:])
-			if err != nil {
-				return err
-			}
-			if (skippy < 0) || (iNdEx+skippy) < 0 {
-				return ErrInvalidLengthDestinationRule
-			}
-			if (iNdEx + skippy) > l {
-				return io.ErrUnexpectedEOF
-			}
-			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
-			iNdEx += skippy
-		}
-	}
-
-	if iNdEx > l {
-		return io.ErrUnexpectedEOF
-	}
-	return nil
-}
-func (m *ConnectionPoolSettings_HTTPSettings) Unmarshal(dAtA []byte) error {
-	l := len(dAtA)
-	iNdEx := 0
-	for iNdEx < l {
-		preIndex := iNdEx
-		var wire uint64
-		for shift := uint(0); ; shift += 7 {
-			if shift >= 64 {
-				return ErrIntOverflowDestinationRule
-			}
-			if iNdEx >= l {
-				return io.ErrUnexpectedEOF
-			}
-			b := dAtA[iNdEx]
-			iNdEx++
-			wire |= uint64(b&0x7F) << shift
-			if b < 0x80 {
-				break
-			}
-		}
-		fieldNum := int32(wire >> 3)
-		wireType := int(wire & 0x7)
-		if wireType == 4 {
-			return fmt.Errorf("proto: HTTPSettings: wiretype end group for non-group")
-		}
-		if fieldNum <= 0 {
-			return fmt.Errorf("proto: HTTPSettings: illegal tag %d (wire type %d)", fieldNum, wire)
-		}
-		switch fieldNum {
-		case 1:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Http1MaxPendingRequests", wireType)
+		case 7:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field ReuseConnection", wireType)
 			}
-			m.Http1MaxPendingRequests = 0
+			var msglen int
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowDestinationRule
@@ -5937,16 +10006,33 @@ func (m *ConnectionPoolSettings_HTTPSettings) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				m.Http1MaxPendingRequests |= int32(b&0x7F) << shift
+				msglen |= int(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-		case 2:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Http2MaxRequests", wireType)
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
 			}
-			m.Http2MaxRequests = 0
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.ReuseConnection == nil {
+				m.ReuseConnection = &types.BoolValue{}
+			}
+			if err := m.ReuseConnection.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 8:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field HttpHealthCheck", wireType)
+			}
+			var msglen int
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowDestinationRule
@@ -5956,16 +10042,32 @@ func (m *ConnectionPoolSettings_HTTPSettings) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				m.Http2MaxRequests |= int32(b&0x7F) << shift
+				msglen |= int(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-		case 3:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field MaxRequestsPerConnection", wireType)
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
 			}
-			m.MaxRequestsPerConnection = 0
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			v := &HealthCheck_HttpHealthCheck{}
+			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			m.HealthChecker = &HealthCheck_HttpHealthCheck_{v}
+			iNdEx = postIndex
+		case 9:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field TcpHealthCheck", wireType)
+			}
+			var msglen int
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowDestinationRule
@@ -5975,16 +10077,32 @@ func (m *ConnectionPoolSettings_HTTPSettings) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				m.MaxRequestsPerConnection |= int32(b&0x7F) << shift
+				msglen |= int(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-		case 4:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field MaxRetries", wireType)
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
 			}
-			m.MaxRetries = 0
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			v := &HealthCheck_TcpHealthCheck{}
+			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			m.HealthChecker = &HealthCheck_TcpHealthCheck_{v}
+			iNdEx = postIndex
+		case 11:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field GrpcHealthCheck", wireType)
+			}
+			var msglen int
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowDestinationRule
@@ -5994,14 +10112,30 @@ func (m *ConnectionPoolSettings_HTTPSettings) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				m.MaxRetries |= int32(b&0x7F) << shift
+				msglen |= int(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-		case 5:
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			v := &HealthCheck_GrpcHealthCheck{}
+			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			m.HealthChecker = &HealthCheck_GrpcHealthCheck_{v}
+			iNdEx = postIndex
+		case 12:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field IdleTimeout", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field NoTrafficInterval", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -6028,18 +10162,18 @@ func (m *ConnectionPoolSettings_HTTPSettings) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.IdleTimeout == nil {
-				m.IdleTimeout = &types.Duration{}
+			if m.NoTrafficInterval == nil {
+				m.NoTrafficInterval = &types.Duration{}
 			}
-			if err := m.IdleTimeout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+			if err := m.NoTrafficInterval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
 			iNdEx = postIndex
-		case 6:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field H2UpgradePolicy", wireType)
+		case 13:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field CustomHealthCheck", wireType)
 			}
-			m.H2UpgradePolicy = 0
+			var msglen int
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowDestinationRule
@@ -6049,16 +10183,32 @@ func (m *ConnectionPoolSettings_HTTPSettings) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				m.H2UpgradePolicy |= ConnectionPoolSettings_HTTPSettings_H2UpgradePolicy(b&0x7F) << shift
+				msglen |= int(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-		case 7:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field UseClientProtocol", wireType)
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
 			}
-			var v int
+			v := &HealthCheck_CustomHealthCheck{}
+			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			m.HealthChecker = &HealthCheck_CustomHealthCheck_{v}
+			iNdEx = postIndex
+		case 14:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field UnhealthyInterval", wireType)
+			}
+			var msglen int
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowDestinationRule
@@ -6068,68 +10218,33 @@ func (m *ConnectionPoolSettings_HTTPSettings) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				v |= int(b&0x7F) << shift
+				msglen |= int(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			m.UseClientProtocol = bool(v != 0)
-		default:
-			iNdEx = preIndex
-			skippy, err := skipDestinationRule(dAtA[iNdEx:])
-			if err != nil {
-				return err
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
 			}
-			if (skippy < 0) || (iNdEx+skippy) < 0 {
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
 				return ErrInvalidLengthDestinationRule
 			}
-			if (iNdEx + skippy) > l {
+			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
-			iNdEx += skippy
-		}
-	}
-
-	if iNdEx > l {
-		return io.ErrUnexpectedEOF
-	}
-	return nil
-}
-func (m *OutlierDetection) Unmarshal(dAtA []byte) error {
-	l := len(dAtA)
-	iNdEx := 0
-	for iNdEx < l {
-		preIndex := iNdEx
-		var wire uint64
-		for shift := uint(0); ; shift += 7 {
-			if shift >= 64 {
-				return ErrIntOverflowDestinationRule
-			}
-			if iNdEx >= l {
-				return io.ErrUnexpectedEOF
+			if m.UnhealthyInterval == nil {
+				m.UnhealthyInterval = &types.Duration{}
 			}
-			b := dAtA[iNdEx]
-			iNdEx++
-			wire |= uint64(b&0x7F) << shift
-			if b < 0x80 {
-				break
+			if err := m.UnhealthyInterval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
 			}
-		}
-		fieldNum := int32(wire >> 3)
-		wireType := int(wire & 0x7)
-		if wireType == 4 {
-			return fmt.Errorf("proto: OutlierDetection: wiretype end group for non-group")
-		}
-		if fieldNum <= 0 {
-			return fmt.Errorf("proto: OutlierDetection: illegal tag %d (wire type %d)", fieldNum, wire)
-		}
-		switch fieldNum {
-		case 1:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field ConsecutiveErrors", wireType)
+			iNdEx = postIndex
+		case 15:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field UnhealthyEdgeInterval", wireType)
 			}
-			m.ConsecutiveErrors = 0
+			var msglen int
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowDestinationRule
@@ -6139,14 +10254,31 @@ func (m *OutlierDetection) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				m.ConsecutiveErrors |= int32(b&0x7F) << shift
+				msglen |= int(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-		case 2:
+			if msglen < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.UnhealthyEdgeInterval == nil {
+				m.UnhealthyEdgeInterval = &types.Duration{}
+			}
+			if err := m.UnhealthyEdgeInterval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 16:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field HealthyEdgeInterval", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -6173,18 +10305,18 @@ func (m *OutlierDetection) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.Interval == nil {
-				m.Interval = &types.Duration{}
+			if m.HealthyEdgeInterval == nil {
+				m.HealthyEdgeInterval = &types.Duration{}
 			}
-			if err := m.Interval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+			if err := m.HealthyEdgeInterval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
 			iNdEx = postIndex
-		case 3:
+		case 17:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field BaseEjectionTime", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field EventLogPath", wireType)
 			}
-			var msglen int
+			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowDestinationRule
@@ -6194,33 +10326,29 @@ func (m *OutlierDetection) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				msglen |= int(b&0x7F) << shift
+				stringLen |= uint64(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			if msglen < 0 {
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
 				return ErrInvalidLengthDestinationRule
 			}
-			postIndex := iNdEx + msglen
+			postIndex := iNdEx + intStringLen
 			if postIndex < 0 {
 				return ErrInvalidLengthDestinationRule
 			}
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.BaseEjectionTime == nil {
-				m.BaseEjectionTime = &types.Duration{}
-			}
-			if err := m.BaseEjectionTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
+			m.EventLogPath = string(dAtA[iNdEx:postIndex])
 			iNdEx = postIndex
-		case 4:
+		case 18:
 			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field MaxEjectionPercent", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field IntervalJitterPercent", wireType)
 			}
-			m.MaxEjectionPercent = 0
+			m.IntervalJitterPercent = 0
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowDestinationRule
@@ -6230,16 +10358,16 @@ func (m *OutlierDetection) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				m.MaxEjectionPercent |= int32(b&0x7F) << shift
+				m.IntervalJitterPercent |= uint32(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-		case 5:
+		case 19:
 			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field MinHealthPercent", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field AlwaysLogHealthCheckFailures", wireType)
 			}
-			m.MinHealthPercent = 0
+			var v int
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowDestinationRule
@@ -6249,14 +10377,15 @@ func (m *OutlierDetection) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				m.MinHealthPercent |= int32(b&0x7F) << shift
+				v |= int(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-		case 6:
+			m.AlwaysLogHealthCheckFailures = bool(v != 0)
+		case 20:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field ConsecutiveGatewayErrors", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field InitialJitter", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -6283,16 +10412,16 @@ func (m *OutlierDetection) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.ConsecutiveGatewayErrors == nil {
-				m.ConsecutiveGatewayErrors = &types.UInt32Value{}
+			if m.InitialJitter == nil {
+				m.InitialJitter = &types.Duration{}
 			}
-			if err := m.ConsecutiveGatewayErrors.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+			if err := m.InitialJitter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
 			iNdEx = postIndex
-		case 7:
+		case 21:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Consecutive_5XxErrors", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field TlsOptions", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -6319,36 +10448,16 @@ func (m *OutlierDetection) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.Consecutive_5XxErrors == nil {
-				m.Consecutive_5XxErrors = &types.UInt32Value{}
+			if m.TlsOptions == nil {
+				m.TlsOptions = &HealthCheck_TlsOptions{}
 			}
-			if err := m.Consecutive_5XxErrors.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+			if err := m.TlsOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
 			iNdEx = postIndex
-		case 8:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field SplitExternalLocalOriginErrors", wireType)
-			}
-			var v int
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowDestinationRule
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				v |= int(b&0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-			m.SplitExternalLocalOriginErrors = bool(v != 0)
-		case 9:
+		case 24:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field ConsecutiveLocalOriginFailures", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field NoTrafficHealthyInterval", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -6375,10 +10484,10 @@ func (m *OutlierDetection) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.ConsecutiveLocalOriginFailures == nil {
-				m.ConsecutiveLocalOriginFailures = &types.UInt32Value{}
+			if m.NoTrafficHealthyInterval == nil {
+				m.NoTrafficHealthyInterval = &types.Duration{}
 			}
-			if err := m.ConsecutiveLocalOriginFailures.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+			if err := m.NoTrafficHealthyInterval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
 			iNdEx = postIndex
@@ -6404,7 +10513,7 @@ func (m *OutlierDetection) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
-func (m *ClientTLSSettings) Unmarshal(dAtA []byte) error {
+func (m *HealthCheck_HttpHealthCheck) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
 	for iNdEx < l {
@@ -6427,34 +10536,15 @@ func (m *ClientTLSSettings) Unmarshal(dAtA []byte) error {
 		fieldNum := int32(wire >> 3)
 		wireType := int(wire & 0x7)
 		if wireType == 4 {
-			return fmt.Errorf("proto: ClientTLSSettings: wiretype end group for non-group")
+			return fmt.Errorf("proto: HttpHealthCheck: wiretype end group for non-group")
 		}
 		if fieldNum <= 0 {
-			return fmt.Errorf("proto: ClientTLSSettings: illegal tag %d (wire type %d)", fieldNum, wire)
+			return fmt.Errorf("proto: HttpHealthCheck: illegal tag %d (wire type %d)", fieldNum, wire)
 		}
 		switch fieldNum {
 		case 1:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
-			}
-			m.Mode = 0
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowDestinationRule
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				m.Mode |= ClientTLSSettings_TLSmode(b&0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		case 2:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field ClientCertificate", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
 			}
 			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
@@ -6482,11 +10572,11 @@ func (m *ClientTLSSettings) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.ClientCertificate = string(dAtA[iNdEx:postIndex])
+			m.Host = string(dAtA[iNdEx:postIndex])
 			iNdEx = postIndex
-		case 3:
+		case 2:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field PrivateKey", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
 			}
 			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
@@ -6514,13 +10604,13 @@ func (m *ClientTLSSettings) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.PrivateKey = string(dAtA[iNdEx:postIndex])
+			m.Path = string(dAtA[iNdEx:postIndex])
 			iNdEx = postIndex
-		case 4:
+		case 3:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field CaCertificates", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Send", wireType)
 			}
-			var stringLen uint64
+			var msglen int
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowDestinationRule
@@ -6530,61 +10620,33 @@ func (m *ClientTLSSettings) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				stringLen |= uint64(b&0x7F) << shift
+				msglen |= int(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			intStringLen := int(stringLen)
-			if intStringLen < 0 {
+			if msglen < 0 {
 				return ErrInvalidLengthDestinationRule
 			}
-			postIndex := iNdEx + intStringLen
+			postIndex := iNdEx + msglen
 			if postIndex < 0 {
 				return ErrInvalidLengthDestinationRule
 			}
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.CaCertificates = string(dAtA[iNdEx:postIndex])
-			iNdEx = postIndex
-		case 5:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field SubjectAltNames", wireType)
-			}
-			var stringLen uint64
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowDestinationRule
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				stringLen |= uint64(b&0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-			intStringLen := int(stringLen)
-			if intStringLen < 0 {
-				return ErrInvalidLengthDestinationRule
-			}
-			postIndex := iNdEx + intStringLen
-			if postIndex < 0 {
-				return ErrInvalidLengthDestinationRule
+			if m.Send == nil {
+				m.Send = &Payload{}
 			}
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
+			if err := m.Send.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
 			}
-			m.SubjectAltNames = append(m.SubjectAltNames, string(dAtA[iNdEx:postIndex]))
 			iNdEx = postIndex
-		case 6:
+		case 4:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Sni", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Receive", wireType)
 			}
-			var stringLen uint64
+			var msglen int
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowDestinationRule
@@ -6594,29 +10656,33 @@ func (m *ClientTLSSettings) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				stringLen |= uint64(b&0x7F) << shift
+				msglen |= int(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			intStringLen := int(stringLen)
-			if intStringLen < 0 {
+			if msglen < 0 {
 				return ErrInvalidLengthDestinationRule
 			}
-			postIndex := iNdEx + intStringLen
+			postIndex := iNdEx + msglen
 			if postIndex < 0 {
 				return ErrInvalidLengthDestinationRule
 			}
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.Sni = string(dAtA[iNdEx:postIndex])
+			if m.Receive == nil {
+				m.Receive = &Payload{}
+			}
+			if err := m.Receive.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
 			iNdEx = postIndex
-		case 7:
+		case 9:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field CredentialName", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field ExpectedStatuses", wireType)
 			}
-			var stringLen uint64
+			var msglen int
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowDestinationRule
@@ -6626,27 +10692,29 @@ func (m *ClientTLSSettings) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				stringLen |= uint64(b&0x7F) << shift
+				msglen |= int(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			intStringLen := int(stringLen)
-			if intStringLen < 0 {
+			if msglen < 0 {
 				return ErrInvalidLengthDestinationRule
 			}
-			postIndex := iNdEx + intStringLen
+			postIndex := iNdEx + msglen
 			if postIndex < 0 {
 				return ErrInvalidLengthDestinationRule
 			}
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.CredentialName = string(dAtA[iNdEx:postIndex])
+			m.ExpectedStatuses = append(m.ExpectedStatuses, &Int64Range{})
+			if err := m.ExpectedStatuses[len(m.ExpectedStatuses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
 			iNdEx = postIndex
-		case 8:
+		case 12:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field InsecureSkipVerify", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field RetriableStatuses", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -6673,10 +10741,8 @@ func (m *ClientTLSSettings) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.InsecureSkipVerify == nil {
-				m.InsecureSkipVerify = &types.BoolValue{}
-			}
-			if err := m.InsecureSkipVerify.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+			m.RetriableStatuses = append(m.RetriableStatuses, &Int64Range{})
+			if err := m.RetriableStatuses[len(m.RetriableStatuses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
 			iNdEx = postIndex
@@ -6702,7 +10768,7 @@ func (m *ClientTLSSettings) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
-func (m *LocalityLoadBalancerSetting) Unmarshal(dAtA []byte) error {
+func (m *HealthCheck_TcpHealthCheck) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
 	for iNdEx < l {
@@ -6725,15 +10791,15 @@ func (m *LocalityLoadBalancerSetting) Unmarshal(dAtA []byte) error {
 		fieldNum := int32(wire >> 3)
 		wireType := int(wire & 0x7)
 		if wireType == 4 {
-			return fmt.Errorf("proto: LocalityLoadBalancerSetting: wiretype end group for non-group")
+			return fmt.Errorf("proto: TcpHealthCheck: wiretype end group for non-group")
 		}
 		if fieldNum <= 0 {
-			return fmt.Errorf("proto: LocalityLoadBalancerSetting: illegal tag %d (wire type %d)", fieldNum, wire)
+			return fmt.Errorf("proto: TcpHealthCheck: illegal tag %d (wire type %d)", fieldNum, wire)
 		}
 		switch fieldNum {
 		case 1:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Distribute", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Send", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -6760,14 +10826,16 @@ func (m *LocalityLoadBalancerSetting) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.Distribute = append(m.Distribute, &LocalityLoadBalancerSetting_Distribute{})
-			if err := m.Distribute[len(m.Distribute)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+			if m.Send == nil {
+				m.Send = &Payload{}
+			}
+			if err := m.Send.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
 			iNdEx = postIndex
 		case 2:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Failover", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Receive", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -6794,50 +10862,65 @@ func (m *LocalityLoadBalancerSetting) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.Failover = append(m.Failover, &LocalityLoadBalancerSetting_Failover{})
-			if err := m.Failover[len(m.Failover)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+			m.Receive = append(m.Receive, &Payload{})
+			if err := m.Receive[len(m.Receive)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
 			iNdEx = postIndex
-		case 3:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
-			}
-			var msglen int
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowDestinationRule
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				msglen |= int(b&0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-			if msglen < 0 {
-				return ErrInvalidLengthDestinationRule
+		default:
+			iNdEx = preIndex
+			skippy, err := skipDestinationRule(dAtA[iNdEx:])
+			if err != nil {
+				return err
 			}
-			postIndex := iNdEx + msglen
-			if postIndex < 0 {
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
 				return ErrInvalidLengthDestinationRule
 			}
-			if postIndex > l {
+			if (iNdEx + skippy) > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.Enabled == nil {
-				m.Enabled = &types.BoolValue{}
+			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *HealthCheck_RedisHealthCheck) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowDestinationRule
 			}
-			if err := m.Enabled.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
 			}
-			iNdEx = postIndex
-		case 4:
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: RedisHealthCheck: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: RedisHealthCheck: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field FailoverPriority", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
 			}
 			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
@@ -6865,7 +10948,7 @@ func (m *LocalityLoadBalancerSetting) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.FailoverPriority = append(m.FailoverPriority, string(dAtA[iNdEx:postIndex]))
+			m.Key = string(dAtA[iNdEx:postIndex])
 			iNdEx = postIndex
 		default:
 			iNdEx = preIndex
@@ -6889,7 +10972,7 @@ func (m *LocalityLoadBalancerSetting) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
-func (m *LocalityLoadBalancerSetting_Distribute) Unmarshal(dAtA []byte) error {
+func (m *HealthCheck_GrpcHealthCheck) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
 	for iNdEx < l {
@@ -6912,15 +10995,15 @@ func (m *LocalityLoadBalancerSetting_Distribute) Unmarshal(dAtA []byte) error {
 		fieldNum := int32(wire >> 3)
 		wireType := int(wire & 0x7)
 		if wireType == 4 {
-			return fmt.Errorf("proto: Distribute: wiretype end group for non-group")
+			return fmt.Errorf("proto: GrpcHealthCheck: wiretype end group for non-group")
 		}
 		if fieldNum <= 0 {
-			return fmt.Errorf("proto: Distribute: illegal tag %d (wire type %d)", fieldNum, wire)
+			return fmt.Errorf("proto: GrpcHealthCheck: illegal tag %d (wire type %d)", fieldNum, wire)
 		}
 		switch fieldNum {
 		case 1:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field ServiceName", wireType)
 			}
 			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
@@ -6948,13 +11031,13 @@ func (m *LocalityLoadBalancerSetting_Distribute) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.From = string(dAtA[iNdEx:postIndex])
+			m.ServiceName = string(dAtA[iNdEx:postIndex])
 			iNdEx = postIndex
 		case 2:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
 			}
-			var msglen int
+			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowDestinationRule
@@ -6964,104 +11047,23 @@ func (m *LocalityLoadBalancerSetting_Distribute) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				msglen |= int(b&0x7F) << shift
+				stringLen |= uint64(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			if msglen < 0 {
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
 				return ErrInvalidLengthDestinationRule
 			}
-			postIndex := iNdEx + msglen
+			postIndex := iNdEx + intStringLen
 			if postIndex < 0 {
 				return ErrInvalidLengthDestinationRule
 			}
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.To == nil {
-				m.To = make(map[string]uint32)
-			}
-			var mapkey string
-			var mapvalue uint32
-			for iNdEx < postIndex {
-				entryPreIndex := iNdEx
-				var wire uint64
-				for shift := uint(0); ; shift += 7 {
-					if shift >= 64 {
-						return ErrIntOverflowDestinationRule
-					}
-					if iNdEx >= l {
-						return io.ErrUnexpectedEOF
-					}
-					b := dAtA[iNdEx]
-					iNdEx++
-					wire |= uint64(b&0x7F) << shift
-					if b < 0x80 {
-						break
-					}
-				}
-				fieldNum := int32(wire >> 3)
-				if fieldNum == 1 {
-					var stringLenmapkey uint64
-					for shift := uint(0); ; shift += 7 {
-						if shift >= 64 {
-							return ErrIntOverflowDestinationRule
-						}
-						if iNdEx >= l {
-							return io.ErrUnexpectedEOF
-						}
-						b := dAtA[iNdEx]
-						iNdEx++
-						stringLenmapkey |= uint64(b&0x7F) << shift
-						if b < 0x80 {
-							break
-						}
-					}
-					intStringLenmapkey := int(stringLenmapkey)
-					if intStringLenmapkey < 0 {
-						return ErrInvalidLengthDestinationRule
-					}
-					postStringIndexmapkey := iNdEx + intStringLenmapkey
-					if postStringIndexmapkey < 0 {
-						return ErrInvalidLengthDestinationRule
-					}
-					if postStringIndexmapkey > l {
-						return io.ErrUnexpectedEOF
-					}
-					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
-					iNdEx = postStringIndexmapkey
-				} else if fieldNum == 2 {
-					for shift := uint(0); ; shift += 7 {
-						if shift >= 64 {
-							return ErrIntOverflowDestinationRule
-						}
-						if iNdEx >= l {
-							return io.ErrUnexpectedEOF
-						}
-						b := dAtA[iNdEx]
-						iNdEx++
-						mapvalue |= uint32(b&0x7F) << shift
-						if b < 0x80 {
-							break
-						}
-					}
-				} else {
-					iNdEx = entryPreIndex
-					skippy, err := skipDestinationRule(dAtA[iNdEx:])
-					if err != nil {
-						return err
-					}
-					if (skippy < 0) || (iNdEx+skippy) < 0 {
-						return ErrInvalidLengthDestinationRule
-					}
-					if (iNdEx + skippy) > postIndex {
-						return io.ErrUnexpectedEOF
-					}
-					iNdEx += skippy
-				}
-			}
-			m.To[mapkey] = mapvalue
+			m.Authority = string(dAtA[iNdEx:postIndex])
 			iNdEx = postIndex
 		default:
 			iNdEx = preIndex
@@ -7085,7 +11087,7 @@ func (m *LocalityLoadBalancerSetting_Distribute) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
-func (m *LocalityLoadBalancerSetting_Failover) Unmarshal(dAtA []byte) error {
+func (m *HealthCheck_CustomHealthCheck) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
 	for iNdEx < l {
@@ -7108,15 +11110,15 @@ func (m *LocalityLoadBalancerSetting_Failover) Unmarshal(dAtA []byte) error {
 		fieldNum := int32(wire >> 3)
 		wireType := int(wire & 0x7)
 		if wireType == 4 {
-			return fmt.Errorf("proto: Failover: wiretype end group for non-group")
+			return fmt.Errorf("proto: CustomHealthCheck: wiretype end group for non-group")
 		}
 		if fieldNum <= 0 {
-			return fmt.Errorf("proto: Failover: illegal tag %d (wire type %d)", fieldNum, wire)
+			return fmt.Errorf("proto: CustomHealthCheck: illegal tag %d (wire type %d)", fieldNum, wire)
 		}
 		switch fieldNum {
 		case 1:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
 			}
 			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
@@ -7144,11 +11146,62 @@ func (m *LocalityLoadBalancerSetting_Failover) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.From = string(dAtA[iNdEx:postIndex])
+			m.Name = string(dAtA[iNdEx:postIndex])
 			iNdEx = postIndex
-		case 2:
+		default:
+			iNdEx = preIndex
+			skippy, err := skipDestinationRule(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthDestinationRule
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *HealthCheck_TlsOptions) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowDestinationRule
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: TlsOptions: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: TlsOptions: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field AlpnProtocols", wireType)
 			}
 			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
@@ -7176,7 +11229,7 @@ func (m *LocalityLoadBalancerSetting_Failover) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.To = string(dAtA[iNdEx:postIndex])
+			m.AlpnProtocols = append(m.AlpnProtocols, string(dAtA[iNdEx:postIndex]))
 			iNdEx = postIndex
 		default:
 			iNdEx = preIndex
diff --git a/networking/v1beta1/destination_rule.proto b/networking/v1beta1/destination_rule.proto
index fd257d4c..9dc14010 100644
--- a/networking/v1beta1/destination_rule.proto
+++ b/networking/v1beta1/destination_rule.proto
@@ -274,6 +274,8 @@ message TrafficPolicy {
 
     // TLS related settings for connections to the upstream service.
     ClientTLSSettings tls = 5;
+
+    repeated HealthCheck health_checks = 101;
   }
 
   // Traffic policies specific to individual ports. Note that port level
@@ -282,6 +284,8 @@ message TrafficPolicy {
   // overridden by port-level settings, i.e. default values will be applied
   // to fields omitted in port-level traffic policies.
   repeated PortTrafficPolicy port_level_settings = 5;
+
+  repeated HealthCheck health_checks = 101;
 }
 
 // A subset of endpoints of a service. Subsets can be used for scenarios
@@ -518,6 +522,13 @@ message LoadBalancerSettings {
   // Locality load balancer settings, this will override mesh wide settings in entirety, meaning no merging would be performed
   // between this object and the object one in MeshConfig
   LocalityLoadBalancerSetting locality_lb_setting = 3;
+
+  // Represents the warmup duration of Service. If set, the newly created endpoint of service
+  // remains in warmup mode starting from its creation time for the duration of this window and
+  // Istio progressively increases amount of traffic for that endpoint instead of sending proportional amount of traffic.
+  // This should be enabled for services that require warm up time to serve full production load with reasonable latency.
+  // Currently this is only supported for ROUND_ROBIN and LEAST_CONN load balancers.
+  google.protobuf.Duration warmup_duration_secs = 4;
 }
 
 // Connection pool settings for an upstream host. The settings apply to
@@ -1124,3 +1135,194 @@ message LocalityLoadBalancerSetting{
     // e.g. true means that turn on locality load balancing for this DestinationRule no matter what mesh wide settings is.
     google.protobuf.BoolValue enabled = 3;
 }
+
+
+// Added by Ingress
+message Int64Range {
+    // start of the range (inclusive)
+    int64 start = 1;
+  
+    // end of the range (exclusive)
+    int64 end = 2;
+}
+
+// Endpoint health status.
+enum HealthStatus {
+  // The health status is not known. This is interpreted by Envoy as *HEALTHY*.
+  UNKNOWN = 0;
+
+  // Healthy.
+  HEALTHY = 1;
+
+  // Unhealthy.
+  UNHEALTHY = 2;
+
+  DRAINING = 3;
+
+  TIMEOUT = 4;
+
+  DEGRADED = 5;
+}
+
+message HealthStatusSet {
+  // An order-independent set of health status.
+  repeated HealthStatus statuses = 1;
+}
+
+message Payload {
+  oneof payload {
+    string text = 1;
+
+    bytes binary = 2;
+  }
+}
+
+// [#next-free-field: 25]
+message HealthCheck {
+  // Describes the encoding of the payload bytes in the payload.
+
+  // [#next-free-field: 13]
+  message HttpHealthCheck {
+    reserved 5, 7;
+
+    reserved "service_name", "use_http2";
+
+    string host = 1;
+
+    // Specifies the HTTP path that will be requested during health checking.
+    string path = 2;
+
+    Payload send = 3;
+
+    Payload receive = 4;
+
+    reserved 6, 8;
+
+    // Specifies a list of HTTP response statuses considered healthy. If provided, replaces default
+    // 200-only policy - 200 must be included explicitly as needed. Ranges follow half-open
+    // semantics of :ref:`Int64Range <envoy_v3_api_msg_type.v3.Int64Range>`. The start and end of each
+    // range are required. Only statuses in the range [100, 600) are allowed.
+    repeated Int64Range expected_statuses = 9;
+
+    repeated Int64Range retriable_statuses = 12;
+  }
+
+  message TcpHealthCheck {
+    // Empty payloads imply a connect-only health check.
+    Payload send = 1;
+
+    repeated Payload receive = 2;
+  }
+
+  message RedisHealthCheck {
+    string key = 1;
+  }
+
+  message GrpcHealthCheck {
+    string service_name = 1;
+
+    string authority = 2;
+    
+
+    reserved 3;
+  }
+
+  // Custom health check.
+  message CustomHealthCheck {
+    reserved 2;
+
+    reserved "config";
+
+    // The registered name of the custom health checker.
+    string name = 1 ;
+  }
+
+  // Health checks occur over the transport socket specified for the cluster. This implies that if a
+  // cluster is using a TLS-enabled transport socket, the health check will also occur over TLS.
+  //
+  // This allows overriding the cluster TLS settings, just for health check connections.
+  message TlsOptions {
+    repeated string alpn_protocols = 1;
+  }
+
+  reserved 10;
+
+  // The time to wait for a health check response. If the timeout is reached the
+  // health check attempt will be considered a failure.
+  google.protobuf.Duration timeout = 1;
+
+  // The interval between health checks.
+  google.protobuf.Duration interval = 2;
+
+  // An optional jitter amount in milliseconds. If specified, Envoy will start health
+  // checking after for a random time in ms between 0 and initial_jitter. This only
+  // applies to the first health check.
+  google.protobuf.Duration initial_jitter = 20;
+
+  // An optional jitter amount in milliseconds. If specified, during every
+  // interval Envoy will add interval_jitter to the wait time.
+  google.protobuf.Duration interval_jitter = 3;
+
+  // An optional jitter amount as a percentage of interval_ms. If specified,
+  // during every interval Envoy will add interval_ms *
+  // interval_jitter_percent / 100 to the wait time.
+  //
+  // If interval_jitter_ms and interval_jitter_percent are both set, both of
+  // them will be used to increase the wait time.
+  uint32 interval_jitter_percent = 18;
+
+  // The number of unhealthy health checks required before a host is marked
+  // unhealthy. Note that for *http* health checking if a host responds with a code not in
+  google.protobuf.UInt32Value unhealthy_threshold = 4;
+
+  // The number of healthy health checks required before a host is marked
+  // healthy. Note that during startup, only a single successful health check is
+  // required to mark a host healthy.
+  google.protobuf.UInt32Value healthy_threshold = 5;
+
+  google.protobuf.UInt32Value alt_port = 6;
+
+  google.protobuf.BoolValue reuse_connection = 7;
+
+  oneof health_checker {
+    // HTTP health check.
+    HttpHealthCheck http_health_check = 8;
+
+    // TCP health check.
+    TcpHealthCheck tcp_health_check = 9;
+
+    // gRPC health check.
+    GrpcHealthCheck grpc_health_check = 11;
+
+    // Custom health check.
+    CustomHealthCheck custom_health_check = 13;
+  }
+
+  // The default value for "no traffic interval" is 60 seconds.
+  google.protobuf.Duration no_traffic_interval = 12;
+
+  // If no_traffic_healthy_interval is not set, it will default to the
+  // no traffic interval and send that interval regardless of health state.
+  google.protobuf.Duration no_traffic_healthy_interval = 24;
+
+  // The default value for "unhealthy interval" is the same as "interval".
+  google.protobuf.Duration unhealthy_interval = 14;
+
+  // The default value for "unhealthy edge interval" is the same as "unhealthy interval".
+  google.protobuf.Duration unhealthy_edge_interval = 15;
+
+  // The default value for "healthy edge interval" is the same as the default interval.
+  google.protobuf.Duration healthy_edge_interval = 16;
+
+  // Specifies the path to the :ref:`health check event log <arch_overview_health_check_logging>`.
+  // If empty, no event log will be written.
+  string event_log_path = 17;
+
+  reserved 22;
+
+  bool always_log_health_check_failures = 19;
+
+  // This allows overriding the cluster TLS settings, just for health check connections.
+  TlsOptions tls_options = 21;
+}
+// End Added
diff --git a/networking/v1beta1/destination_rule_deepcopy.gen.go b/networking/v1beta1/destination_rule_deepcopy.gen.go
index 07a08b7b..6a584b8f 100644
--- a/networking/v1beta1/destination_rule_deepcopy.gen.go
+++ b/networking/v1beta1/destination_rule_deepcopy.gen.go
@@ -492,3 +492,213 @@ func (in *LocalityLoadBalancerSetting_Failover) DeepCopy() *LocalityLoadBalancer
 func (in *LocalityLoadBalancerSetting_Failover) DeepCopyInterface() interface{} {
 	return in.DeepCopy()
 }
+
+// DeepCopyInto supports using Int64Range within kubernetes types, where deepcopy-gen is used.
+func (in *Int64Range) DeepCopyInto(out *Int64Range) {
+	p := proto.Clone(in).(*Int64Range)
+	*out = *p
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Int64Range. Required by controller-gen.
+func (in *Int64Range) DeepCopy() *Int64Range {
+	if in == nil {
+		return nil
+	}
+	out := new(Int64Range)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInterface is an autogenerated deepcopy function, copying the receiver, creating a new Int64Range. Required by controller-gen.
+func (in *Int64Range) DeepCopyInterface() interface{} {
+	return in.DeepCopy()
+}
+
+// DeepCopyInto supports using HealthStatusSet within kubernetes types, where deepcopy-gen is used.
+func (in *HealthStatusSet) DeepCopyInto(out *HealthStatusSet) {
+	p := proto.Clone(in).(*HealthStatusSet)
+	*out = *p
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new HealthStatusSet. Required by controller-gen.
+func (in *HealthStatusSet) DeepCopy() *HealthStatusSet {
+	if in == nil {
+		return nil
+	}
+	out := new(HealthStatusSet)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInterface is an autogenerated deepcopy function, copying the receiver, creating a new HealthStatusSet. Required by controller-gen.
+func (in *HealthStatusSet) DeepCopyInterface() interface{} {
+	return in.DeepCopy()
+}
+
+// DeepCopyInto supports using Payload within kubernetes types, where deepcopy-gen is used.
+func (in *Payload) DeepCopyInto(out *Payload) {
+	p := proto.Clone(in).(*Payload)
+	*out = *p
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Payload. Required by controller-gen.
+func (in *Payload) DeepCopy() *Payload {
+	if in == nil {
+		return nil
+	}
+	out := new(Payload)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInterface is an autogenerated deepcopy function, copying the receiver, creating a new Payload. Required by controller-gen.
+func (in *Payload) DeepCopyInterface() interface{} {
+	return in.DeepCopy()
+}
+
+// DeepCopyInto supports using HealthCheck within kubernetes types, where deepcopy-gen is used.
+func (in *HealthCheck) DeepCopyInto(out *HealthCheck) {
+	p := proto.Clone(in).(*HealthCheck)
+	*out = *p
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new HealthCheck. Required by controller-gen.
+func (in *HealthCheck) DeepCopy() *HealthCheck {
+	if in == nil {
+		return nil
+	}
+	out := new(HealthCheck)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInterface is an autogenerated deepcopy function, copying the receiver, creating a new HealthCheck. Required by controller-gen.
+func (in *HealthCheck) DeepCopyInterface() interface{} {
+	return in.DeepCopy()
+}
+
+// DeepCopyInto supports using HealthCheck_HttpHealthCheck within kubernetes types, where deepcopy-gen is used.
+func (in *HealthCheck_HttpHealthCheck) DeepCopyInto(out *HealthCheck_HttpHealthCheck) {
+	p := proto.Clone(in).(*HealthCheck_HttpHealthCheck)
+	*out = *p
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new HealthCheck_HttpHealthCheck. Required by controller-gen.
+func (in *HealthCheck_HttpHealthCheck) DeepCopy() *HealthCheck_HttpHealthCheck {
+	if in == nil {
+		return nil
+	}
+	out := new(HealthCheck_HttpHealthCheck)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInterface is an autogenerated deepcopy function, copying the receiver, creating a new HealthCheck_HttpHealthCheck. Required by controller-gen.
+func (in *HealthCheck_HttpHealthCheck) DeepCopyInterface() interface{} {
+	return in.DeepCopy()
+}
+
+// DeepCopyInto supports using HealthCheck_TcpHealthCheck within kubernetes types, where deepcopy-gen is used.
+func (in *HealthCheck_TcpHealthCheck) DeepCopyInto(out *HealthCheck_TcpHealthCheck) {
+	p := proto.Clone(in).(*HealthCheck_TcpHealthCheck)
+	*out = *p
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new HealthCheck_TcpHealthCheck. Required by controller-gen.
+func (in *HealthCheck_TcpHealthCheck) DeepCopy() *HealthCheck_TcpHealthCheck {
+	if in == nil {
+		return nil
+	}
+	out := new(HealthCheck_TcpHealthCheck)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInterface is an autogenerated deepcopy function, copying the receiver, creating a new HealthCheck_TcpHealthCheck. Required by controller-gen.
+func (in *HealthCheck_TcpHealthCheck) DeepCopyInterface() interface{} {
+	return in.DeepCopy()
+}
+
+// DeepCopyInto supports using HealthCheck_RedisHealthCheck within kubernetes types, where deepcopy-gen is used.
+func (in *HealthCheck_RedisHealthCheck) DeepCopyInto(out *HealthCheck_RedisHealthCheck) {
+	p := proto.Clone(in).(*HealthCheck_RedisHealthCheck)
+	*out = *p
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new HealthCheck_RedisHealthCheck. Required by controller-gen.
+func (in *HealthCheck_RedisHealthCheck) DeepCopy() *HealthCheck_RedisHealthCheck {
+	if in == nil {
+		return nil
+	}
+	out := new(HealthCheck_RedisHealthCheck)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInterface is an autogenerated deepcopy function, copying the receiver, creating a new HealthCheck_RedisHealthCheck. Required by controller-gen.
+func (in *HealthCheck_RedisHealthCheck) DeepCopyInterface() interface{} {
+	return in.DeepCopy()
+}
+
+// DeepCopyInto supports using HealthCheck_GrpcHealthCheck within kubernetes types, where deepcopy-gen is used.
+func (in *HealthCheck_GrpcHealthCheck) DeepCopyInto(out *HealthCheck_GrpcHealthCheck) {
+	p := proto.Clone(in).(*HealthCheck_GrpcHealthCheck)
+	*out = *p
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new HealthCheck_GrpcHealthCheck. Required by controller-gen.
+func (in *HealthCheck_GrpcHealthCheck) DeepCopy() *HealthCheck_GrpcHealthCheck {
+	if in == nil {
+		return nil
+	}
+	out := new(HealthCheck_GrpcHealthCheck)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInterface is an autogenerated deepcopy function, copying the receiver, creating a new HealthCheck_GrpcHealthCheck. Required by controller-gen.
+func (in *HealthCheck_GrpcHealthCheck) DeepCopyInterface() interface{} {
+	return in.DeepCopy()
+}
+
+// DeepCopyInto supports using HealthCheck_CustomHealthCheck within kubernetes types, where deepcopy-gen is used.
+func (in *HealthCheck_CustomHealthCheck) DeepCopyInto(out *HealthCheck_CustomHealthCheck) {
+	p := proto.Clone(in).(*HealthCheck_CustomHealthCheck)
+	*out = *p
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new HealthCheck_CustomHealthCheck. Required by controller-gen.
+func (in *HealthCheck_CustomHealthCheck) DeepCopy() *HealthCheck_CustomHealthCheck {
+	if in == nil {
+		return nil
+	}
+	out := new(HealthCheck_CustomHealthCheck)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInterface is an autogenerated deepcopy function, copying the receiver, creating a new HealthCheck_CustomHealthCheck. Required by controller-gen.
+func (in *HealthCheck_CustomHealthCheck) DeepCopyInterface() interface{} {
+	return in.DeepCopy()
+}
+
+// DeepCopyInto supports using HealthCheck_TlsOptions within kubernetes types, where deepcopy-gen is used.
+func (in *HealthCheck_TlsOptions) DeepCopyInto(out *HealthCheck_TlsOptions) {
+	p := proto.Clone(in).(*HealthCheck_TlsOptions)
+	*out = *p
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new HealthCheck_TlsOptions. Required by controller-gen.
+func (in *HealthCheck_TlsOptions) DeepCopy() *HealthCheck_TlsOptions {
+	if in == nil {
+		return nil
+	}
+	out := new(HealthCheck_TlsOptions)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInterface is an autogenerated deepcopy function, copying the receiver, creating a new HealthCheck_TlsOptions. Required by controller-gen.
+func (in *HealthCheck_TlsOptions) DeepCopyInterface() interface{} {
+	return in.DeepCopy()
+}
diff --git a/networking/v1beta1/destination_rule_json.gen.go b/networking/v1beta1/destination_rule_json.gen.go
index 01d8b860..094f50ea 100644
--- a/networking/v1beta1/destination_rule_json.gen.go
+++ b/networking/v1beta1/destination_rule_json.gen.go
@@ -335,6 +335,116 @@ func (this *LocalityLoadBalancerSetting_Failover) UnmarshalJSON(b []byte) error
 	return DestinationRuleUnmarshaler.Unmarshal(bytes.NewReader(b), this)
 }
 
+// MarshalJSON is a custom marshaler for Int64Range
+func (this *Int64Range) MarshalJSON() ([]byte, error) {
+	str, err := DestinationRuleMarshaler.MarshalToString(this)
+	return []byte(str), err
+}
+
+// UnmarshalJSON is a custom unmarshaler for Int64Range
+func (this *Int64Range) UnmarshalJSON(b []byte) error {
+	return DestinationRuleUnmarshaler.Unmarshal(bytes.NewReader(b), this)
+}
+
+// MarshalJSON is a custom marshaler for HealthStatusSet
+func (this *HealthStatusSet) MarshalJSON() ([]byte, error) {
+	str, err := DestinationRuleMarshaler.MarshalToString(this)
+	return []byte(str), err
+}
+
+// UnmarshalJSON is a custom unmarshaler for HealthStatusSet
+func (this *HealthStatusSet) UnmarshalJSON(b []byte) error {
+	return DestinationRuleUnmarshaler.Unmarshal(bytes.NewReader(b), this)
+}
+
+// MarshalJSON is a custom marshaler for Payload
+func (this *Payload) MarshalJSON() ([]byte, error) {
+	str, err := DestinationRuleMarshaler.MarshalToString(this)
+	return []byte(str), err
+}
+
+// UnmarshalJSON is a custom unmarshaler for Payload
+func (this *Payload) UnmarshalJSON(b []byte) error {
+	return DestinationRuleUnmarshaler.Unmarshal(bytes.NewReader(b), this)
+}
+
+// MarshalJSON is a custom marshaler for HealthCheck
+func (this *HealthCheck) MarshalJSON() ([]byte, error) {
+	str, err := DestinationRuleMarshaler.MarshalToString(this)
+	return []byte(str), err
+}
+
+// UnmarshalJSON is a custom unmarshaler for HealthCheck
+func (this *HealthCheck) UnmarshalJSON(b []byte) error {
+	return DestinationRuleUnmarshaler.Unmarshal(bytes.NewReader(b), this)
+}
+
+// MarshalJSON is a custom marshaler for HealthCheck_HttpHealthCheck
+func (this *HealthCheck_HttpHealthCheck) MarshalJSON() ([]byte, error) {
+	str, err := DestinationRuleMarshaler.MarshalToString(this)
+	return []byte(str), err
+}
+
+// UnmarshalJSON is a custom unmarshaler for HealthCheck_HttpHealthCheck
+func (this *HealthCheck_HttpHealthCheck) UnmarshalJSON(b []byte) error {
+	return DestinationRuleUnmarshaler.Unmarshal(bytes.NewReader(b), this)
+}
+
+// MarshalJSON is a custom marshaler for HealthCheck_TcpHealthCheck
+func (this *HealthCheck_TcpHealthCheck) MarshalJSON() ([]byte, error) {
+	str, err := DestinationRuleMarshaler.MarshalToString(this)
+	return []byte(str), err
+}
+
+// UnmarshalJSON is a custom unmarshaler for HealthCheck_TcpHealthCheck
+func (this *HealthCheck_TcpHealthCheck) UnmarshalJSON(b []byte) error {
+	return DestinationRuleUnmarshaler.Unmarshal(bytes.NewReader(b), this)
+}
+
+// MarshalJSON is a custom marshaler for HealthCheck_RedisHealthCheck
+func (this *HealthCheck_RedisHealthCheck) MarshalJSON() ([]byte, error) {
+	str, err := DestinationRuleMarshaler.MarshalToString(this)
+	return []byte(str), err
+}
+
+// UnmarshalJSON is a custom unmarshaler for HealthCheck_RedisHealthCheck
+func (this *HealthCheck_RedisHealthCheck) UnmarshalJSON(b []byte) error {
+	return DestinationRuleUnmarshaler.Unmarshal(bytes.NewReader(b), this)
+}
+
+// MarshalJSON is a custom marshaler for HealthCheck_GrpcHealthCheck
+func (this *HealthCheck_GrpcHealthCheck) MarshalJSON() ([]byte, error) {
+	str, err := DestinationRuleMarshaler.MarshalToString(this)
+	return []byte(str), err
+}
+
+// UnmarshalJSON is a custom unmarshaler for HealthCheck_GrpcHealthCheck
+func (this *HealthCheck_GrpcHealthCheck) UnmarshalJSON(b []byte) error {
+	return DestinationRuleUnmarshaler.Unmarshal(bytes.NewReader(b), this)
+}
+
+// MarshalJSON is a custom marshaler for HealthCheck_CustomHealthCheck
+func (this *HealthCheck_CustomHealthCheck) MarshalJSON() ([]byte, error) {
+	str, err := DestinationRuleMarshaler.MarshalToString(this)
+	return []byte(str), err
+}
+
+// UnmarshalJSON is a custom unmarshaler for HealthCheck_CustomHealthCheck
+func (this *HealthCheck_CustomHealthCheck) UnmarshalJSON(b []byte) error {
+	return DestinationRuleUnmarshaler.Unmarshal(bytes.NewReader(b), this)
+}
+
+// MarshalJSON is a custom marshaler for HealthCheck_TlsOptions
+func (this *HealthCheck_TlsOptions) MarshalJSON() ([]byte, error) {
+	str, err := DestinationRuleMarshaler.MarshalToString(this)
+	return []byte(str), err
+}
+
+// UnmarshalJSON is a custom unmarshaler for HealthCheck_TlsOptions
+func (this *HealthCheck_TlsOptions) UnmarshalJSON(b []byte) error {
+	return DestinationRuleUnmarshaler.Unmarshal(bytes.NewReader(b), this)
+}
+
 var (
 	DestinationRuleMarshaler   = &github_com_gogo_protobuf_jsonpb.Marshaler{}
 	DestinationRuleUnmarshaler = &github_com_gogo_protobuf_jsonpb.Unmarshaler{AllowUnknownFields: true}
diff --git a/networking/v1beta1/service_subscription_list.gen.json b/networking/v1beta1/service_subscription_list.gen.json
new file mode 100644
index 00000000..8d59a985
--- /dev/null
+++ b/networking/v1beta1/service_subscription_list.gen.json
@@ -0,0 +1,85 @@
+{
+  "openapi": "3.0.0",
+  "info": {
+    "title": "",
+    "version": "v1beta1"
+  },
+  "components": {
+    "schemas": {
+      "istio.networking.v1beta1.Port": {
+        "description": "Port describes the properties of a specific port of a service.",
+        "type": "object",
+        "properties": {
+          "number": {
+            "description": "A valid non-negative integer port number.",
+            "type": "integer"
+          },
+          "protocol": {
+            "description": "The protocol exposed on the port. MUST BE one of HTTP|HTTPS|GRPC|HTTP2|MONGO|TCP|TLS. TLS implies the connection will be routed based on the SNI header to the destination without terminating the TLS connection.",
+            "type": "string"
+          },
+          "name": {
+            "description": "Label assigned to the port.",
+            "type": "string"
+          },
+          "targetPort": {
+            "description": "The port number on the endpoint where the traffic will be received. Applicable only when used with ServiceEntries.",
+            "type": "integer"
+          }
+        }
+      },
+      "istio.networking.v1beta1.ServiceSubscription": {
+        "type": "object",
+        "properties": {
+          "hostname": {
+            "type": "string"
+          },
+          "version": {
+            "type": "string"
+          },
+          "group": {
+            "type": "string"
+          },
+          "port": {
+            "$ref": "#/components/schemas/istio.networking.v1beta1.Port"
+          },
+          "units": {
+            "type": "array",
+            "items": {
+              "type": "string"
+            }
+          },
+          "labels": {
+            "type": "object",
+            "additionalProperties": {
+              "type": "string"
+            }
+          }
+        }
+      },
+      "istio.networking.v1beta1.ServiceSubscriptionList": {
+        "description": "\u003c!-- crd generation tags +cue-gen:ServiceSubscriptionList:groupName:networking.istio.io +cue-gen:ServiceSubscriptionList:version:v1beta1 +cue-gen:ServiceSubscriptionList:annotations:helm.sh/resource-policy=keep +cue-gen:ServiceSubscriptionList:labels:app=istio-pilot,chart=istio,heritage=Tiller,release=istio +cue-gen:ServiceSubscriptionList:subresource:status +cue-gen:ServiceSubscriptionList:scope:Namespaced +cue-gen:ServiceSubscriptionList:resource:categories=istio-io,networking-istio-io +cue-gen:ServiceSubscriptionList:preserveUnknownFields:false --\u003e",
+        "type": "object",
+        "properties": {
+          "resolution": {
+            "$ref": "#/components/schemas/istio.networking.v1beta1.ServiceSubscriptionList.Resolution"
+          },
+          "subscriptions": {
+            "type": "array",
+            "items": {
+              "$ref": "#/components/schemas/istio.networking.v1beta1.ServiceSubscription"
+            }
+          }
+        }
+      },
+      "istio.networking.v1beta1.ServiceSubscriptionList.Resolution": {
+        "type": "string",
+        "enum": [
+          "CONFIGSERVER",
+          "VIPSERVER",
+          "NACOS"
+        ]
+      }
+    }
+  }
+}
\ No newline at end of file
diff --git a/networking/v1beta1/service_subscription_list.pb.go b/networking/v1beta1/service_subscription_list.pb.go
new file mode 100644
index 00000000..aedff2d0
--- /dev/null
+++ b/networking/v1beta1/service_subscription_list.pb.go
@@ -0,0 +1,995 @@
+// Code generated by protoc-gen-gogo. DO NOT EDIT.
+// source: networking/v1beta1/service_subscription_list.proto
+
+package v1beta1
+
+import (
+	fmt "fmt"
+	proto "github.com/gogo/protobuf/proto"
+	io "io"
+	math "math"
+	math_bits "math/bits"
+)
+
+// Reference imports to suppress errors if they are not otherwise used.
+var _ = proto.Marshal
+var _ = fmt.Errorf
+var _ = math.Inf
+
+// This is a compile-time assertion to ensure that this generated file
+// is compatible with the proto package it is being compiled against.
+// A compilation error at this line likely means your copy of the
+// proto package needs to be updated.
+const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package
+
+type ServiceSubscriptionList_Resolution int32
+
+const (
+	ServiceSubscriptionList_CONFIGSERVER ServiceSubscriptionList_Resolution = 0
+	ServiceSubscriptionList_VIPSERVER    ServiceSubscriptionList_Resolution = 1
+	ServiceSubscriptionList_NACOS        ServiceSubscriptionList_Resolution = 2
+)
+
+var ServiceSubscriptionList_Resolution_name = map[int32]string{
+	0: "CONFIGSERVER",
+	1: "VIPSERVER",
+	2: "NACOS",
+}
+
+var ServiceSubscriptionList_Resolution_value = map[string]int32{
+	"CONFIGSERVER": 0,
+	"VIPSERVER":    1,
+	"NACOS":        2,
+}
+
+func (x ServiceSubscriptionList_Resolution) String() string {
+	return proto.EnumName(ServiceSubscriptionList_Resolution_name, int32(x))
+}
+
+func (ServiceSubscriptionList_Resolution) EnumDescriptor() ([]byte, []int) {
+	return fileDescriptor_7087ab823a7e505e, []int{0, 0}
+}
+
+// <!-- crd generation tags
+// +cue-gen:ServiceSubscriptionList:groupName:networking.istio.io
+// +cue-gen:ServiceSubscriptionList:version:v1beta1
+// +cue-gen:ServiceSubscriptionList:annotations:helm.sh/resource-policy=keep
+// +cue-gen:ServiceSubscriptionList:labels:app=istio-pilot,chart=istio,heritage=Tiller,release=istio
+// +cue-gen:ServiceSubscriptionList:subresource:status
+// +cue-gen:ServiceSubscriptionList:scope:Namespaced
+// +cue-gen:ServiceSubscriptionList:resource:categories=istio-io,networking-istio-io
+// +cue-gen:ServiceSubscriptionList:preserveUnknownFields:false
+// -->
+//
+// <!-- go code generation tags
+// +kubetype-gen
+// +kubetype-gen:groupVersion=networking.istio.io/v1beta1
+// +genclient
+// +k8s:deepcopy-gen=true
+// -->
+type ServiceSubscriptionList struct {
+	Resolution           ServiceSubscriptionList_Resolution `protobuf:"varint,1,opt,name=resolution,proto3,enum=istio.networking.v1beta1.ServiceSubscriptionList_Resolution" json:"resolution,omitempty"`
+	Subscriptions        []*ServiceSubscription             `protobuf:"bytes,2,rep,name=subscriptions,proto3" json:"subscriptions,omitempty"`
+	XXX_NoUnkeyedLiteral struct{}                           `json:"-"`
+	XXX_unrecognized     []byte                             `json:"-"`
+	XXX_sizecache        int32                              `json:"-"`
+}
+
+func (m *ServiceSubscriptionList) Reset()         { *m = ServiceSubscriptionList{} }
+func (m *ServiceSubscriptionList) String() string { return proto.CompactTextString(m) }
+func (*ServiceSubscriptionList) ProtoMessage()    {}
+func (*ServiceSubscriptionList) Descriptor() ([]byte, []int) {
+	return fileDescriptor_7087ab823a7e505e, []int{0}
+}
+func (m *ServiceSubscriptionList) XXX_Unmarshal(b []byte) error {
+	return m.Unmarshal(b)
+}
+func (m *ServiceSubscriptionList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	if deterministic {
+		return xxx_messageInfo_ServiceSubscriptionList.Marshal(b, m, deterministic)
+	} else {
+		b = b[:cap(b)]
+		n, err := m.MarshalToSizedBuffer(b)
+		if err != nil {
+			return nil, err
+		}
+		return b[:n], nil
+	}
+}
+func (m *ServiceSubscriptionList) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_ServiceSubscriptionList.Merge(m, src)
+}
+func (m *ServiceSubscriptionList) XXX_Size() int {
+	return m.Size()
+}
+func (m *ServiceSubscriptionList) XXX_DiscardUnknown() {
+	xxx_messageInfo_ServiceSubscriptionList.DiscardUnknown(m)
+}
+
+var xxx_messageInfo_ServiceSubscriptionList proto.InternalMessageInfo
+
+func (m *ServiceSubscriptionList) GetResolution() ServiceSubscriptionList_Resolution {
+	if m != nil {
+		return m.Resolution
+	}
+	return ServiceSubscriptionList_CONFIGSERVER
+}
+
+func (m *ServiceSubscriptionList) GetSubscriptions() []*ServiceSubscription {
+	if m != nil {
+		return m.Subscriptions
+	}
+	return nil
+}
+
+type ServiceSubscription struct {
+	Hostname             string            `protobuf:"bytes,1,opt,name=hostname,proto3" json:"hostname,omitempty"`
+	Version              string            `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
+	Group                string            `protobuf:"bytes,3,opt,name=group,proto3" json:"group,omitempty"`
+	Port                 *Port             `protobuf:"bytes,4,opt,name=port,proto3" json:"port,omitempty"`
+	Units                []string          `protobuf:"bytes,5,rep,name=units,proto3" json:"units,omitempty"`
+	Labels               map[string]string `protobuf:"bytes,6,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
+	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
+	XXX_unrecognized     []byte            `json:"-"`
+	XXX_sizecache        int32             `json:"-"`
+}
+
+func (m *ServiceSubscription) Reset()         { *m = ServiceSubscription{} }
+func (m *ServiceSubscription) String() string { return proto.CompactTextString(m) }
+func (*ServiceSubscription) ProtoMessage()    {}
+func (*ServiceSubscription) Descriptor() ([]byte, []int) {
+	return fileDescriptor_7087ab823a7e505e, []int{1}
+}
+func (m *ServiceSubscription) XXX_Unmarshal(b []byte) error {
+	return m.Unmarshal(b)
+}
+func (m *ServiceSubscription) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	if deterministic {
+		return xxx_messageInfo_ServiceSubscription.Marshal(b, m, deterministic)
+	} else {
+		b = b[:cap(b)]
+		n, err := m.MarshalToSizedBuffer(b)
+		if err != nil {
+			return nil, err
+		}
+		return b[:n], nil
+	}
+}
+func (m *ServiceSubscription) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_ServiceSubscription.Merge(m, src)
+}
+func (m *ServiceSubscription) XXX_Size() int {
+	return m.Size()
+}
+func (m *ServiceSubscription) XXX_DiscardUnknown() {
+	xxx_messageInfo_ServiceSubscription.DiscardUnknown(m)
+}
+
+var xxx_messageInfo_ServiceSubscription proto.InternalMessageInfo
+
+func (m *ServiceSubscription) GetHostname() string {
+	if m != nil {
+		return m.Hostname
+	}
+	return ""
+}
+
+func (m *ServiceSubscription) GetVersion() string {
+	if m != nil {
+		return m.Version
+	}
+	return ""
+}
+
+func (m *ServiceSubscription) GetGroup() string {
+	if m != nil {
+		return m.Group
+	}
+	return ""
+}
+
+func (m *ServiceSubscription) GetPort() *Port {
+	if m != nil {
+		return m.Port
+	}
+	return nil
+}
+
+func (m *ServiceSubscription) GetUnits() []string {
+	if m != nil {
+		return m.Units
+	}
+	return nil
+}
+
+func (m *ServiceSubscription) GetLabels() map[string]string {
+	if m != nil {
+		return m.Labels
+	}
+	return nil
+}
+
+func init() {
+	proto.RegisterEnum("istio.networking.v1beta1.ServiceSubscriptionList_Resolution", ServiceSubscriptionList_Resolution_name, ServiceSubscriptionList_Resolution_value)
+	proto.RegisterType((*ServiceSubscriptionList)(nil), "istio.networking.v1beta1.ServiceSubscriptionList")
+	proto.RegisterType((*ServiceSubscription)(nil), "istio.networking.v1beta1.ServiceSubscription")
+	proto.RegisterMapType((map[string]string)(nil), "istio.networking.v1beta1.ServiceSubscription.LabelsEntry")
+}
+
+func init() {
+	proto.RegisterFile("networking/v1beta1/service_subscription_list.proto", fileDescriptor_7087ab823a7e505e)
+}
+
+var fileDescriptor_7087ab823a7e505e = []byte{
+	// 399 bytes of a gzipped FileDescriptorProto
+	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x92, 0xc1, 0x8a, 0xd3, 0x40,
+	0x1c, 0xc6, 0x9d, 0x64, 0x5b, 0xed, 0xbf, 0xae, 0x84, 0x51, 0x70, 0xe8, 0x21, 0x86, 0x9e, 0x7a,
+	0xd9, 0x84, 0x8d, 0x97, 0x5d, 0xf1, 0xa2, 0x4b, 0x95, 0x85, 0xa5, 0xad, 0x13, 0xe8, 0x41, 0x84,
+	0x92, 0x94, 0xa1, 0x0e, 0x8d, 0x99, 0x30, 0x33, 0x49, 0xe9, 0x0b, 0xf8, 0x4e, 0xbe, 0x81, 0x47,
+	0x1f, 0x41, 0xfa, 0x24, 0x92, 0x49, 0x6c, 0x23, 0xb6, 0x87, 0xde, 0xf2, 0xfd, 0x33, 0xff, 0xdf,
+	0x37, 0xdf, 0xc7, 0x40, 0x98, 0x31, 0xbd, 0x11, 0x72, 0xcd, 0xb3, 0x55, 0x50, 0x5e, 0x27, 0x4c,
+	0xc7, 0xd7, 0x81, 0x62, 0xb2, 0xe4, 0x4b, 0xb6, 0x50, 0x45, 0xa2, 0x96, 0x92, 0xe7, 0x9a, 0x8b,
+	0x6c, 0x91, 0x72, 0xa5, 0xfd, 0x5c, 0x0a, 0x2d, 0x30, 0xe1, 0x4a, 0x73, 0xe1, 0x1f, 0x36, 0xfd,
+	0x66, 0x73, 0xe0, 0x1d, 0xa1, 0xad, 0x62, 0xcd, 0x36, 0xf1, 0xb6, 0xde, 0x1d, 0x7e, 0xb7, 0xe0,
+	0x65, 0x54, 0xf3, 0xa3, 0x16, 0xfe, 0x81, 0x2b, 0x8d, 0xbf, 0x00, 0x48, 0xa6, 0x44, 0x5a, 0x54,
+	0x13, 0x82, 0x3c, 0x34, 0x7a, 0x16, 0xbe, 0xf5, 0x4f, 0x99, 0xf9, 0x27, 0x30, 0x3e, 0xdd, 0x33,
+	0x68, 0x8b, 0x87, 0x23, 0xb8, 0x6c, 0x07, 0x52, 0xc4, 0xf2, 0xec, 0x51, 0x3f, 0xbc, 0x3a, 0xcb,
+	0x80, 0xfe, 0xcb, 0x18, 0xde, 0x00, 0x1c, 0xec, 0xb0, 0x03, 0x4f, 0xef, 0xa6, 0x93, 0x0f, 0xf7,
+	0x1f, 0xa3, 0x31, 0x9d, 0x8f, 0xa9, 0xf3, 0x08, 0x5f, 0x42, 0x6f, 0x7e, 0x3f, 0x6b, 0x24, 0xc2,
+	0x3d, 0xe8, 0x4c, 0xde, 0xdd, 0x4d, 0x23, 0xc7, 0x1a, 0xfe, 0xb0, 0xe0, 0xf9, 0x11, 0x03, 0x3c,
+	0x80, 0x27, 0x5f, 0x85, 0xd2, 0x59, 0xfc, 0x8d, 0x99, 0x0a, 0x7a, 0x74, 0xaf, 0x31, 0x81, 0xc7,
+	0x25, 0x93, 0xaa, 0x6a, 0xc7, 0x32, 0xbf, 0xfe, 0x4a, 0xfc, 0x02, 0x3a, 0x2b, 0x29, 0x8a, 0x9c,
+	0xd8, 0x66, 0x5e, 0x0b, 0x1c, 0xc2, 0x45, 0x2e, 0xa4, 0x26, 0x17, 0x1e, 0x1a, 0xf5, 0x43, 0xf7,
+	0x74, 0xd2, 0x99, 0x90, 0x9a, 0x9a, 0xb3, 0x15, 0xa9, 0xc8, 0xb8, 0x56, 0xa4, 0xe3, 0xd9, 0x15,
+	0xc9, 0x08, 0xfc, 0x09, 0xba, 0x69, 0x9c, 0xb0, 0x54, 0x91, 0xae, 0x69, 0xed, 0xf6, 0xac, 0xd6,
+	0xfc, 0x07, 0xb3, 0x3b, 0xce, 0xb4, 0xdc, 0xd2, 0x06, 0x34, 0xb8, 0x85, 0x7e, 0x6b, 0x8c, 0x1d,
+	0xb0, 0xd7, 0x6c, 0xdb, 0x44, 0xae, 0x3e, 0xab, 0x9b, 0x94, 0x71, 0x5a, 0xb0, 0x26, 0x6b, 0x2d,
+	0xde, 0x58, 0x37, 0xe8, 0xfd, 0xd5, 0xcf, 0x9d, 0x8b, 0x7e, 0xed, 0x5c, 0xf4, 0x7b, 0xe7, 0xa2,
+	0xcf, 0xaf, 0xea, 0xab, 0x70, 0x11, 0xc4, 0x39, 0x0f, 0xfe, 0x7f, 0x81, 0x49, 0xd7, 0x3c, 0xbd,
+	0xd7, 0x7f, 0x02, 0x00, 0x00, 0xff, 0xff, 0xad, 0xc4, 0xe9, 0x05, 0xec, 0x02, 0x00, 0x00,
+}
+
+func (m *ServiceSubscriptionList) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *ServiceSubscriptionList) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *ServiceSubscriptionList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
+	var l int
+	_ = l
+	if m.XXX_unrecognized != nil {
+		i -= len(m.XXX_unrecognized)
+		copy(dAtA[i:], m.XXX_unrecognized)
+	}
+	if len(m.Subscriptions) > 0 {
+		for iNdEx := len(m.Subscriptions) - 1; iNdEx >= 0; iNdEx-- {
+			{
+				size, err := m.Subscriptions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
+				if err != nil {
+					return 0, err
+				}
+				i -= size
+				i = encodeVarintServiceSubscriptionList(dAtA, i, uint64(size))
+			}
+			i--
+			dAtA[i] = 0x12
+		}
+	}
+	if m.Resolution != 0 {
+		i = encodeVarintServiceSubscriptionList(dAtA, i, uint64(m.Resolution))
+		i--
+		dAtA[i] = 0x8
+	}
+	return len(dAtA) - i, nil
+}
+
+func (m *ServiceSubscription) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *ServiceSubscription) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *ServiceSubscription) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
+	var l int
+	_ = l
+	if m.XXX_unrecognized != nil {
+		i -= len(m.XXX_unrecognized)
+		copy(dAtA[i:], m.XXX_unrecognized)
+	}
+	if len(m.Labels) > 0 {
+		for k := range m.Labels {
+			v := m.Labels[k]
+			baseI := i
+			i -= len(v)
+			copy(dAtA[i:], v)
+			i = encodeVarintServiceSubscriptionList(dAtA, i, uint64(len(v)))
+			i--
+			dAtA[i] = 0x12
+			i -= len(k)
+			copy(dAtA[i:], k)
+			i = encodeVarintServiceSubscriptionList(dAtA, i, uint64(len(k)))
+			i--
+			dAtA[i] = 0xa
+			i = encodeVarintServiceSubscriptionList(dAtA, i, uint64(baseI-i))
+			i--
+			dAtA[i] = 0x32
+		}
+	}
+	if len(m.Units) > 0 {
+		for iNdEx := len(m.Units) - 1; iNdEx >= 0; iNdEx-- {
+			i -= len(m.Units[iNdEx])
+			copy(dAtA[i:], m.Units[iNdEx])
+			i = encodeVarintServiceSubscriptionList(dAtA, i, uint64(len(m.Units[iNdEx])))
+			i--
+			dAtA[i] = 0x2a
+		}
+	}
+	if m.Port != nil {
+		{
+			size, err := m.Port.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintServiceSubscriptionList(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x22
+	}
+	if len(m.Group) > 0 {
+		i -= len(m.Group)
+		copy(dAtA[i:], m.Group)
+		i = encodeVarintServiceSubscriptionList(dAtA, i, uint64(len(m.Group)))
+		i--
+		dAtA[i] = 0x1a
+	}
+	if len(m.Version) > 0 {
+		i -= len(m.Version)
+		copy(dAtA[i:], m.Version)
+		i = encodeVarintServiceSubscriptionList(dAtA, i, uint64(len(m.Version)))
+		i--
+		dAtA[i] = 0x12
+	}
+	if len(m.Hostname) > 0 {
+		i -= len(m.Hostname)
+		copy(dAtA[i:], m.Hostname)
+		i = encodeVarintServiceSubscriptionList(dAtA, i, uint64(len(m.Hostname)))
+		i--
+		dAtA[i] = 0xa
+	}
+	return len(dAtA) - i, nil
+}
+
+func encodeVarintServiceSubscriptionList(dAtA []byte, offset int, v uint64) int {
+	offset -= sovServiceSubscriptionList(v)
+	base := offset
+	for v >= 1<<7 {
+		dAtA[offset] = uint8(v&0x7f | 0x80)
+		v >>= 7
+		offset++
+	}
+	dAtA[offset] = uint8(v)
+	return base
+}
+func (m *ServiceSubscriptionList) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if m.Resolution != 0 {
+		n += 1 + sovServiceSubscriptionList(uint64(m.Resolution))
+	}
+	if len(m.Subscriptions) > 0 {
+		for _, e := range m.Subscriptions {
+			l = e.Size()
+			n += 1 + l + sovServiceSubscriptionList(uint64(l))
+		}
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *ServiceSubscription) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	l = len(m.Hostname)
+	if l > 0 {
+		n += 1 + l + sovServiceSubscriptionList(uint64(l))
+	}
+	l = len(m.Version)
+	if l > 0 {
+		n += 1 + l + sovServiceSubscriptionList(uint64(l))
+	}
+	l = len(m.Group)
+	if l > 0 {
+		n += 1 + l + sovServiceSubscriptionList(uint64(l))
+	}
+	if m.Port != nil {
+		l = m.Port.Size()
+		n += 1 + l + sovServiceSubscriptionList(uint64(l))
+	}
+	if len(m.Units) > 0 {
+		for _, s := range m.Units {
+			l = len(s)
+			n += 1 + l + sovServiceSubscriptionList(uint64(l))
+		}
+	}
+	if len(m.Labels) > 0 {
+		for k, v := range m.Labels {
+			_ = k
+			_ = v
+			mapEntrySize := 1 + len(k) + sovServiceSubscriptionList(uint64(len(k))) + 1 + len(v) + sovServiceSubscriptionList(uint64(len(v)))
+			n += mapEntrySize + 1 + sovServiceSubscriptionList(uint64(mapEntrySize))
+		}
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func sovServiceSubscriptionList(x uint64) (n int) {
+	return (math_bits.Len64(x|1) + 6) / 7
+}
+func sozServiceSubscriptionList(x uint64) (n int) {
+	return sovServiceSubscriptionList(uint64((x << 1) ^ uint64((int64(x) >> 63))))
+}
+func (m *ServiceSubscriptionList) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowServiceSubscriptionList
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: ServiceSubscriptionList: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: ServiceSubscriptionList: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Resolution", wireType)
+			}
+			m.Resolution = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowServiceSubscriptionList
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.Resolution |= ServiceSubscriptionList_Resolution(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Subscriptions", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowServiceSubscriptionList
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthServiceSubscriptionList
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthServiceSubscriptionList
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Subscriptions = append(m.Subscriptions, &ServiceSubscription{})
+			if err := m.Subscriptions[len(m.Subscriptions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipServiceSubscriptionList(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthServiceSubscriptionList
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *ServiceSubscription) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowServiceSubscriptionList
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: ServiceSubscription: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: ServiceSubscription: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowServiceSubscriptionList
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthServiceSubscriptionList
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthServiceSubscriptionList
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Hostname = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowServiceSubscriptionList
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthServiceSubscriptionList
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthServiceSubscriptionList
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Version = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 3:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowServiceSubscriptionList
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthServiceSubscriptionList
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthServiceSubscriptionList
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Group = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 4:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowServiceSubscriptionList
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthServiceSubscriptionList
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthServiceSubscriptionList
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.Port == nil {
+				m.Port = &Port{}
+			}
+			if err := m.Port.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 5:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Units", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowServiceSubscriptionList
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthServiceSubscriptionList
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthServiceSubscriptionList
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Units = append(m.Units, string(dAtA[iNdEx:postIndex]))
+			iNdEx = postIndex
+		case 6:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowServiceSubscriptionList
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthServiceSubscriptionList
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthServiceSubscriptionList
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.Labels == nil {
+				m.Labels = make(map[string]string)
+			}
+			var mapkey string
+			var mapvalue string
+			for iNdEx < postIndex {
+				entryPreIndex := iNdEx
+				var wire uint64
+				for shift := uint(0); ; shift += 7 {
+					if shift >= 64 {
+						return ErrIntOverflowServiceSubscriptionList
+					}
+					if iNdEx >= l {
+						return io.ErrUnexpectedEOF
+					}
+					b := dAtA[iNdEx]
+					iNdEx++
+					wire |= uint64(b&0x7F) << shift
+					if b < 0x80 {
+						break
+					}
+				}
+				fieldNum := int32(wire >> 3)
+				if fieldNum == 1 {
+					var stringLenmapkey uint64
+					for shift := uint(0); ; shift += 7 {
+						if shift >= 64 {
+							return ErrIntOverflowServiceSubscriptionList
+						}
+						if iNdEx >= l {
+							return io.ErrUnexpectedEOF
+						}
+						b := dAtA[iNdEx]
+						iNdEx++
+						stringLenmapkey |= uint64(b&0x7F) << shift
+						if b < 0x80 {
+							break
+						}
+					}
+					intStringLenmapkey := int(stringLenmapkey)
+					if intStringLenmapkey < 0 {
+						return ErrInvalidLengthServiceSubscriptionList
+					}
+					postStringIndexmapkey := iNdEx + intStringLenmapkey
+					if postStringIndexmapkey < 0 {
+						return ErrInvalidLengthServiceSubscriptionList
+					}
+					if postStringIndexmapkey > l {
+						return io.ErrUnexpectedEOF
+					}
+					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
+					iNdEx = postStringIndexmapkey
+				} else if fieldNum == 2 {
+					var stringLenmapvalue uint64
+					for shift := uint(0); ; shift += 7 {
+						if shift >= 64 {
+							return ErrIntOverflowServiceSubscriptionList
+						}
+						if iNdEx >= l {
+							return io.ErrUnexpectedEOF
+						}
+						b := dAtA[iNdEx]
+						iNdEx++
+						stringLenmapvalue |= uint64(b&0x7F) << shift
+						if b < 0x80 {
+							break
+						}
+					}
+					intStringLenmapvalue := int(stringLenmapvalue)
+					if intStringLenmapvalue < 0 {
+						return ErrInvalidLengthServiceSubscriptionList
+					}
+					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
+					if postStringIndexmapvalue < 0 {
+						return ErrInvalidLengthServiceSubscriptionList
+					}
+					if postStringIndexmapvalue > l {
+						return io.ErrUnexpectedEOF
+					}
+					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
+					iNdEx = postStringIndexmapvalue
+				} else {
+					iNdEx = entryPreIndex
+					skippy, err := skipServiceSubscriptionList(dAtA[iNdEx:])
+					if err != nil {
+						return err
+					}
+					if (skippy < 0) || (iNdEx+skippy) < 0 {
+						return ErrInvalidLengthServiceSubscriptionList
+					}
+					if (iNdEx + skippy) > postIndex {
+						return io.ErrUnexpectedEOF
+					}
+					iNdEx += skippy
+				}
+			}
+			m.Labels[mapkey] = mapvalue
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipServiceSubscriptionList(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthServiceSubscriptionList
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func skipServiceSubscriptionList(dAtA []byte) (n int, err error) {
+	l := len(dAtA)
+	iNdEx := 0
+	depth := 0
+	for iNdEx < l {
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return 0, ErrIntOverflowServiceSubscriptionList
+			}
+			if iNdEx >= l {
+				return 0, io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= (uint64(b) & 0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		wireType := int(wire & 0x7)
+		switch wireType {
+		case 0:
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return 0, ErrIntOverflowServiceSubscriptionList
+				}
+				if iNdEx >= l {
+					return 0, io.ErrUnexpectedEOF
+				}
+				iNdEx++
+				if dAtA[iNdEx-1] < 0x80 {
+					break
+				}
+			}
+		case 1:
+			iNdEx += 8
+		case 2:
+			var length int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return 0, ErrIntOverflowServiceSubscriptionList
+				}
+				if iNdEx >= l {
+					return 0, io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				length |= (int(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if length < 0 {
+				return 0, ErrInvalidLengthServiceSubscriptionList
+			}
+			iNdEx += length
+		case 3:
+			depth++
+		case 4:
+			if depth == 0 {
+				return 0, ErrUnexpectedEndOfGroupServiceSubscriptionList
+			}
+			depth--
+		case 5:
+			iNdEx += 4
+		default:
+			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
+		}
+		if iNdEx < 0 {
+			return 0, ErrInvalidLengthServiceSubscriptionList
+		}
+		if depth == 0 {
+			return iNdEx, nil
+		}
+	}
+	return 0, io.ErrUnexpectedEOF
+}
+
+var (
+	ErrInvalidLengthServiceSubscriptionList        = fmt.Errorf("proto: negative length found during unmarshaling")
+	ErrIntOverflowServiceSubscriptionList          = fmt.Errorf("proto: integer overflow")
+	ErrUnexpectedEndOfGroupServiceSubscriptionList = fmt.Errorf("proto: unexpected end of group")
+)
diff --git a/networking/v1beta1/service_subscription_list.proto b/networking/v1beta1/service_subscription_list.proto
new file mode 100644
index 00000000..a3f014a8
--- /dev/null
+++ b/networking/v1beta1/service_subscription_list.proto
@@ -0,0 +1,44 @@
+syntax = "proto3";
+
+package istio.networking.v1beta1;
+
+import "networking/v1beta1/gateway.proto";
+
+option go_package = "istio.io/api/networking/v1beta1";
+
+// <!-- crd generation tags
+// +cue-gen:ServiceSubscriptionList:groupName:networking.istio.io
+// +cue-gen:ServiceSubscriptionList:version:v1beta1
+// +cue-gen:ServiceSubscriptionList:annotations:helm.sh/resource-policy=keep
+// +cue-gen:ServiceSubscriptionList:labels:app=istio-pilot,chart=istio,heritage=Tiller,release=istio
+// +cue-gen:ServiceSubscriptionList:subresource:status
+// +cue-gen:ServiceSubscriptionList:scope:Namespaced
+// +cue-gen:ServiceSubscriptionList:resource:categories=istio-io,networking-istio-io
+// +cue-gen:ServiceSubscriptionList:preserveUnknownFields:false
+// -->
+//
+// <!-- go code generation tags
+// +kubetype-gen
+// +kubetype-gen:groupVersion=networking.istio.io/v1beta1
+// +genclient
+// +k8s:deepcopy-gen=true
+// -->
+message ServiceSubscriptionList {
+  enum Resolution {
+    CONFIGSERVER = 0;
+    VIPSERVER = 1;
+    NACOS = 2;
+  };
+
+  Resolution resolution = 1;
+  repeated ServiceSubscription subscriptions = 2;
+}
+
+message ServiceSubscription {
+  string hostname = 1;
+  string version = 2;
+  string group = 3;
+  Port port = 4;
+  repeated string units = 5;
+  map<string, string> labels = 6;
+}
\ No newline at end of file
diff --git a/networking/v1beta1/service_subscription_list_deepcopy.gen.go b/networking/v1beta1/service_subscription_list_deepcopy.gen.go
new file mode 100644
index 00000000..a7652223
--- /dev/null
+++ b/networking/v1beta1/service_subscription_list_deepcopy.gen.go
@@ -0,0 +1,57 @@
+// Code generated by protoc-gen-gogo. DO NOT EDIT.
+// source: networking/v1beta1/service_subscription_list.proto
+
+package v1beta1
+
+import (
+	fmt "fmt"
+	proto "github.com/gogo/protobuf/proto"
+	math "math"
+)
+
+// Reference imports to suppress errors if they are not otherwise used.
+var _ = proto.Marshal
+var _ = fmt.Errorf
+var _ = math.Inf
+
+// DeepCopyInto supports using ServiceSubscriptionList within kubernetes types, where deepcopy-gen is used.
+func (in *ServiceSubscriptionList) DeepCopyInto(out *ServiceSubscriptionList) {
+	p := proto.Clone(in).(*ServiceSubscriptionList)
+	*out = *p
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceSubscriptionList. Required by controller-gen.
+func (in *ServiceSubscriptionList) DeepCopy() *ServiceSubscriptionList {
+	if in == nil {
+		return nil
+	}
+	out := new(ServiceSubscriptionList)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInterface is an autogenerated deepcopy function, copying the receiver, creating a new ServiceSubscriptionList. Required by controller-gen.
+func (in *ServiceSubscriptionList) DeepCopyInterface() interface{} {
+	return in.DeepCopy()
+}
+
+// DeepCopyInto supports using ServiceSubscription within kubernetes types, where deepcopy-gen is used.
+func (in *ServiceSubscription) DeepCopyInto(out *ServiceSubscription) {
+	p := proto.Clone(in).(*ServiceSubscription)
+	*out = *p
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceSubscription. Required by controller-gen.
+func (in *ServiceSubscription) DeepCopy() *ServiceSubscription {
+	if in == nil {
+		return nil
+	}
+	out := new(ServiceSubscription)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInterface is an autogenerated deepcopy function, copying the receiver, creating a new ServiceSubscription. Required by controller-gen.
+func (in *ServiceSubscription) DeepCopyInterface() interface{} {
+	return in.DeepCopy()
+}
diff --git a/networking/v1beta1/service_subscription_list_json.gen.go b/networking/v1beta1/service_subscription_list_json.gen.go
new file mode 100644
index 00000000..d6d2a8c2
--- /dev/null
+++ b/networking/v1beta1/service_subscription_list_json.gen.go
@@ -0,0 +1,44 @@
+// Code generated by protoc-gen-gogo. DO NOT EDIT.
+// source: networking/v1beta1/service_subscription_list.proto
+
+package v1beta1
+
+import (
+	bytes "bytes"
+	fmt "fmt"
+	github_com_gogo_protobuf_jsonpb "github.com/gogo/protobuf/jsonpb"
+	proto "github.com/gogo/protobuf/proto"
+	math "math"
+)
+
+// Reference imports to suppress errors if they are not otherwise used.
+var _ = proto.Marshal
+var _ = fmt.Errorf
+var _ = math.Inf
+
+// MarshalJSON is a custom marshaler for ServiceSubscriptionList
+func (this *ServiceSubscriptionList) MarshalJSON() ([]byte, error) {
+	str, err := ServiceSubscriptionListMarshaler.MarshalToString(this)
+	return []byte(str), err
+}
+
+// UnmarshalJSON is a custom unmarshaler for ServiceSubscriptionList
+func (this *ServiceSubscriptionList) UnmarshalJSON(b []byte) error {
+	return ServiceSubscriptionListUnmarshaler.Unmarshal(bytes.NewReader(b), this)
+}
+
+// MarshalJSON is a custom marshaler for ServiceSubscription
+func (this *ServiceSubscription) MarshalJSON() ([]byte, error) {
+	str, err := ServiceSubscriptionListMarshaler.MarshalToString(this)
+	return []byte(str), err
+}
+
+// UnmarshalJSON is a custom unmarshaler for ServiceSubscription
+func (this *ServiceSubscription) UnmarshalJSON(b []byte) error {
+	return ServiceSubscriptionListUnmarshaler.Unmarshal(bytes.NewReader(b), this)
+}
+
+var (
+	ServiceSubscriptionListMarshaler   = &github_com_gogo_protobuf_jsonpb.Marshaler{}
+	ServiceSubscriptionListUnmarshaler = &github_com_gogo_protobuf_jsonpb.Unmarshaler{AllowUnknownFields: true}
+)
diff --git a/networking/v1beta1/virtual_service.gen.json b/networking/v1beta1/virtual_service.gen.json
index 82a477e8..3fc28690 100644
--- a/networking/v1beta1/virtual_service.gen.json
+++ b/networking/v1beta1/virtual_service.gen.json
@@ -88,6 +88,20 @@
           }
         }
       },
+      "istio.networking.v1beta1.HTTPDirectResponse": {
+        "description": "Added by ingress Return an arbitrary HTTP response directly, without proxying.",
+        "type": "object",
+        "properties": {
+          "responseCode": {
+            "description": "Response code for downstream client.",
+            "type": "integer"
+          },
+          "body": {
+            "description": "TODO Support filename, bytes or not",
+            "type": "string"
+          }
+        }
+      },
       "istio.networking.v1beta1.HTTPFaultInjection": {
         "description": "HTTPFaultInjection can be used to specify one or more faults to inject while forwarding HTTP requests to the destination specified in a route. Fault specification is part of a VirtualService rule. Faults include aborting the Http request from downstream service, and/or delaying proxying of requests. A fault rule MUST HAVE delay or abort or both.",
         "type": "object",
@@ -246,6 +260,234 @@
           }
         ]
       },
+      "istio.networking.v1beta1.HTTPFilter": {
+        "type": "object",
+        "properties": {
+          "name": {
+            "description": "The http filter name should be meaningful. E.g. ip-access-control, jwt, rbac, cors.",
+            "type": "string"
+          },
+          "disable": {
+            "description": "Disable this filter and all request will pass.",
+            "type": "boolean"
+          }
+        },
+        "oneOf": [
+          {
+            "not": {
+              "anyOf": [
+                {
+                  "required": [
+                    "ipAccessControl"
+                  ],
+                  "properties": {
+                    "ipAccessControl": {
+                      "$ref": "#/components/schemas/istio.networking.v1beta1.IPAccessControl"
+                    }
+                  }
+                },
+                {
+                  "required": [
+                    "localRateLimit"
+                  ],
+                  "properties": {
+                    "localRateLimit": {
+                      "$ref": "#/components/schemas/istio.networking.v1beta1.LocalRateLimit"
+                    }
+                  }
+                }
+              ]
+            }
+          },
+          {
+            "required": [
+              "ipAccessControl"
+            ],
+            "properties": {
+              "ipAccessControl": {
+                "$ref": "#/components/schemas/istio.networking.v1beta1.IPAccessControl"
+              }
+            }
+          },
+          {
+            "required": [
+              "localRateLimit"
+            ],
+            "properties": {
+              "localRateLimit": {
+                "$ref": "#/components/schemas/istio.networking.v1beta1.LocalRateLimit"
+              }
+            }
+          }
+        ]
+      },
+      "istio.networking.v1beta1.HTTPInternalActiveRedirect": {
+        "description": "More detail information, please see envoy document about InternalRedirectPolicy. The only difference is that this redirect policy allow user to specify how to control the redirect url.",
+        "type": "object",
+        "properties": {
+          "maxInternalRedirects": {
+            "type": "integer"
+          },
+          "redirectResponseCodes": {
+            "description": "Invalid code is in [200, 301, 302, 303, 304, 307, 308]",
+            "type": "array",
+            "items": {
+              "type": "integer"
+            }
+          },
+          "allowCrossScheme": {
+            "type": "boolean"
+          },
+          "headers": {
+            "$ref": "#/components/schemas/istio.networking.v1beta1.Headers"
+          },
+          "authority": {
+            "description": "During internal redirect, rewrite the Authority/Host header with this value.",
+            "type": "string"
+          },
+          "forcedUseOriginalHost": {
+            "description": "If true, the host name in the downstream request is used for redirection.",
+            "type": "boolean"
+          },
+          "forcedAddHeaderBeforeRouteMatcher": {
+            "type": "boolean"
+          },
+          "policies": {
+            "type": "array",
+            "items": {
+              "$ref": "#/components/schemas/istio.networking.v1beta1.HTTPInternalActiveRedirect.RedirectPolicy"
+            }
+          }
+        },
+        "oneOf": [
+          {
+            "not": {
+              "anyOf": [
+                {
+                  "required": [
+                    "redirectUrl"
+                  ],
+                  "properties": {
+                    "redirectUrl": {
+                      "type": "string"
+                    }
+                  }
+                },
+                {
+                  "required": [
+                    "redirectUrlRewriteRegex"
+                  ],
+                  "properties": {
+                    "redirectUrlRewriteRegex": {
+                      "$ref": "#/components/schemas/istio.networking.v1beta1.RegexMatchAndSubstitute"
+                    }
+                  }
+                }
+              ]
+            }
+          },
+          {
+            "required": [
+              "redirectUrl"
+            ],
+            "properties": {
+              "redirectUrl": {
+                "type": "string"
+              }
+            }
+          },
+          {
+            "required": [
+              "redirectUrlRewriteRegex"
+            ],
+            "properties": {
+              "redirectUrlRewriteRegex": {
+                "$ref": "#/components/schemas/istio.networking.v1beta1.RegexMatchAndSubstitute"
+              }
+            }
+          }
+        ]
+      },
+      "istio.networking.v1beta1.HTTPInternalActiveRedirect.RedirectPolicy": {
+        "type": "object",
+        "properties": {
+          "maxInternalRedirects": {
+            "type": "integer"
+          },
+          "redirectResponseCodes": {
+            "description": "Invalid code is in [200, 301, 302, 303, 304, 307, 308]",
+            "type": "array",
+            "items": {
+              "type": "integer"
+            }
+          },
+          "allowCrossScheme": {
+            "type": "boolean"
+          },
+          "headers": {
+            "$ref": "#/components/schemas/istio.networking.v1beta1.Headers"
+          },
+          "authority": {
+            "description": "During internal redirect, rewrite the Authority/Host header with this value.",
+            "type": "string"
+          },
+          "forcedUseOriginalHost": {
+            "description": "If true, the host name in the downstream request is used for redirection.",
+            "type": "boolean"
+          },
+          "forcedAddHeaderBeforeRouteMatcher": {
+            "type": "boolean"
+          }
+        },
+        "oneOf": [
+          {
+            "not": {
+              "anyOf": [
+                {
+                  "required": [
+                    "redirectUrl"
+                  ],
+                  "properties": {
+                    "redirectUrl": {
+                      "type": "string"
+                    }
+                  }
+                },
+                {
+                  "required": [
+                    "redirectUrlRewriteRegex"
+                  ],
+                  "properties": {
+                    "redirectUrlRewriteRegex": {
+                      "$ref": "#/components/schemas/istio.networking.v1beta1.RegexMatchAndSubstitute"
+                    }
+                  }
+                }
+              ]
+            }
+          },
+          {
+            "required": [
+              "redirectUrl"
+            ],
+            "properties": {
+              "redirectUrl": {
+                "type": "string"
+              }
+            }
+          },
+          {
+            "required": [
+              "redirectUrlRewriteRegex"
+            ],
+            "properties": {
+              "redirectUrlRewriteRegex": {
+                "$ref": "#/components/schemas/istio.networking.v1beta1.RegexMatchAndSubstitute"
+              }
+            }
+          }
+        ]
+      },
       "istio.networking.v1beta1.HTTPMatchRequest": {
         "description": "HttpMatchRequest specifies a set of criterion to be met in order for the rule to be applied to the HTTP request. For example, the following restricts the rule to match only requests where the URL path starts with /ratings/v2/ and the request contains a custom `end-user` header with value `jason`.",
         "type": "object",
@@ -429,6 +671,9 @@
           "authority": {
             "description": "rewrite the Authority/Host header with this value.",
             "type": "string"
+          },
+          "uriRegex": {
+            "$ref": "#/components/schemas/istio.networking.v1beta1.RegexMatchAndSubstitute"
           }
         }
       },
@@ -454,9 +699,22 @@
               "$ref": "#/components/schemas/istio.networking.v1beta1.HTTPRouteDestination"
             }
           },
+          "routeHTTPFilters": {
+            "description": "HTTP Filters for route scope.",
+            "type": "array",
+            "items": {
+              "$ref": "#/components/schemas/istio.networking.v1beta1.HTTPFilter"
+            }
+          },
           "redirect": {
             "$ref": "#/components/schemas/istio.networking.v1beta1.HTTPRedirect"
           },
+          "internalActiveRedirect": {
+            "$ref": "#/components/schemas/istio.networking.v1beta1.HTTPInternalActiveRedirect"
+          },
+          "directResponse": {
+            "$ref": "#/components/schemas/istio.networking.v1beta1.HTTPDirectResponse"
+          },
           "delegate": {
             "$ref": "#/components/schemas/istio.networking.v1beta1.Delegate"
           },
@@ -507,6 +765,13 @@
           },
           "headers": {
             "$ref": "#/components/schemas/istio.networking.v1beta1.Headers"
+          },
+          "fallbackClusters": {
+            "description": "Added by ingress",
+            "type": "array",
+            "items": {
+              "$ref": "#/components/schemas/istio.networking.v1beta1.Destination"
+            }
           }
         }
       },
@@ -549,6 +814,25 @@
           }
         }
       },
+      "istio.networking.v1beta1.IPAccessControl": {
+        "type": "object",
+        "properties": {
+          "remoteIpBlocks": {
+            "description": "Used for white ip access control",
+            "type": "array",
+            "items": {
+              "type": "string"
+            }
+          },
+          "notRemoteIpBlocks": {
+            "description": "Used for black ip access control",
+            "type": "array",
+            "items": {
+              "type": "string"
+            }
+          }
+        }
+      },
       "istio.networking.v1beta1.L4MatchAttributes": {
         "description": "L4 connection match attributes. Note that L4 connection matching support is incomplete.",
         "type": "object",
@@ -588,6 +872,21 @@
           }
         }
       },
+      "istio.networking.v1beta1.LocalRateLimit": {
+        "type": "object",
+        "properties": {
+          "tokenBucket": {
+            "$ref": "#/components/schemas/istio.networking.v1beta1.TokenBucket"
+          },
+          "perDownstreamConnection": {
+            "type": "boolean"
+          },
+          "statusCode": {
+            "description": "Default rate limit status code is 429.",
+            "type": "integer"
+          }
+        }
+      },
       "istio.networking.v1beta1.Percent": {
         "description": "Percent specifies a percentage in the range of [0.0, 100.0].",
         "type": "object",
@@ -608,6 +907,20 @@
           }
         }
       },
+      "istio.networking.v1beta1.RegexMatchAndSubstitute": {
+        "description": "Describes how to match a string and then produce a new string using a regular expression and a substitution string.",
+        "type": "object",
+        "properties": {
+          "pattern": {
+            "description": "RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).",
+            "type": "string"
+          },
+          "substitution": {
+            "description": "The string that should be substituted into matching portions of the subject string during a substitution operation to produce a new string.",
+            "type": "string"
+          }
+        }
+      },
       "istio.networking.v1beta1.RouteDestination": {
         "description": "L4 routing rule weighted destination.",
         "type": "object",
@@ -782,6 +1095,20 @@
           }
         }
       },
+      "istio.networking.v1beta1.TokenBucket": {
+        "type": "object",
+        "properties": {
+          "maxTokens": {
+            "type": "integer"
+          },
+          "tokensPefFill": {
+            "type": "integer"
+          },
+          "fillInterval": {
+            "type": "string"
+          }
+        }
+      },
       "istio.networking.v1beta1.VirtualService": {
         "description": "Configuration affecting traffic routing.",
         "type": "object",
@@ -800,6 +1127,13 @@
               "type": "string"
             }
           },
+          "hostHTTPFilters": {
+            "description": "HTTP Filters for host scope.",
+            "type": "array",
+            "items": {
+              "$ref": "#/components/schemas/istio.networking.v1beta1.HTTPFilter"
+            }
+          },
           "http": {
             "description": "An ordered list of route rules for HTTP traffic. HTTP routes will be applied to platform service ports named 'http-*'/'http2-*'/'grpc-*', gateway ports with protocol HTTP/HTTP2/GRPC/ TLS-terminated-HTTPS and service entry ports using HTTP/HTTP2/GRPC protocols. The first rule matching an incoming request is used.",
             "type": "array",
diff --git a/networking/v1beta1/virtual_service.pb.go b/networking/v1beta1/virtual_service.pb.go
index 9433b94f..521c09c2 100644
--- a/networking/v1beta1/virtual_service.pb.go
+++ b/networking/v1beta1/virtual_service.pb.go
@@ -272,6 +272,8 @@ type VirtualService struct {
 	// rules will apply only to the gateways. To apply the rules to both
 	// gateways and sidecars, specify `mesh` as one of the gateway names.
 	Gateways []string `protobuf:"bytes,2,rep,name=gateways,proto3" json:"gateways,omitempty"`
+	// HTTP Filters for host scope.
+	HostHTTPFilters []*HTTPFilter `protobuf:"bytes,1000,rep,name=hostHTTPFilters,proto3" json:"hostHTTPFilters,omitempty"`
 	// An ordered list of route rules for HTTP traffic. HTTP routes will be
 	// applied to platform service ports named 'http-*'/'http2-*'/'grpc-*', gateway
 	// ports with protocol HTTP/HTTP2/GRPC/ TLS-terminated-HTTPS and service
@@ -357,6 +359,13 @@ func (m *VirtualService) GetGateways() []string {
 	return nil
 }
 
+func (m *VirtualService) GetHostHTTPFilters() []*HTTPFilter {
+	if m != nil {
+		return m.HostHTTPFilters
+	}
+	return nil
+}
+
 func (m *VirtualService) GetHttp() []*HTTPRoute {
 	if m != nil {
 		return m.Http
@@ -727,11 +736,20 @@ type HTTPRoute struct {
 	// glossary in beginning of document). Weights associated with the
 	// service version determine the proportion of traffic it receives.
 	Route []*HTTPRouteDestination `protobuf:"bytes,2,rep,name=route,proto3" json:"route,omitempty"`
+	// HTTP Filters for route scope.
+	RouteHTTPFilters []*HTTPFilter `protobuf:"bytes,1000,rep,name=routeHTTPFilters,proto3" json:"routeHTTPFilters,omitempty"`
 	// A HTTP rule can either redirect or forward (default) traffic. If
 	// traffic passthrough option is specified in the rule,
 	// route/redirect will be ignored. The redirect primitive can be used to
 	// send a HTTP 301 redirect to a different URI or Authority.
 	Redirect *HTTPRedirect `protobuf:"bytes,3,opt,name=redirect,proto3" json:"redirect,omitempty"`
+	// Added by ingress
+	// This policy will trigger an internal redirect according to the response code
+	// without notifying downstream.
+	InternalActiveRedirect *HTTPInternalActiveRedirect `protobuf:"bytes,25,opt,name=internal_active_redirect,json=internalActiveRedirect,proto3" json:"internal_active_redirect,omitempty"`
+	// Added by ingress
+	// Return an arbitrary HTTP response directly, without proxying.
+	DirectResponse *HTTPDirectResponse `protobuf:"bytes,26,opt,name=direct_response,json=directResponse,proto3" json:"direct_response,omitempty"`
 	// Delegate is used to specify the particular VirtualService which
 	// can be used to define delegate HTTPRoute.
 	//
@@ -837,6 +855,13 @@ func (m *HTTPRoute) GetRoute() []*HTTPRouteDestination {
 	return nil
 }
 
+func (m *HTTPRoute) GetRouteHTTPFilters() []*HTTPFilter {
+	if m != nil {
+		return m.RouteHTTPFilters
+	}
+	return nil
+}
+
 func (m *HTTPRoute) GetRedirect() *HTTPRedirect {
 	if m != nil {
 		return m.Redirect
@@ -844,6 +869,20 @@ func (m *HTTPRoute) GetRedirect() *HTTPRedirect {
 	return nil
 }
 
+func (m *HTTPRoute) GetInternalActiveRedirect() *HTTPInternalActiveRedirect {
+	if m != nil {
+		return m.InternalActiveRedirect
+	}
+	return nil
+}
+
+func (m *HTTPRoute) GetDirectResponse() *HTTPDirectResponse {
+	if m != nil {
+		return m.DirectResponse
+	}
+	return nil
+}
+
 func (m *HTTPRoute) GetDelegate() *Delegate {
 	if m != nil {
 		return m.Delegate
@@ -1894,10 +1933,12 @@ type HTTPRouteDestination struct {
 	// be 100.
 	Weight int32 `protobuf:"varint,2,opt,name=weight,proto3" json:"weight,omitempty"`
 	// Header manipulation rules
-	Headers              *Headers `protobuf:"bytes,7,opt,name=headers,proto3" json:"headers,omitempty"`
-	XXX_NoUnkeyedLiteral struct{} `json:"-"`
-	XXX_unrecognized     []byte   `json:"-"`
-	XXX_sizecache        int32    `json:"-"`
+	Headers *Headers `protobuf:"bytes,7,opt,name=headers,proto3" json:"headers,omitempty"`
+	// Added by ingress
+	FallbackClusters     []*Destination `protobuf:"bytes,100,rep,name=fallback_clusters,json=fallbackClusters,proto3" json:"fallback_clusters,omitempty"`
+	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
+	XXX_unrecognized     []byte         `json:"-"`
+	XXX_sizecache        int32          `json:"-"`
 }
 
 func (m *HTTPRouteDestination) Reset()         { *m = HTTPRouteDestination{} }
@@ -1954,6 +1995,13 @@ func (m *HTTPRouteDestination) GetHeaders() *Headers {
 	return nil
 }
 
+func (m *HTTPRouteDestination) GetFallbackClusters() []*Destination {
+	if m != nil {
+		return m.FallbackClusters
+	}
+	return nil
+}
+
 // L4 routing rule weighted destination.
 type RouteDestination struct {
 	// Destination uniquely identifies the instances of a service
@@ -2409,6 +2457,379 @@ func (*HTTPRedirect) XXX_OneofWrappers() []interface{} {
 	}
 }
 
+// More detail information, please see envoy document about InternalRedirectPolicy.
+// The only difference is that this redirect policy allow user to specify how to control the redirect url.
+type HTTPInternalActiveRedirect struct {
+	MaxInternalRedirects uint32 `protobuf:"varint,1,opt,name=max_internal_redirects,json=maxInternalRedirects,proto3" json:"max_internal_redirects,omitempty"`
+	// Invalid code is in [200, 301, 302, 303, 304, 307, 308]
+	RedirectResponseCodes []uint32 `protobuf:"varint,2,rep,packed,name=redirect_response_codes,json=redirectResponseCodes,proto3" json:"redirect_response_codes,omitempty"`
+	// Types that are valid to be assigned to RedirectUrlRewriteSpecifier:
+	//	*HTTPInternalActiveRedirect_RedirectUrl
+	//	*HTTPInternalActiveRedirect_RedirectUrlRewriteRegex
+	RedirectUrlRewriteSpecifier isHTTPInternalActiveRedirect_RedirectUrlRewriteSpecifier `protobuf_oneof:"redirect_url_rewrite_specifier"`
+	AllowCrossScheme            bool                                                     `protobuf:"varint,5,opt,name=allow_cross_scheme,json=allowCrossScheme,proto3" json:"allow_cross_scheme,omitempty"`
+	// Currently, only support for the add operation for request header.
+	Headers *Headers `protobuf:"bytes,6,opt,name=headers,proto3" json:"headers,omitempty"`
+	// During internal redirect, rewrite the Authority/Host header with this value.
+	Authority string `protobuf:"bytes,7,opt,name=authority,proto3" json:"authority,omitempty"`
+	// If true, the host name in the downstream request is used for redirection.
+	ForcedUseOriginalHost             bool                                         `protobuf:"varint,16,opt,name=forced_use_original_host,json=forcedUseOriginalHost,proto3" json:"forced_use_original_host,omitempty"`
+	ForcedAddHeaderBeforeRouteMatcher bool                                         `protobuf:"varint,17,opt,name=forced_add_header_before_route_matcher,json=forcedAddHeaderBeforeRouteMatcher,proto3" json:"forced_add_header_before_route_matcher,omitempty"`
+	Policies                          []*HTTPInternalActiveRedirect_RedirectPolicy `protobuf:"bytes,15,rep,name=policies,proto3" json:"policies,omitempty"`
+	XXX_NoUnkeyedLiteral              struct{}                                     `json:"-"`
+	XXX_unrecognized                  []byte                                       `json:"-"`
+	XXX_sizecache                     int32                                        `json:"-"`
+}
+
+func (m *HTTPInternalActiveRedirect) Reset()         { *m = HTTPInternalActiveRedirect{} }
+func (m *HTTPInternalActiveRedirect) String() string { return proto.CompactTextString(m) }
+func (*HTTPInternalActiveRedirect) ProtoMessage()    {}
+func (*HTTPInternalActiveRedirect) Descriptor() ([]byte, []int) {
+	return fileDescriptor_8c56a442a0838fd7, []int{13}
+}
+func (m *HTTPInternalActiveRedirect) XXX_Unmarshal(b []byte) error {
+	return m.Unmarshal(b)
+}
+func (m *HTTPInternalActiveRedirect) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	if deterministic {
+		return xxx_messageInfo_HTTPInternalActiveRedirect.Marshal(b, m, deterministic)
+	} else {
+		b = b[:cap(b)]
+		n, err := m.MarshalToSizedBuffer(b)
+		if err != nil {
+			return nil, err
+		}
+		return b[:n], nil
+	}
+}
+func (m *HTTPInternalActiveRedirect) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_HTTPInternalActiveRedirect.Merge(m, src)
+}
+func (m *HTTPInternalActiveRedirect) XXX_Size() int {
+	return m.Size()
+}
+func (m *HTTPInternalActiveRedirect) XXX_DiscardUnknown() {
+	xxx_messageInfo_HTTPInternalActiveRedirect.DiscardUnknown(m)
+}
+
+var xxx_messageInfo_HTTPInternalActiveRedirect proto.InternalMessageInfo
+
+type isHTTPInternalActiveRedirect_RedirectUrlRewriteSpecifier interface {
+	isHTTPInternalActiveRedirect_RedirectUrlRewriteSpecifier()
+	MarshalTo([]byte) (int, error)
+	Size() int
+}
+
+type HTTPInternalActiveRedirect_RedirectUrl struct {
+	RedirectUrl string `protobuf:"bytes,3,opt,name=redirect_url,json=redirectUrl,proto3,oneof" json:"redirect_url,omitempty"`
+}
+type HTTPInternalActiveRedirect_RedirectUrlRewriteRegex struct {
+	RedirectUrlRewriteRegex *RegexMatchAndSubstitute `protobuf:"bytes,4,opt,name=redirect_url_rewrite_regex,json=redirectUrlRewriteRegex,proto3,oneof" json:"redirect_url_rewrite_regex,omitempty"`
+}
+
+func (*HTTPInternalActiveRedirect_RedirectUrl) isHTTPInternalActiveRedirect_RedirectUrlRewriteSpecifier() {
+}
+func (*HTTPInternalActiveRedirect_RedirectUrlRewriteRegex) isHTTPInternalActiveRedirect_RedirectUrlRewriteSpecifier() {
+}
+
+func (m *HTTPInternalActiveRedirect) GetRedirectUrlRewriteSpecifier() isHTTPInternalActiveRedirect_RedirectUrlRewriteSpecifier {
+	if m != nil {
+		return m.RedirectUrlRewriteSpecifier
+	}
+	return nil
+}
+
+func (m *HTTPInternalActiveRedirect) GetMaxInternalRedirects() uint32 {
+	if m != nil {
+		return m.MaxInternalRedirects
+	}
+	return 0
+}
+
+func (m *HTTPInternalActiveRedirect) GetRedirectResponseCodes() []uint32 {
+	if m != nil {
+		return m.RedirectResponseCodes
+	}
+	return nil
+}
+
+func (m *HTTPInternalActiveRedirect) GetRedirectUrl() string {
+	if x, ok := m.GetRedirectUrlRewriteSpecifier().(*HTTPInternalActiveRedirect_RedirectUrl); ok {
+		return x.RedirectUrl
+	}
+	return ""
+}
+
+func (m *HTTPInternalActiveRedirect) GetRedirectUrlRewriteRegex() *RegexMatchAndSubstitute {
+	if x, ok := m.GetRedirectUrlRewriteSpecifier().(*HTTPInternalActiveRedirect_RedirectUrlRewriteRegex); ok {
+		return x.RedirectUrlRewriteRegex
+	}
+	return nil
+}
+
+func (m *HTTPInternalActiveRedirect) GetAllowCrossScheme() bool {
+	if m != nil {
+		return m.AllowCrossScheme
+	}
+	return false
+}
+
+func (m *HTTPInternalActiveRedirect) GetHeaders() *Headers {
+	if m != nil {
+		return m.Headers
+	}
+	return nil
+}
+
+func (m *HTTPInternalActiveRedirect) GetAuthority() string {
+	if m != nil {
+		return m.Authority
+	}
+	return ""
+}
+
+func (m *HTTPInternalActiveRedirect) GetForcedUseOriginalHost() bool {
+	if m != nil {
+		return m.ForcedUseOriginalHost
+	}
+	return false
+}
+
+func (m *HTTPInternalActiveRedirect) GetForcedAddHeaderBeforeRouteMatcher() bool {
+	if m != nil {
+		return m.ForcedAddHeaderBeforeRouteMatcher
+	}
+	return false
+}
+
+func (m *HTTPInternalActiveRedirect) GetPolicies() []*HTTPInternalActiveRedirect_RedirectPolicy {
+	if m != nil {
+		return m.Policies
+	}
+	return nil
+}
+
+// XXX_OneofWrappers is for the internal use of the proto package.
+func (*HTTPInternalActiveRedirect) XXX_OneofWrappers() []interface{} {
+	return []interface{}{
+		(*HTTPInternalActiveRedirect_RedirectUrl)(nil),
+		(*HTTPInternalActiveRedirect_RedirectUrlRewriteRegex)(nil),
+	}
+}
+
+type HTTPInternalActiveRedirect_RedirectPolicy struct {
+	MaxInternalRedirects uint32 `protobuf:"varint,8,opt,name=max_internal_redirects,json=maxInternalRedirects,proto3" json:"max_internal_redirects,omitempty"`
+	// Invalid code is in [200, 301, 302, 303, 304, 307, 308]
+	RedirectResponseCodes []uint32 `protobuf:"varint,9,rep,packed,name=redirect_response_codes,json=redirectResponseCodes,proto3" json:"redirect_response_codes,omitempty"`
+	// Types that are valid to be assigned to RedirectUrlRewriteSpecifier:
+	//	*HTTPInternalActiveRedirect_RedirectPolicy_RedirectUrl
+	//	*HTTPInternalActiveRedirect_RedirectPolicy_RedirectUrlRewriteRegex
+	RedirectUrlRewriteSpecifier isHTTPInternalActiveRedirect_RedirectPolicy_RedirectUrlRewriteSpecifier `protobuf_oneof:"redirect_url_rewrite_specifier"`
+	AllowCrossScheme            bool                                                                    `protobuf:"varint,12,opt,name=allow_cross_scheme,json=allowCrossScheme,proto3" json:"allow_cross_scheme,omitempty"`
+	// Currently, only support for the add operation for request header.
+	Headers *Headers `protobuf:"bytes,13,opt,name=headers,proto3" json:"headers,omitempty"`
+	// During internal redirect, rewrite the Authority/Host header with this value.
+	Authority string `protobuf:"bytes,14,opt,name=authority,proto3" json:"authority,omitempty"`
+	// If true, the host name in the downstream request is used for redirection.
+	ForcedUseOriginalHost             bool     `protobuf:"varint,17,opt,name=forced_use_original_host,json=forcedUseOriginalHost,proto3" json:"forced_use_original_host,omitempty"`
+	ForcedAddHeaderBeforeRouteMatcher bool     `protobuf:"varint,18,opt,name=forced_add_header_before_route_matcher,json=forcedAddHeaderBeforeRouteMatcher,proto3" json:"forced_add_header_before_route_matcher,omitempty"`
+	XXX_NoUnkeyedLiteral              struct{} `json:"-"`
+	XXX_unrecognized                  []byte   `json:"-"`
+	XXX_sizecache                     int32    `json:"-"`
+}
+
+func (m *HTTPInternalActiveRedirect_RedirectPolicy) Reset() {
+	*m = HTTPInternalActiveRedirect_RedirectPolicy{}
+}
+func (m *HTTPInternalActiveRedirect_RedirectPolicy) String() string {
+	return proto.CompactTextString(m)
+}
+func (*HTTPInternalActiveRedirect_RedirectPolicy) ProtoMessage() {}
+func (*HTTPInternalActiveRedirect_RedirectPolicy) Descriptor() ([]byte, []int) {
+	return fileDescriptor_8c56a442a0838fd7, []int{13, 0}
+}
+func (m *HTTPInternalActiveRedirect_RedirectPolicy) XXX_Unmarshal(b []byte) error {
+	return m.Unmarshal(b)
+}
+func (m *HTTPInternalActiveRedirect_RedirectPolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	if deterministic {
+		return xxx_messageInfo_HTTPInternalActiveRedirect_RedirectPolicy.Marshal(b, m, deterministic)
+	} else {
+		b = b[:cap(b)]
+		n, err := m.MarshalToSizedBuffer(b)
+		if err != nil {
+			return nil, err
+		}
+		return b[:n], nil
+	}
+}
+func (m *HTTPInternalActiveRedirect_RedirectPolicy) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_HTTPInternalActiveRedirect_RedirectPolicy.Merge(m, src)
+}
+func (m *HTTPInternalActiveRedirect_RedirectPolicy) XXX_Size() int {
+	return m.Size()
+}
+func (m *HTTPInternalActiveRedirect_RedirectPolicy) XXX_DiscardUnknown() {
+	xxx_messageInfo_HTTPInternalActiveRedirect_RedirectPolicy.DiscardUnknown(m)
+}
+
+var xxx_messageInfo_HTTPInternalActiveRedirect_RedirectPolicy proto.InternalMessageInfo
+
+type isHTTPInternalActiveRedirect_RedirectPolicy_RedirectUrlRewriteSpecifier interface {
+	isHTTPInternalActiveRedirect_RedirectPolicy_RedirectUrlRewriteSpecifier()
+	MarshalTo([]byte) (int, error)
+	Size() int
+}
+
+type HTTPInternalActiveRedirect_RedirectPolicy_RedirectUrl struct {
+	RedirectUrl string `protobuf:"bytes,10,opt,name=redirect_url,json=redirectUrl,proto3,oneof" json:"redirect_url,omitempty"`
+}
+type HTTPInternalActiveRedirect_RedirectPolicy_RedirectUrlRewriteRegex struct {
+	RedirectUrlRewriteRegex *RegexMatchAndSubstitute `protobuf:"bytes,11,opt,name=redirect_url_rewrite_regex,json=redirectUrlRewriteRegex,proto3,oneof" json:"redirect_url_rewrite_regex,omitempty"`
+}
+
+func (*HTTPInternalActiveRedirect_RedirectPolicy_RedirectUrl) isHTTPInternalActiveRedirect_RedirectPolicy_RedirectUrlRewriteSpecifier() {
+}
+func (*HTTPInternalActiveRedirect_RedirectPolicy_RedirectUrlRewriteRegex) isHTTPInternalActiveRedirect_RedirectPolicy_RedirectUrlRewriteSpecifier() {
+}
+
+func (m *HTTPInternalActiveRedirect_RedirectPolicy) GetRedirectUrlRewriteSpecifier() isHTTPInternalActiveRedirect_RedirectPolicy_RedirectUrlRewriteSpecifier {
+	if m != nil {
+		return m.RedirectUrlRewriteSpecifier
+	}
+	return nil
+}
+
+func (m *HTTPInternalActiveRedirect_RedirectPolicy) GetMaxInternalRedirects() uint32 {
+	if m != nil {
+		return m.MaxInternalRedirects
+	}
+	return 0
+}
+
+func (m *HTTPInternalActiveRedirect_RedirectPolicy) GetRedirectResponseCodes() []uint32 {
+	if m != nil {
+		return m.RedirectResponseCodes
+	}
+	return nil
+}
+
+func (m *HTTPInternalActiveRedirect_RedirectPolicy) GetRedirectUrl() string {
+	if x, ok := m.GetRedirectUrlRewriteSpecifier().(*HTTPInternalActiveRedirect_RedirectPolicy_RedirectUrl); ok {
+		return x.RedirectUrl
+	}
+	return ""
+}
+
+func (m *HTTPInternalActiveRedirect_RedirectPolicy) GetRedirectUrlRewriteRegex() *RegexMatchAndSubstitute {
+	if x, ok := m.GetRedirectUrlRewriteSpecifier().(*HTTPInternalActiveRedirect_RedirectPolicy_RedirectUrlRewriteRegex); ok {
+		return x.RedirectUrlRewriteRegex
+	}
+	return nil
+}
+
+func (m *HTTPInternalActiveRedirect_RedirectPolicy) GetAllowCrossScheme() bool {
+	if m != nil {
+		return m.AllowCrossScheme
+	}
+	return false
+}
+
+func (m *HTTPInternalActiveRedirect_RedirectPolicy) GetHeaders() *Headers {
+	if m != nil {
+		return m.Headers
+	}
+	return nil
+}
+
+func (m *HTTPInternalActiveRedirect_RedirectPolicy) GetAuthority() string {
+	if m != nil {
+		return m.Authority
+	}
+	return ""
+}
+
+func (m *HTTPInternalActiveRedirect_RedirectPolicy) GetForcedUseOriginalHost() bool {
+	if m != nil {
+		return m.ForcedUseOriginalHost
+	}
+	return false
+}
+
+func (m *HTTPInternalActiveRedirect_RedirectPolicy) GetForcedAddHeaderBeforeRouteMatcher() bool {
+	if m != nil {
+		return m.ForcedAddHeaderBeforeRouteMatcher
+	}
+	return false
+}
+
+// XXX_OneofWrappers is for the internal use of the proto package.
+func (*HTTPInternalActiveRedirect_RedirectPolicy) XXX_OneofWrappers() []interface{} {
+	return []interface{}{
+		(*HTTPInternalActiveRedirect_RedirectPolicy_RedirectUrl)(nil),
+		(*HTTPInternalActiveRedirect_RedirectPolicy_RedirectUrlRewriteRegex)(nil),
+	}
+}
+
+// Added by ingress
+// Return an arbitrary HTTP response directly, without proxying.
+type HTTPDirectResponse struct {
+	// Response code for downstream client.
+	ResponseCode uint32 `protobuf:"varint,1,opt,name=response_code,json=responseCode,proto3" json:"response_code,omitempty"`
+	// TODO Support filename, bytes or not
+	Body                 string   `protobuf:"bytes,2,opt,name=body,proto3" json:"body,omitempty"`
+	XXX_NoUnkeyedLiteral struct{} `json:"-"`
+	XXX_unrecognized     []byte   `json:"-"`
+	XXX_sizecache        int32    `json:"-"`
+}
+
+func (m *HTTPDirectResponse) Reset()         { *m = HTTPDirectResponse{} }
+func (m *HTTPDirectResponse) String() string { return proto.CompactTextString(m) }
+func (*HTTPDirectResponse) ProtoMessage()    {}
+func (*HTTPDirectResponse) Descriptor() ([]byte, []int) {
+	return fileDescriptor_8c56a442a0838fd7, []int{14}
+}
+func (m *HTTPDirectResponse) XXX_Unmarshal(b []byte) error {
+	return m.Unmarshal(b)
+}
+func (m *HTTPDirectResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	if deterministic {
+		return xxx_messageInfo_HTTPDirectResponse.Marshal(b, m, deterministic)
+	} else {
+		b = b[:cap(b)]
+		n, err := m.MarshalToSizedBuffer(b)
+		if err != nil {
+			return nil, err
+		}
+		return b[:n], nil
+	}
+}
+func (m *HTTPDirectResponse) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_HTTPDirectResponse.Merge(m, src)
+}
+func (m *HTTPDirectResponse) XXX_Size() int {
+	return m.Size()
+}
+func (m *HTTPDirectResponse) XXX_DiscardUnknown() {
+	xxx_messageInfo_HTTPDirectResponse.DiscardUnknown(m)
+}
+
+var xxx_messageInfo_HTTPDirectResponse proto.InternalMessageInfo
+
+func (m *HTTPDirectResponse) GetResponseCode() uint32 {
+	if m != nil {
+		return m.ResponseCode
+	}
+	return 0
+}
+
+func (m *HTTPDirectResponse) GetBody() string {
+	if m != nil {
+		return m.Body
+	}
+	return ""
+}
+
 // HTTPRewrite can be used to rewrite specific parts of a HTTP request
 // before forwarding the request to the destination. Rewrite primitive can
 // be used only with HTTPRouteDestination. The following example
@@ -2467,17 +2888,21 @@ type HTTPRewrite struct {
 	// provided in this field will replace the corresponding matched prefix.
 	Uri string `protobuf:"bytes,1,opt,name=uri,proto3" json:"uri,omitempty"`
 	// rewrite the Authority/Host header with this value.
-	Authority            string   `protobuf:"bytes,2,opt,name=authority,proto3" json:"authority,omitempty"`
-	XXX_NoUnkeyedLiteral struct{} `json:"-"`
-	XXX_unrecognized     []byte   `json:"-"`
-	XXX_sizecache        int32    `json:"-"`
+	Authority string `protobuf:"bytes,2,opt,name=authority,proto3" json:"authority,omitempty"`
+	// uri_regex can be used for rewriting portions of path that match the
+	// pattern during forwarding the request
+	// RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
+	UriRegex             *RegexMatchAndSubstitute `protobuf:"bytes,3,opt,name=uri_regex,json=uriRegex,proto3" json:"uri_regex,omitempty"`
+	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
+	XXX_unrecognized     []byte                   `json:"-"`
+	XXX_sizecache        int32                    `json:"-"`
 }
 
 func (m *HTTPRewrite) Reset()         { *m = HTTPRewrite{} }
 func (m *HTTPRewrite) String() string { return proto.CompactTextString(m) }
 func (*HTTPRewrite) ProtoMessage()    {}
 func (*HTTPRewrite) Descriptor() ([]byte, []int) {
-	return fileDescriptor_8c56a442a0838fd7, []int{13}
+	return fileDescriptor_8c56a442a0838fd7, []int{15}
 }
 func (m *HTTPRewrite) XXX_Unmarshal(b []byte) error {
 	return m.Unmarshal(b)
@@ -2520,24 +2945,91 @@ func (m *HTTPRewrite) GetAuthority() string {
 	return ""
 }
 
-// Describes how to match a given string in HTTP headers. Match is
-// case-sensitive.
-type StringMatch struct {
-	// Types that are valid to be assigned to MatchType:
-	//	*StringMatch_Exact
-	//	*StringMatch_Prefix
-	//	*StringMatch_Regex
-	MatchType            isStringMatch_MatchType `protobuf_oneof:"match_type"`
-	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
-	XXX_unrecognized     []byte                  `json:"-"`
-	XXX_sizecache        int32                   `json:"-"`
+func (m *HTTPRewrite) GetUriRegex() *RegexMatchAndSubstitute {
+	if m != nil {
+		return m.UriRegex
+	}
+	return nil
 }
 
-func (m *StringMatch) Reset()         { *m = StringMatch{} }
-func (m *StringMatch) String() string { return proto.CompactTextString(m) }
-func (*StringMatch) ProtoMessage()    {}
+// Describes how to match a string and then produce a new string using a regular
+// expression and a substitution string.
+type RegexMatchAndSubstitute struct {
+	// RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
+	Pattern string `protobuf:"bytes,1,opt,name=pattern,proto3" json:"pattern,omitempty"`
+	// The string that should be substituted into matching portions of the
+	// subject string during a substitution operation to produce a new string.
+	Substitution         string   `protobuf:"bytes,2,opt,name=substitution,proto3" json:"substitution,omitempty"`
+	XXX_NoUnkeyedLiteral struct{} `json:"-"`
+	XXX_unrecognized     []byte   `json:"-"`
+	XXX_sizecache        int32    `json:"-"`
+}
+
+func (m *RegexMatchAndSubstitute) Reset()         { *m = RegexMatchAndSubstitute{} }
+func (m *RegexMatchAndSubstitute) String() string { return proto.CompactTextString(m) }
+func (*RegexMatchAndSubstitute) ProtoMessage()    {}
+func (*RegexMatchAndSubstitute) Descriptor() ([]byte, []int) {
+	return fileDescriptor_8c56a442a0838fd7, []int{16}
+}
+func (m *RegexMatchAndSubstitute) XXX_Unmarshal(b []byte) error {
+	return m.Unmarshal(b)
+}
+func (m *RegexMatchAndSubstitute) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	if deterministic {
+		return xxx_messageInfo_RegexMatchAndSubstitute.Marshal(b, m, deterministic)
+	} else {
+		b = b[:cap(b)]
+		n, err := m.MarshalToSizedBuffer(b)
+		if err != nil {
+			return nil, err
+		}
+		return b[:n], nil
+	}
+}
+func (m *RegexMatchAndSubstitute) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_RegexMatchAndSubstitute.Merge(m, src)
+}
+func (m *RegexMatchAndSubstitute) XXX_Size() int {
+	return m.Size()
+}
+func (m *RegexMatchAndSubstitute) XXX_DiscardUnknown() {
+	xxx_messageInfo_RegexMatchAndSubstitute.DiscardUnknown(m)
+}
+
+var xxx_messageInfo_RegexMatchAndSubstitute proto.InternalMessageInfo
+
+func (m *RegexMatchAndSubstitute) GetPattern() string {
+	if m != nil {
+		return m.Pattern
+	}
+	return ""
+}
+
+func (m *RegexMatchAndSubstitute) GetSubstitution() string {
+	if m != nil {
+		return m.Substitution
+	}
+	return ""
+}
+
+// Describes how to match a given string in HTTP headers. Match is
+// case-sensitive.
+type StringMatch struct {
+	// Types that are valid to be assigned to MatchType:
+	//	*StringMatch_Exact
+	//	*StringMatch_Prefix
+	//	*StringMatch_Regex
+	MatchType            isStringMatch_MatchType `protobuf_oneof:"match_type"`
+	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
+	XXX_unrecognized     []byte                  `json:"-"`
+	XXX_sizecache        int32                   `json:"-"`
+}
+
+func (m *StringMatch) Reset()         { *m = StringMatch{} }
+func (m *StringMatch) String() string { return proto.CompactTextString(m) }
+func (*StringMatch) ProtoMessage()    {}
 func (*StringMatch) Descriptor() ([]byte, []int) {
-	return fileDescriptor_8c56a442a0838fd7, []int{14}
+	return fileDescriptor_8c56a442a0838fd7, []int{17}
 }
 func (m *StringMatch) XXX_Unmarshal(b []byte) error {
 	return m.Unmarshal(b)
@@ -2703,7 +3195,7 @@ func (m *HTTPRetry) Reset()         { *m = HTTPRetry{} }
 func (m *HTTPRetry) String() string { return proto.CompactTextString(m) }
 func (*HTTPRetry) ProtoMessage()    {}
 func (*HTTPRetry) Descriptor() ([]byte, []int) {
-	return fileDescriptor_8c56a442a0838fd7, []int{15}
+	return fileDescriptor_8c56a442a0838fd7, []int{18}
 }
 func (m *HTTPRetry) XXX_Unmarshal(b []byte) error {
 	return m.Unmarshal(b)
@@ -2859,7 +3351,7 @@ func (m *CorsPolicy) Reset()         { *m = CorsPolicy{} }
 func (m *CorsPolicy) String() string { return proto.CompactTextString(m) }
 func (*CorsPolicy) ProtoMessage()    {}
 func (*CorsPolicy) Descriptor() ([]byte, []int) {
-	return fileDescriptor_8c56a442a0838fd7, []int{16}
+	return fileDescriptor_8c56a442a0838fd7, []int{19}
 }
 func (m *CorsPolicy) XXX_Unmarshal(b []byte) error {
 	return m.Unmarshal(b)
@@ -2962,7 +3454,7 @@ func (m *HTTPFaultInjection) Reset()         { *m = HTTPFaultInjection{} }
 func (m *HTTPFaultInjection) String() string { return proto.CompactTextString(m) }
 func (*HTTPFaultInjection) ProtoMessage()    {}
 func (*HTTPFaultInjection) Descriptor() ([]byte, []int) {
-	return fileDescriptor_8c56a442a0838fd7, []int{17}
+	return fileDescriptor_8c56a442a0838fd7, []int{20}
 }
 func (m *HTTPFaultInjection) XXX_Unmarshal(b []byte) error {
 	return m.Unmarshal(b)
@@ -3085,7 +3577,7 @@ func (m *HTTPFaultInjection_Delay) Reset()         { *m = HTTPFaultInjection_Del
 func (m *HTTPFaultInjection_Delay) String() string { return proto.CompactTextString(m) }
 func (*HTTPFaultInjection_Delay) ProtoMessage()    {}
 func (*HTTPFaultInjection_Delay) Descriptor() ([]byte, []int) {
-	return fileDescriptor_8c56a442a0838fd7, []int{17, 0}
+	return fileDescriptor_8c56a442a0838fd7, []int{20, 0}
 }
 func (m *HTTPFaultInjection_Delay) XXX_Unmarshal(b []byte) error {
 	return m.Unmarshal(b)
@@ -3245,7 +3737,7 @@ func (m *HTTPFaultInjection_Abort) Reset()         { *m = HTTPFaultInjection_Abo
 func (m *HTTPFaultInjection_Abort) String() string { return proto.CompactTextString(m) }
 func (*HTTPFaultInjection_Abort) ProtoMessage()    {}
 func (*HTTPFaultInjection_Abort) Descriptor() ([]byte, []int) {
-	return fileDescriptor_8c56a442a0838fd7, []int{17, 1}
+	return fileDescriptor_8c56a442a0838fd7, []int{20, 1}
 }
 func (m *HTTPFaultInjection_Abort) XXX_Unmarshal(b []byte) error {
 	return m.Unmarshal(b)
@@ -3352,7 +3844,7 @@ func (m *PortSelector) Reset()         { *m = PortSelector{} }
 func (m *PortSelector) String() string { return proto.CompactTextString(m) }
 func (*PortSelector) ProtoMessage()    {}
 func (*PortSelector) Descriptor() ([]byte, []int) {
-	return fileDescriptor_8c56a442a0838fd7, []int{18}
+	return fileDescriptor_8c56a442a0838fd7, []int{21}
 }
 func (m *PortSelector) XXX_Unmarshal(b []byte) error {
 	return m.Unmarshal(b)
@@ -3400,7 +3892,7 @@ func (m *Percent) Reset()         { *m = Percent{} }
 func (m *Percent) String() string { return proto.CompactTextString(m) }
 func (*Percent) ProtoMessage()    {}
 func (*Percent) Descriptor() ([]byte, []int) {
-	return fileDescriptor_8c56a442a0838fd7, []int{19}
+	return fileDescriptor_8c56a442a0838fd7, []int{22}
 }
 func (m *Percent) XXX_Unmarshal(b []byte) error {
 	return m.Unmarshal(b)
@@ -3436,6 +3928,297 @@ func (m *Percent) GetValue() float64 {
 	return 0
 }
 
+type HTTPFilter struct {
+	// The http filter name should be meaningful.
+	// E.g. ip-access-control, jwt, rbac, cors.
+	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
+	// Disable this filter and all request will pass.
+	Disable bool `protobuf:"varint,2,opt,name=disable,proto3" json:"disable,omitempty"`
+	// Types that are valid to be assigned to Filter:
+	//	*HTTPFilter_IpAccessControl
+	//	*HTTPFilter_LocalRateLimit
+	Filter               isHTTPFilter_Filter `protobuf_oneof:"Filter"`
+	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
+	XXX_unrecognized     []byte              `json:"-"`
+	XXX_sizecache        int32               `json:"-"`
+}
+
+func (m *HTTPFilter) Reset()         { *m = HTTPFilter{} }
+func (m *HTTPFilter) String() string { return proto.CompactTextString(m) }
+func (*HTTPFilter) ProtoMessage()    {}
+func (*HTTPFilter) Descriptor() ([]byte, []int) {
+	return fileDescriptor_8c56a442a0838fd7, []int{23}
+}
+func (m *HTTPFilter) XXX_Unmarshal(b []byte) error {
+	return m.Unmarshal(b)
+}
+func (m *HTTPFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	if deterministic {
+		return xxx_messageInfo_HTTPFilter.Marshal(b, m, deterministic)
+	} else {
+		b = b[:cap(b)]
+		n, err := m.MarshalToSizedBuffer(b)
+		if err != nil {
+			return nil, err
+		}
+		return b[:n], nil
+	}
+}
+func (m *HTTPFilter) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_HTTPFilter.Merge(m, src)
+}
+func (m *HTTPFilter) XXX_Size() int {
+	return m.Size()
+}
+func (m *HTTPFilter) XXX_DiscardUnknown() {
+	xxx_messageInfo_HTTPFilter.DiscardUnknown(m)
+}
+
+var xxx_messageInfo_HTTPFilter proto.InternalMessageInfo
+
+type isHTTPFilter_Filter interface {
+	isHTTPFilter_Filter()
+	MarshalTo([]byte) (int, error)
+	Size() int
+}
+
+type HTTPFilter_IpAccessControl struct {
+	IpAccessControl *IPAccessControl `protobuf:"bytes,3,opt,name=ip_access_control,json=ipAccessControl,proto3,oneof" json:"ip_access_control,omitempty"`
+}
+type HTTPFilter_LocalRateLimit struct {
+	LocalRateLimit *LocalRateLimit `protobuf:"bytes,4,opt,name=local_rate_limit,json=localRateLimit,proto3,oneof" json:"local_rate_limit,omitempty"`
+}
+
+func (*HTTPFilter_IpAccessControl) isHTTPFilter_Filter() {}
+func (*HTTPFilter_LocalRateLimit) isHTTPFilter_Filter()  {}
+
+func (m *HTTPFilter) GetFilter() isHTTPFilter_Filter {
+	if m != nil {
+		return m.Filter
+	}
+	return nil
+}
+
+func (m *HTTPFilter) GetName() string {
+	if m != nil {
+		return m.Name
+	}
+	return ""
+}
+
+func (m *HTTPFilter) GetDisable() bool {
+	if m != nil {
+		return m.Disable
+	}
+	return false
+}
+
+func (m *HTTPFilter) GetIpAccessControl() *IPAccessControl {
+	if x, ok := m.GetFilter().(*HTTPFilter_IpAccessControl); ok {
+		return x.IpAccessControl
+	}
+	return nil
+}
+
+func (m *HTTPFilter) GetLocalRateLimit() *LocalRateLimit {
+	if x, ok := m.GetFilter().(*HTTPFilter_LocalRateLimit); ok {
+		return x.LocalRateLimit
+	}
+	return nil
+}
+
+// XXX_OneofWrappers is for the internal use of the proto package.
+func (*HTTPFilter) XXX_OneofWrappers() []interface{} {
+	return []interface{}{
+		(*HTTPFilter_IpAccessControl)(nil),
+		(*HTTPFilter_LocalRateLimit)(nil),
+	}
+}
+
+type IPAccessControl struct {
+	// Used for white ip access control
+	RemoteIpBlocks []string `protobuf:"bytes,1,rep,name=remote_ip_blocks,json=remoteIpBlocks,proto3" json:"remote_ip_blocks,omitempty"`
+	// Used for black ip access control
+	NotRemoteIpBlocks    []string `protobuf:"bytes,2,rep,name=not_remote_ip_blocks,json=notRemoteIpBlocks,proto3" json:"not_remote_ip_blocks,omitempty"`
+	XXX_NoUnkeyedLiteral struct{} `json:"-"`
+	XXX_unrecognized     []byte   `json:"-"`
+	XXX_sizecache        int32    `json:"-"`
+}
+
+func (m *IPAccessControl) Reset()         { *m = IPAccessControl{} }
+func (m *IPAccessControl) String() string { return proto.CompactTextString(m) }
+func (*IPAccessControl) ProtoMessage()    {}
+func (*IPAccessControl) Descriptor() ([]byte, []int) {
+	return fileDescriptor_8c56a442a0838fd7, []int{24}
+}
+func (m *IPAccessControl) XXX_Unmarshal(b []byte) error {
+	return m.Unmarshal(b)
+}
+func (m *IPAccessControl) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	if deterministic {
+		return xxx_messageInfo_IPAccessControl.Marshal(b, m, deterministic)
+	} else {
+		b = b[:cap(b)]
+		n, err := m.MarshalToSizedBuffer(b)
+		if err != nil {
+			return nil, err
+		}
+		return b[:n], nil
+	}
+}
+func (m *IPAccessControl) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_IPAccessControl.Merge(m, src)
+}
+func (m *IPAccessControl) XXX_Size() int {
+	return m.Size()
+}
+func (m *IPAccessControl) XXX_DiscardUnknown() {
+	xxx_messageInfo_IPAccessControl.DiscardUnknown(m)
+}
+
+var xxx_messageInfo_IPAccessControl proto.InternalMessageInfo
+
+func (m *IPAccessControl) GetRemoteIpBlocks() []string {
+	if m != nil {
+		return m.RemoteIpBlocks
+	}
+	return nil
+}
+
+func (m *IPAccessControl) GetNotRemoteIpBlocks() []string {
+	if m != nil {
+		return m.NotRemoteIpBlocks
+	}
+	return nil
+}
+
+type LocalRateLimit struct {
+	TokenBucket             *TokenBucket `protobuf:"bytes,1,opt,name=token_bucket,json=tokenBucket,proto3" json:"token_bucket,omitempty"`
+	PerDownstreamConnection bool         `protobuf:"varint,2,opt,name=per_downstream_connection,json=perDownstreamConnection,proto3" json:"per_downstream_connection,omitempty"`
+	// Default rate limit status code is 429.
+	StatusCode           uint32   `protobuf:"varint,3,opt,name=status_code,json=statusCode,proto3" json:"status_code,omitempty"`
+	XXX_NoUnkeyedLiteral struct{} `json:"-"`
+	XXX_unrecognized     []byte   `json:"-"`
+	XXX_sizecache        int32    `json:"-"`
+}
+
+func (m *LocalRateLimit) Reset()         { *m = LocalRateLimit{} }
+func (m *LocalRateLimit) String() string { return proto.CompactTextString(m) }
+func (*LocalRateLimit) ProtoMessage()    {}
+func (*LocalRateLimit) Descriptor() ([]byte, []int) {
+	return fileDescriptor_8c56a442a0838fd7, []int{25}
+}
+func (m *LocalRateLimit) XXX_Unmarshal(b []byte) error {
+	return m.Unmarshal(b)
+}
+func (m *LocalRateLimit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	if deterministic {
+		return xxx_messageInfo_LocalRateLimit.Marshal(b, m, deterministic)
+	} else {
+		b = b[:cap(b)]
+		n, err := m.MarshalToSizedBuffer(b)
+		if err != nil {
+			return nil, err
+		}
+		return b[:n], nil
+	}
+}
+func (m *LocalRateLimit) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_LocalRateLimit.Merge(m, src)
+}
+func (m *LocalRateLimit) XXX_Size() int {
+	return m.Size()
+}
+func (m *LocalRateLimit) XXX_DiscardUnknown() {
+	xxx_messageInfo_LocalRateLimit.DiscardUnknown(m)
+}
+
+var xxx_messageInfo_LocalRateLimit proto.InternalMessageInfo
+
+func (m *LocalRateLimit) GetTokenBucket() *TokenBucket {
+	if m != nil {
+		return m.TokenBucket
+	}
+	return nil
+}
+
+func (m *LocalRateLimit) GetPerDownstreamConnection() bool {
+	if m != nil {
+		return m.PerDownstreamConnection
+	}
+	return false
+}
+
+func (m *LocalRateLimit) GetStatusCode() uint32 {
+	if m != nil {
+		return m.StatusCode
+	}
+	return 0
+}
+
+type TokenBucket struct {
+	MaxTokens            uint32          `protobuf:"varint,1,opt,name=max_tokens,json=maxTokens,proto3" json:"max_tokens,omitempty"`
+	TokensPefFill        uint32          `protobuf:"varint,2,opt,name=tokens_pef_fill,json=tokensPefFill,proto3" json:"tokens_pef_fill,omitempty"`
+	FillInterval         *types.Duration `protobuf:"bytes,3,opt,name=fill_interval,json=fillInterval,proto3" json:"fill_interval,omitempty"`
+	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
+	XXX_unrecognized     []byte          `json:"-"`
+	XXX_sizecache        int32           `json:"-"`
+}
+
+func (m *TokenBucket) Reset()         { *m = TokenBucket{} }
+func (m *TokenBucket) String() string { return proto.CompactTextString(m) }
+func (*TokenBucket) ProtoMessage()    {}
+func (*TokenBucket) Descriptor() ([]byte, []int) {
+	return fileDescriptor_8c56a442a0838fd7, []int{26}
+}
+func (m *TokenBucket) XXX_Unmarshal(b []byte) error {
+	return m.Unmarshal(b)
+}
+func (m *TokenBucket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	if deterministic {
+		return xxx_messageInfo_TokenBucket.Marshal(b, m, deterministic)
+	} else {
+		b = b[:cap(b)]
+		n, err := m.MarshalToSizedBuffer(b)
+		if err != nil {
+			return nil, err
+		}
+		return b[:n], nil
+	}
+}
+func (m *TokenBucket) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_TokenBucket.Merge(m, src)
+}
+func (m *TokenBucket) XXX_Size() int {
+	return m.Size()
+}
+func (m *TokenBucket) XXX_DiscardUnknown() {
+	xxx_messageInfo_TokenBucket.DiscardUnknown(m)
+}
+
+var xxx_messageInfo_TokenBucket proto.InternalMessageInfo
+
+func (m *TokenBucket) GetMaxTokens() uint32 {
+	if m != nil {
+		return m.MaxTokens
+	}
+	return 0
+}
+
+func (m *TokenBucket) GetTokensPefFill() uint32 {
+	if m != nil {
+		return m.TokensPefFill
+	}
+	return 0
+}
+
+func (m *TokenBucket) GetFillInterval() *types.Duration {
+	if m != nil {
+		return m.FillInterval
+	}
+	return nil
+}
+
 func init() {
 	proto.RegisterEnum("istio.networking.v1beta1.HTTPRedirect_RedirectPortSelection", HTTPRedirect_RedirectPortSelection_name, HTTPRedirect_RedirectPortSelection_value)
 	proto.RegisterType((*VirtualService)(nil), "istio.networking.v1beta1.VirtualService")
@@ -3460,7 +4243,11 @@ func init() {
 	proto.RegisterType((*TLSMatchAttributes)(nil), "istio.networking.v1beta1.TLSMatchAttributes")
 	proto.RegisterMapType((map[string]string)(nil), "istio.networking.v1beta1.TLSMatchAttributes.SourceLabelsEntry")
 	proto.RegisterType((*HTTPRedirect)(nil), "istio.networking.v1beta1.HTTPRedirect")
+	proto.RegisterType((*HTTPInternalActiveRedirect)(nil), "istio.networking.v1beta1.HTTPInternalActiveRedirect")
+	proto.RegisterType((*HTTPInternalActiveRedirect_RedirectPolicy)(nil), "istio.networking.v1beta1.HTTPInternalActiveRedirect.RedirectPolicy")
+	proto.RegisterType((*HTTPDirectResponse)(nil), "istio.networking.v1beta1.HTTPDirectResponse")
 	proto.RegisterType((*HTTPRewrite)(nil), "istio.networking.v1beta1.HTTPRewrite")
+	proto.RegisterType((*RegexMatchAndSubstitute)(nil), "istio.networking.v1beta1.RegexMatchAndSubstitute")
 	proto.RegisterType((*StringMatch)(nil), "istio.networking.v1beta1.StringMatch")
 	proto.RegisterType((*HTTPRetry)(nil), "istio.networking.v1beta1.HTTPRetry")
 	proto.RegisterType((*CorsPolicy)(nil), "istio.networking.v1beta1.CorsPolicy")
@@ -3469,6 +4256,10 @@ func init() {
 	proto.RegisterType((*HTTPFaultInjection_Abort)(nil), "istio.networking.v1beta1.HTTPFaultInjection.Abort")
 	proto.RegisterType((*PortSelector)(nil), "istio.networking.v1beta1.PortSelector")
 	proto.RegisterType((*Percent)(nil), "istio.networking.v1beta1.Percent")
+	proto.RegisterType((*HTTPFilter)(nil), "istio.networking.v1beta1.HTTPFilter")
+	proto.RegisterType((*IPAccessControl)(nil), "istio.networking.v1beta1.IPAccessControl")
+	proto.RegisterType((*LocalRateLimit)(nil), "istio.networking.v1beta1.LocalRateLimit")
+	proto.RegisterType((*TokenBucket)(nil), "istio.networking.v1beta1.TokenBucket")
 }
 
 func init() {
@@ -3476,139 +4267,186 @@ func init() {
 }
 
 var fileDescriptor_8c56a442a0838fd7 = []byte{
-	// 2098 bytes of a gzipped FileDescriptorProto
-	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x59, 0x4f, 0x73, 0x1b, 0x49,
-	0x15, 0xf7, 0xe8, 0xbf, 0x9e, 0x24, 0x5b, 0xee, 0x4d, 0xb2, 0x13, 0x93, 0x4a, 0x1c, 0x85, 0x2c,
-	0x06, 0x16, 0xb9, 0xd6, 0xd9, 0x22, 0xd4, 0x66, 0xb3, 0xbb, 0xfe, 0x97, 0x75, 0x5c, 0x4e, 0xec,
-	0xb4, 0x95, 0xa5, 0x8a, 0x03, 0x53, 0xa3, 0x99, 0x17, 0x69, 0x88, 0x34, 0x33, 0xe9, 0xe9, 0xb1,
-	0xad, 0xe2, 0xca, 0x85, 0x03, 0x45, 0x71, 0xa1, 0x8a, 0x2b, 0x9f, 0x82, 0x8f, 0xc0, 0x89, 0xe2,
-	0xc4, 0x15, 0x2a, 0x37, 0x0e, 0x7c, 0x05, 0x8a, 0xea, 0x3f, 0x23, 0x8d, 0x2c, 0xdb, 0x92, 0xc2,
-	0x06, 0x4e, 0x56, 0xbf, 0x7e, 0xbf, 0x5f, 0x77, 0xbf, 0xd7, 0xfd, 0xde, 0x9b, 0x67, 0x58, 0xf3,
-	0x91, 0x9f, 0x06, 0xec, 0xb5, 0xe7, 0x77, 0xd6, 0x4f, 0x3e, 0x69, 0x23, 0xb7, 0x3f, 0x59, 0x3f,
-	0xf1, 0x18, 0x8f, 0xed, 0x9e, 0x15, 0x21, 0x3b, 0xf1, 0x1c, 0x6c, 0x86, 0x2c, 0xe0, 0x01, 0x31,
-	0xbd, 0x88, 0x7b, 0x41, 0x73, 0xa4, 0xdf, 0xd4, 0xfa, 0x2b, 0x77, 0x3a, 0x41, 0xd0, 0xe9, 0xe1,
-	0xba, 0x1d, 0x7a, 0xeb, 0xaf, 0x3c, 0xec, 0xb9, 0x56, 0x1b, 0xbb, 0xf6, 0x89, 0x17, 0x30, 0x05,
-	0x5d, 0xb9, 0xad, 0x15, 0xe4, 0xa8, 0x1d, 0xbf, 0x5a, 0x77, 0x63, 0x66, 0x73, 0x2f, 0xf0, 0x2f,
-	0x9b, 0x3f, 0x65, 0x76, 0x18, 0x22, 0x8b, 0xd4, 0x7c, 0xe3, 0x57, 0x19, 0x58, 0xfc, 0x46, 0x6d,
-	0xea, 0x58, 0xed, 0x89, 0x5c, 0x83, 0x7c, 0x37, 0x88, 0x78, 0x64, 0x1a, 0xab, 0xd9, 0xb5, 0x32,
-	0x55, 0x03, 0xb2, 0x02, 0xa5, 0x8e, 0xcd, 0xf1, 0xd4, 0x1e, 0x44, 0x66, 0x46, 0x4e, 0x0c, 0xc7,
-	0xe4, 0x21, 0xe4, 0xba, 0x9c, 0x87, 0x66, 0x76, 0x35, 0xbb, 0x56, 0xd9, 0xb8, 0xd7, 0xbc, 0xec,
-	0x38, 0xcd, 0xbd, 0x56, 0xeb, 0x88, 0x06, 0x31, 0x47, 0x2a, 0x01, 0xe4, 0x53, 0xc8, 0xf2, 0x5e,
-	0x64, 0xe6, 0x25, 0xae, 0x71, 0x39, 0xae, 0x75, 0x70, 0xac, 0x60, 0x42, 0x5d, 0xa2, 0x9c, 0xd0,
-	0xcc, 0x4d, 0x45, 0x6d, 0x1f, 0x25, 0x28, 0x27, 0x24, 0xdf, 0x81, 0x32, 0x9e, 0x85, 0x01, 0xe3,
-	0x16, 0x0f, 0xcc, 0x82, 0x3a, 0x81, 0x12, 0xb4, 0x82, 0xc6, 0x2f, 0xa1, 0xb2, 0x83, 0x11, 0xf7,
-	0x7c, 0x69, 0x3b, 0x62, 0x42, 0x4e, 0x9c, 0xda, 0x34, 0x56, 0x8d, 0xb5, 0xf2, 0x56, 0xee, 0xed,
-	0xa6, 0x91, 0xa1, 0x52, 0x42, 0x6e, 0x40, 0x21, 0x8a, 0xdb, 0x11, 0x72, 0x33, 0x23, 0xe6, 0xa8,
-	0x1e, 0x91, 0xcf, 0x20, 0x27, 0xa8, 0xcc, 0xec, 0xaa, 0xb1, 0x56, 0xd9, 0xf8, 0xe8, 0xf2, 0x4d,
-	0x1d, 0x05, 0x8c, 0x1f, 0x63, 0x0f, 0x1d, 0x1e, 0x30, 0x2a, 0x31, 0x8d, 0xdf, 0x95, 0xa0, 0x3c,
-	0xb4, 0x0c, 0x21, 0x90, 0xf3, 0xed, 0x3e, 0x9a, 0xcb, 0x92, 0x5f, 0xfe, 0x26, 0x5f, 0x41, 0xbe,
-	0x6f, 0x73, 0xa7, 0x2b, 0x5d, 0x52, 0xd9, 0xf8, 0xc1, 0xd5, 0x16, 0x7e, 0x26, 0x54, 0x29, 0xbe,
-	0x89, 0x31, 0xe2, 0x54, 0x01, 0xc9, 0x0e, 0xe4, 0x99, 0xa0, 0x97, 0xbe, 0xab, 0x6c, 0x34, 0x67,
-	0xf0, 0x51, 0xca, 0x20, 0x54, 0x81, 0xc9, 0x16, 0x94, 0x18, 0xba, 0x1e, 0x43, 0x67, 0x86, 0x93,
-	0x4a, 0x22, 0xad, 0x4d, 0x87, 0x38, 0xf2, 0x05, 0x94, 0x5c, 0xec, 0xa1, 0xb8, 0x3c, 0xe6, 0x35,
-	0xc9, 0x71, 0x85, 0x0b, 0x77, 0xb4, 0x26, 0x1d, 0x62, 0xc8, 0x97, 0x50, 0x64, 0x78, 0xca, 0x3c,
-	0x8e, 0x66, 0x4e, 0xc2, 0xef, 0x4f, 0xdb, 0x82, 0x54, 0xa6, 0x09, 0x8a, 0x3c, 0x80, 0x22, 0xf7,
-	0xfa, 0x18, 0xc4, 0xdc, 0x2c, 0x48, 0x82, 0x9b, 0x4d, 0xf5, 0x48, 0x9a, 0xc9, 0x23, 0x69, 0xee,
-	0xe8, 0x47, 0x44, 0x13, 0x4d, 0xf2, 0x58, 0xac, 0xca, 0x99, 0x87, 0x91, 0x59, 0x94, 0xa0, 0x69,
-	0xb7, 0x1c, 0x39, 0x1b, 0xd0, 0x04, 0x43, 0xb6, 0x20, 0xff, 0xca, 0x8e, 0x7b, 0xdc, 0x2c, 0x49,
-	0xf0, 0xc7, 0x57, 0x83, 0x9f, 0x08, 0xd5, 0xa7, 0xfe, 0x2f, 0xd0, 0x51, 0xc6, 0x97, 0x50, 0xf2,
-	0x18, 0x0a, 0x7d, 0x8f, 0xb1, 0x80, 0x99, 0xe5, 0x69, 0xe7, 0x4e, 0xbb, 0x4e, 0x83, 0xc8, 0xd7,
-	0xb0, 0xa8, 0x7e, 0x59, 0x21, 0x32, 0x07, 0x7d, 0x6e, 0x12, 0x49, 0x73, 0x6b, 0xe2, 0xf4, 0x2f,
-	0x9f, 0xfa, 0xfc, 0xc1, 0xc6, 0x37, 0x76, 0x2f, 0xc6, 0xad, 0x8c, 0x69, 0xd0, 0x9a, 0xc2, 0x1d,
-	0x29, 0x18, 0x79, 0x0e, 0xcb, 0xe3, 0x44, 0x76, 0x07, 0xcd, 0x0f, 0x24, 0xd7, 0xdd, 0x2b, 0xee,
-	0xbd, 0xd2, 0xa5, 0xf5, 0x31, 0x32, 0xbb, 0x83, 0x64, 0x17, 0x2a, 0x4e, 0xc0, 0x22, 0x2b, 0x0c,
-	0x7a, 0x9e, 0x33, 0x30, 0x41, 0x32, 0x7d, 0xf7, 0x72, 0xa6, 0xed, 0x80, 0x45, 0x47, 0x52, 0x97,
-	0x82, 0x33, 0xfc, 0x4d, 0x1e, 0x41, 0xb1, 0x8b, 0xb6, 0x8b, 0x2c, 0x32, 0xeb, 0xd3, 0x36, 0xb3,
-	0xa7, 0x14, 0x69, 0x82, 0xd8, 0xcf, 0x95, 0xf2, 0xf5, 0xc2, 0x7e, 0xae, 0x54, 0xa9, 0xd7, 0xe9,
-	0xf2, 0x29, 0xb6, 0xa3, 0xc0, 0x79, 0x8d, 0xdc, 0x8a, 0xc3, 0x0e, 0xb3, 0x5d, 0xa4, 0x8b, 0x22,
-	0x66, 0xfa, 0xae, 0xa5, 0xd5, 0xe9, 0x87, 0x0c, 0xfb, 0xc1, 0x09, 0x5a, 0x0c, 0xa3, 0x30, 0xf0,
-	0x23, 0x1c, 0x4d, 0x68, 0xc5, 0x89, 0x89, 0x1b, 0x43, 0x84, 0x7c, 0x96, 0x23, 0xf9, 0x10, 0x30,
-	0x26, 0x6f, 0x7c, 0x0e, 0xa5, 0xe4, 0xee, 0x0f, 0x23, 0x82, 0x91, 0x8a, 0x08, 0xb7, 0xa0, 0x2c,
-	0xfe, 0x46, 0xa1, 0xed, 0xa0, 0x0e, 0x45, 0x23, 0x41, 0xe3, 0x6d, 0x16, 0x8a, 0xfa, 0x8c, 0xe4,
-	0x40, 0xdc, 0x5c, 0x49, 0x2e, 0x09, 0x2a, 0x1b, 0x1b, 0x53, 0xed, 0xa2, 0xff, 0x1e, 0x86, 0xa8,
-	0x9e, 0x41, 0x44, 0x13, 0x0a, 0xf2, 0x5c, 0x44, 0x00, 0x75, 0x36, 0xb9, 0xec, 0xbb, 0xd1, 0x0d,
-	0x39, 0x56, 0xfe, 0x94, 0x81, 0xfa, 0xf9, 0x69, 0xf2, 0x0c, 0xb2, 0x22, 0xc2, 0xaa, 0x60, 0xf7,
-	0x68, 0x7e, 0xfe, 0xe6, 0x31, 0xf2, 0x5d, 0x5f, 0x3c, 0x40, 0xc1, 0x23, 0xe8, 0x6c, 0xd7, 0xd5,
-	0x91, 0xef, 0x5d, 0xe8, 0x36, 0x5d, 0x57, 0xd3, 0xd9, 0xae, 0x2b, 0x52, 0x80, 0x72, 0xa6, 0xcc,
-	0x77, 0x65, 0xaa, 0x47, 0x2b, 0x3f, 0x86, 0x52, 0xb2, 0x2e, 0xa9, 0x43, 0xf6, 0x35, 0x0e, 0xb4,
-	0xc7, 0xc4, 0x4f, 0x91, 0x55, 0x4f, 0xc4, 0x8b, 0xd2, 0xce, 0x52, 0x83, 0xcf, 0x32, 0x3f, 0x31,
-	0x04, 0x2e, 0x59, 0x60, 0x1e, 0x5c, 0xe3, 0xf7, 0x06, 0x94, 0x92, 0xc4, 0x48, 0xf6, 0xc6, 0x33,
-	0xc4, 0xc7, 0x57, 0xe6, 0x52, 0x99, 0x20, 0x36, 0x39, 0x67, 0x5e, 0x3b, 0xe6, 0x18, 0xe9, 0x04,
-	0xa7, 0x33, 0xc5, 0x57, 0xe3, 0x99, 0xe2, 0x8a, 0x5c, 0x73, 0x49, 0x96, 0x68, 0xfc, 0x56, 0x6c,
-	0x4c, 0xe7, 0x5e, 0xb2, 0x39, 0xbe, 0xb1, 0x1f, 0x5e, 0x4e, 0x77, 0xf0, 0xe9, 0xb9, 0x7d, 0x7d,
-	0x7b, 0x3b, 0xfa, 0x43, 0x19, 0xea, 0xe7, 0x33, 0xe3, 0xf0, 0x59, 0x55, 0x52, 0xcf, 0xea, 0x21,
-	0x64, 0x63, 0xe6, 0xe9, 0x87, 0x72, 0x45, 0x80, 0x3d, 0xe6, 0xcc, 0xf3, 0x3b, 0x8a, 0x4e, 0x20,
-	0x44, 0x70, 0x8e, 0x9c, 0x2e, 0xf6, 0x93, 0x57, 0x31, 0x23, 0x56, 0x83, 0x64, 0x6c, 0x47, 0xde,
-	0x0d, 0x5c, 0x9d, 0x56, 0x67, 0x85, 0x2b, 0x10, 0xd9, 0x86, 0xb2, 0x1d, 0xf3, 0x6e, 0xc0, 0x3c,
-	0x3e, 0x98, 0x9e, 0x15, 0xd3, 0x0c, 0x23, 0x1c, 0x79, 0x31, 0x0a, 0xa0, 0xaa, 0x20, 0x7b, 0x38,
-	0x7b, 0x99, 0x91, 0xbc, 0x1d, 0xf5, 0x4c, 0x12, 0x1e, 0x61, 0x62, 0x59, 0x15, 0x89, 0x3c, 0x5b,
-	0x53, 0xd5, 0x0e, 0xb1, 0xa1, 0x16, 0x05, 0x31, 0x73, 0xd0, 0xea, 0xd9, 0x6d, 0xec, 0x89, 0x7c,
-	0x2a, 0x16, 0xfb, 0x7c, 0x8e, 0xc5, 0x8e, 0x25, 0xfe, 0x40, 0xc2, 0xd5, 0x8a, 0xd5, 0x28, 0x25,
-	0x1a, 0xab, 0x55, 0x4b, 0xe7, 0x6a, 0xd5, 0x9f, 0x43, 0xf5, 0x4d, 0x8c, 0x6c, 0x60, 0x85, 0x36,
-	0xb3, 0xfb, 0x91, 0x59, 0x9e, 0x1a, 0x15, 0xce, 0xaf, 0xfe, 0x42, 0xc0, 0x8f, 0x24, 0x5a, 0x2d,
-	0x5e, 0x79, 0x33, 0x92, 0x90, 0x8f, 0x60, 0xc9, 0xeb, 0xf8, 0x01, 0x43, 0x2b, 0x66, 0x9e, 0xe5,
-	0xd8, 0x11, 0xca, 0x8c, 0x56, 0xa2, 0x35, 0x25, 0x7e, 0xc9, 0xbc, 0x6d, 0x3b, 0x42, 0xd2, 0x81,
-	0xa5, 0x53, 0x8f, 0x77, 0x83, 0x78, 0x18, 0xf3, 0xcd, 0xaa, 0xdc, 0xca, 0x17, 0x73, 0x6c, 0xe5,
-	0xa7, 0x8a, 0x61, 0xcc, 0xf8, 0x8b, 0xa7, 0x63, 0x42, 0xf2, 0x7d, 0xa8, 0x6b, 0x7b, 0x8f, 0x12,
-	0x46, 0x4d, 0x5e, 0xf9, 0x25, 0x25, 0x7f, 0x9e, 0x88, 0x57, 0x6c, 0xa8, 0xa6, 0xa9, 0x2e, 0x88,
-	0x46, 0x8f, 0xd2, 0xd1, 0x68, 0xe6, 0x4b, 0x96, 0x0a, 0x76, 0x5f, 0xc2, 0xf2, 0x84, 0xf7, 0xe6,
-	0x8a, 0x96, 0x08, 0xf5, 0xf3, 0x0e, 0x78, 0x1f, 0xfb, 0xec, 0xc2, 0x07, 0x17, 0x18, 0xf7, 0x3d,
-	0xac, 0xd4, 0xf8, 0x63, 0x06, 0xae, 0x5d, 0x54, 0x73, 0x93, 0x67, 0x50, 0x71, 0x47, 0xc3, 0xe9,
-	0x31, 0x29, 0x85, 0xd5, 0x11, 0x3d, 0x8d, 0x17, 0x69, 0xeb, 0x14, 0xbd, 0x4e, 0x57, 0x7d, 0xb9,
-	0xe4, 0xa9, 0x1e, 0xa5, 0xeb, 0xa6, 0xe2, 0x3b, 0xd4, 0x4d, 0xd9, 0x7a, 0xf1, 0x7f, 0x50, 0x0e,
-	0x0d, 0xa0, 0xfe, 0x7f, 0xb2, 0x4f, 0xe3, 0x9f, 0x19, 0x58, 0x9e, 0x48, 0x4d, 0x64, 0x1d, 0x3e,
-	0x48, 0x81, 0xad, 0x28, 0x6e, 0xfb, 0x38, 0xfc, 0x64, 0x26, 0xa9, 0xa9, 0x63, 0x35, 0x33, 0x0c,
-	0x85, 0x99, 0x54, 0x28, 0xbc, 0x37, 0x0c, 0x85, 0x0a, 0x2f, 0x83, 0x7f, 0x39, 0x09, 0x66, 0x0a,
-	0x49, 0xda, 0xe7, 0xe3, 0xa5, 0xfa, 0xee, 0x7d, 0x3c, 0x47, 0x22, 0x9d, 0x2b, 0x60, 0xe6, 0xcf,
-	0x05, 0xcc, 0x8b, 0xe2, 0x47, 0xe1, 0xe2, 0xf8, 0xf1, 0xdf, 0x3e, 0xee, 0xc6, 0xbf, 0x33, 0x40,
-	0x26, 0xeb, 0x13, 0x72, 0x17, 0xca, 0x91, 0xef, 0x59, 0xa9, 0xae, 0x84, 0x76, 0x60, 0x29, 0xf2,
-	0xbd, 0x3d, 0xd9, 0x9e, 0xb8, 0xc4, 0x1f, 0x99, 0xa9, 0xfe, 0xc8, 0xa6, 0xfc, 0xe1, 0x9c, 0x37,
-	0x75, 0x7e, 0x5a, 0x44, 0x9e, 0xdc, 0xec, 0x5c, 0xb6, 0x2e, 0xcc, 0x60, 0xeb, 0xe2, 0xfb, 0xb1,
-	0xf5, 0x7e, 0xae, 0x94, 0xab, 0xe7, 0xe9, 0xf8, 0x05, 0x6c, 0xfc, 0x25, 0x03, 0xd5, 0xf4, 0x77,
-	0xbb, 0x60, 0x4c, 0x0a, 0xa2, 0xb2, 0xaa, 0x74, 0x6e, 0xa5, 0x6b, 0x0d, 0xfd, 0xe5, 0x31, 0x2a,
-	0x22, 0xae, 0x69, 0xb3, 0x8a, 0x22, 0xa4, 0xb6, 0xb7, 0xa0, 0x0d, 0x6b, 0x89, 0xa7, 0xca, 0xbc,
-	0x13, 0xb4, 0xe4, 0x64, 0x7e, 0xd5, 0x58, 0x5b, 0x9c, 0x96, 0xf1, 0x93, 0x2d, 0x34, 0x93, 0x1f,
-	0xa3, 0xce, 0x89, 0x17, 0xf8, 0x7b, 0x0b, 0x14, 0x14, 0xa5, 0x10, 0xcb, 0xb6, 0x8c, 0x2a, 0xbf,
-	0x0a, 0xba, 0x2d, 0xa3, 0xea, 0xaa, 0x7b, 0x50, 0x4b, 0x1a, 0x0f, 0x96, 0x13, 0xb8, 0xa8, 0xdd,
-	0x5d, 0x4d, 0x84, 0xdb, 0x81, 0x8b, 0x8d, 0xa7, 0x70, 0xfd, 0xc2, 0x35, 0xc8, 0x4d, 0xb8, 0xfe,
-	0x84, 0x1e, 0x3e, 0xb3, 0x8e, 0xe8, 0x61, 0xeb, 0x70, 0xfb, 0xf0, 0xc0, 0xda, 0xd9, 0x7d, 0xb2,
-	0xf9, 0xf2, 0xa0, 0x55, 0x5f, 0x20, 0xd7, 0x61, 0x59, 0x4e, 0xd1, 0xdd, 0x17, 0x2f, 0x77, 0x8f,
-	0x5b, 0xd6, 0xd1, 0x21, 0x6d, 0xd5, 0x8d, 0xad, 0xa5, 0xd4, 0x7a, 0xb2, 0xb7, 0xf3, 0x18, 0x2a,
-	0xa9, 0x26, 0xc4, 0xbc, 0xe6, 0x6c, 0x20, 0x54, 0x52, 0x69, 0x83, 0xdc, 0x80, 0x3c, 0x9e, 0xd9,
-	0x8e, 0x6e, 0x4c, 0xed, 0x2d, 0x50, 0x35, 0x24, 0x26, 0x14, 0x42, 0x86, 0xaf, 0xbc, 0x33, 0xc5,
-	0xb0, 0xb7, 0x40, 0xf5, 0x58, 0x20, 0x18, 0x76, 0xf0, 0x4c, 0x85, 0x16, 0x81, 0x90, 0xc3, 0xad,
-	0x2a, 0x80, 0x2c, 0xae, 0x2d, 0x3e, 0x08, 0xb1, 0xf1, 0x77, 0x43, 0x77, 0xa0, 0x50, 0xdc, 0xa2,
-	0x55, 0x28, 0xd9, 0x9c, 0x63, 0x3f, 0x94, 0xaf, 0xcd, 0x58, 0xcb, 0x27, 0xaf, 0x2d, 0x91, 0x92,
-	0x4d, 0x58, 0x0a, 0x91, 0x59, 0x9c, 0x0d, 0xac, 0xa4, 0x95, 0x92, 0x99, 0xd6, 0x4a, 0xa9, 0x85,
-	0xc8, 0x5a, 0x6c, 0xd0, 0xd2, 0x0d, 0x95, 0x9b, 0xe2, 0x43, 0x52, 0x10, 0x04, 0xbe, 0x0e, 0x7b,
-	0xb2, 0x59, 0x32, 0x38, 0xf4, 0x09, 0x85, 0x0f, 0xd5, 0x94, 0x48, 0x12, 0x1c, 0xad, 0x5e, 0xe0,
-	0xd8, 0x3d, 0x8f, 0x7b, 0x18, 0xe9, 0xda, 0x76, 0x65, 0x62, 0x95, 0xad, 0x20, 0xe8, 0xc9, 0x86,
-	0x05, 0xbd, 0x2e, 0xa1, 0x54, 0x22, 0x0f, 0x86, 0xc0, 0xc6, 0xbf, 0x32, 0x00, 0xa3, 0xc6, 0x01,
-	0xb9, 0x0f, 0x55, 0xbb, 0xd7, 0x0b, 0x4e, 0xad, 0x80, 0x79, 0x1d, 0xcf, 0xd7, 0x41, 0x25, 0x63,
-	0x1a, 0xb4, 0x22, 0xe5, 0x87, 0x52, 0x4c, 0xf6, 0xa1, 0x96, 0x56, 0x4b, 0x6a, 0xd5, 0x19, 0x93,
-	0x7c, 0x35, 0x45, 0x15, 0x89, 0xab, 0xa8, 0xb8, 0x54, 0xcd, 0x9e, 0xc4, 0x26, 0xa5, 0xf4, 0x4c,
-	0xc9, 0x46, 0x4a, 0x49, 0x4a, 0xce, 0xa6, 0x94, 0x92, 0x8a, 0xee, 0x3e, 0x2c, 0xe2, 0x59, 0x18,
-	0x8c, 0xd2, 0xa9, 0x4c, 0x09, 0x65, 0x5a, 0x53, 0xd2, 0x44, 0x6d, 0x03, 0x8a, 0x7d, 0xfb, 0xcc,
-	0xb2, 0x3b, 0x28, 0x1f, 0xdc, 0x95, 0xce, 0x29, 0xf4, 0xed, 0xb3, 0xcd, 0x0e, 0x92, 0xaf, 0x61,
-	0x59, 0xad, 0xef, 0x30, 0x74, 0xd1, 0xe7, 0x9e, 0xdd, 0x8b, 0x74, 0x97, 0xec, 0x2a, 0xa3, 0xd7,
-	0x25, 0x68, 0x7b, 0x84, 0x69, 0xfc, 0x26, 0x0f, 0x64, 0xb2, 0x95, 0x25, 0x3e, 0x53, 0x5d, 0xec,
-	0xd9, 0x83, 0x19, 0x5a, 0x11, 0x13, 0xe0, 0xe6, 0x8e, 0x40, 0x52, 0x45, 0x20, 0x98, 0xec, 0x76,
-	0x92, 0x50, 0xe7, 0x65, 0xda, 0x14, 0x48, 0xaa, 0x08, 0x56, 0x7e, 0x9d, 0x81, 0xbc, 0xa4, 0x26,
-	0xb7, 0xa0, 0x98, 0xf4, 0xc6, 0xd4, 0xbd, 0x17, 0x17, 0x22, 0x11, 0x91, 0x2d, 0xa8, 0xbc, 0xf2,
-	0xce, 0xd0, 0xb5, 0xd4, 0x09, 0xa6, 0x5d, 0x78, 0xf5, 0x68, 0x44, 0x9c, 0x92, 0xa8, 0x1d, 0xbd,
-	0xeb, 0x65, 0xe1, 0x24, 0x5f, 0x99, 0x49, 0x33, 0x65, 0xa7, 0x30, 0xed, 0x2d, 0xd0, 0x7a, 0x0a,
-	0xa5, 0x98, 0x36, 0x01, 0x52, 0xed, 0xb7, 0xfc, 0xac, 0xed, 0xb7, 0x14, 0x68, 0x6b, 0x19, 0x96,
-	0xba, 0x9c, 0x87, 0x6a, 0x17, 0x32, 0x10, 0xac, 0xfc, 0xcd, 0x80, 0xbc, 0x34, 0x0e, 0xf9, 0x1e,
-	0x54, 0xe4, 0x64, 0xc4, 0x6d, 0x1e, 0x47, 0xaa, 0x26, 0x1a, 0x1d, 0x49, 0x4c, 0x1d, 0xcb, 0x19,
-	0x72, 0x17, 0x2a, 0x1d, 0x16, 0x3a, 0x89, 0x62, 0x12, 0x67, 0x40, 0x08, 0x47, 0x2a, 0x02, 0xb0,
-	0x61, 0xa1, 0x6c, 0x5f, 0xe6, 0x12, 0x15, 0x29, 0xdc, 0x95, 0xdd, 0xc9, 0x6f, 0xe1, 0x38, 0x55,
-	0x00, 0xc9, 0x2f, 0x4f, 0xb2, 0x9f, 0x2b, 0x19, 0xf5, 0xcc, 0xd0, 0x79, 0x8d, 0x0d, 0xa8, 0xa6,
-	0x3b, 0xef, 0x22, 0x61, 0xf8, 0x71, 0xbf, 0x8d, 0x4c, 0x7a, 0xba, 0x46, 0xf5, 0x68, 0x3f, 0x57,
-	0xca, 0xd4, 0xb3, 0xaa, 0x19, 0xd0, 0xb8, 0x03, 0xc5, 0xa4, 0xe7, 0x39, 0x4c, 0xa3, 0x42, 0xdb,
-	0xd0, 0x69, 0x74, 0xeb, 0x47, 0x7f, 0x7e, 0x7b, 0xdb, 0xf8, 0xeb, 0xdb, 0xdb, 0xc6, 0x3f, 0xde,
-	0xde, 0x36, 0x7e, 0x76, 0x47, 0xed, 0xd6, 0x0b, 0xe4, 0x7f, 0x6b, 0x26, 0xff, 0xf9, 0xd3, 0x2e,
-	0x48, 0xcf, 0x3e, 0xf8, 0x4f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x41, 0xf5, 0x90, 0x14, 0x19, 0x1a,
-	0x00, 0x00,
+	// 2856 bytes of a gzipped FileDescriptorProto
+	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x5a, 0x49, 0x6f, 0x24, 0x49,
+	0xf5, 0x77, 0x6d, 0xae, 0xaa, 0x57, 0x55, 0x76, 0x39, 0xa6, 0x97, 0x6c, 0xff, 0xfb, 0xdf, 0x4b,
+	0x35, 0x33, 0x78, 0x60, 0x70, 0x6b, 0x3c, 0xad, 0x69, 0x34, 0xbb, 0xcb, 0xee, 0x9e, 0x6a, 0xcb,
+	0x6e, 0xbb, 0xc3, 0xf6, 0x8c, 0xc4, 0x81, 0x54, 0x56, 0x66, 0xb8, 0x1c, 0x38, 0x2b, 0x33, 0x27,
+	0x32, 0xd2, 0x8b, 0xf8, 0x02, 0x70, 0x18, 0x71, 0x41, 0x48, 0x7c, 0x06, 0x3e, 0x00, 0x7c, 0x04,
+	0x0e, 0x08, 0x71, 0x81, 0x2b, 0xa8, 0x4f, 0x70, 0xe0, 0x84, 0xc4, 0x11, 0xa1, 0xd8, 0xb2, 0xb2,
+	0xbc, 0xd4, 0xd2, 0xb3, 0x70, 0x72, 0xc5, 0x8b, 0xf7, 0x7b, 0xb1, 0xbd, 0xf8, 0xbd, 0x17, 0x2f,
+	0x0d, 0x4b, 0x01, 0xe1, 0x27, 0x21, 0x3b, 0xa2, 0x41, 0xef, 0xe1, 0xf1, 0xdb, 0x5d, 0xc2, 0x9d,
+	0xb7, 0x1f, 0x1e, 0x53, 0xc6, 0x13, 0xc7, 0xb7, 0x63, 0xc2, 0x8e, 0xa9, 0x4b, 0x96, 0x23, 0x16,
+	0xf2, 0x10, 0x59, 0x34, 0xe6, 0x34, 0x5c, 0x1e, 0xe8, 0x2f, 0x6b, 0xfd, 0xc5, 0xbb, 0xbd, 0x30,
+	0xec, 0xf9, 0xe4, 0xa1, 0x13, 0xd1, 0x87, 0x07, 0x94, 0xf8, 0x9e, 0xdd, 0x25, 0x87, 0xce, 0x31,
+	0x0d, 0x99, 0x82, 0x2e, 0xde, 0xd1, 0x0a, 0xb2, 0xd5, 0x4d, 0x0e, 0x1e, 0x7a, 0x09, 0x73, 0x38,
+	0x0d, 0x83, 0xab, 0xfa, 0x4f, 0x98, 0x13, 0x45, 0x84, 0xc5, 0xaa, 0xbf, 0xf5, 0xe7, 0x3c, 0xcc,
+	0x7d, 0xa6, 0x26, 0xb5, 0xab, 0xe6, 0x84, 0xae, 0x41, 0xe9, 0x30, 0x8c, 0x79, 0x6c, 0xe5, 0xee,
+	0x15, 0x96, 0xaa, 0x58, 0x35, 0xd0, 0x22, 0x54, 0x7a, 0x0e, 0x27, 0x27, 0xce, 0x59, 0x6c, 0xe5,
+	0x65, 0x47, 0xda, 0x46, 0xdb, 0x30, 0x2f, 0x94, 0x3a, 0x7b, 0x7b, 0x3b, 0x4f, 0xa9, 0xcf, 0x09,
+	0x8b, 0xad, 0xbf, 0x97, 0xef, 0x15, 0x96, 0x6a, 0x2b, 0xdf, 0x59, 0xbe, 0x6a, 0x69, 0xcb, 0x03,
+	0x6d, 0x7c, 0x1e, 0x8d, 0x1e, 0x43, 0xf1, 0x90, 0xf3, 0xc8, 0x2a, 0x48, 0x23, 0x0f, 0x46, 0x1b,
+	0xc1, 0x61, 0xc2, 0x09, 0x96, 0x00, 0xf4, 0x08, 0x0a, 0xdc, 0x8f, 0xad, 0x92, 0xc4, 0xb5, 0xae,
+	0xc6, 0xed, 0x6d, 0xee, 0x2a, 0x98, 0x50, 0x97, 0x28, 0x37, 0xb2, 0x8a, 0x63, 0x51, 0x6b, 0x3b,
+	0x06, 0xe5, 0x46, 0xe8, 0xff, 0xa0, 0x4a, 0x4e, 0xa3, 0x90, 0x71, 0x9b, 0x87, 0xd6, 0xac, 0xda,
+	0x12, 0x25, 0xd8, 0x0b, 0x5b, 0x3f, 0x85, 0xda, 0x3a, 0x89, 0x39, 0x0d, 0xe4, 0x61, 0x20, 0x0b,
+	0x8a, 0x62, 0x8d, 0x56, 0xee, 0x5e, 0x6e, 0xa9, 0xda, 0x2e, 0xbe, 0x5c, 0xcd, 0xe5, 0xb1, 0x94,
+	0xa0, 0x1b, 0x30, 0x1b, 0x27, 0xdd, 0x98, 0x70, 0x2b, 0x2f, 0xfa, 0xb0, 0x6e, 0xa1, 0xf7, 0xa0,
+	0x28, 0x4c, 0x59, 0x85, 0x7b, 0xb9, 0xa5, 0xda, 0xca, 0x1b, 0x57, 0x4f, 0x6a, 0x27, 0x64, 0x7c,
+	0x97, 0xf8, 0xc4, 0xe5, 0x21, 0xc3, 0x12, 0xd3, 0xfa, 0x0d, 0x40, 0x35, 0xdd, 0x19, 0x84, 0xa0,
+	0x18, 0x38, 0x7d, 0x62, 0x2d, 0x48, 0xfb, 0xf2, 0x37, 0xfa, 0x04, 0x4a, 0x7d, 0x87, 0xbb, 0x87,
+	0xf2, 0x8c, 0x6b, 0x2b, 0xdf, 0x1b, 0xbd, 0xc3, 0x5b, 0x42, 0x15, 0x93, 0x2f, 0x12, 0x12, 0x73,
+	0xac, 0x80, 0x68, 0x1d, 0x4a, 0x4c, 0x98, 0x97, 0xce, 0x50, 0x5b, 0x59, 0x9e, 0xe0, 0x8c, 0x32,
+	0x1b, 0x82, 0x15, 0x18, 0xbd, 0x80, 0xa6, 0xfc, 0xf1, 0xca, 0xae, 0x73, 0x01, 0x8e, 0xda, 0x50,
+	0x61, 0xc4, 0xa3, 0x8c, 0xb8, 0x13, 0x6c, 0x9e, 0x9c, 0x9b, 0xd6, 0xc6, 0x29, 0x0e, 0x05, 0x60,
+	0xd1, 0x80, 0x13, 0x16, 0x38, 0xbe, 0xed, 0xb8, 0x9c, 0x1e, 0x13, 0x3b, 0xb5, 0x79, 0x4b, 0xda,
+	0x7c, 0x34, 0xda, 0xe6, 0x33, 0x8d, 0x5e, 0x95, 0xe0, 0x74, 0x84, 0x1b, 0xf4, 0x52, 0x39, 0xda,
+	0x87, 0x79, 0xf5, 0xcb, 0x66, 0x24, 0x8e, 0xc2, 0x20, 0x26, 0xd6, 0xa2, 0x1c, 0xe6, 0xad, 0xd1,
+	0xc3, 0xac, 0x2b, 0xb3, 0x1a, 0x83, 0xe7, 0xbc, 0xa1, 0x36, 0xfa, 0x08, 0x2a, 0x1e, 0xf1, 0x89,
+	0xb8, 0xa7, 0xd6, 0x35, 0x69, 0x6f, 0x84, 0x73, 0xaf, 0x6b, 0x4d, 0x9c, 0x62, 0xd0, 0xc7, 0x50,
+	0x66, 0xe4, 0x84, 0x51, 0x4e, 0xac, 0xa2, 0x84, 0xbf, 0x3e, 0x6e, 0x27, 0xa5, 0x32, 0x36, 0x28,
+	0xf4, 0x0e, 0x94, 0x39, 0xed, 0x93, 0x30, 0xe1, 0xd6, 0xac, 0x34, 0x70, 0x6b, 0x59, 0xf1, 0xd1,
+	0xb2, 0xe1, 0xa3, 0xe5, 0x75, 0xcd, 0x57, 0xd8, 0x68, 0xa2, 0x0f, 0xc5, 0xa8, 0x9c, 0x51, 0x12,
+	0x5b, 0x65, 0x09, 0x1a, 0x77, 0xff, 0x09, 0x67, 0x67, 0xd8, 0x60, 0x50, 0x1b, 0x4a, 0x07, 0x4e,
+	0xe2, 0x73, 0xab, 0x32, 0xc9, 0x0e, 0x3e, 0x15, 0xaa, 0xcf, 0x82, 0x9f, 0x10, 0x57, 0xb9, 0xa5,
+	0x84, 0xa2, 0x0f, 0x61, 0xb6, 0x4f, 0x19, 0x0b, 0x99, 0x55, 0x1d, 0xb7, 0xee, 0xac, 0x53, 0x6b,
+	0x10, 0xfa, 0x14, 0xe6, 0xd4, 0x2f, 0x3b, 0x22, 0xcc, 0x25, 0x01, 0xb7, 0x90, 0x34, 0x73, 0xfb,
+	0xc2, 0xea, 0xf7, 0x9f, 0x05, 0xfc, 0x9d, 0x95, 0xcf, 0x1c, 0x3f, 0x21, 0xed, 0xbc, 0x95, 0xc3,
+	0x0d, 0x85, 0xdb, 0x51, 0x30, 0xf4, 0x1c, 0x16, 0x86, 0x0d, 0x39, 0x3d, 0x62, 0xbd, 0x26, 0x6d,
+	0xdd, 0x1f, 0xc1, 0x08, 0x4a, 0x17, 0x37, 0x87, 0x8c, 0x39, 0x3d, 0x82, 0x9e, 0x40, 0xcd, 0x0d,
+	0x59, 0x6c, 0x47, 0xa1, 0x4f, 0xdd, 0x33, 0x0b, 0xa4, 0xa5, 0x11, 0x17, 0x6d, 0x2d, 0x64, 0xf1,
+	0x8e, 0xd4, 0xc5, 0xe0, 0xa6, 0xbf, 0xd1, 0xfb, 0x50, 0x3e, 0x24, 0x8e, 0x27, 0x2e, 0x6b, 0x73,
+	0xdc, 0x64, 0x3a, 0x4a, 0x11, 0x1b, 0xc4, 0x46, 0xb1, 0x52, 0x6a, 0xce, 0x6e, 0x14, 0x2b, 0xb5,
+	0x66, 0x13, 0x2f, 0x9c, 0x90, 0x6e, 0x1c, 0xba, 0x47, 0x84, 0xdb, 0x49, 0xd4, 0x63, 0x8e, 0x47,
+	0xf0, 0x9c, 0x08, 0x4f, 0x81, 0x67, 0x6b, 0x75, 0x7c, 0x93, 0x91, 0x7e, 0x28, 0xef, 0x9f, 0x72,
+	0xea, 0x41, 0x87, 0x56, 0xbc, 0xd0, 0x71, 0x23, 0x45, 0x48, 0xc2, 0x1a, 0xc8, 0x53, 0xc0, 0x90,
+	0xbc, 0xf5, 0x01, 0x54, 0x8c, 0xef, 0xa7, 0x5c, 0x99, 0xcb, 0x70, 0xe5, 0x6d, 0xa8, 0x8a, 0xbf,
+	0x71, 0xe4, 0xb8, 0x44, 0x93, 0xf4, 0x40, 0xd0, 0x7a, 0x59, 0x80, 0xb2, 0x5e, 0x23, 0xda, 0x14,
+	0x9e, 0x2b, 0x8d, 0x4b, 0x03, 0xb5, 0x95, 0x95, 0xb1, 0xfb, 0xa2, 0xff, 0x6e, 0x47, 0x44, 0x5d,
+	0x83, 0x18, 0x1b, 0x13, 0xe8, 0xb9, 0x20, 0x32, 0xcd, 0x06, 0xf9, 0x57, 0x36, 0x97, 0xda, 0x58,
+	0xfc, 0x5d, 0x1e, 0x9a, 0xe7, 0xbb, 0xd1, 0x16, 0x14, 0x44, 0xec, 0x51, 0x61, 0xe0, 0xfd, 0xe9,
+	0xed, 0x2f, 0xef, 0x12, 0xfe, 0x24, 0x10, 0x17, 0x50, 0xd8, 0x11, 0xe6, 0x1c, 0xcf, 0xd3, 0x31,
+	0xe1, 0x55, 0xcc, 0xad, 0x7a, 0x9e, 0x36, 0xe7, 0x78, 0x9e, 0x08, 0x8e, 0xea, 0x30, 0x65, 0x26,
+	0x50, 0xc5, 0xba, 0xb5, 0xf8, 0x2e, 0x54, 0xcc, 0xb8, 0xa8, 0x09, 0x85, 0x23, 0x72, 0xa6, 0x4f,
+	0x4c, 0xfc, 0x14, 0x09, 0xcc, 0xb1, 0xb8, 0x51, 0xfa, 0xb0, 0x54, 0xe3, 0xbd, 0xfc, 0x0f, 0x73,
+	0x02, 0x67, 0x06, 0x98, 0x06, 0xd7, 0xfa, 0x55, 0x0e, 0x2a, 0x26, 0x65, 0x40, 0x9d, 0xe1, 0xd8,
+	0xf9, 0xd6, 0xc8, 0x2c, 0x43, 0x86, 0xce, 0x55, 0xce, 0x19, 0xed, 0x26, 0x9c, 0xc4, 0x3a, 0xf4,
+	0xeb, 0x18, 0xfa, 0xc9, 0x70, 0x0c, 0x1d, 0x11, 0x85, 0xaf, 0x88, 0x9f, 0xad, 0x5f, 0x88, 0x89,
+	0xe9, 0xac, 0x04, 0xad, 0x0e, 0x4f, 0xec, 0xfb, 0x57, 0x9b, 0xdb, 0x7c, 0x74, 0x6e, 0x5e, 0x5f,
+	0xdf, 0x8c, 0x7e, 0x5d, 0x85, 0xe6, 0xf9, 0x9c, 0x21, 0xbd, 0x56, 0xb5, 0xcc, 0xb5, 0x7a, 0x0c,
+	0x85, 0x84, 0x51, 0x7d, 0x51, 0x46, 0x10, 0xec, 0x2e, 0x67, 0x34, 0xe8, 0x29, 0x73, 0x02, 0x21,
+	0xc8, 0x39, 0x76, 0x0f, 0x49, 0xdf, 0xdc, 0x8a, 0x09, 0xb1, 0x1a, 0x24, 0xb9, 0x9d, 0xf0, 0xc3,
+	0xd0, 0xd3, 0xd9, 0xc1, 0xa4, 0x70, 0x05, 0x42, 0x6b, 0x50, 0x75, 0x12, 0x7e, 0x18, 0x32, 0xca,
+	0xcf, 0xc6, 0x47, 0xc5, 0xac, 0x85, 0x01, 0x0e, 0xbd, 0x18, 0x10, 0xa8, 0x4a, 0x55, 0x1f, 0x4f,
+	0x9e, 0x80, 0x99, 0xbb, 0xa3, 0xae, 0x89, 0xb1, 0x23, 0xb6, 0x58, 0xe6, 0x8b, 0x22, 0xce, 0x36,
+	0x54, 0x1e, 0x88, 0x1c, 0x68, 0xc4, 0x61, 0xc2, 0x5c, 0x62, 0xfb, 0x4e, 0x97, 0xf8, 0x22, 0x9e,
+	0x8a, 0xc1, 0x3e, 0x98, 0x62, 0xb0, 0x5d, 0x89, 0xdf, 0x94, 0x70, 0x35, 0x62, 0x3d, 0xce, 0x88,
+	0x86, 0x9e, 0x05, 0x95, 0x73, 0xcf, 0x82, 0x1f, 0x43, 0xfd, 0x8b, 0x84, 0xb0, 0x33, 0x3b, 0x72,
+	0x98, 0xd3, 0x8f, 0xad, 0xea, 0x58, 0x56, 0x38, 0x3f, 0xfa, 0x0b, 0x01, 0xdf, 0x91, 0x68, 0x35,
+	0x78, 0xed, 0x8b, 0x81, 0x04, 0xbd, 0x01, 0xf3, 0xb4, 0x17, 0x84, 0x8c, 0xd8, 0x09, 0xa3, 0xb6,
+	0xeb, 0xc4, 0x44, 0x46, 0xb4, 0x0a, 0x6e, 0x28, 0xf1, 0x3e, 0xa3, 0x6b, 0x4e, 0x4c, 0x50, 0x0f,
+	0xe6, 0x4f, 0x28, 0x3f, 0x0c, 0x93, 0x94, 0xf3, 0xad, 0xba, 0x9c, 0xca, 0x47, 0x53, 0x4c, 0xe5,
+	0x73, 0x65, 0x61, 0x68, 0xf3, 0xe7, 0x4e, 0x86, 0x84, 0xe8, 0x4d, 0x68, 0xea, 0xfd, 0x1e, 0x04,
+	0x8c, 0x86, 0x74, 0xf9, 0x79, 0x25, 0x7f, 0x6e, 0xc4, 0x8b, 0x0e, 0xd4, 0xb3, 0xa6, 0x2e, 0x61,
+	0xa3, 0xf7, 0xb3, 0x6c, 0x34, 0xb1, 0x93, 0x65, 0xc8, 0xee, 0x63, 0x58, 0xb8, 0x70, 0x7a, 0x53,
+	0xb1, 0x25, 0x81, 0xe6, 0xf9, 0x03, 0xf8, 0x26, 0xe6, 0x79, 0x08, 0xaf, 0x5d, 0xb2, 0xb9, 0xdf,
+	0xc0, 0x48, 0xad, 0x7f, 0xe7, 0xe1, 0xda, 0x65, 0xaf, 0x11, 0xb4, 0x05, 0x35, 0x6f, 0xd0, 0x1c,
+	0xcf, 0x49, 0x19, 0xac, 0x66, 0xf4, 0x2c, 0x5e, 0x84, 0xad, 0x13, 0x42, 0x7b, 0x87, 0xea, 0x4d,
+	0x57, 0xc2, 0xba, 0x95, 0xcd, 0x9b, 0xca, 0xd3, 0xe6, 0x4d, 0x08, 0xc3, 0xc2, 0x81, 0xe3, 0xfb,
+	0x5d, 0xc7, 0x3d, 0xb2, 0x5d, 0x3f, 0x89, 0xe5, 0x5b, 0xc9, 0x93, 0x7e, 0x3c, 0x61, 0x7a, 0xda,
+	0x34, 0xf8, 0x35, 0x0d, 0xdf, 0x28, 0x56, 0x0a, 0xcd, 0xf2, 0xb7, 0x90, 0x62, 0x9d, 0x41, 0xf3,
+	0x7f, 0xb4, 0xe7, 0xad, 0x7f, 0xe4, 0x61, 0xe1, 0x42, 0xb8, 0x43, 0x0f, 0xe1, 0xb5, 0x0c, 0xd8,
+	0x8e, 0x93, 0x6e, 0x40, 0xd2, 0x8a, 0x07, 0xca, 0x74, 0xed, 0xaa, 0x9e, 0x94, 0x5e, 0xf3, 0x19,
+	0x7a, 0x7d, 0x90, 0xd2, 0xab, 0xc2, 0xcb, 0x80, 0x52, 0x35, 0x04, 0xa9, 0x90, 0xa8, 0x7b, 0x9e,
+	0x83, 0x55, 0x95, 0xe1, 0xc3, 0x29, 0x82, 0xf3, 0x54, 0x24, 0x5c, 0x3a, 0x47, 0xc2, 0x97, 0x71,
+	0xd2, 0xec, 0xe5, 0x9c, 0xf4, 0x55, 0x09, 0xa3, 0xf5, 0x9f, 0x3c, 0xa0, 0x8b, 0x39, 0x0f, 0xba,
+	0x0f, 0xd5, 0x38, 0xa0, 0x76, 0xa6, 0xa8, 0xa4, 0x0f, 0xb0, 0x12, 0x07, 0xb4, 0x23, 0xab, 0x4b,
+	0x57, 0x9c, 0x47, 0x7e, 0xec, 0x79, 0x14, 0x32, 0xe7, 0xe1, 0x9e, 0xdf, 0xea, 0xd2, 0x38, 0x96,
+	0xbf, 0x38, 0xd9, 0xa9, 0xf6, 0x7a, 0x76, 0x82, 0xbd, 0x2e, 0x7f, 0x33, 0x7b, 0xbd, 0x51, 0xac,
+	0x14, 0x9b, 0x25, 0x3c, 0xec, 0x80, 0xad, 0x3f, 0xe6, 0xa1, 0x9e, 0x2d, 0x69, 0x08, 0x8b, 0x26,
+	0xc9, 0xaa, 0xaa, 0xec, 0xe9, 0x76, 0x36, 0x7f, 0xd1, 0xaf, 0x99, 0x41, 0x62, 0x72, 0x4d, 0x6f,
+	0xab, 0x48, 0x6c, 0x1a, 0x9d, 0x19, 0xbd, 0xb1, 0xb6, 0xb8, 0xaa, 0x8c, 0x1e, 0x13, 0x5b, 0x76,
+	0x96, 0xee, 0xe5, 0x96, 0xe6, 0xc6, 0x65, 0x11, 0x66, 0x0a, 0xcb, 0xe6, 0xc7, 0xa0, 0x4e, 0x45,
+	0xc3, 0xa0, 0x33, 0x83, 0x41, 0x99, 0x14, 0x62, 0x59, 0x04, 0x53, 0x29, 0xdd, 0xac, 0x2e, 0x82,
+	0xa9, 0x5c, 0xed, 0x01, 0x34, 0x4c, 0xdd, 0xc5, 0x76, 0x43, 0x8f, 0xe8, 0xe3, 0xae, 0x1b, 0xe1,
+	0x5a, 0xe8, 0x91, 0xd6, 0x33, 0xb8, 0x7e, 0xe9, 0x18, 0xe8, 0x16, 0x5c, 0x7f, 0x8a, 0xb7, 0xb7,
+	0xec, 0x1d, 0xbc, 0xbd, 0xb7, 0xbd, 0xb6, 0xbd, 0x69, 0xaf, 0x3f, 0x79, 0xba, 0xba, 0xbf, 0xb9,
+	0xd7, 0x9c, 0x41, 0xd7, 0x61, 0x41, 0x76, 0xe1, 0x27, 0x2f, 0xf6, 0x9f, 0xec, 0xee, 0xd9, 0x3b,
+	0xdb, 0x78, 0xaf, 0x99, 0x6b, 0xcf, 0x67, 0xc6, 0x93, 0x95, 0xb4, 0x9f, 0x01, 0x2c, 0x5e, 0x5d,
+	0xcf, 0x41, 0x8f, 0xe0, 0x46, 0xdf, 0x39, 0xb5, 0xd3, 0x5a, 0x91, 0x01, 0xc7, 0x72, 0xc7, 0x1b,
+	0xf8, 0x5a, 0xdf, 0x39, 0x35, 0x50, 0x03, 0x8a, 0xd1, 0xbb, 0x70, 0x33, 0x1d, 0x25, 0xa5, 0x56,
+	0xb1, 0x3c, 0xe5, 0xf0, 0x0d, 0x7c, 0xdd, 0x74, 0x9b, 0x4a, 0x8e, 0x58, 0x67, 0x8c, 0x1e, 0x40,
+	0xba, 0x70, 0x3b, 0x61, 0xbe, 0xa2, 0x9b, 0xce, 0x0c, 0xae, 0x19, 0xe9, 0x3e, 0xf3, 0x51, 0x04,
+	0x8b, 0x59, 0x25, 0x5b, 0x97, 0x62, 0x6c, 0x46, 0x7a, 0xe4, 0x54, 0x27, 0xac, 0x6f, 0x8f, 0x48,
+	0xeb, 0x85, 0x9a, 0xba, 0x13, 0x81, 0xb7, 0x9b, 0x74, 0x63, 0x4e, 0x79, 0xc2, 0x49, 0x67, 0x06,
+	0xdf, 0xcc, 0x8c, 0x62, 0x0a, 0x3d, 0x42, 0x19, 0xbd, 0x05, 0xc8, 0xf1, 0xfd, 0xf0, 0xc4, 0x76,
+	0x59, 0x18, 0xc7, 0xb6, 0x3e, 0xc8, 0x92, 0xcc, 0xc4, 0x9a, 0xb2, 0x67, 0x4d, 0x74, 0xec, 0xaa,
+	0x23, 0xcd, 0xc4, 0xc0, 0xd9, 0xa9, 0x63, 0xe0, 0x90, 0xf3, 0x96, 0xcf, 0x3b, 0xef, 0x63, 0xb0,
+	0x0e, 0x42, 0xe6, 0x12, 0xcf, 0x4e, 0x62, 0x62, 0x87, 0x8c, 0xf6, 0xa8, 0x38, 0x14, 0x59, 0x78,
+	0x6d, 0xca, 0xe9, 0x5c, 0x57, 0xfd, 0xfb, 0x31, 0xd9, 0xd6, 0xbd, 0x82, 0x7e, 0xd0, 0x0b, 0x78,
+	0x43, 0x03, 0x1d, 0xcf, 0x54, 0x1e, 0xec, 0x2e, 0x39, 0x10, 0xa9, 0xa5, 0x7c, 0xd5, 0xd8, 0xf2,
+	0x75, 0x44, 0x98, 0xac, 0xa1, 0x56, 0xf0, 0x7d, 0xa5, 0xbd, 0xea, 0x79, 0x6a, 0x86, 0x6d, 0xa9,
+	0x2a, 0x23, 0xdc, 0x96, 0x52, 0x44, 0x36, 0x54, 0x64, 0x91, 0x85, 0x92, 0xd8, 0x9a, 0x97, 0x34,
+	0xb4, 0xf6, 0x2a, 0x15, 0xc3, 0xcc, 0xed, 0x91, 0x55, 0x98, 0xd4, 0xe8, 0xe2, 0x1f, 0x8a, 0x30,
+	0x37, 0xdc, 0x39, 0xc2, 0x1b, 0x2b, 0xaf, 0xe6, 0x8d, 0xd5, 0x69, 0xbc, 0x11, 0xa6, 0xf7, 0xc6,
+	0xda, 0xb7, 0xe6, 0x8d, 0xf5, 0xf1, 0xde, 0xd8, 0xf8, 0x6a, 0xde, 0x38, 0x37, 0x8d, 0x37, 0x2e,
+	0x7c, 0x3d, 0xde, 0x88, 0x26, 0xf4, 0xc6, 0xf6, 0x3d, 0xb8, 0x73, 0xe9, 0x31, 0xc4, 0x11, 0x71,
+	0xe9, 0x01, 0x9d, 0x44, 0xa3, 0xb5, 0x05, 0xe8, 0x62, 0xc9, 0x59, 0x31, 0x74, 0xc6, 0x69, 0x34,
+	0xf1, 0xd5, 0x59, 0xc6, 0x57, 0x44, 0xb0, 0xee, 0x86, 0x9e, 0x09, 0x37, 0xf2, 0x77, 0xeb, 0xcb,
+	0x1c, 0xd4, 0x32, 0x35, 0xe3, 0xa9, 0x23, 0xd5, 0x73, 0xa8, 0x8a, 0x57, 0x9f, 0x72, 0xa4, 0xc2,
+	0x2b, 0x3a, 0x12, 0xae, 0x24, 0x8c, 0xca, 0xbe, 0xd6, 0xe7, 0x70, 0xf3, 0x0a, 0x25, 0x64, 0x41,
+	0x39, 0x72, 0xb8, 0xb8, 0x37, 0x7a, 0x7a, 0xa6, 0x89, 0x5a, 0x50, 0x8f, 0x8d, 0x9e, 0x48, 0x62,
+	0xf3, 0x3a, 0x01, 0xcc, 0xc8, 0x5a, 0x04, 0x6a, 0x99, 0xe7, 0x08, 0xba, 0x01, 0x25, 0x72, 0xea,
+	0xb8, 0xfa, 0x53, 0x50, 0x67, 0x06, 0xab, 0x26, 0xb2, 0x60, 0x36, 0x62, 0xe4, 0x80, 0x9e, 0x2a,
+	0x23, 0x9d, 0x19, 0xac, 0xdb, 0x02, 0x31, 0x58, 0xa5, 0x44, 0xc8, 0x66, 0xbb, 0x0e, 0x20, 0x1d,
+	0xc1, 0xe6, 0x67, 0x11, 0x69, 0xfd, 0x35, 0xa7, 0xbf, 0xf9, 0x10, 0x91, 0x49, 0xdc, 0x83, 0x8a,
+	0x98, 0x62, 0x3f, 0xd2, 0xa1, 0xa8, 0x64, 0x32, 0x2e, 0x23, 0x45, 0xab, 0x30, 0x1f, 0x11, 0x66,
+	0x73, 0x76, 0x66, 0x9b, 0x12, 0x7d, 0x7e, 0x5c, 0x89, 0xbe, 0x11, 0x11, 0xb6, 0xc7, 0xce, 0xf6,
+	0x74, 0xa1, 0xfe, 0x16, 0x54, 0x98, 0x18, 0xcd, 0x0e, 0x03, 0x9d, 0xfa, 0xca, 0x22, 0xfc, 0xd9,
+	0x76, 0x80, 0xb0, 0x20, 0x15, 0xd1, 0x25, 0x1e, 0x0a, 0x9c, 0xd8, 0x7e, 0xe8, 0x3a, 0x3e, 0xe5,
+	0x82, 0x0d, 0x55, 0x08, 0x5a, 0xbc, 0x30, 0x4a, 0x3b, 0x0c, 0x7d, 0x59, 0x08, 0x17, 0x84, 0x23,
+	0xf2, 0x2e, 0x89, 0xdc, 0x4c, 0x81, 0xad, 0x7f, 0xe6, 0x01, 0x06, 0x05, 0x69, 0xf4, 0x3a, 0xd4,
+	0xd5, 0x45, 0x57, 0x57, 0x4b, 0x27, 0x96, 0x79, 0x2b, 0x87, 0x6b, 0x52, 0xae, 0xee, 0x14, 0xda,
+	0x80, 0x46, 0x56, 0xcd, 0xd4, 0x40, 0x26, 0x7c, 0x3c, 0xd6, 0x33, 0xa6, 0x04, 0xe5, 0x69, 0x5b,
+	0xaa, 0x16, 0x64, 0xf2, 0x53, 0xa5, 0xb4, 0xa5, 0x64, 0x03, 0x25, 0x43, 0x2c, 0x85, 0x8c, 0x92,
+	0xa9, 0x14, 0xbc, 0x0e, 0x73, 0xe4, 0x34, 0x0a, 0x07, 0x4f, 0x2a, 0xf9, 0x2c, 0xa8, 0xe2, 0x86,
+	0x92, 0x1a, 0xb5, 0x15, 0x28, 0x0b, 0x46, 0x77, 0x7a, 0x2a, 0x9e, 0x8e, 0x3c, 0x9c, 0xd9, 0xbe,
+	0x73, 0xba, 0xda, 0x23, 0xe8, 0x53, 0x58, 0x30, 0x04, 0x48, 0x3c, 0x12, 0x70, 0xea, 0xf8, 0x26,
+	0xd4, 0x8e, 0xda, 0x74, 0xc3, 0x8d, 0x29, 0xa6, 0xf5, 0x65, 0x49, 0xdd, 0xf8, 0xe1, 0x4f, 0x24,
+	0xa8, 0x03, 0x25, 0x8f, 0xf8, 0xce, 0xd9, 0x04, 0x25, 0xee, 0x0b, 0xe0, 0xe5, 0x75, 0x81, 0xc4,
+	0xca, 0x80, 0xb0, 0xe4, 0x74, 0xcd, 0xa3, 0x6a, 0x5a, 0x4b, 0xab, 0x02, 0x89, 0x95, 0x81, 0xc5,
+	0x9f, 0xe7, 0xa1, 0x24, 0x4d, 0xa3, 0xdb, 0x50, 0x36, 0xdf, 0x5c, 0x94, 0xdf, 0x0b, 0x87, 0x30,
+	0x22, 0xd4, 0x86, 0xda, 0x01, 0x3d, 0x25, 0x9e, 0xad, 0x56, 0x30, 0xce, 0xe1, 0xd5, 0xa5, 0x11,
+	0xb9, 0xaa, 0x44, 0xad, 0xeb, 0x59, 0x2f, 0x88, 0x43, 0x0a, 0xd4, 0x36, 0x69, 0x4b, 0x85, 0x31,
+	0x96, 0x3a, 0x33, 0xb8, 0x99, 0x41, 0x29, 0x4b, 0xab, 0x00, 0x99, 0xcf, 0x3a, 0xa5, 0x49, 0x3f,
+	0xeb, 0x64, 0x40, 0xed, 0x05, 0x98, 0x3f, 0xe4, 0x3c, 0x52, 0xb3, 0x90, 0x44, 0xb0, 0xf8, 0x97,
+	0x1c, 0x94, 0xe4, 0xe6, 0xa0, 0xef, 0x42, 0x4d, 0x76, 0xc6, 0xdc, 0xe1, 0x49, 0xac, 0xde, 0xc5,
+	0x83, 0x25, 0x89, 0xae, 0x5d, 0xd9, 0x83, 0xee, 0x43, 0xad, 0xc7, 0x22, 0xd7, 0x28, 0x1a, 0x9e,
+	0x01, 0x21, 0x1c, 0xa8, 0x08, 0xc0, 0x8a, 0x4d, 0xe4, 0x67, 0xb1, 0xa2, 0x51, 0x91, 0xc2, 0x27,
+	0xf2, 0xab, 0xd7, 0xd7, 0xb0, 0x9c, 0x3a, 0x80, 0xb4, 0x2f, 0x57, 0xb2, 0x51, 0xac, 0xe4, 0x9a,
+	0xf9, 0xf4, 0xf0, 0x5a, 0x2b, 0x50, 0xcf, 0x7e, 0xeb, 0x16, 0x8f, 0x86, 0x20, 0xe9, 0x77, 0x09,
+	0xd3, 0x31, 0x47, 0xb7, 0x36, 0x8a, 0x95, 0x7c, 0xb3, 0xa0, 0x8a, 0xcc, 0xad, 0xbb, 0x50, 0x36,
+	0xdf, 0xd2, 0xd2, 0xa7, 0x94, 0xd0, 0xce, 0xe9, 0xa7, 0x54, 0xeb, 0x5f, 0x39, 0x80, 0xc1, 0xd7,
+	0xe3, 0x4b, 0xbf, 0xff, 0x58, 0x50, 0xf6, 0x68, 0xec, 0x74, 0x7d, 0xf5, 0x0a, 0xab, 0x60, 0xd3,
+	0x44, 0x9f, 0xc3, 0x02, 0x8d, 0x6c, 0xc7, 0x75, 0x49, 0x1c, 0xdb, 0x6e, 0x18, 0x70, 0x16, 0xfa,
+	0xda, 0x15, 0xde, 0xbc, 0x7a, 0xe1, 0xcf, 0x76, 0x56, 0x25, 0x62, 0x4d, 0x01, 0x3a, 0x33, 0x78,
+	0x9e, 0x46, 0x43, 0x22, 0xb4, 0x07, 0x4d, 0xc9, 0x98, 0x36, 0x73, 0x04, 0x79, 0xd2, 0x3e, 0xe5,
+	0x9a, 0x37, 0x97, 0x46, 0xd4, 0x0d, 0x04, 0x02, 0x3b, 0x9c, 0x6c, 0x0a, 0xfd, 0xce, 0x0c, 0x9e,
+	0xf3, 0x87, 0x24, 0xed, 0x0a, 0xcc, 0xaa, 0x65, 0xb6, 0x7c, 0x98, 0x3f, 0x37, 0x0b, 0xb4, 0x04,
+	0x4d, 0xcd, 0xd5, 0x34, 0xb2, 0xbb, 0x7e, 0xe8, 0x1e, 0x99, 0x72, 0xc8, 0x9c, 0x92, 0x3f, 0x8b,
+	0xda, 0x52, 0x8a, 0x1e, 0xc2, 0xb5, 0x20, 0xe4, 0xf6, 0x05, 0x6d, 0x45, 0x86, 0x0b, 0x41, 0xc8,
+	0xf1, 0x10, 0xa0, 0xf5, 0xdb, 0x1c, 0xcc, 0x0d, 0x4f, 0x0e, 0x75, 0xa0, 0xce, 0xc3, 0x23, 0x12,
+	0xd8, 0xdd, 0xc4, 0x3d, 0x22, 0x7c, 0x7c, 0xf5, 0x67, 0x4f, 0x68, 0xb7, 0xa5, 0x32, 0xae, 0xf1,
+	0x41, 0x03, 0xbd, 0x07, 0xb7, 0x44, 0x1c, 0xf3, 0xc2, 0x93, 0x20, 0xe6, 0x8c, 0x38, 0x7d, 0x71,
+	0x10, 0x81, 0x22, 0x09, 0x7d, 0x5e, 0x37, 0x23, 0xc2, 0xd6, 0xd3, 0xfe, 0xb5, 0xb4, 0x1b, 0xdd,
+	0x85, 0x9a, 0x72, 0xf9, 0xec, 0xe3, 0x12, 0x94, 0x48, 0x3e, 0x2d, 0x7f, 0x99, 0x83, 0x5a, 0x66,
+	0x64, 0xf4, 0xff, 0x22, 0xe4, 0x9e, 0xda, 0x72, 0x7c, 0xf3, 0xc6, 0xab, 0xf6, 0x9d, 0x53, 0xa9,
+	0x23, 0x0b, 0xd2, 0xaa, 0xcb, 0x8e, 0xc8, 0x81, 0x7d, 0x40, 0x7d, 0x5f, 0xd7, 0x8b, 0x1a, 0x4a,
+	0xbc, 0x43, 0x0e, 0x9e, 0x52, 0xdf, 0x47, 0x1f, 0x41, 0x43, 0x74, 0xaa, 0x4c, 0xfd, 0xd8, 0xf1,
+	0xc7, 0xd2, 0x07, 0xae, 0x0b, 0xfd, 0x67, 0x5a, 0xbd, 0xfd, 0x83, 0xdf, 0xbf, 0xbc, 0x93, 0xfb,
+	0xd3, 0xcb, 0x3b, 0xb9, 0xbf, 0xbd, 0xbc, 0x93, 0xfb, 0xd1, 0x5d, 0xb5, 0x69, 0x34, 0x94, 0xff,
+	0x25, 0x74, 0xf1, 0x9f, 0x8e, 0xba, 0xb3, 0xd2, 0xde, 0x3b, 0xff, 0x0d, 0x00, 0x00, 0xff, 0xff,
+	0x7a, 0x8a, 0xc7, 0xb4, 0x91, 0x24, 0x00, 0x00,
 }
 
 func (m *VirtualService) Marshal() (dAtA []byte, err error) {
@@ -3635,6 +4473,22 @@ func (m *VirtualService) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 		i -= len(m.XXX_unrecognized)
 		copy(dAtA[i:], m.XXX_unrecognized)
 	}
+	if len(m.HostHTTPFilters) > 0 {
+		for iNdEx := len(m.HostHTTPFilters) - 1; iNdEx >= 0; iNdEx-- {
+			{
+				size, err := m.HostHTTPFilters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
+				if err != nil {
+					return 0, err
+				}
+				i -= size
+				i = encodeVarintVirtualService(dAtA, i, uint64(size))
+			}
+			i--
+			dAtA[i] = 0x3e
+			i--
+			dAtA[i] = 0xc2
+		}
+	}
 	if len(m.ExportTo) > 0 {
 		for iNdEx := len(m.ExportTo) - 1; iNdEx >= 0; iNdEx-- {
 			i -= len(m.ExportTo[iNdEx])
@@ -3784,9 +4638,25 @@ func (m *HTTPRoute) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 		i -= len(m.XXX_unrecognized)
 		copy(dAtA[i:], m.XXX_unrecognized)
 	}
-	if m.Delegate != nil {
+	if len(m.RouteHTTPFilters) > 0 {
+		for iNdEx := len(m.RouteHTTPFilters) - 1; iNdEx >= 0; iNdEx-- {
+			{
+				size, err := m.RouteHTTPFilters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
+				if err != nil {
+					return 0, err
+				}
+				i -= size
+				i = encodeVarintVirtualService(dAtA, i, uint64(size))
+			}
+			i--
+			dAtA[i] = 0x3e
+			i--
+			dAtA[i] = 0xc2
+		}
+	}
+	if m.DirectResponse != nil {
 		{
-			size, err := m.Delegate.MarshalToSizedBuffer(dAtA[:i])
+			size, err := m.DirectResponse.MarshalToSizedBuffer(dAtA[:i])
 			if err != nil {
 				return 0, err
 			}
@@ -3796,7 +4666,35 @@ func (m *HTTPRoute) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 		i--
 		dAtA[i] = 0x1
 		i--
-		dAtA[i] = 0xa2
+		dAtA[i] = 0xd2
+	}
+	if m.InternalActiveRedirect != nil {
+		{
+			size, err := m.InternalActiveRedirect.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintVirtualService(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x1
+		i--
+		dAtA[i] = 0xca
+	}
+	if m.Delegate != nil {
+		{
+			size, err := m.Delegate.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintVirtualService(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x1
+		i--
+		dAtA[i] = 0xa2
 	}
 	if m.MirrorPercentage != nil {
 		{
@@ -4474,6 +5372,22 @@ func (m *HTTPRouteDestination) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 		i -= len(m.XXX_unrecognized)
 		copy(dAtA[i:], m.XXX_unrecognized)
 	}
+	if len(m.FallbackClusters) > 0 {
+		for iNdEx := len(m.FallbackClusters) - 1; iNdEx >= 0; iNdEx-- {
+			{
+				size, err := m.FallbackClusters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
+				if err != nil {
+					return 0, err
+				}
+				i -= size
+				i = encodeVarintVirtualService(dAtA, i, uint64(size))
+			}
+			i--
+			dAtA[i] = 0x6
+			i--
+			dAtA[i] = 0xa2
+		}
+	}
 	if m.Headers != nil {
 		{
 			size, err := m.Headers.MarshalToSizedBuffer(dAtA[:i])
@@ -4804,7 +5718,7 @@ func (m *HTTPRedirect_DerivePort) MarshalToSizedBuffer(dAtA []byte) (int, error)
 	dAtA[i] = 0x28
 	return len(dAtA) - i, nil
 }
-func (m *HTTPRewrite) Marshal() (dAtA []byte, err error) {
+func (m *HTTPInternalActiveRedirect) Marshal() (dAtA []byte, err error) {
 	size := m.Size()
 	dAtA = make([]byte, size)
 	n, err := m.MarshalToSizedBuffer(dAtA[:size])
@@ -4814,12 +5728,12 @@ func (m *HTTPRewrite) Marshal() (dAtA []byte, err error) {
 	return dAtA[:n], nil
 }
 
-func (m *HTTPRewrite) MarshalTo(dAtA []byte) (int, error) {
+func (m *HTTPInternalActiveRedirect) MarshalTo(dAtA []byte) (int, error) {
 	size := m.Size()
 	return m.MarshalToSizedBuffer(dAtA[:size])
 }
 
-func (m *HTTPRewrite) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+func (m *HTTPInternalActiveRedirect) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 	i := len(dAtA)
 	_ = i
 	var l int
@@ -4828,102 +5742,144 @@ func (m *HTTPRewrite) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 		i -= len(m.XXX_unrecognized)
 		copy(dAtA[i:], m.XXX_unrecognized)
 	}
+	if m.ForcedAddHeaderBeforeRouteMatcher {
+		i--
+		if m.ForcedAddHeaderBeforeRouteMatcher {
+			dAtA[i] = 1
+		} else {
+			dAtA[i] = 0
+		}
+		i--
+		dAtA[i] = 0x1
+		i--
+		dAtA[i] = 0x88
+	}
+	if m.ForcedUseOriginalHost {
+		i--
+		if m.ForcedUseOriginalHost {
+			dAtA[i] = 1
+		} else {
+			dAtA[i] = 0
+		}
+		i--
+		dAtA[i] = 0x1
+		i--
+		dAtA[i] = 0x80
+	}
+	if len(m.Policies) > 0 {
+		for iNdEx := len(m.Policies) - 1; iNdEx >= 0; iNdEx-- {
+			{
+				size, err := m.Policies[iNdEx].MarshalToSizedBuffer(dAtA[:i])
+				if err != nil {
+					return 0, err
+				}
+				i -= size
+				i = encodeVarintVirtualService(dAtA, i, uint64(size))
+			}
+			i--
+			dAtA[i] = 0x7a
+		}
+	}
 	if len(m.Authority) > 0 {
 		i -= len(m.Authority)
 		copy(dAtA[i:], m.Authority)
 		i = encodeVarintVirtualService(dAtA, i, uint64(len(m.Authority)))
 		i--
-		dAtA[i] = 0x12
+		dAtA[i] = 0x3a
 	}
-	if len(m.Uri) > 0 {
-		i -= len(m.Uri)
-		copy(dAtA[i:], m.Uri)
-		i = encodeVarintVirtualService(dAtA, i, uint64(len(m.Uri)))
+	if m.Headers != nil {
+		{
+			size, err := m.Headers.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintVirtualService(dAtA, i, uint64(size))
+		}
 		i--
-		dAtA[i] = 0xa
-	}
-	return len(dAtA) - i, nil
-}
-
-func (m *StringMatch) Marshal() (dAtA []byte, err error) {
-	size := m.Size()
-	dAtA = make([]byte, size)
-	n, err := m.MarshalToSizedBuffer(dAtA[:size])
-	if err != nil {
-		return nil, err
+		dAtA[i] = 0x32
 	}
-	return dAtA[:n], nil
-}
-
-func (m *StringMatch) MarshalTo(dAtA []byte) (int, error) {
-	size := m.Size()
-	return m.MarshalToSizedBuffer(dAtA[:size])
-}
-
-func (m *StringMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
-	i := len(dAtA)
-	_ = i
-	var l int
-	_ = l
-	if m.XXX_unrecognized != nil {
-		i -= len(m.XXX_unrecognized)
-		copy(dAtA[i:], m.XXX_unrecognized)
+	if m.AllowCrossScheme {
+		i--
+		if m.AllowCrossScheme {
+			dAtA[i] = 1
+		} else {
+			dAtA[i] = 0
+		}
+		i--
+		dAtA[i] = 0x28
 	}
-	if m.MatchType != nil {
+	if m.RedirectUrlRewriteSpecifier != nil {
 		{
-			size := m.MatchType.Size()
+			size := m.RedirectUrlRewriteSpecifier.Size()
 			i -= size
-			if _, err := m.MatchType.MarshalTo(dAtA[i:]); err != nil {
+			if _, err := m.RedirectUrlRewriteSpecifier.MarshalTo(dAtA[i:]); err != nil {
 				return 0, err
 			}
 		}
 	}
+	if len(m.RedirectResponseCodes) > 0 {
+		dAtA29 := make([]byte, len(m.RedirectResponseCodes)*10)
+		var j28 int
+		for _, num := range m.RedirectResponseCodes {
+			for num >= 1<<7 {
+				dAtA29[j28] = uint8(uint64(num)&0x7f | 0x80)
+				num >>= 7
+				j28++
+			}
+			dAtA29[j28] = uint8(num)
+			j28++
+		}
+		i -= j28
+		copy(dAtA[i:], dAtA29[:j28])
+		i = encodeVarintVirtualService(dAtA, i, uint64(j28))
+		i--
+		dAtA[i] = 0x12
+	}
+	if m.MaxInternalRedirects != 0 {
+		i = encodeVarintVirtualService(dAtA, i, uint64(m.MaxInternalRedirects))
+		i--
+		dAtA[i] = 0x8
+	}
 	return len(dAtA) - i, nil
 }
 
-func (m *StringMatch_Exact) MarshalTo(dAtA []byte) (int, error) {
-	size := m.Size()
-	return m.MarshalToSizedBuffer(dAtA[:size])
-}
-
-func (m *StringMatch_Exact) MarshalToSizedBuffer(dAtA []byte) (int, error) {
-	i := len(dAtA)
-	i -= len(m.Exact)
-	copy(dAtA[i:], m.Exact)
-	i = encodeVarintVirtualService(dAtA, i, uint64(len(m.Exact)))
-	i--
-	dAtA[i] = 0xa
-	return len(dAtA) - i, nil
-}
-func (m *StringMatch_Prefix) MarshalTo(dAtA []byte) (int, error) {
+func (m *HTTPInternalActiveRedirect_RedirectUrl) MarshalTo(dAtA []byte) (int, error) {
 	size := m.Size()
 	return m.MarshalToSizedBuffer(dAtA[:size])
 }
 
-func (m *StringMatch_Prefix) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+func (m *HTTPInternalActiveRedirect_RedirectUrl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 	i := len(dAtA)
-	i -= len(m.Prefix)
-	copy(dAtA[i:], m.Prefix)
-	i = encodeVarintVirtualService(dAtA, i, uint64(len(m.Prefix)))
+	i -= len(m.RedirectUrl)
+	copy(dAtA[i:], m.RedirectUrl)
+	i = encodeVarintVirtualService(dAtA, i, uint64(len(m.RedirectUrl)))
 	i--
-	dAtA[i] = 0x12
+	dAtA[i] = 0x1a
 	return len(dAtA) - i, nil
 }
-func (m *StringMatch_Regex) MarshalTo(dAtA []byte) (int, error) {
+func (m *HTTPInternalActiveRedirect_RedirectUrlRewriteRegex) MarshalTo(dAtA []byte) (int, error) {
 	size := m.Size()
 	return m.MarshalToSizedBuffer(dAtA[:size])
 }
 
-func (m *StringMatch_Regex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+func (m *HTTPInternalActiveRedirect_RedirectUrlRewriteRegex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 	i := len(dAtA)
-	i -= len(m.Regex)
-	copy(dAtA[i:], m.Regex)
-	i = encodeVarintVirtualService(dAtA, i, uint64(len(m.Regex)))
-	i--
-	dAtA[i] = 0x1a
+	if m.RedirectUrlRewriteRegex != nil {
+		{
+			size, err := m.RedirectUrlRewriteRegex.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintVirtualService(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x22
+	}
 	return len(dAtA) - i, nil
 }
-func (m *HTTPRetry) Marshal() (dAtA []byte, err error) {
+func (m *HTTPInternalActiveRedirect_RedirectPolicy) Marshal() (dAtA []byte, err error) {
 	size := m.Size()
 	dAtA = make([]byte, size)
 	n, err := m.MarshalToSizedBuffer(dAtA[:size])
@@ -4933,12 +5889,12 @@ func (m *HTTPRetry) Marshal() (dAtA []byte, err error) {
 	return dAtA[:n], nil
 }
 
-func (m *HTTPRetry) MarshalTo(dAtA []byte) (int, error) {
+func (m *HTTPInternalActiveRedirect_RedirectPolicy) MarshalTo(dAtA []byte) (int, error) {
 	size := m.Size()
 	return m.MarshalToSizedBuffer(dAtA[:size])
 }
 
-func (m *HTTPRetry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+func (m *HTTPInternalActiveRedirect_RedirectPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 	i := len(dAtA)
 	_ = i
 	var l int
@@ -4947,9 +5903,40 @@ func (m *HTTPRetry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 		i -= len(m.XXX_unrecognized)
 		copy(dAtA[i:], m.XXX_unrecognized)
 	}
-	if m.RetryRemoteLocalities != nil {
+	if m.ForcedAddHeaderBeforeRouteMatcher {
+		i--
+		if m.ForcedAddHeaderBeforeRouteMatcher {
+			dAtA[i] = 1
+		} else {
+			dAtA[i] = 0
+		}
+		i--
+		dAtA[i] = 0x1
+		i--
+		dAtA[i] = 0x90
+	}
+	if m.ForcedUseOriginalHost {
+		i--
+		if m.ForcedUseOriginalHost {
+			dAtA[i] = 1
+		} else {
+			dAtA[i] = 0
+		}
+		i--
+		dAtA[i] = 0x1
+		i--
+		dAtA[i] = 0x88
+	}
+	if len(m.Authority) > 0 {
+		i -= len(m.Authority)
+		copy(dAtA[i:], m.Authority)
+		i = encodeVarintVirtualService(dAtA, i, uint64(len(m.Authority)))
+		i--
+		dAtA[i] = 0x72
+	}
+	if m.Headers != nil {
 		{
-			size, err := m.RetryRemoteLocalities.MarshalToSizedBuffer(dAtA[:i])
+			size, err := m.Headers.MarshalToSizedBuffer(dAtA[:i])
 			if err != nil {
 				return 0, err
 			}
@@ -4957,36 +5944,89 @@ func (m *HTTPRetry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 			i = encodeVarintVirtualService(dAtA, i, uint64(size))
 		}
 		i--
-		dAtA[i] = 0x22
+		dAtA[i] = 0x6a
 	}
-	if len(m.RetryOn) > 0 {
-		i -= len(m.RetryOn)
-		copy(dAtA[i:], m.RetryOn)
-		i = encodeVarintVirtualService(dAtA, i, uint64(len(m.RetryOn)))
+	if m.AllowCrossScheme {
 		i--
-		dAtA[i] = 0x1a
+		if m.AllowCrossScheme {
+			dAtA[i] = 1
+		} else {
+			dAtA[i] = 0
+		}
+		i--
+		dAtA[i] = 0x60
 	}
-	if m.PerTryTimeout != nil {
+	if m.RedirectUrlRewriteSpecifier != nil {
 		{
-			size, err := m.PerTryTimeout.MarshalToSizedBuffer(dAtA[:i])
-			if err != nil {
+			size := m.RedirectUrlRewriteSpecifier.Size()
+			i -= size
+			if _, err := m.RedirectUrlRewriteSpecifier.MarshalTo(dAtA[i:]); err != nil {
 				return 0, err
 			}
-			i -= size
-			i = encodeVarintVirtualService(dAtA, i, uint64(size))
 		}
+	}
+	if len(m.RedirectResponseCodes) > 0 {
+		dAtA33 := make([]byte, len(m.RedirectResponseCodes)*10)
+		var j32 int
+		for _, num := range m.RedirectResponseCodes {
+			for num >= 1<<7 {
+				dAtA33[j32] = uint8(uint64(num)&0x7f | 0x80)
+				num >>= 7
+				j32++
+			}
+			dAtA33[j32] = uint8(num)
+			j32++
+		}
+		i -= j32
+		copy(dAtA[i:], dAtA33[:j32])
+		i = encodeVarintVirtualService(dAtA, i, uint64(j32))
 		i--
-		dAtA[i] = 0x12
+		dAtA[i] = 0x4a
 	}
-	if m.Attempts != 0 {
-		i = encodeVarintVirtualService(dAtA, i, uint64(m.Attempts))
+	if m.MaxInternalRedirects != 0 {
+		i = encodeVarintVirtualService(dAtA, i, uint64(m.MaxInternalRedirects))
 		i--
-		dAtA[i] = 0x8
+		dAtA[i] = 0x40
 	}
 	return len(dAtA) - i, nil
 }
 
-func (m *CorsPolicy) Marshal() (dAtA []byte, err error) {
+func (m *HTTPInternalActiveRedirect_RedirectPolicy_RedirectUrl) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *HTTPInternalActiveRedirect_RedirectPolicy_RedirectUrl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	i -= len(m.RedirectUrl)
+	copy(dAtA[i:], m.RedirectUrl)
+	i = encodeVarintVirtualService(dAtA, i, uint64(len(m.RedirectUrl)))
+	i--
+	dAtA[i] = 0x52
+	return len(dAtA) - i, nil
+}
+func (m *HTTPInternalActiveRedirect_RedirectPolicy_RedirectUrlRewriteRegex) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *HTTPInternalActiveRedirect_RedirectPolicy_RedirectUrlRewriteRegex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	if m.RedirectUrlRewriteRegex != nil {
+		{
+			size, err := m.RedirectUrlRewriteRegex.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintVirtualService(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x5a
+	}
+	return len(dAtA) - i, nil
+}
+func (m *HTTPDirectResponse) Marshal() (dAtA []byte, err error) {
 	size := m.Size()
 	dAtA = make([]byte, size)
 	n, err := m.MarshalToSizedBuffer(dAtA[:size])
@@ -4996,12 +6036,12 @@ func (m *CorsPolicy) Marshal() (dAtA []byte, err error) {
 	return dAtA[:n], nil
 }
 
-func (m *CorsPolicy) MarshalTo(dAtA []byte) (int, error) {
+func (m *HTTPDirectResponse) MarshalTo(dAtA []byte) (int, error) {
 	size := m.Size()
 	return m.MarshalToSizedBuffer(dAtA[:size])
 }
 
-func (m *CorsPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+func (m *HTTPDirectResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 	i := len(dAtA)
 	_ = i
 	var l int
@@ -5010,84 +6050,22 @@ func (m *CorsPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 		i -= len(m.XXX_unrecognized)
 		copy(dAtA[i:], m.XXX_unrecognized)
 	}
-	if len(m.AllowOrigins) > 0 {
-		for iNdEx := len(m.AllowOrigins) - 1; iNdEx >= 0; iNdEx-- {
-			{
-				size, err := m.AllowOrigins[iNdEx].MarshalToSizedBuffer(dAtA[:i])
-				if err != nil {
-					return 0, err
-				}
-				i -= size
-				i = encodeVarintVirtualService(dAtA, i, uint64(size))
-			}
-			i--
-			dAtA[i] = 0x3a
-		}
-	}
-	if m.AllowCredentials != nil {
-		{
-			size, err := m.AllowCredentials.MarshalToSizedBuffer(dAtA[:i])
-			if err != nil {
-				return 0, err
-			}
-			i -= size
-			i = encodeVarintVirtualService(dAtA, i, uint64(size))
-		}
+	if len(m.Body) > 0 {
+		i -= len(m.Body)
+		copy(dAtA[i:], m.Body)
+		i = encodeVarintVirtualService(dAtA, i, uint64(len(m.Body)))
 		i--
-		dAtA[i] = 0x32
+		dAtA[i] = 0x12
 	}
-	if m.MaxAge != nil {
-		{
-			size, err := m.MaxAge.MarshalToSizedBuffer(dAtA[:i])
-			if err != nil {
-				return 0, err
-			}
-			i -= size
-			i = encodeVarintVirtualService(dAtA, i, uint64(size))
-		}
+	if m.ResponseCode != 0 {
+		i = encodeVarintVirtualService(dAtA, i, uint64(m.ResponseCode))
 		i--
-		dAtA[i] = 0x2a
-	}
-	if len(m.ExposeHeaders) > 0 {
-		for iNdEx := len(m.ExposeHeaders) - 1; iNdEx >= 0; iNdEx-- {
-			i -= len(m.ExposeHeaders[iNdEx])
-			copy(dAtA[i:], m.ExposeHeaders[iNdEx])
-			i = encodeVarintVirtualService(dAtA, i, uint64(len(m.ExposeHeaders[iNdEx])))
-			i--
-			dAtA[i] = 0x22
-		}
-	}
-	if len(m.AllowHeaders) > 0 {
-		for iNdEx := len(m.AllowHeaders) - 1; iNdEx >= 0; iNdEx-- {
-			i -= len(m.AllowHeaders[iNdEx])
-			copy(dAtA[i:], m.AllowHeaders[iNdEx])
-			i = encodeVarintVirtualService(dAtA, i, uint64(len(m.AllowHeaders[iNdEx])))
-			i--
-			dAtA[i] = 0x1a
-		}
-	}
-	if len(m.AllowMethods) > 0 {
-		for iNdEx := len(m.AllowMethods) - 1; iNdEx >= 0; iNdEx-- {
-			i -= len(m.AllowMethods[iNdEx])
-			copy(dAtA[i:], m.AllowMethods[iNdEx])
-			i = encodeVarintVirtualService(dAtA, i, uint64(len(m.AllowMethods[iNdEx])))
-			i--
-			dAtA[i] = 0x12
-		}
-	}
-	if len(m.AllowOrigin) > 0 {
-		for iNdEx := len(m.AllowOrigin) - 1; iNdEx >= 0; iNdEx-- {
-			i -= len(m.AllowOrigin[iNdEx])
-			copy(dAtA[i:], m.AllowOrigin[iNdEx])
-			i = encodeVarintVirtualService(dAtA, i, uint64(len(m.AllowOrigin[iNdEx])))
-			i--
-			dAtA[i] = 0xa
-		}
+		dAtA[i] = 0x8
 	}
 	return len(dAtA) - i, nil
 }
 
-func (m *HTTPFaultInjection) Marshal() (dAtA []byte, err error) {
+func (m *HTTPRewrite) Marshal() (dAtA []byte, err error) {
 	size := m.Size()
 	dAtA = make([]byte, size)
 	n, err := m.MarshalToSizedBuffer(dAtA[:size])
@@ -5097,12 +6075,12 @@ func (m *HTTPFaultInjection) Marshal() (dAtA []byte, err error) {
 	return dAtA[:n], nil
 }
 
-func (m *HTTPFaultInjection) MarshalTo(dAtA []byte) (int, error) {
+func (m *HTTPRewrite) MarshalTo(dAtA []byte) (int, error) {
 	size := m.Size()
 	return m.MarshalToSizedBuffer(dAtA[:size])
 }
 
-func (m *HTTPFaultInjection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+func (m *HTTPRewrite) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 	i := len(dAtA)
 	_ = i
 	var l int
@@ -5111,9 +6089,9 @@ func (m *HTTPFaultInjection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 		i -= len(m.XXX_unrecognized)
 		copy(dAtA[i:], m.XXX_unrecognized)
 	}
-	if m.Abort != nil {
+	if m.UriRegex != nil {
 		{
-			size, err := m.Abort.MarshalToSizedBuffer(dAtA[:i])
+			size, err := m.UriRegex.MarshalToSizedBuffer(dAtA[:i])
 			if err != nil {
 				return 0, err
 			}
@@ -5121,24 +6099,26 @@ func (m *HTTPFaultInjection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 			i = encodeVarintVirtualService(dAtA, i, uint64(size))
 		}
 		i--
+		dAtA[i] = 0x1a
+	}
+	if len(m.Authority) > 0 {
+		i -= len(m.Authority)
+		copy(dAtA[i:], m.Authority)
+		i = encodeVarintVirtualService(dAtA, i, uint64(len(m.Authority)))
+		i--
 		dAtA[i] = 0x12
 	}
-	if m.Delay != nil {
-		{
-			size, err := m.Delay.MarshalToSizedBuffer(dAtA[:i])
-			if err != nil {
-				return 0, err
-			}
-			i -= size
-			i = encodeVarintVirtualService(dAtA, i, uint64(size))
-		}
+	if len(m.Uri) > 0 {
+		i -= len(m.Uri)
+		copy(dAtA[i:], m.Uri)
+		i = encodeVarintVirtualService(dAtA, i, uint64(len(m.Uri)))
 		i--
 		dAtA[i] = 0xa
 	}
 	return len(dAtA) - i, nil
 }
 
-func (m *HTTPFaultInjection_Delay) Marshal() (dAtA []byte, err error) {
+func (m *RegexMatchAndSubstitute) Marshal() (dAtA []byte, err error) {
 	size := m.Size()
 	dAtA = make([]byte, size)
 	n, err := m.MarshalToSizedBuffer(dAtA[:size])
@@ -5148,12 +6128,12 @@ func (m *HTTPFaultInjection_Delay) Marshal() (dAtA []byte, err error) {
 	return dAtA[:n], nil
 }
 
-func (m *HTTPFaultInjection_Delay) MarshalTo(dAtA []byte) (int, error) {
+func (m *RegexMatchAndSubstitute) MarshalTo(dAtA []byte) (int, error) {
 	size := m.Size()
 	return m.MarshalToSizedBuffer(dAtA[:size])
 }
 
-func (m *HTTPFaultInjection_Delay) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+func (m *RegexMatchAndSubstitute) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 	i := len(dAtA)
 	_ = i
 	var l int
@@ -5162,78 +6142,24 @@ func (m *HTTPFaultInjection_Delay) MarshalToSizedBuffer(dAtA []byte) (int, error
 		i -= len(m.XXX_unrecognized)
 		copy(dAtA[i:], m.XXX_unrecognized)
 	}
-	if m.Percentage != nil {
-		{
-			size, err := m.Percentage.MarshalToSizedBuffer(dAtA[:i])
-			if err != nil {
-				return 0, err
-			}
-			i -= size
-			i = encodeVarintVirtualService(dAtA, i, uint64(size))
-		}
-		i--
-		dAtA[i] = 0x2a
-	}
-	if m.HttpDelayType != nil {
-		{
-			size := m.HttpDelayType.Size()
-			i -= size
-			if _, err := m.HttpDelayType.MarshalTo(dAtA[i:]); err != nil {
-				return 0, err
-			}
-		}
-	}
-	if m.Percent != 0 {
-		i = encodeVarintVirtualService(dAtA, i, uint64(m.Percent))
-		i--
-		dAtA[i] = 0x8
-	}
-	return len(dAtA) - i, nil
-}
-
-func (m *HTTPFaultInjection_Delay_FixedDelay) MarshalTo(dAtA []byte) (int, error) {
-	size := m.Size()
-	return m.MarshalToSizedBuffer(dAtA[:size])
-}
-
-func (m *HTTPFaultInjection_Delay_FixedDelay) MarshalToSizedBuffer(dAtA []byte) (int, error) {
-	i := len(dAtA)
-	if m.FixedDelay != nil {
-		{
-			size, err := m.FixedDelay.MarshalToSizedBuffer(dAtA[:i])
-			if err != nil {
-				return 0, err
-			}
-			i -= size
-			i = encodeVarintVirtualService(dAtA, i, uint64(size))
-		}
+	if len(m.Substitution) > 0 {
+		i -= len(m.Substitution)
+		copy(dAtA[i:], m.Substitution)
+		i = encodeVarintVirtualService(dAtA, i, uint64(len(m.Substitution)))
 		i--
 		dAtA[i] = 0x12
 	}
-	return len(dAtA) - i, nil
-}
-func (m *HTTPFaultInjection_Delay_ExponentialDelay) MarshalTo(dAtA []byte) (int, error) {
-	size := m.Size()
-	return m.MarshalToSizedBuffer(dAtA[:size])
-}
-
-func (m *HTTPFaultInjection_Delay_ExponentialDelay) MarshalToSizedBuffer(dAtA []byte) (int, error) {
-	i := len(dAtA)
-	if m.ExponentialDelay != nil {
-		{
-			size, err := m.ExponentialDelay.MarshalToSizedBuffer(dAtA[:i])
-			if err != nil {
-				return 0, err
-			}
-			i -= size
-			i = encodeVarintVirtualService(dAtA, i, uint64(size))
-		}
+	if len(m.Pattern) > 0 {
+		i -= len(m.Pattern)
+		copy(dAtA[i:], m.Pattern)
+		i = encodeVarintVirtualService(dAtA, i, uint64(len(m.Pattern)))
 		i--
-		dAtA[i] = 0x1a
+		dAtA[i] = 0xa
 	}
 	return len(dAtA) - i, nil
 }
-func (m *HTTPFaultInjection_Abort) Marshal() (dAtA []byte, err error) {
+
+func (m *StringMatch) Marshal() (dAtA []byte, err error) {
 	size := m.Size()
 	dAtA = make([]byte, size)
 	n, err := m.MarshalToSizedBuffer(dAtA[:size])
@@ -5243,12 +6169,12 @@ func (m *HTTPFaultInjection_Abort) Marshal() (dAtA []byte, err error) {
 	return dAtA[:n], nil
 }
 
-func (m *HTTPFaultInjection_Abort) MarshalTo(dAtA []byte) (int, error) {
+func (m *StringMatch) MarshalTo(dAtA []byte) (int, error) {
 	size := m.Size()
 	return m.MarshalToSizedBuffer(dAtA[:size])
 }
 
-func (m *HTTPFaultInjection_Abort) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+func (m *StringMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 	i := len(dAtA)
 	_ = i
 	var l int
@@ -5257,23 +6183,11 @@ func (m *HTTPFaultInjection_Abort) MarshalToSizedBuffer(dAtA []byte) (int, error
 		i -= len(m.XXX_unrecognized)
 		copy(dAtA[i:], m.XXX_unrecognized)
 	}
-	if m.Percentage != nil {
-		{
-			size, err := m.Percentage.MarshalToSizedBuffer(dAtA[:i])
-			if err != nil {
-				return 0, err
-			}
-			i -= size
-			i = encodeVarintVirtualService(dAtA, i, uint64(size))
-		}
-		i--
-		dAtA[i] = 0x2a
-	}
-	if m.ErrorType != nil {
+	if m.MatchType != nil {
 		{
-			size := m.ErrorType.Size()
+			size := m.MatchType.Size()
 			i -= size
-			if _, err := m.ErrorType.MarshalTo(dAtA[i:]); err != nil {
+			if _, err := m.MatchType.MarshalTo(dAtA[i:]); err != nil {
 				return 0, err
 			}
 		}
@@ -5281,47 +6195,49 @@ func (m *HTTPFaultInjection_Abort) MarshalToSizedBuffer(dAtA []byte) (int, error
 	return len(dAtA) - i, nil
 }
 
-func (m *HTTPFaultInjection_Abort_HttpStatus) MarshalTo(dAtA []byte) (int, error) {
+func (m *StringMatch_Exact) MarshalTo(dAtA []byte) (int, error) {
 	size := m.Size()
 	return m.MarshalToSizedBuffer(dAtA[:size])
 }
 
-func (m *HTTPFaultInjection_Abort_HttpStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+func (m *StringMatch_Exact) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 	i := len(dAtA)
-	i = encodeVarintVirtualService(dAtA, i, uint64(m.HttpStatus))
+	i -= len(m.Exact)
+	copy(dAtA[i:], m.Exact)
+	i = encodeVarintVirtualService(dAtA, i, uint64(len(m.Exact)))
 	i--
-	dAtA[i] = 0x10
+	dAtA[i] = 0xa
 	return len(dAtA) - i, nil
 }
-func (m *HTTPFaultInjection_Abort_GrpcStatus) MarshalTo(dAtA []byte) (int, error) {
+func (m *StringMatch_Prefix) MarshalTo(dAtA []byte) (int, error) {
 	size := m.Size()
 	return m.MarshalToSizedBuffer(dAtA[:size])
 }
 
-func (m *HTTPFaultInjection_Abort_GrpcStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+func (m *StringMatch_Prefix) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 	i := len(dAtA)
-	i -= len(m.GrpcStatus)
-	copy(dAtA[i:], m.GrpcStatus)
-	i = encodeVarintVirtualService(dAtA, i, uint64(len(m.GrpcStatus)))
+	i -= len(m.Prefix)
+	copy(dAtA[i:], m.Prefix)
+	i = encodeVarintVirtualService(dAtA, i, uint64(len(m.Prefix)))
 	i--
-	dAtA[i] = 0x1a
+	dAtA[i] = 0x12
 	return len(dAtA) - i, nil
 }
-func (m *HTTPFaultInjection_Abort_Http2Error) MarshalTo(dAtA []byte) (int, error) {
+func (m *StringMatch_Regex) MarshalTo(dAtA []byte) (int, error) {
 	size := m.Size()
 	return m.MarshalToSizedBuffer(dAtA[:size])
 }
 
-func (m *HTTPFaultInjection_Abort_Http2Error) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+func (m *StringMatch_Regex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 	i := len(dAtA)
-	i -= len(m.Http2Error)
-	copy(dAtA[i:], m.Http2Error)
-	i = encodeVarintVirtualService(dAtA, i, uint64(len(m.Http2Error)))
+	i -= len(m.Regex)
+	copy(dAtA[i:], m.Regex)
+	i = encodeVarintVirtualService(dAtA, i, uint64(len(m.Regex)))
 	i--
-	dAtA[i] = 0x22
+	dAtA[i] = 0x1a
 	return len(dAtA) - i, nil
 }
-func (m *PortSelector) Marshal() (dAtA []byte, err error) {
+func (m *HTTPRetry) Marshal() (dAtA []byte, err error) {
 	size := m.Size()
 	dAtA = make([]byte, size)
 	n, err := m.MarshalToSizedBuffer(dAtA[:size])
@@ -5331,12 +6247,12 @@ func (m *PortSelector) Marshal() (dAtA []byte, err error) {
 	return dAtA[:n], nil
 }
 
-func (m *PortSelector) MarshalTo(dAtA []byte) (int, error) {
+func (m *HTTPRetry) MarshalTo(dAtA []byte) (int, error) {
 	size := m.Size()
 	return m.MarshalToSizedBuffer(dAtA[:size])
 }
 
-func (m *PortSelector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+func (m *HTTPRetry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 	i := len(dAtA)
 	_ = i
 	var l int
@@ -5345,30 +6261,61 @@ func (m *PortSelector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 		i -= len(m.XXX_unrecognized)
 		copy(dAtA[i:], m.XXX_unrecognized)
 	}
-	if m.Number != 0 {
-		i = encodeVarintVirtualService(dAtA, i, uint64(m.Number))
+	if m.RetryRemoteLocalities != nil {
+		{
+			size, err := m.RetryRemoteLocalities.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintVirtualService(dAtA, i, uint64(size))
+		}
 		i--
-		dAtA[i] = 0x8
+		dAtA[i] = 0x22
 	}
-	return len(dAtA) - i, nil
-}
-
-func (m *Percent) Marshal() (dAtA []byte, err error) {
-	size := m.Size()
-	dAtA = make([]byte, size)
-	n, err := m.MarshalToSizedBuffer(dAtA[:size])
-	if err != nil {
-		return nil, err
+	if len(m.RetryOn) > 0 {
+		i -= len(m.RetryOn)
+		copy(dAtA[i:], m.RetryOn)
+		i = encodeVarintVirtualService(dAtA, i, uint64(len(m.RetryOn)))
+		i--
+		dAtA[i] = 0x1a
 	}
-	return dAtA[:n], nil
+	if m.PerTryTimeout != nil {
+		{
+			size, err := m.PerTryTimeout.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintVirtualService(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x12
+	}
+	if m.Attempts != 0 {
+		i = encodeVarintVirtualService(dAtA, i, uint64(m.Attempts))
+		i--
+		dAtA[i] = 0x8
+	}
+	return len(dAtA) - i, nil
 }
 
-func (m *Percent) MarshalTo(dAtA []byte) (int, error) {
+func (m *CorsPolicy) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *CorsPolicy) MarshalTo(dAtA []byte) (int, error) {
 	size := m.Size()
 	return m.MarshalToSizedBuffer(dAtA[:size])
 }
 
-func (m *Percent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+func (m *CorsPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 	i := len(dAtA)
 	_ = i
 	var l int
@@ -5377,282 +6324,912 @@ func (m *Percent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 		i -= len(m.XXX_unrecognized)
 		copy(dAtA[i:], m.XXX_unrecognized)
 	}
-	if m.Value != 0 {
-		i -= 8
-		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Value))))
-		i--
-		dAtA[i] = 0x9
-	}
-	return len(dAtA) - i, nil
-}
-
-func encodeVarintVirtualService(dAtA []byte, offset int, v uint64) int {
-	offset -= sovVirtualService(v)
-	base := offset
-	for v >= 1<<7 {
-		dAtA[offset] = uint8(v&0x7f | 0x80)
-		v >>= 7
-		offset++
-	}
-	dAtA[offset] = uint8(v)
-	return base
-}
-func (m *VirtualService) Size() (n int) {
-	if m == nil {
-		return 0
-	}
-	var l int
-	_ = l
-	if len(m.Hosts) > 0 {
-		for _, s := range m.Hosts {
-			l = len(s)
-			n += 1 + l + sovVirtualService(uint64(l))
+	if len(m.AllowOrigins) > 0 {
+		for iNdEx := len(m.AllowOrigins) - 1; iNdEx >= 0; iNdEx-- {
+			{
+				size, err := m.AllowOrigins[iNdEx].MarshalToSizedBuffer(dAtA[:i])
+				if err != nil {
+					return 0, err
+				}
+				i -= size
+				i = encodeVarintVirtualService(dAtA, i, uint64(size))
+			}
+			i--
+			dAtA[i] = 0x3a
 		}
 	}
-	if len(m.Gateways) > 0 {
-		for _, s := range m.Gateways {
-			l = len(s)
-			n += 1 + l + sovVirtualService(uint64(l))
+	if m.AllowCredentials != nil {
+		{
+			size, err := m.AllowCredentials.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintVirtualService(dAtA, i, uint64(size))
 		}
+		i--
+		dAtA[i] = 0x32
 	}
-	if len(m.Http) > 0 {
-		for _, e := range m.Http {
-			l = e.Size()
-			n += 1 + l + sovVirtualService(uint64(l))
+	if m.MaxAge != nil {
+		{
+			size, err := m.MaxAge.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintVirtualService(dAtA, i, uint64(size))
 		}
+		i--
+		dAtA[i] = 0x2a
 	}
-	if len(m.Tcp) > 0 {
-		for _, e := range m.Tcp {
-			l = e.Size()
-			n += 1 + l + sovVirtualService(uint64(l))
+	if len(m.ExposeHeaders) > 0 {
+		for iNdEx := len(m.ExposeHeaders) - 1; iNdEx >= 0; iNdEx-- {
+			i -= len(m.ExposeHeaders[iNdEx])
+			copy(dAtA[i:], m.ExposeHeaders[iNdEx])
+			i = encodeVarintVirtualService(dAtA, i, uint64(len(m.ExposeHeaders[iNdEx])))
+			i--
+			dAtA[i] = 0x22
 		}
 	}
-	if len(m.Tls) > 0 {
-		for _, e := range m.Tls {
-			l = e.Size()
-			n += 1 + l + sovVirtualService(uint64(l))
+	if len(m.AllowHeaders) > 0 {
+		for iNdEx := len(m.AllowHeaders) - 1; iNdEx >= 0; iNdEx-- {
+			i -= len(m.AllowHeaders[iNdEx])
+			copy(dAtA[i:], m.AllowHeaders[iNdEx])
+			i = encodeVarintVirtualService(dAtA, i, uint64(len(m.AllowHeaders[iNdEx])))
+			i--
+			dAtA[i] = 0x1a
 		}
 	}
-	if len(m.ExportTo) > 0 {
-		for _, s := range m.ExportTo {
-			l = len(s)
-			n += 1 + l + sovVirtualService(uint64(l))
+	if len(m.AllowMethods) > 0 {
+		for iNdEx := len(m.AllowMethods) - 1; iNdEx >= 0; iNdEx-- {
+			i -= len(m.AllowMethods[iNdEx])
+			copy(dAtA[i:], m.AllowMethods[iNdEx])
+			i = encodeVarintVirtualService(dAtA, i, uint64(len(m.AllowMethods[iNdEx])))
+			i--
+			dAtA[i] = 0x12
 		}
 	}
-	if m.XXX_unrecognized != nil {
-		n += len(m.XXX_unrecognized)
+	if len(m.AllowOrigin) > 0 {
+		for iNdEx := len(m.AllowOrigin) - 1; iNdEx >= 0; iNdEx-- {
+			i -= len(m.AllowOrigin[iNdEx])
+			copy(dAtA[i:], m.AllowOrigin[iNdEx])
+			i = encodeVarintVirtualService(dAtA, i, uint64(len(m.AllowOrigin[iNdEx])))
+			i--
+			dAtA[i] = 0xa
+		}
 	}
-	return n
+	return len(dAtA) - i, nil
 }
 
-func (m *Destination) Size() (n int) {
-	if m == nil {
-		return 0
+func (m *HTTPFaultInjection) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
 	}
+	return dAtA[:n], nil
+}
+
+func (m *HTTPFaultInjection) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *HTTPFaultInjection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
 	var l int
 	_ = l
-	l = len(m.Host)
-	if l > 0 {
-		n += 1 + l + sovVirtualService(uint64(l))
-	}
-	l = len(m.Subset)
-	if l > 0 {
-		n += 1 + l + sovVirtualService(uint64(l))
+	if m.XXX_unrecognized != nil {
+		i -= len(m.XXX_unrecognized)
+		copy(dAtA[i:], m.XXX_unrecognized)
 	}
-	if m.Port != nil {
-		l = m.Port.Size()
-		n += 1 + l + sovVirtualService(uint64(l))
+	if m.Abort != nil {
+		{
+			size, err := m.Abort.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintVirtualService(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x12
 	}
-	if m.XXX_unrecognized != nil {
-		n += len(m.XXX_unrecognized)
+	if m.Delay != nil {
+		{
+			size, err := m.Delay.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintVirtualService(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0xa
 	}
-	return n
+	return len(dAtA) - i, nil
 }
 
-func (m *HTTPRoute) Size() (n int) {
-	if m == nil {
-		return 0
+func (m *HTTPFaultInjection_Delay) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
 	}
+	return dAtA[:n], nil
+}
+
+func (m *HTTPFaultInjection_Delay) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *HTTPFaultInjection_Delay) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
 	var l int
 	_ = l
-	if len(m.Match) > 0 {
-		for _, e := range m.Match {
-			l = e.Size()
-			n += 1 + l + sovVirtualService(uint64(l))
+	if m.XXX_unrecognized != nil {
+		i -= len(m.XXX_unrecognized)
+		copy(dAtA[i:], m.XXX_unrecognized)
+	}
+	if m.Percentage != nil {
+		{
+			size, err := m.Percentage.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintVirtualService(dAtA, i, uint64(size))
 		}
+		i--
+		dAtA[i] = 0x2a
 	}
-	if len(m.Route) > 0 {
-		for _, e := range m.Route {
-			l = e.Size()
-			n += 1 + l + sovVirtualService(uint64(l))
+	if m.HttpDelayType != nil {
+		{
+			size := m.HttpDelayType.Size()
+			i -= size
+			if _, err := m.HttpDelayType.MarshalTo(dAtA[i:]); err != nil {
+				return 0, err
+			}
 		}
 	}
-	if m.Redirect != nil {
-		l = m.Redirect.Size()
-		n += 1 + l + sovVirtualService(uint64(l))
-	}
-	if m.Rewrite != nil {
-		l = m.Rewrite.Size()
-		n += 1 + l + sovVirtualService(uint64(l))
-	}
-	if m.Timeout != nil {
-		l = m.Timeout.Size()
-		n += 1 + l + sovVirtualService(uint64(l))
-	}
-	if m.Retries != nil {
-		l = m.Retries.Size()
-		n += 1 + l + sovVirtualService(uint64(l))
-	}
-	if m.Fault != nil {
-		l = m.Fault.Size()
-		n += 1 + l + sovVirtualService(uint64(l))
-	}
-	if m.Mirror != nil {
-		l = m.Mirror.Size()
-		n += 1 + l + sovVirtualService(uint64(l))
-	}
-	if m.CorsPolicy != nil {
-		l = m.CorsPolicy.Size()
-		n += 1 + l + sovVirtualService(uint64(l))
-	}
-	if m.Headers != nil {
-		l = m.Headers.Size()
-		n += 2 + l + sovVirtualService(uint64(l))
-	}
-	l = len(m.Name)
-	if l > 0 {
-		n += 2 + l + sovVirtualService(uint64(l))
-	}
-	if m.MirrorPercent != nil {
-		l = m.MirrorPercent.Size()
-		n += 2 + l + sovVirtualService(uint64(l))
+	if m.Percent != 0 {
+		i = encodeVarintVirtualService(dAtA, i, uint64(m.Percent))
+		i--
+		dAtA[i] = 0x8
 	}
-	if m.MirrorPercentage != nil {
-		l = m.MirrorPercentage.Size()
-		n += 2 + l + sovVirtualService(uint64(l))
+	return len(dAtA) - i, nil
+}
+
+func (m *HTTPFaultInjection_Delay_FixedDelay) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *HTTPFaultInjection_Delay_FixedDelay) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	if m.FixedDelay != nil {
+		{
+			size, err := m.FixedDelay.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintVirtualService(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x12
 	}
-	if m.Delegate != nil {
-		l = m.Delegate.Size()
-		n += 2 + l + sovVirtualService(uint64(l))
+	return len(dAtA) - i, nil
+}
+func (m *HTTPFaultInjection_Delay_ExponentialDelay) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *HTTPFaultInjection_Delay_ExponentialDelay) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	if m.ExponentialDelay != nil {
+		{
+			size, err := m.ExponentialDelay.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintVirtualService(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x1a
 	}
-	if m.XXX_unrecognized != nil {
-		n += len(m.XXX_unrecognized)
+	return len(dAtA) - i, nil
+}
+func (m *HTTPFaultInjection_Abort) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
 	}
-	return n
+	return dAtA[:n], nil
 }
 
-func (m *Delegate) Size() (n int) {
-	if m == nil {
-		return 0
-	}
+func (m *HTTPFaultInjection_Abort) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *HTTPFaultInjection_Abort) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
 	var l int
 	_ = l
-	l = len(m.Name)
-	if l > 0 {
-		n += 1 + l + sovVirtualService(uint64(l))
+	if m.XXX_unrecognized != nil {
+		i -= len(m.XXX_unrecognized)
+		copy(dAtA[i:], m.XXX_unrecognized)
 	}
-	l = len(m.Namespace)
-	if l > 0 {
-		n += 1 + l + sovVirtualService(uint64(l))
+	if m.Percentage != nil {
+		{
+			size, err := m.Percentage.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintVirtualService(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x2a
 	}
-	if m.XXX_unrecognized != nil {
-		n += len(m.XXX_unrecognized)
+	if m.ErrorType != nil {
+		{
+			size := m.ErrorType.Size()
+			i -= size
+			if _, err := m.ErrorType.MarshalTo(dAtA[i:]); err != nil {
+				return 0, err
+			}
+		}
 	}
-	return n
+	return len(dAtA) - i, nil
 }
 
-func (m *Headers) Size() (n int) {
-	if m == nil {
-		return 0
+func (m *HTTPFaultInjection_Abort_HttpStatus) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *HTTPFaultInjection_Abort_HttpStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	i = encodeVarintVirtualService(dAtA, i, uint64(m.HttpStatus))
+	i--
+	dAtA[i] = 0x10
+	return len(dAtA) - i, nil
+}
+func (m *HTTPFaultInjection_Abort_GrpcStatus) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *HTTPFaultInjection_Abort_GrpcStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	i -= len(m.GrpcStatus)
+	copy(dAtA[i:], m.GrpcStatus)
+	i = encodeVarintVirtualService(dAtA, i, uint64(len(m.GrpcStatus)))
+	i--
+	dAtA[i] = 0x1a
+	return len(dAtA) - i, nil
+}
+func (m *HTTPFaultInjection_Abort_Http2Error) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *HTTPFaultInjection_Abort_Http2Error) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	i -= len(m.Http2Error)
+	copy(dAtA[i:], m.Http2Error)
+	i = encodeVarintVirtualService(dAtA, i, uint64(len(m.Http2Error)))
+	i--
+	dAtA[i] = 0x22
+	return len(dAtA) - i, nil
+}
+func (m *PortSelector) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
 	}
+	return dAtA[:n], nil
+}
+
+func (m *PortSelector) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *PortSelector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
 	var l int
 	_ = l
-	if m.Request != nil {
-		l = m.Request.Size()
-		n += 1 + l + sovVirtualService(uint64(l))
-	}
-	if m.Response != nil {
-		l = m.Response.Size()
-		n += 1 + l + sovVirtualService(uint64(l))
-	}
 	if m.XXX_unrecognized != nil {
-		n += len(m.XXX_unrecognized)
+		i -= len(m.XXX_unrecognized)
+		copy(dAtA[i:], m.XXX_unrecognized)
 	}
-	return n
+	if m.Number != 0 {
+		i = encodeVarintVirtualService(dAtA, i, uint64(m.Number))
+		i--
+		dAtA[i] = 0x8
+	}
+	return len(dAtA) - i, nil
 }
 
-func (m *Headers_HeaderOperations) Size() (n int) {
-	if m == nil {
-		return 0
+func (m *Percent) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
 	}
+	return dAtA[:n], nil
+}
+
+func (m *Percent) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *Percent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
 	var l int
 	_ = l
-	if len(m.Set) > 0 {
-		for k, v := range m.Set {
-			_ = k
-			_ = v
-			mapEntrySize := 1 + len(k) + sovVirtualService(uint64(len(k))) + 1 + len(v) + sovVirtualService(uint64(len(v)))
-			n += mapEntrySize + 1 + sovVirtualService(uint64(mapEntrySize))
-		}
+	if m.XXX_unrecognized != nil {
+		i -= len(m.XXX_unrecognized)
+		copy(dAtA[i:], m.XXX_unrecognized)
 	}
-	if len(m.Add) > 0 {
-		for k, v := range m.Add {
-			_ = k
-			_ = v
-			mapEntrySize := 1 + len(k) + sovVirtualService(uint64(len(k))) + 1 + len(v) + sovVirtualService(uint64(len(v)))
-			n += mapEntrySize + 1 + sovVirtualService(uint64(mapEntrySize))
+	if m.Value != 0 {
+		i -= 8
+		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Value))))
+		i--
+		dAtA[i] = 0x9
+	}
+	return len(dAtA) - i, nil
+}
+
+func (m *HTTPFilter) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *HTTPFilter) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *HTTPFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
+	var l int
+	_ = l
+	if m.XXX_unrecognized != nil {
+		i -= len(m.XXX_unrecognized)
+		copy(dAtA[i:], m.XXX_unrecognized)
+	}
+	if m.Filter != nil {
+		{
+			size := m.Filter.Size()
+			i -= size
+			if _, err := m.Filter.MarshalTo(dAtA[i:]); err != nil {
+				return 0, err
+			}
 		}
 	}
-	if len(m.Remove) > 0 {
-		for _, s := range m.Remove {
-			l = len(s)
-			n += 1 + l + sovVirtualService(uint64(l))
+	if m.Disable {
+		i--
+		if m.Disable {
+			dAtA[i] = 1
+		} else {
+			dAtA[i] = 0
+		}
+		i--
+		dAtA[i] = 0x10
+	}
+	if len(m.Name) > 0 {
+		i -= len(m.Name)
+		copy(dAtA[i:], m.Name)
+		i = encodeVarintVirtualService(dAtA, i, uint64(len(m.Name)))
+		i--
+		dAtA[i] = 0xa
+	}
+	return len(dAtA) - i, nil
+}
+
+func (m *HTTPFilter_IpAccessControl) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *HTTPFilter_IpAccessControl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	if m.IpAccessControl != nil {
+		{
+			size, err := m.IpAccessControl.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintVirtualService(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x1a
+	}
+	return len(dAtA) - i, nil
+}
+func (m *HTTPFilter_LocalRateLimit) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *HTTPFilter_LocalRateLimit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	if m.LocalRateLimit != nil {
+		{
+			size, err := m.LocalRateLimit.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintVirtualService(dAtA, i, uint64(size))
 		}
+		i--
+		dAtA[i] = 0x22
+	}
+	return len(dAtA) - i, nil
+}
+func (m *IPAccessControl) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
 	}
+	return dAtA[:n], nil
+}
+
+func (m *IPAccessControl) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *IPAccessControl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
+	var l int
+	_ = l
 	if m.XXX_unrecognized != nil {
-		n += len(m.XXX_unrecognized)
+		i -= len(m.XXX_unrecognized)
+		copy(dAtA[i:], m.XXX_unrecognized)
 	}
-	return n
+	if len(m.NotRemoteIpBlocks) > 0 {
+		for iNdEx := len(m.NotRemoteIpBlocks) - 1; iNdEx >= 0; iNdEx-- {
+			i -= len(m.NotRemoteIpBlocks[iNdEx])
+			copy(dAtA[i:], m.NotRemoteIpBlocks[iNdEx])
+			i = encodeVarintVirtualService(dAtA, i, uint64(len(m.NotRemoteIpBlocks[iNdEx])))
+			i--
+			dAtA[i] = 0x12
+		}
+	}
+	if len(m.RemoteIpBlocks) > 0 {
+		for iNdEx := len(m.RemoteIpBlocks) - 1; iNdEx >= 0; iNdEx-- {
+			i -= len(m.RemoteIpBlocks[iNdEx])
+			copy(dAtA[i:], m.RemoteIpBlocks[iNdEx])
+			i = encodeVarintVirtualService(dAtA, i, uint64(len(m.RemoteIpBlocks[iNdEx])))
+			i--
+			dAtA[i] = 0xa
+		}
+	}
+	return len(dAtA) - i, nil
 }
 
-func (m *TLSRoute) Size() (n int) {
-	if m == nil {
-		return 0
+func (m *LocalRateLimit) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
 	}
+	return dAtA[:n], nil
+}
+
+func (m *LocalRateLimit) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *LocalRateLimit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
 	var l int
 	_ = l
-	if len(m.Match) > 0 {
-		for _, e := range m.Match {
-			l = e.Size()
-			n += 1 + l + sovVirtualService(uint64(l))
+	if m.XXX_unrecognized != nil {
+		i -= len(m.XXX_unrecognized)
+		copy(dAtA[i:], m.XXX_unrecognized)
+	}
+	if m.StatusCode != 0 {
+		i = encodeVarintVirtualService(dAtA, i, uint64(m.StatusCode))
+		i--
+		dAtA[i] = 0x18
+	}
+	if m.PerDownstreamConnection {
+		i--
+		if m.PerDownstreamConnection {
+			dAtA[i] = 1
+		} else {
+			dAtA[i] = 0
 		}
+		i--
+		dAtA[i] = 0x10
 	}
-	if len(m.Route) > 0 {
-		for _, e := range m.Route {
-			l = e.Size()
-			n += 1 + l + sovVirtualService(uint64(l))
+	if m.TokenBucket != nil {
+		{
+			size, err := m.TokenBucket.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintVirtualService(dAtA, i, uint64(size))
 		}
+		i--
+		dAtA[i] = 0xa
+	}
+	return len(dAtA) - i, nil
+}
+
+func (m *TokenBucket) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
 	}
+	return dAtA[:n], nil
+}
+
+func (m *TokenBucket) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *TokenBucket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
+	var l int
+	_ = l
 	if m.XXX_unrecognized != nil {
-		n += len(m.XXX_unrecognized)
+		i -= len(m.XXX_unrecognized)
+		copy(dAtA[i:], m.XXX_unrecognized)
 	}
-	return n
+	if m.FillInterval != nil {
+		{
+			size, err := m.FillInterval.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintVirtualService(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x1a
+	}
+	if m.TokensPefFill != 0 {
+		i = encodeVarintVirtualService(dAtA, i, uint64(m.TokensPefFill))
+		i--
+		dAtA[i] = 0x10
+	}
+	if m.MaxTokens != 0 {
+		i = encodeVarintVirtualService(dAtA, i, uint64(m.MaxTokens))
+		i--
+		dAtA[i] = 0x8
+	}
+	return len(dAtA) - i, nil
 }
 
-func (m *TCPRoute) Size() (n int) {
+func encodeVarintVirtualService(dAtA []byte, offset int, v uint64) int {
+	offset -= sovVirtualService(v)
+	base := offset
+	for v >= 1<<7 {
+		dAtA[offset] = uint8(v&0x7f | 0x80)
+		v >>= 7
+		offset++
+	}
+	dAtA[offset] = uint8(v)
+	return base
+}
+func (m *VirtualService) Size() (n int) {
 	if m == nil {
 		return 0
 	}
 	var l int
 	_ = l
-	if len(m.Match) > 0 {
-		for _, e := range m.Match {
+	if len(m.Hosts) > 0 {
+		for _, s := range m.Hosts {
+			l = len(s)
+			n += 1 + l + sovVirtualService(uint64(l))
+		}
+	}
+	if len(m.Gateways) > 0 {
+		for _, s := range m.Gateways {
+			l = len(s)
+			n += 1 + l + sovVirtualService(uint64(l))
+		}
+	}
+	if len(m.Http) > 0 {
+		for _, e := range m.Http {
 			l = e.Size()
 			n += 1 + l + sovVirtualService(uint64(l))
 		}
 	}
-	if len(m.Route) > 0 {
-		for _, e := range m.Route {
+	if len(m.Tcp) > 0 {
+		for _, e := range m.Tcp {
+			l = e.Size()
+			n += 1 + l + sovVirtualService(uint64(l))
+		}
+	}
+	if len(m.Tls) > 0 {
+		for _, e := range m.Tls {
+			l = e.Size()
+			n += 1 + l + sovVirtualService(uint64(l))
+		}
+	}
+	if len(m.ExportTo) > 0 {
+		for _, s := range m.ExportTo {
+			l = len(s)
+			n += 1 + l + sovVirtualService(uint64(l))
+		}
+	}
+	if len(m.HostHTTPFilters) > 0 {
+		for _, e := range m.HostHTTPFilters {
+			l = e.Size()
+			n += 2 + l + sovVirtualService(uint64(l))
+		}
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *Destination) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	l = len(m.Host)
+	if l > 0 {
+		n += 1 + l + sovVirtualService(uint64(l))
+	}
+	l = len(m.Subset)
+	if l > 0 {
+		n += 1 + l + sovVirtualService(uint64(l))
+	}
+	if m.Port != nil {
+		l = m.Port.Size()
+		n += 1 + l + sovVirtualService(uint64(l))
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *HTTPRoute) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if len(m.Match) > 0 {
+		for _, e := range m.Match {
+			l = e.Size()
+			n += 1 + l + sovVirtualService(uint64(l))
+		}
+	}
+	if len(m.Route) > 0 {
+		for _, e := range m.Route {
+			l = e.Size()
+			n += 1 + l + sovVirtualService(uint64(l))
+		}
+	}
+	if m.Redirect != nil {
+		l = m.Redirect.Size()
+		n += 1 + l + sovVirtualService(uint64(l))
+	}
+	if m.Rewrite != nil {
+		l = m.Rewrite.Size()
+		n += 1 + l + sovVirtualService(uint64(l))
+	}
+	if m.Timeout != nil {
+		l = m.Timeout.Size()
+		n += 1 + l + sovVirtualService(uint64(l))
+	}
+	if m.Retries != nil {
+		l = m.Retries.Size()
+		n += 1 + l + sovVirtualService(uint64(l))
+	}
+	if m.Fault != nil {
+		l = m.Fault.Size()
+		n += 1 + l + sovVirtualService(uint64(l))
+	}
+	if m.Mirror != nil {
+		l = m.Mirror.Size()
+		n += 1 + l + sovVirtualService(uint64(l))
+	}
+	if m.CorsPolicy != nil {
+		l = m.CorsPolicy.Size()
+		n += 1 + l + sovVirtualService(uint64(l))
+	}
+	if m.Headers != nil {
+		l = m.Headers.Size()
+		n += 2 + l + sovVirtualService(uint64(l))
+	}
+	l = len(m.Name)
+	if l > 0 {
+		n += 2 + l + sovVirtualService(uint64(l))
+	}
+	if m.MirrorPercent != nil {
+		l = m.MirrorPercent.Size()
+		n += 2 + l + sovVirtualService(uint64(l))
+	}
+	if m.MirrorPercentage != nil {
+		l = m.MirrorPercentage.Size()
+		n += 2 + l + sovVirtualService(uint64(l))
+	}
+	if m.Delegate != nil {
+		l = m.Delegate.Size()
+		n += 2 + l + sovVirtualService(uint64(l))
+	}
+	if m.InternalActiveRedirect != nil {
+		l = m.InternalActiveRedirect.Size()
+		n += 2 + l + sovVirtualService(uint64(l))
+	}
+	if m.DirectResponse != nil {
+		l = m.DirectResponse.Size()
+		n += 2 + l + sovVirtualService(uint64(l))
+	}
+	if len(m.RouteHTTPFilters) > 0 {
+		for _, e := range m.RouteHTTPFilters {
+			l = e.Size()
+			n += 2 + l + sovVirtualService(uint64(l))
+		}
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *Delegate) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	l = len(m.Name)
+	if l > 0 {
+		n += 1 + l + sovVirtualService(uint64(l))
+	}
+	l = len(m.Namespace)
+	if l > 0 {
+		n += 1 + l + sovVirtualService(uint64(l))
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *Headers) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if m.Request != nil {
+		l = m.Request.Size()
+		n += 1 + l + sovVirtualService(uint64(l))
+	}
+	if m.Response != nil {
+		l = m.Response.Size()
+		n += 1 + l + sovVirtualService(uint64(l))
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *Headers_HeaderOperations) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if len(m.Set) > 0 {
+		for k, v := range m.Set {
+			_ = k
+			_ = v
+			mapEntrySize := 1 + len(k) + sovVirtualService(uint64(len(k))) + 1 + len(v) + sovVirtualService(uint64(len(v)))
+			n += mapEntrySize + 1 + sovVirtualService(uint64(mapEntrySize))
+		}
+	}
+	if len(m.Add) > 0 {
+		for k, v := range m.Add {
+			_ = k
+			_ = v
+			mapEntrySize := 1 + len(k) + sovVirtualService(uint64(len(k))) + 1 + len(v) + sovVirtualService(uint64(len(v)))
+			n += mapEntrySize + 1 + sovVirtualService(uint64(mapEntrySize))
+		}
+	}
+	if len(m.Remove) > 0 {
+		for _, s := range m.Remove {
+			l = len(s)
+			n += 1 + l + sovVirtualService(uint64(l))
+		}
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *TLSRoute) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if len(m.Match) > 0 {
+		for _, e := range m.Match {
+			l = e.Size()
+			n += 1 + l + sovVirtualService(uint64(l))
+		}
+	}
+	if len(m.Route) > 0 {
+		for _, e := range m.Route {
+			l = e.Size()
+			n += 1 + l + sovVirtualService(uint64(l))
+		}
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *TCPRoute) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if len(m.Match) > 0 {
+		for _, e := range m.Match {
+			l = e.Size()
+			n += 1 + l + sovVirtualService(uint64(l))
+		}
+	}
+	if len(m.Route) > 0 {
+		for _, e := range m.Route {
 			l = e.Size()
 			n += 1 + l + sovVirtualService(uint64(l))
 		}
@@ -5775,6 +7352,12 @@ func (m *HTTPRouteDestination) Size() (n int) {
 		l = m.Headers.Size()
 		n += 1 + l + sovVirtualService(uint64(l))
 	}
+	if len(m.FallbackClusters) > 0 {
+		for _, e := range m.FallbackClusters {
+			l = e.Size()
+			n += 2 + l + sovVirtualService(uint64(l))
+		}
+	}
 	if m.XXX_unrecognized != nil {
 		n += len(m.XXX_unrecognized)
 	}
@@ -5936,48 +7519,225 @@ func (m *HTTPRedirect_DerivePort) Size() (n int) {
 	n += 1 + sovVirtualService(uint64(m.DerivePort))
 	return n
 }
-func (m *HTTPRewrite) Size() (n int) {
+func (m *HTTPInternalActiveRedirect) Size() (n int) {
 	if m == nil {
 		return 0
 	}
 	var l int
 	_ = l
-	l = len(m.Uri)
-	if l > 0 {
+	if m.MaxInternalRedirects != 0 {
+		n += 1 + sovVirtualService(uint64(m.MaxInternalRedirects))
+	}
+	if len(m.RedirectResponseCodes) > 0 {
+		l = 0
+		for _, e := range m.RedirectResponseCodes {
+			l += sovVirtualService(uint64(e))
+		}
+		n += 1 + sovVirtualService(uint64(l)) + l
+	}
+	if m.RedirectUrlRewriteSpecifier != nil {
+		n += m.RedirectUrlRewriteSpecifier.Size()
+	}
+	if m.AllowCrossScheme {
+		n += 2
+	}
+	if m.Headers != nil {
+		l = m.Headers.Size()
 		n += 1 + l + sovVirtualService(uint64(l))
 	}
 	l = len(m.Authority)
 	if l > 0 {
 		n += 1 + l + sovVirtualService(uint64(l))
 	}
+	if len(m.Policies) > 0 {
+		for _, e := range m.Policies {
+			l = e.Size()
+			n += 1 + l + sovVirtualService(uint64(l))
+		}
+	}
+	if m.ForcedUseOriginalHost {
+		n += 3
+	}
+	if m.ForcedAddHeaderBeforeRouteMatcher {
+		n += 3
+	}
 	if m.XXX_unrecognized != nil {
 		n += len(m.XXX_unrecognized)
 	}
 	return n
 }
 
-func (m *StringMatch) Size() (n int) {
+func (m *HTTPInternalActiveRedirect_RedirectUrl) Size() (n int) {
 	if m == nil {
 		return 0
 	}
 	var l int
 	_ = l
-	if m.MatchType != nil {
-		n += m.MatchType.Size()
-	}
-	if m.XXX_unrecognized != nil {
-		n += len(m.XXX_unrecognized)
-	}
+	l = len(m.RedirectUrl)
+	n += 1 + l + sovVirtualService(uint64(l))
 	return n
 }
-
-func (m *StringMatch_Exact) Size() (n int) {
+func (m *HTTPInternalActiveRedirect_RedirectUrlRewriteRegex) Size() (n int) {
 	if m == nil {
 		return 0
 	}
 	var l int
 	_ = l
-	l = len(m.Exact)
+	if m.RedirectUrlRewriteRegex != nil {
+		l = m.RedirectUrlRewriteRegex.Size()
+		n += 1 + l + sovVirtualService(uint64(l))
+	}
+	return n
+}
+func (m *HTTPInternalActiveRedirect_RedirectPolicy) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if m.MaxInternalRedirects != 0 {
+		n += 1 + sovVirtualService(uint64(m.MaxInternalRedirects))
+	}
+	if len(m.RedirectResponseCodes) > 0 {
+		l = 0
+		for _, e := range m.RedirectResponseCodes {
+			l += sovVirtualService(uint64(e))
+		}
+		n += 1 + sovVirtualService(uint64(l)) + l
+	}
+	if m.RedirectUrlRewriteSpecifier != nil {
+		n += m.RedirectUrlRewriteSpecifier.Size()
+	}
+	if m.AllowCrossScheme {
+		n += 2
+	}
+	if m.Headers != nil {
+		l = m.Headers.Size()
+		n += 1 + l + sovVirtualService(uint64(l))
+	}
+	l = len(m.Authority)
+	if l > 0 {
+		n += 1 + l + sovVirtualService(uint64(l))
+	}
+	if m.ForcedUseOriginalHost {
+		n += 3
+	}
+	if m.ForcedAddHeaderBeforeRouteMatcher {
+		n += 3
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *HTTPInternalActiveRedirect_RedirectPolicy_RedirectUrl) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	l = len(m.RedirectUrl)
+	n += 1 + l + sovVirtualService(uint64(l))
+	return n
+}
+func (m *HTTPInternalActiveRedirect_RedirectPolicy_RedirectUrlRewriteRegex) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if m.RedirectUrlRewriteRegex != nil {
+		l = m.RedirectUrlRewriteRegex.Size()
+		n += 1 + l + sovVirtualService(uint64(l))
+	}
+	return n
+}
+func (m *HTTPDirectResponse) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if m.ResponseCode != 0 {
+		n += 1 + sovVirtualService(uint64(m.ResponseCode))
+	}
+	l = len(m.Body)
+	if l > 0 {
+		n += 1 + l + sovVirtualService(uint64(l))
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *HTTPRewrite) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	l = len(m.Uri)
+	if l > 0 {
+		n += 1 + l + sovVirtualService(uint64(l))
+	}
+	l = len(m.Authority)
+	if l > 0 {
+		n += 1 + l + sovVirtualService(uint64(l))
+	}
+	if m.UriRegex != nil {
+		l = m.UriRegex.Size()
+		n += 1 + l + sovVirtualService(uint64(l))
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *RegexMatchAndSubstitute) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	l = len(m.Pattern)
+	if l > 0 {
+		n += 1 + l + sovVirtualService(uint64(l))
+	}
+	l = len(m.Substitution)
+	if l > 0 {
+		n += 1 + l + sovVirtualService(uint64(l))
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *StringMatch) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if m.MatchType != nil {
+		n += m.MatchType.Size()
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *StringMatch_Exact) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	l = len(m.Exact)
 	n += 1 + l + sovVirtualService(uint64(l))
 	return n
 }
@@ -6222,6 +7982,120 @@ func (m *Percent) Size() (n int) {
 	return n
 }
 
+func (m *HTTPFilter) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	l = len(m.Name)
+	if l > 0 {
+		n += 1 + l + sovVirtualService(uint64(l))
+	}
+	if m.Disable {
+		n += 2
+	}
+	if m.Filter != nil {
+		n += m.Filter.Size()
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *HTTPFilter_IpAccessControl) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if m.IpAccessControl != nil {
+		l = m.IpAccessControl.Size()
+		n += 1 + l + sovVirtualService(uint64(l))
+	}
+	return n
+}
+func (m *HTTPFilter_LocalRateLimit) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if m.LocalRateLimit != nil {
+		l = m.LocalRateLimit.Size()
+		n += 1 + l + sovVirtualService(uint64(l))
+	}
+	return n
+}
+func (m *IPAccessControl) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if len(m.RemoteIpBlocks) > 0 {
+		for _, s := range m.RemoteIpBlocks {
+			l = len(s)
+			n += 1 + l + sovVirtualService(uint64(l))
+		}
+	}
+	if len(m.NotRemoteIpBlocks) > 0 {
+		for _, s := range m.NotRemoteIpBlocks {
+			l = len(s)
+			n += 1 + l + sovVirtualService(uint64(l))
+		}
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *LocalRateLimit) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if m.TokenBucket != nil {
+		l = m.TokenBucket.Size()
+		n += 1 + l + sovVirtualService(uint64(l))
+	}
+	if m.PerDownstreamConnection {
+		n += 2
+	}
+	if m.StatusCode != 0 {
+		n += 1 + sovVirtualService(uint64(m.StatusCode))
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *TokenBucket) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if m.MaxTokens != 0 {
+		n += 1 + sovVirtualService(uint64(m.MaxTokens))
+	}
+	if m.TokensPefFill != 0 {
+		n += 1 + sovVirtualService(uint64(m.TokensPefFill))
+	}
+	if m.FillInterval != nil {
+		l = m.FillInterval.Size()
+		n += 1 + l + sovVirtualService(uint64(l))
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
 func sovVirtualService(x uint64) (n int) {
 	return (math_bits.Len64(x|1) + 6) / 7
 }
@@ -6247,21 +8121,1473 @@ func (m *VirtualService) Unmarshal(dAtA []byte) error {
 			if b < 0x80 {
 				break
 			}
-		}
-		fieldNum := int32(wire >> 3)
-		wireType := int(wire & 0x7)
-		if wireType == 4 {
-			return fmt.Errorf("proto: VirtualService: wiretype end group for non-group")
-		}
-		if fieldNum <= 0 {
-			return fmt.Errorf("proto: VirtualService: illegal tag %d (wire type %d)", fieldNum, wire)
-		}
-		switch fieldNum {
-		case 1:
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: VirtualService: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: VirtualService: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Hosts", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Hosts = append(m.Hosts, string(dAtA[iNdEx:postIndex]))
+			iNdEx = postIndex
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Gateways", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Gateways = append(m.Gateways, string(dAtA[iNdEx:postIndex]))
+			iNdEx = postIndex
+		case 3:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Http", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Http = append(m.Http, &HTTPRoute{})
+			if err := m.Http[len(m.Http)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 4:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Tcp", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Tcp = append(m.Tcp, &TCPRoute{})
+			if err := m.Tcp[len(m.Tcp)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 5:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Tls", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Tls = append(m.Tls, &TLSRoute{})
+			if err := m.Tls[len(m.Tls)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 6:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field ExportTo", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.ExportTo = append(m.ExportTo, string(dAtA[iNdEx:postIndex]))
+			iNdEx = postIndex
+		case 1000:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field HostHTTPFilters", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.HostHTTPFilters = append(m.HostHTTPFilters, &HTTPFilter{})
+			if err := m.HostHTTPFilters[len(m.HostHTTPFilters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipVirtualService(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *Destination) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowVirtualService
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: Destination: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: Destination: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Host = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Subset", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Subset = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 3:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.Port == nil {
+				m.Port = &PortSelector{}
+			}
+			if err := m.Port.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipVirtualService(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *HTTPRoute) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowVirtualService
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: HTTPRoute: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: HTTPRoute: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Match", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Match = append(m.Match, &HTTPMatchRequest{})
+			if err := m.Match[len(m.Match)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Route", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Route = append(m.Route, &HTTPRouteDestination{})
+			if err := m.Route[len(m.Route)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 3:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Redirect", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.Redirect == nil {
+				m.Redirect = &HTTPRedirect{}
+			}
+			if err := m.Redirect.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 4:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Rewrite", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.Rewrite == nil {
+				m.Rewrite = &HTTPRewrite{}
+			}
+			if err := m.Rewrite.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 6:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.Timeout == nil {
+				m.Timeout = &types.Duration{}
+			}
+			if err := m.Timeout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 7:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Retries", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.Retries == nil {
+				m.Retries = &HTTPRetry{}
+			}
+			if err := m.Retries.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 8:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Fault", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.Fault == nil {
+				m.Fault = &HTTPFaultInjection{}
+			}
+			if err := m.Fault.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 9:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Mirror", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.Mirror == nil {
+				m.Mirror = &Destination{}
+			}
+			if err := m.Mirror.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 10:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field CorsPolicy", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.CorsPolicy == nil {
+				m.CorsPolicy = &CorsPolicy{}
+			}
+			if err := m.CorsPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 16:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.Headers == nil {
+				m.Headers = &Headers{}
+			}
+			if err := m.Headers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 17:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Name = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 18:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field MirrorPercent", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.MirrorPercent == nil {
+				m.MirrorPercent = &types.UInt32Value{}
+			}
+			if err := m.MirrorPercent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 19:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field MirrorPercentage", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.MirrorPercentage == nil {
+				m.MirrorPercentage = &Percent{}
+			}
+			if err := m.MirrorPercentage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 20:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Delegate", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.Delegate == nil {
+				m.Delegate = &Delegate{}
+			}
+			if err := m.Delegate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 25:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field InternalActiveRedirect", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.InternalActiveRedirect == nil {
+				m.InternalActiveRedirect = &HTTPInternalActiveRedirect{}
+			}
+			if err := m.InternalActiveRedirect.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 26:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field DirectResponse", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.DirectResponse == nil {
+				m.DirectResponse = &HTTPDirectResponse{}
+			}
+			if err := m.DirectResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 1000:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field RouteHTTPFilters", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.RouteHTTPFilters = append(m.RouteHTTPFilters, &HTTPFilter{})
+			if err := m.RouteHTTPFilters[len(m.RouteHTTPFilters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipVirtualService(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *Delegate) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowVirtualService
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: Delegate: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: Delegate: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Name = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Namespace = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipVirtualService(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *Headers) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowVirtualService
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: Headers: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: Headers: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.Request == nil {
+				m.Request = &Headers_HeaderOperations{}
+			}
+			if err := m.Request.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.Response == nil {
+				m.Response = &Headers_HeaderOperations{}
+			}
+			if err := m.Response.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipVirtualService(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *Headers_HeaderOperations) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowVirtualService
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: HeaderOperations: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: HeaderOperations: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Set", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.Set == nil {
+				m.Set = make(map[string]string)
+			}
+			var mapkey string
+			var mapvalue string
+			for iNdEx < postIndex {
+				entryPreIndex := iNdEx
+				var wire uint64
+				for shift := uint(0); ; shift += 7 {
+					if shift >= 64 {
+						return ErrIntOverflowVirtualService
+					}
+					if iNdEx >= l {
+						return io.ErrUnexpectedEOF
+					}
+					b := dAtA[iNdEx]
+					iNdEx++
+					wire |= uint64(b&0x7F) << shift
+					if b < 0x80 {
+						break
+					}
+				}
+				fieldNum := int32(wire >> 3)
+				if fieldNum == 1 {
+					var stringLenmapkey uint64
+					for shift := uint(0); ; shift += 7 {
+						if shift >= 64 {
+							return ErrIntOverflowVirtualService
+						}
+						if iNdEx >= l {
+							return io.ErrUnexpectedEOF
+						}
+						b := dAtA[iNdEx]
+						iNdEx++
+						stringLenmapkey |= uint64(b&0x7F) << shift
+						if b < 0x80 {
+							break
+						}
+					}
+					intStringLenmapkey := int(stringLenmapkey)
+					if intStringLenmapkey < 0 {
+						return ErrInvalidLengthVirtualService
+					}
+					postStringIndexmapkey := iNdEx + intStringLenmapkey
+					if postStringIndexmapkey < 0 {
+						return ErrInvalidLengthVirtualService
+					}
+					if postStringIndexmapkey > l {
+						return io.ErrUnexpectedEOF
+					}
+					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
+					iNdEx = postStringIndexmapkey
+				} else if fieldNum == 2 {
+					var stringLenmapvalue uint64
+					for shift := uint(0); ; shift += 7 {
+						if shift >= 64 {
+							return ErrIntOverflowVirtualService
+						}
+						if iNdEx >= l {
+							return io.ErrUnexpectedEOF
+						}
+						b := dAtA[iNdEx]
+						iNdEx++
+						stringLenmapvalue |= uint64(b&0x7F) << shift
+						if b < 0x80 {
+							break
+						}
+					}
+					intStringLenmapvalue := int(stringLenmapvalue)
+					if intStringLenmapvalue < 0 {
+						return ErrInvalidLengthVirtualService
+					}
+					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
+					if postStringIndexmapvalue < 0 {
+						return ErrInvalidLengthVirtualService
+					}
+					if postStringIndexmapvalue > l {
+						return io.ErrUnexpectedEOF
+					}
+					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
+					iNdEx = postStringIndexmapvalue
+				} else {
+					iNdEx = entryPreIndex
+					skippy, err := skipVirtualService(dAtA[iNdEx:])
+					if err != nil {
+						return err
+					}
+					if (skippy < 0) || (iNdEx+skippy) < 0 {
+						return ErrInvalidLengthVirtualService
+					}
+					if (iNdEx + skippy) > postIndex {
+						return io.ErrUnexpectedEOF
+					}
+					iNdEx += skippy
+				}
+			}
+			m.Set[mapkey] = mapvalue
+			iNdEx = postIndex
+		case 2:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Hosts", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Add", wireType)
 			}
-			var stringLen uint64
+			var msglen int
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowVirtualService
@@ -6271,27 +9597,122 @@ func (m *VirtualService) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				stringLen |= uint64(b&0x7F) << shift
+				msglen |= int(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			intStringLen := int(stringLen)
-			if intStringLen < 0 {
+			if msglen < 0 {
 				return ErrInvalidLengthVirtualService
 			}
-			postIndex := iNdEx + intStringLen
+			postIndex := iNdEx + msglen
 			if postIndex < 0 {
 				return ErrInvalidLengthVirtualService
 			}
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.Hosts = append(m.Hosts, string(dAtA[iNdEx:postIndex]))
+			if m.Add == nil {
+				m.Add = make(map[string]string)
+			}
+			var mapkey string
+			var mapvalue string
+			for iNdEx < postIndex {
+				entryPreIndex := iNdEx
+				var wire uint64
+				for shift := uint(0); ; shift += 7 {
+					if shift >= 64 {
+						return ErrIntOverflowVirtualService
+					}
+					if iNdEx >= l {
+						return io.ErrUnexpectedEOF
+					}
+					b := dAtA[iNdEx]
+					iNdEx++
+					wire |= uint64(b&0x7F) << shift
+					if b < 0x80 {
+						break
+					}
+				}
+				fieldNum := int32(wire >> 3)
+				if fieldNum == 1 {
+					var stringLenmapkey uint64
+					for shift := uint(0); ; shift += 7 {
+						if shift >= 64 {
+							return ErrIntOverflowVirtualService
+						}
+						if iNdEx >= l {
+							return io.ErrUnexpectedEOF
+						}
+						b := dAtA[iNdEx]
+						iNdEx++
+						stringLenmapkey |= uint64(b&0x7F) << shift
+						if b < 0x80 {
+							break
+						}
+					}
+					intStringLenmapkey := int(stringLenmapkey)
+					if intStringLenmapkey < 0 {
+						return ErrInvalidLengthVirtualService
+					}
+					postStringIndexmapkey := iNdEx + intStringLenmapkey
+					if postStringIndexmapkey < 0 {
+						return ErrInvalidLengthVirtualService
+					}
+					if postStringIndexmapkey > l {
+						return io.ErrUnexpectedEOF
+					}
+					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
+					iNdEx = postStringIndexmapkey
+				} else if fieldNum == 2 {
+					var stringLenmapvalue uint64
+					for shift := uint(0); ; shift += 7 {
+						if shift >= 64 {
+							return ErrIntOverflowVirtualService
+						}
+						if iNdEx >= l {
+							return io.ErrUnexpectedEOF
+						}
+						b := dAtA[iNdEx]
+						iNdEx++
+						stringLenmapvalue |= uint64(b&0x7F) << shift
+						if b < 0x80 {
+							break
+						}
+					}
+					intStringLenmapvalue := int(stringLenmapvalue)
+					if intStringLenmapvalue < 0 {
+						return ErrInvalidLengthVirtualService
+					}
+					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
+					if postStringIndexmapvalue < 0 {
+						return ErrInvalidLengthVirtualService
+					}
+					if postStringIndexmapvalue > l {
+						return io.ErrUnexpectedEOF
+					}
+					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
+					iNdEx = postStringIndexmapvalue
+				} else {
+					iNdEx = entryPreIndex
+					skippy, err := skipVirtualService(dAtA[iNdEx:])
+					if err != nil {
+						return err
+					}
+					if (skippy < 0) || (iNdEx+skippy) < 0 {
+						return ErrInvalidLengthVirtualService
+					}
+					if (iNdEx + skippy) > postIndex {
+						return io.ErrUnexpectedEOF
+					}
+					iNdEx += skippy
+				}
+			}
+			m.Add[mapkey] = mapvalue
 			iNdEx = postIndex
-		case 2:
+		case 3:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Gateways", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Remove", wireType)
 			}
 			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
@@ -6319,79 +9740,62 @@ func (m *VirtualService) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.Gateways = append(m.Gateways, string(dAtA[iNdEx:postIndex]))
+			m.Remove = append(m.Remove, string(dAtA[iNdEx:postIndex]))
 			iNdEx = postIndex
-		case 3:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Http", wireType)
-			}
-			var msglen int
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowVirtualService
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				msglen |= int(b&0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-			if msglen < 0 {
-				return ErrInvalidLengthVirtualService
+		default:
+			iNdEx = preIndex
+			skippy, err := skipVirtualService(dAtA[iNdEx:])
+			if err != nil {
+				return err
 			}
-			postIndex := iNdEx + msglen
-			if postIndex < 0 {
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
 				return ErrInvalidLengthVirtualService
 			}
-			if postIndex > l {
+			if (iNdEx + skippy) > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.Http = append(m.Http, &HTTPRoute{})
-			if err := m.Http[len(m.Http)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
-			iNdEx = postIndex
-		case 4:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Tcp", wireType)
-			}
-			var msglen int
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowVirtualService
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				msglen |= int(b&0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-			if msglen < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			postIndex := iNdEx + msglen
-			if postIndex < 0 {
-				return ErrInvalidLengthVirtualService
+			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *TLSRoute) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowVirtualService
 			}
-			if postIndex > l {
+			if iNdEx >= l {
 				return io.ErrUnexpectedEOF
 			}
-			m.Tcp = append(m.Tcp, &TCPRoute{})
-			if err := m.Tcp[len(m.Tcp)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
 			}
-			iNdEx = postIndex
-		case 5:
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: TLSRoute: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: TLSRoute: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Tls", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Match", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -6418,16 +9822,16 @@ func (m *VirtualService) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.Tls = append(m.Tls, &TLSRoute{})
-			if err := m.Tls[len(m.Tls)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+			m.Match = append(m.Match, &TLSMatchAttributes{})
+			if err := m.Match[len(m.Match)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
 			iNdEx = postIndex
-		case 6:
+		case 2:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field ExportTo", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Route", wireType)
 			}
-			var stringLen uint64
+			var msglen int
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowVirtualService
@@ -6437,23 +9841,25 @@ func (m *VirtualService) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				stringLen |= uint64(b&0x7F) << shift
+				msglen |= int(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			intStringLen := int(stringLen)
-			if intStringLen < 0 {
+			if msglen < 0 {
 				return ErrInvalidLengthVirtualService
 			}
-			postIndex := iNdEx + intStringLen
+			postIndex := iNdEx + msglen
 			if postIndex < 0 {
 				return ErrInvalidLengthVirtualService
 			}
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.ExportTo = append(m.ExportTo, string(dAtA[iNdEx:postIndex]))
+			m.Route = append(m.Route, &RouteDestination{})
+			if err := m.Route[len(m.Route)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
 			iNdEx = postIndex
 		default:
 			iNdEx = preIndex
@@ -6477,7 +9883,7 @@ func (m *VirtualService) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
-func (m *Destination) Unmarshal(dAtA []byte) error {
+func (m *TCPRoute) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
 	for iNdEx < l {
@@ -6500,17 +9906,17 @@ func (m *Destination) Unmarshal(dAtA []byte) error {
 		fieldNum := int32(wire >> 3)
 		wireType := int(wire & 0x7)
 		if wireType == 4 {
-			return fmt.Errorf("proto: Destination: wiretype end group for non-group")
+			return fmt.Errorf("proto: TCPRoute: wiretype end group for non-group")
 		}
 		if fieldNum <= 0 {
-			return fmt.Errorf("proto: Destination: illegal tag %d (wire type %d)", fieldNum, wire)
+			return fmt.Errorf("proto: TCPRoute: illegal tag %d (wire type %d)", fieldNum, wire)
 		}
 		switch fieldNum {
 		case 1:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Match", wireType)
 			}
-			var stringLen uint64
+			var msglen int
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowVirtualService
@@ -6520,59 +9926,29 @@ func (m *Destination) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				stringLen |= uint64(b&0x7F) << shift
+				msglen |= int(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			intStringLen := int(stringLen)
-			if intStringLen < 0 {
+			if msglen < 0 {
 				return ErrInvalidLengthVirtualService
 			}
-			postIndex := iNdEx + intStringLen
+			postIndex := iNdEx + msglen
 			if postIndex < 0 {
 				return ErrInvalidLengthVirtualService
 			}
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.Host = string(dAtA[iNdEx:postIndex])
-			iNdEx = postIndex
-		case 2:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Subset", wireType)
-			}
-			var stringLen uint64
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowVirtualService
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				stringLen |= uint64(b&0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-			intStringLen := int(stringLen)
-			if intStringLen < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			postIndex := iNdEx + intStringLen
-			if postIndex < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
+			m.Match = append(m.Match, &L4MatchAttributes{})
+			if err := m.Match[len(m.Match)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
 			}
-			m.Subset = string(dAtA[iNdEx:postIndex])
 			iNdEx = postIndex
-		case 3:
+		case 2:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Route", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -6599,10 +9975,8 @@ func (m *Destination) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.Port == nil {
-				m.Port = &PortSelector{}
-			}
-			if err := m.Port.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+			m.Route = append(m.Route, &RouteDestination{})
+			if err := m.Route[len(m.Route)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
 			iNdEx = postIndex
@@ -6628,7 +10002,7 @@ func (m *Destination) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
-func (m *HTTPRoute) Unmarshal(dAtA []byte) error {
+func (m *HTTPMatchRequest) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
 	for iNdEx < l {
@@ -6651,15 +10025,15 @@ func (m *HTTPRoute) Unmarshal(dAtA []byte) error {
 		fieldNum := int32(wire >> 3)
 		wireType := int(wire & 0x7)
 		if wireType == 4 {
-			return fmt.Errorf("proto: HTTPRoute: wiretype end group for non-group")
+			return fmt.Errorf("proto: HTTPMatchRequest: wiretype end group for non-group")
 		}
 		if fieldNum <= 0 {
-			return fmt.Errorf("proto: HTTPRoute: illegal tag %d (wire type %d)", fieldNum, wire)
+			return fmt.Errorf("proto: HTTPMatchRequest: illegal tag %d (wire type %d)", fieldNum, wire)
 		}
 		switch fieldNum {
 		case 1:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Match", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -6686,14 +10060,16 @@ func (m *HTTPRoute) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.Match = append(m.Match, &HTTPMatchRequest{})
-			if err := m.Match[len(m.Match)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+			if m.Uri == nil {
+				m.Uri = &StringMatch{}
+			}
+			if err := m.Uri.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
 			iNdEx = postIndex
 		case 2:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Route", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Scheme", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -6720,14 +10096,16 @@ func (m *HTTPRoute) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.Route = append(m.Route, &HTTPRouteDestination{})
-			if err := m.Route[len(m.Route)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+			if m.Scheme == nil {
+				m.Scheme = &StringMatch{}
+			}
+			if err := m.Scheme.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
 			iNdEx = postIndex
 		case 3:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Redirect", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -6754,16 +10132,16 @@ func (m *HTTPRoute) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.Redirect == nil {
-				m.Redirect = &HTTPRedirect{}
+			if m.Method == nil {
+				m.Method = &StringMatch{}
 			}
-			if err := m.Redirect.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+			if err := m.Method.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
 			iNdEx = postIndex
 		case 4:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Rewrite", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -6790,18 +10168,147 @@ func (m *HTTPRoute) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.Rewrite == nil {
-				m.Rewrite = &HTTPRewrite{}
+			if m.Authority == nil {
+				m.Authority = &StringMatch{}
 			}
-			if err := m.Rewrite.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+			if err := m.Authority.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
 			iNdEx = postIndex
-		case 6:
+		case 5:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.Headers == nil {
+				m.Headers = make(map[string]*StringMatch)
+			}
+			var mapkey string
+			var mapvalue *StringMatch
+			for iNdEx < postIndex {
+				entryPreIndex := iNdEx
+				var wire uint64
+				for shift := uint(0); ; shift += 7 {
+					if shift >= 64 {
+						return ErrIntOverflowVirtualService
+					}
+					if iNdEx >= l {
+						return io.ErrUnexpectedEOF
+					}
+					b := dAtA[iNdEx]
+					iNdEx++
+					wire |= uint64(b&0x7F) << shift
+					if b < 0x80 {
+						break
+					}
+				}
+				fieldNum := int32(wire >> 3)
+				if fieldNum == 1 {
+					var stringLenmapkey uint64
+					for shift := uint(0); ; shift += 7 {
+						if shift >= 64 {
+							return ErrIntOverflowVirtualService
+						}
+						if iNdEx >= l {
+							return io.ErrUnexpectedEOF
+						}
+						b := dAtA[iNdEx]
+						iNdEx++
+						stringLenmapkey |= uint64(b&0x7F) << shift
+						if b < 0x80 {
+							break
+						}
+					}
+					intStringLenmapkey := int(stringLenmapkey)
+					if intStringLenmapkey < 0 {
+						return ErrInvalidLengthVirtualService
+					}
+					postStringIndexmapkey := iNdEx + intStringLenmapkey
+					if postStringIndexmapkey < 0 {
+						return ErrInvalidLengthVirtualService
+					}
+					if postStringIndexmapkey > l {
+						return io.ErrUnexpectedEOF
+					}
+					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
+					iNdEx = postStringIndexmapkey
+				} else if fieldNum == 2 {
+					var mapmsglen int
+					for shift := uint(0); ; shift += 7 {
+						if shift >= 64 {
+							return ErrIntOverflowVirtualService
+						}
+						if iNdEx >= l {
+							return io.ErrUnexpectedEOF
+						}
+						b := dAtA[iNdEx]
+						iNdEx++
+						mapmsglen |= int(b&0x7F) << shift
+						if b < 0x80 {
+							break
+						}
+					}
+					if mapmsglen < 0 {
+						return ErrInvalidLengthVirtualService
+					}
+					postmsgIndex := iNdEx + mapmsglen
+					if postmsgIndex < 0 {
+						return ErrInvalidLengthVirtualService
+					}
+					if postmsgIndex > l {
+						return io.ErrUnexpectedEOF
+					}
+					mapvalue = &StringMatch{}
+					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
+						return err
+					}
+					iNdEx = postmsgIndex
+				} else {
+					iNdEx = entryPreIndex
+					skippy, err := skipVirtualService(dAtA[iNdEx:])
+					if err != nil {
+						return err
+					}
+					if (skippy < 0) || (iNdEx+skippy) < 0 {
+						return ErrInvalidLengthVirtualService
+					}
+					if (iNdEx + skippy) > postIndex {
+						return io.ErrUnexpectedEOF
+					}
+					iNdEx += skippy
+				}
+			}
+			m.Headers[mapkey] = mapvalue
+			iNdEx = postIndex
+		case 6:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
 			}
-			var msglen int
+			m.Port = 0
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowVirtualService
@@ -6811,31 +10318,14 @@ func (m *HTTPRoute) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				msglen |= int(b&0x7F) << shift
+				m.Port |= uint32(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			if msglen < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			postIndex := iNdEx + msglen
-			if postIndex < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			if m.Timeout == nil {
-				m.Timeout = &types.Duration{}
-			}
-			if err := m.Timeout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
-			iNdEx = postIndex
 		case 7:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Retries", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field SourceLabels", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -6862,18 +10352,109 @@ func (m *HTTPRoute) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.Retries == nil {
-				m.Retries = &HTTPRetry{}
+			if m.SourceLabels == nil {
+				m.SourceLabels = make(map[string]string)
 			}
-			if err := m.Retries.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
+			var mapkey string
+			var mapvalue string
+			for iNdEx < postIndex {
+				entryPreIndex := iNdEx
+				var wire uint64
+				for shift := uint(0); ; shift += 7 {
+					if shift >= 64 {
+						return ErrIntOverflowVirtualService
+					}
+					if iNdEx >= l {
+						return io.ErrUnexpectedEOF
+					}
+					b := dAtA[iNdEx]
+					iNdEx++
+					wire |= uint64(b&0x7F) << shift
+					if b < 0x80 {
+						break
+					}
+				}
+				fieldNum := int32(wire >> 3)
+				if fieldNum == 1 {
+					var stringLenmapkey uint64
+					for shift := uint(0); ; shift += 7 {
+						if shift >= 64 {
+							return ErrIntOverflowVirtualService
+						}
+						if iNdEx >= l {
+							return io.ErrUnexpectedEOF
+						}
+						b := dAtA[iNdEx]
+						iNdEx++
+						stringLenmapkey |= uint64(b&0x7F) << shift
+						if b < 0x80 {
+							break
+						}
+					}
+					intStringLenmapkey := int(stringLenmapkey)
+					if intStringLenmapkey < 0 {
+						return ErrInvalidLengthVirtualService
+					}
+					postStringIndexmapkey := iNdEx + intStringLenmapkey
+					if postStringIndexmapkey < 0 {
+						return ErrInvalidLengthVirtualService
+					}
+					if postStringIndexmapkey > l {
+						return io.ErrUnexpectedEOF
+					}
+					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
+					iNdEx = postStringIndexmapkey
+				} else if fieldNum == 2 {
+					var stringLenmapvalue uint64
+					for shift := uint(0); ; shift += 7 {
+						if shift >= 64 {
+							return ErrIntOverflowVirtualService
+						}
+						if iNdEx >= l {
+							return io.ErrUnexpectedEOF
+						}
+						b := dAtA[iNdEx]
+						iNdEx++
+						stringLenmapvalue |= uint64(b&0x7F) << shift
+						if b < 0x80 {
+							break
+						}
+					}
+					intStringLenmapvalue := int(stringLenmapvalue)
+					if intStringLenmapvalue < 0 {
+						return ErrInvalidLengthVirtualService
+					}
+					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
+					if postStringIndexmapvalue < 0 {
+						return ErrInvalidLengthVirtualService
+					}
+					if postStringIndexmapvalue > l {
+						return io.ErrUnexpectedEOF
+					}
+					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
+					iNdEx = postStringIndexmapvalue
+				} else {
+					iNdEx = entryPreIndex
+					skippy, err := skipVirtualService(dAtA[iNdEx:])
+					if err != nil {
+						return err
+					}
+					if (skippy < 0) || (iNdEx+skippy) < 0 {
+						return ErrInvalidLengthVirtualService
+					}
+					if (iNdEx + skippy) > postIndex {
+						return io.ErrUnexpectedEOF
+					}
+					iNdEx += skippy
+				}
 			}
+			m.SourceLabels[mapkey] = mapvalue
 			iNdEx = postIndex
 		case 8:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Fault", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Gateways", wireType)
 			}
-			var msglen int
+			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowVirtualService
@@ -6883,31 +10464,27 @@ func (m *HTTPRoute) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				msglen |= int(b&0x7F) << shift
+				stringLen |= uint64(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			if msglen < 0 {
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
 				return ErrInvalidLengthVirtualService
 			}
-			postIndex := iNdEx + msglen
+			postIndex := iNdEx + intStringLen
 			if postIndex < 0 {
 				return ErrInvalidLengthVirtualService
 			}
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.Fault == nil {
-				m.Fault = &HTTPFaultInjection{}
-			}
-			if err := m.Fault.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
+			m.Gateways = append(m.Gateways, string(dAtA[iNdEx:postIndex]))
 			iNdEx = postIndex
 		case 9:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Mirror", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field QueryParams", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -6934,54 +10511,111 @@ func (m *HTTPRoute) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.Mirror == nil {
-				m.Mirror = &Destination{}
-			}
-			if err := m.Mirror.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
-			iNdEx = postIndex
-		case 10:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field CorsPolicy", wireType)
+			if m.QueryParams == nil {
+				m.QueryParams = make(map[string]*StringMatch)
 			}
-			var msglen int
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowVirtualService
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
+			var mapkey string
+			var mapvalue *StringMatch
+			for iNdEx < postIndex {
+				entryPreIndex := iNdEx
+				var wire uint64
+				for shift := uint(0); ; shift += 7 {
+					if shift >= 64 {
+						return ErrIntOverflowVirtualService
+					}
+					if iNdEx >= l {
+						return io.ErrUnexpectedEOF
+					}
+					b := dAtA[iNdEx]
+					iNdEx++
+					wire |= uint64(b&0x7F) << shift
+					if b < 0x80 {
+						break
+					}
 				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				msglen |= int(b&0x7F) << shift
-				if b < 0x80 {
-					break
+				fieldNum := int32(wire >> 3)
+				if fieldNum == 1 {
+					var stringLenmapkey uint64
+					for shift := uint(0); ; shift += 7 {
+						if shift >= 64 {
+							return ErrIntOverflowVirtualService
+						}
+						if iNdEx >= l {
+							return io.ErrUnexpectedEOF
+						}
+						b := dAtA[iNdEx]
+						iNdEx++
+						stringLenmapkey |= uint64(b&0x7F) << shift
+						if b < 0x80 {
+							break
+						}
+					}
+					intStringLenmapkey := int(stringLenmapkey)
+					if intStringLenmapkey < 0 {
+						return ErrInvalidLengthVirtualService
+					}
+					postStringIndexmapkey := iNdEx + intStringLenmapkey
+					if postStringIndexmapkey < 0 {
+						return ErrInvalidLengthVirtualService
+					}
+					if postStringIndexmapkey > l {
+						return io.ErrUnexpectedEOF
+					}
+					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
+					iNdEx = postStringIndexmapkey
+				} else if fieldNum == 2 {
+					var mapmsglen int
+					for shift := uint(0); ; shift += 7 {
+						if shift >= 64 {
+							return ErrIntOverflowVirtualService
+						}
+						if iNdEx >= l {
+							return io.ErrUnexpectedEOF
+						}
+						b := dAtA[iNdEx]
+						iNdEx++
+						mapmsglen |= int(b&0x7F) << shift
+						if b < 0x80 {
+							break
+						}
+					}
+					if mapmsglen < 0 {
+						return ErrInvalidLengthVirtualService
+					}
+					postmsgIndex := iNdEx + mapmsglen
+					if postmsgIndex < 0 {
+						return ErrInvalidLengthVirtualService
+					}
+					if postmsgIndex > l {
+						return io.ErrUnexpectedEOF
+					}
+					mapvalue = &StringMatch{}
+					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
+						return err
+					}
+					iNdEx = postmsgIndex
+				} else {
+					iNdEx = entryPreIndex
+					skippy, err := skipVirtualService(dAtA[iNdEx:])
+					if err != nil {
+						return err
+					}
+					if (skippy < 0) || (iNdEx+skippy) < 0 {
+						return ErrInvalidLengthVirtualService
+					}
+					if (iNdEx + skippy) > postIndex {
+						return io.ErrUnexpectedEOF
+					}
+					iNdEx += skippy
 				}
 			}
-			if msglen < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			postIndex := iNdEx + msglen
-			if postIndex < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			if m.CorsPolicy == nil {
-				m.CorsPolicy = &CorsPolicy{}
-			}
-			if err := m.CorsPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
+			m.QueryParams[mapkey] = mapvalue
 			iNdEx = postIndex
-		case 16:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
+		case 10:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field IgnoreUriCase", wireType)
 			}
-			var msglen int
+			var v int
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowVirtualService
@@ -6991,29 +10625,13 @@ func (m *HTTPRoute) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				msglen |= int(b&0x7F) << shift
+				v |= int(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			if msglen < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			postIndex := iNdEx + msglen
-			if postIndex < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			if m.Headers == nil {
-				m.Headers = &Headers{}
-			}
-			if err := m.Headers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
-			iNdEx = postIndex
-		case 17:
+			m.IgnoreUriCase = bool(v != 0)
+		case 11:
 			if wireType != 2 {
 				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
 			}
@@ -7045,81 +10663,9 @@ func (m *HTTPRoute) Unmarshal(dAtA []byte) error {
 			}
 			m.Name = string(dAtA[iNdEx:postIndex])
 			iNdEx = postIndex
-		case 18:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field MirrorPercent", wireType)
-			}
-			var msglen int
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowVirtualService
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				msglen |= int(b&0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-			if msglen < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			postIndex := iNdEx + msglen
-			if postIndex < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			if m.MirrorPercent == nil {
-				m.MirrorPercent = &types.UInt32Value{}
-			}
-			if err := m.MirrorPercent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
-			iNdEx = postIndex
-		case 19:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field MirrorPercentage", wireType)
-			}
-			var msglen int
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowVirtualService
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				msglen |= int(b&0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-			if msglen < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			postIndex := iNdEx + msglen
-			if postIndex < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			if m.MirrorPercentage == nil {
-				m.MirrorPercentage = &Percent{}
-			}
-			if err := m.MirrorPercentage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
-			iNdEx = postIndex
-		case 20:
+		case 12:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Delegate", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field WithoutHeaders", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -7146,99 +10692,109 @@ func (m *HTTPRoute) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.Delegate == nil {
-				m.Delegate = &Delegate{}
-			}
-			if err := m.Delegate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
-			iNdEx = postIndex
-		default:
-			iNdEx = preIndex
-			skippy, err := skipVirtualService(dAtA[iNdEx:])
-			if err != nil {
-				return err
-			}
-			if (skippy < 0) || (iNdEx+skippy) < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			if (iNdEx + skippy) > l {
-				return io.ErrUnexpectedEOF
-			}
-			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
-			iNdEx += skippy
-		}
-	}
-
-	if iNdEx > l {
-		return io.ErrUnexpectedEOF
-	}
-	return nil
-}
-func (m *Delegate) Unmarshal(dAtA []byte) error {
-	l := len(dAtA)
-	iNdEx := 0
-	for iNdEx < l {
-		preIndex := iNdEx
-		var wire uint64
-		for shift := uint(0); ; shift += 7 {
-			if shift >= 64 {
-				return ErrIntOverflowVirtualService
-			}
-			if iNdEx >= l {
-				return io.ErrUnexpectedEOF
-			}
-			b := dAtA[iNdEx]
-			iNdEx++
-			wire |= uint64(b&0x7F) << shift
-			if b < 0x80 {
-				break
-			}
-		}
-		fieldNum := int32(wire >> 3)
-		wireType := int(wire & 0x7)
-		if wireType == 4 {
-			return fmt.Errorf("proto: Delegate: wiretype end group for non-group")
-		}
-		if fieldNum <= 0 {
-			return fmt.Errorf("proto: Delegate: illegal tag %d (wire type %d)", fieldNum, wire)
-		}
-		switch fieldNum {
-		case 1:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
+			if m.WithoutHeaders == nil {
+				m.WithoutHeaders = make(map[string]*StringMatch)
 			}
-			var stringLen uint64
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowVirtualService
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
+			var mapkey string
+			var mapvalue *StringMatch
+			for iNdEx < postIndex {
+				entryPreIndex := iNdEx
+				var wire uint64
+				for shift := uint(0); ; shift += 7 {
+					if shift >= 64 {
+						return ErrIntOverflowVirtualService
+					}
+					if iNdEx >= l {
+						return io.ErrUnexpectedEOF
+					}
+					b := dAtA[iNdEx]
+					iNdEx++
+					wire |= uint64(b&0x7F) << shift
+					if b < 0x80 {
+						break
+					}
 				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				stringLen |= uint64(b&0x7F) << shift
-				if b < 0x80 {
-					break
+				fieldNum := int32(wire >> 3)
+				if fieldNum == 1 {
+					var stringLenmapkey uint64
+					for shift := uint(0); ; shift += 7 {
+						if shift >= 64 {
+							return ErrIntOverflowVirtualService
+						}
+						if iNdEx >= l {
+							return io.ErrUnexpectedEOF
+						}
+						b := dAtA[iNdEx]
+						iNdEx++
+						stringLenmapkey |= uint64(b&0x7F) << shift
+						if b < 0x80 {
+							break
+						}
+					}
+					intStringLenmapkey := int(stringLenmapkey)
+					if intStringLenmapkey < 0 {
+						return ErrInvalidLengthVirtualService
+					}
+					postStringIndexmapkey := iNdEx + intStringLenmapkey
+					if postStringIndexmapkey < 0 {
+						return ErrInvalidLengthVirtualService
+					}
+					if postStringIndexmapkey > l {
+						return io.ErrUnexpectedEOF
+					}
+					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
+					iNdEx = postStringIndexmapkey
+				} else if fieldNum == 2 {
+					var mapmsglen int
+					for shift := uint(0); ; shift += 7 {
+						if shift >= 64 {
+							return ErrIntOverflowVirtualService
+						}
+						if iNdEx >= l {
+							return io.ErrUnexpectedEOF
+						}
+						b := dAtA[iNdEx]
+						iNdEx++
+						mapmsglen |= int(b&0x7F) << shift
+						if b < 0x80 {
+							break
+						}
+					}
+					if mapmsglen < 0 {
+						return ErrInvalidLengthVirtualService
+					}
+					postmsgIndex := iNdEx + mapmsglen
+					if postmsgIndex < 0 {
+						return ErrInvalidLengthVirtualService
+					}
+					if postmsgIndex > l {
+						return io.ErrUnexpectedEOF
+					}
+					mapvalue = &StringMatch{}
+					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
+						return err
+					}
+					iNdEx = postmsgIndex
+				} else {
+					iNdEx = entryPreIndex
+					skippy, err := skipVirtualService(dAtA[iNdEx:])
+					if err != nil {
+						return err
+					}
+					if (skippy < 0) || (iNdEx+skippy) < 0 {
+						return ErrInvalidLengthVirtualService
+					}
+					if (iNdEx + skippy) > postIndex {
+						return io.ErrUnexpectedEOF
+					}
+					iNdEx += skippy
 				}
 			}
-			intStringLen := int(stringLen)
-			if intStringLen < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			postIndex := iNdEx + intStringLen
-			if postIndex < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			m.Name = string(dAtA[iNdEx:postIndex])
+			m.WithoutHeaders[mapkey] = mapvalue
 			iNdEx = postIndex
-		case 2:
+		case 13:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field SourceNamespace", wireType)
 			}
 			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
@@ -7266,7 +10822,7 @@ func (m *Delegate) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.Namespace = string(dAtA[iNdEx:postIndex])
+			m.SourceNamespace = string(dAtA[iNdEx:postIndex])
 			iNdEx = postIndex
 		default:
 			iNdEx = preIndex
@@ -7290,7 +10846,7 @@ func (m *Delegate) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
-func (m *Headers) Unmarshal(dAtA []byte) error {
+func (m *HTTPRouteDestination) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
 	for iNdEx < l {
@@ -7313,15 +10869,15 @@ func (m *Headers) Unmarshal(dAtA []byte) error {
 		fieldNum := int32(wire >> 3)
 		wireType := int(wire & 0x7)
 		if wireType == 4 {
-			return fmt.Errorf("proto: Headers: wiretype end group for non-group")
+			return fmt.Errorf("proto: HTTPRouteDestination: wiretype end group for non-group")
 		}
 		if fieldNum <= 0 {
-			return fmt.Errorf("proto: Headers: illegal tag %d (wire type %d)", fieldNum, wire)
+			return fmt.Errorf("proto: HTTPRouteDestination: illegal tag %d (wire type %d)", fieldNum, wire)
 		}
 		switch fieldNum {
 		case 1:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Destination", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -7348,18 +10904,18 @@ func (m *Headers) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.Request == nil {
-				m.Request = &Headers_HeaderOperations{}
+			if m.Destination == nil {
+				m.Destination = &Destination{}
 			}
-			if err := m.Request.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+			if err := m.Destination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
 			iNdEx = postIndex
 		case 2:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
 			}
-			var msglen int
+			m.Weight = 0
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowVirtualService
@@ -7369,82 +10925,14 @@ func (m *Headers) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				msglen |= int(b&0x7F) << shift
+				m.Weight |= int32(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			if msglen < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			postIndex := iNdEx + msglen
-			if postIndex < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			if m.Response == nil {
-				m.Response = &Headers_HeaderOperations{}
-			}
-			if err := m.Response.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
-			iNdEx = postIndex
-		default:
-			iNdEx = preIndex
-			skippy, err := skipVirtualService(dAtA[iNdEx:])
-			if err != nil {
-				return err
-			}
-			if (skippy < 0) || (iNdEx+skippy) < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			if (iNdEx + skippy) > l {
-				return io.ErrUnexpectedEOF
-			}
-			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
-			iNdEx += skippy
-		}
-	}
-
-	if iNdEx > l {
-		return io.ErrUnexpectedEOF
-	}
-	return nil
-}
-func (m *Headers_HeaderOperations) Unmarshal(dAtA []byte) error {
-	l := len(dAtA)
-	iNdEx := 0
-	for iNdEx < l {
-		preIndex := iNdEx
-		var wire uint64
-		for shift := uint(0); ; shift += 7 {
-			if shift >= 64 {
-				return ErrIntOverflowVirtualService
-			}
-			if iNdEx >= l {
-				return io.ErrUnexpectedEOF
-			}
-			b := dAtA[iNdEx]
-			iNdEx++
-			wire |= uint64(b&0x7F) << shift
-			if b < 0x80 {
-				break
-			}
-		}
-		fieldNum := int32(wire >> 3)
-		wireType := int(wire & 0x7)
-		if wireType == 4 {
-			return fmt.Errorf("proto: HeaderOperations: wiretype end group for non-group")
-		}
-		if fieldNum <= 0 {
-			return fmt.Errorf("proto: HeaderOperations: illegal tag %d (wire type %d)", fieldNum, wire)
-		}
-		switch fieldNum {
-		case 1:
+		case 7:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Set", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -7458,120 +10946,29 @@ func (m *Headers_HeaderOperations) Unmarshal(dAtA []byte) error {
 				iNdEx++
 				msglen |= int(b&0x7F) << shift
 				if b < 0x80 {
-					break
-				}
-			}
-			if msglen < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			postIndex := iNdEx + msglen
-			if postIndex < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			if m.Set == nil {
-				m.Set = make(map[string]string)
-			}
-			var mapkey string
-			var mapvalue string
-			for iNdEx < postIndex {
-				entryPreIndex := iNdEx
-				var wire uint64
-				for shift := uint(0); ; shift += 7 {
-					if shift >= 64 {
-						return ErrIntOverflowVirtualService
-					}
-					if iNdEx >= l {
-						return io.ErrUnexpectedEOF
-					}
-					b := dAtA[iNdEx]
-					iNdEx++
-					wire |= uint64(b&0x7F) << shift
-					if b < 0x80 {
-						break
-					}
-				}
-				fieldNum := int32(wire >> 3)
-				if fieldNum == 1 {
-					var stringLenmapkey uint64
-					for shift := uint(0); ; shift += 7 {
-						if shift >= 64 {
-							return ErrIntOverflowVirtualService
-						}
-						if iNdEx >= l {
-							return io.ErrUnexpectedEOF
-						}
-						b := dAtA[iNdEx]
-						iNdEx++
-						stringLenmapkey |= uint64(b&0x7F) << shift
-						if b < 0x80 {
-							break
-						}
-					}
-					intStringLenmapkey := int(stringLenmapkey)
-					if intStringLenmapkey < 0 {
-						return ErrInvalidLengthVirtualService
-					}
-					postStringIndexmapkey := iNdEx + intStringLenmapkey
-					if postStringIndexmapkey < 0 {
-						return ErrInvalidLengthVirtualService
-					}
-					if postStringIndexmapkey > l {
-						return io.ErrUnexpectedEOF
-					}
-					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
-					iNdEx = postStringIndexmapkey
-				} else if fieldNum == 2 {
-					var stringLenmapvalue uint64
-					for shift := uint(0); ; shift += 7 {
-						if shift >= 64 {
-							return ErrIntOverflowVirtualService
-						}
-						if iNdEx >= l {
-							return io.ErrUnexpectedEOF
-						}
-						b := dAtA[iNdEx]
-						iNdEx++
-						stringLenmapvalue |= uint64(b&0x7F) << shift
-						if b < 0x80 {
-							break
-						}
-					}
-					intStringLenmapvalue := int(stringLenmapvalue)
-					if intStringLenmapvalue < 0 {
-						return ErrInvalidLengthVirtualService
-					}
-					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
-					if postStringIndexmapvalue < 0 {
-						return ErrInvalidLengthVirtualService
-					}
-					if postStringIndexmapvalue > l {
-						return io.ErrUnexpectedEOF
-					}
-					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
-					iNdEx = postStringIndexmapvalue
-				} else {
-					iNdEx = entryPreIndex
-					skippy, err := skipVirtualService(dAtA[iNdEx:])
-					if err != nil {
-						return err
-					}
-					if (skippy < 0) || (iNdEx+skippy) < 0 {
-						return ErrInvalidLengthVirtualService
-					}
-					if (iNdEx + skippy) > postIndex {
-						return io.ErrUnexpectedEOF
-					}
-					iNdEx += skippy
+					break
 				}
 			}
-			m.Set[mapkey] = mapvalue
+			if msglen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.Headers == nil {
+				m.Headers = &Headers{}
+			}
+			if err := m.Headers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
 			iNdEx = postIndex
-		case 2:
+		case 100:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Add", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field FallbackClusters", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -7598,109 +10995,67 @@ func (m *Headers_HeaderOperations) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.Add == nil {
-				m.Add = make(map[string]string)
-			}
-			var mapkey string
-			var mapvalue string
-			for iNdEx < postIndex {
-				entryPreIndex := iNdEx
-				var wire uint64
-				for shift := uint(0); ; shift += 7 {
-					if shift >= 64 {
-						return ErrIntOverflowVirtualService
-					}
-					if iNdEx >= l {
-						return io.ErrUnexpectedEOF
-					}
-					b := dAtA[iNdEx]
-					iNdEx++
-					wire |= uint64(b&0x7F) << shift
-					if b < 0x80 {
-						break
-					}
-				}
-				fieldNum := int32(wire >> 3)
-				if fieldNum == 1 {
-					var stringLenmapkey uint64
-					for shift := uint(0); ; shift += 7 {
-						if shift >= 64 {
-							return ErrIntOverflowVirtualService
-						}
-						if iNdEx >= l {
-							return io.ErrUnexpectedEOF
-						}
-						b := dAtA[iNdEx]
-						iNdEx++
-						stringLenmapkey |= uint64(b&0x7F) << shift
-						if b < 0x80 {
-							break
-						}
-					}
-					intStringLenmapkey := int(stringLenmapkey)
-					if intStringLenmapkey < 0 {
-						return ErrInvalidLengthVirtualService
-					}
-					postStringIndexmapkey := iNdEx + intStringLenmapkey
-					if postStringIndexmapkey < 0 {
-						return ErrInvalidLengthVirtualService
-					}
-					if postStringIndexmapkey > l {
-						return io.ErrUnexpectedEOF
-					}
-					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
-					iNdEx = postStringIndexmapkey
-				} else if fieldNum == 2 {
-					var stringLenmapvalue uint64
-					for shift := uint(0); ; shift += 7 {
-						if shift >= 64 {
-							return ErrIntOverflowVirtualService
-						}
-						if iNdEx >= l {
-							return io.ErrUnexpectedEOF
-						}
-						b := dAtA[iNdEx]
-						iNdEx++
-						stringLenmapvalue |= uint64(b&0x7F) << shift
-						if b < 0x80 {
-							break
-						}
-					}
-					intStringLenmapvalue := int(stringLenmapvalue)
-					if intStringLenmapvalue < 0 {
-						return ErrInvalidLengthVirtualService
-					}
-					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
-					if postStringIndexmapvalue < 0 {
-						return ErrInvalidLengthVirtualService
-					}
-					if postStringIndexmapvalue > l {
-						return io.ErrUnexpectedEOF
-					}
-					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
-					iNdEx = postStringIndexmapvalue
-				} else {
-					iNdEx = entryPreIndex
-					skippy, err := skipVirtualService(dAtA[iNdEx:])
-					if err != nil {
-						return err
-					}
-					if (skippy < 0) || (iNdEx+skippy) < 0 {
-						return ErrInvalidLengthVirtualService
-					}
-					if (iNdEx + skippy) > postIndex {
-						return io.ErrUnexpectedEOF
-					}
-					iNdEx += skippy
-				}
+			m.FallbackClusters = append(m.FallbackClusters, &Destination{})
+			if err := m.FallbackClusters[len(m.FallbackClusters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
 			}
-			m.Add[mapkey] = mapvalue
 			iNdEx = postIndex
-		case 3:
+		default:
+			iNdEx = preIndex
+			skippy, err := skipVirtualService(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *RouteDestination) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowVirtualService
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: RouteDestination: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: RouteDestination: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Remove", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Destination", wireType)
 			}
-			var stringLen uint64
+			var msglen int
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowVirtualService
@@ -7710,24 +11065,47 @@ func (m *Headers_HeaderOperations) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				stringLen |= uint64(b&0x7F) << shift
+				msglen |= int(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			intStringLen := int(stringLen)
-			if intStringLen < 0 {
+			if msglen < 0 {
 				return ErrInvalidLengthVirtualService
 			}
-			postIndex := iNdEx + intStringLen
+			postIndex := iNdEx + msglen
 			if postIndex < 0 {
 				return ErrInvalidLengthVirtualService
 			}
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.Remove = append(m.Remove, string(dAtA[iNdEx:postIndex]))
+			if m.Destination == nil {
+				m.Destination = &Destination{}
+			}
+			if err := m.Destination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
 			iNdEx = postIndex
+		case 2:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
+			}
+			m.Weight = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.Weight |= int32(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
 		default:
 			iNdEx = preIndex
 			skippy, err := skipVirtualService(dAtA[iNdEx:])
@@ -7750,7 +11128,7 @@ func (m *Headers_HeaderOperations) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
-func (m *TLSRoute) Unmarshal(dAtA []byte) error {
+func (m *L4MatchAttributes) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
 	for iNdEx < l {
@@ -7773,17 +11151,68 @@ func (m *TLSRoute) Unmarshal(dAtA []byte) error {
 		fieldNum := int32(wire >> 3)
 		wireType := int(wire & 0x7)
 		if wireType == 4 {
-			return fmt.Errorf("proto: TLSRoute: wiretype end group for non-group")
+			return fmt.Errorf("proto: L4MatchAttributes: wiretype end group for non-group")
 		}
 		if fieldNum <= 0 {
-			return fmt.Errorf("proto: TLSRoute: illegal tag %d (wire type %d)", fieldNum, wire)
+			return fmt.Errorf("proto: L4MatchAttributes: illegal tag %d (wire type %d)", fieldNum, wire)
 		}
 		switch fieldNum {
 		case 1:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Match", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field DestinationSubnets", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.DestinationSubnets = append(m.DestinationSubnets, string(dAtA[iNdEx:postIndex]))
+			iNdEx = postIndex
+		case 2:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
+			}
+			m.Port = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.Port |= uint32(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		case 3:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field SourceSubnet", wireType)
 			}
-			var msglen int
+			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowVirtualService
@@ -7793,29 +11222,27 @@ func (m *TLSRoute) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				msglen |= int(b&0x7F) << shift
+				stringLen |= uint64(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			if msglen < 0 {
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
 				return ErrInvalidLengthVirtualService
 			}
-			postIndex := iNdEx + msglen
+			postIndex := iNdEx + intStringLen
 			if postIndex < 0 {
 				return ErrInvalidLengthVirtualService
 			}
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.Match = append(m.Match, &TLSMatchAttributes{})
-			if err := m.Match[len(m.Match)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
+			m.SourceSubnet = string(dAtA[iNdEx:postIndex])
 			iNdEx = postIndex
-		case 2:
+		case 4:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Route", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field SourceLabels", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -7842,67 +11269,109 @@ func (m *TLSRoute) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.Route = append(m.Route, &RouteDestination{})
-			if err := m.Route[len(m.Route)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
-			iNdEx = postIndex
-		default:
-			iNdEx = preIndex
-			skippy, err := skipVirtualService(dAtA[iNdEx:])
-			if err != nil {
-				return err
-			}
-			if (skippy < 0) || (iNdEx+skippy) < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			if (iNdEx + skippy) > l {
-				return io.ErrUnexpectedEOF
-			}
-			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
-			iNdEx += skippy
-		}
-	}
-
-	if iNdEx > l {
-		return io.ErrUnexpectedEOF
-	}
-	return nil
-}
-func (m *TCPRoute) Unmarshal(dAtA []byte) error {
-	l := len(dAtA)
-	iNdEx := 0
-	for iNdEx < l {
-		preIndex := iNdEx
-		var wire uint64
-		for shift := uint(0); ; shift += 7 {
-			if shift >= 64 {
-				return ErrIntOverflowVirtualService
-			}
-			if iNdEx >= l {
-				return io.ErrUnexpectedEOF
+			if m.SourceLabels == nil {
+				m.SourceLabels = make(map[string]string)
 			}
-			b := dAtA[iNdEx]
-			iNdEx++
-			wire |= uint64(b&0x7F) << shift
-			if b < 0x80 {
-				break
+			var mapkey string
+			var mapvalue string
+			for iNdEx < postIndex {
+				entryPreIndex := iNdEx
+				var wire uint64
+				for shift := uint(0); ; shift += 7 {
+					if shift >= 64 {
+						return ErrIntOverflowVirtualService
+					}
+					if iNdEx >= l {
+						return io.ErrUnexpectedEOF
+					}
+					b := dAtA[iNdEx]
+					iNdEx++
+					wire |= uint64(b&0x7F) << shift
+					if b < 0x80 {
+						break
+					}
+				}
+				fieldNum := int32(wire >> 3)
+				if fieldNum == 1 {
+					var stringLenmapkey uint64
+					for shift := uint(0); ; shift += 7 {
+						if shift >= 64 {
+							return ErrIntOverflowVirtualService
+						}
+						if iNdEx >= l {
+							return io.ErrUnexpectedEOF
+						}
+						b := dAtA[iNdEx]
+						iNdEx++
+						stringLenmapkey |= uint64(b&0x7F) << shift
+						if b < 0x80 {
+							break
+						}
+					}
+					intStringLenmapkey := int(stringLenmapkey)
+					if intStringLenmapkey < 0 {
+						return ErrInvalidLengthVirtualService
+					}
+					postStringIndexmapkey := iNdEx + intStringLenmapkey
+					if postStringIndexmapkey < 0 {
+						return ErrInvalidLengthVirtualService
+					}
+					if postStringIndexmapkey > l {
+						return io.ErrUnexpectedEOF
+					}
+					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
+					iNdEx = postStringIndexmapkey
+				} else if fieldNum == 2 {
+					var stringLenmapvalue uint64
+					for shift := uint(0); ; shift += 7 {
+						if shift >= 64 {
+							return ErrIntOverflowVirtualService
+						}
+						if iNdEx >= l {
+							return io.ErrUnexpectedEOF
+						}
+						b := dAtA[iNdEx]
+						iNdEx++
+						stringLenmapvalue |= uint64(b&0x7F) << shift
+						if b < 0x80 {
+							break
+						}
+					}
+					intStringLenmapvalue := int(stringLenmapvalue)
+					if intStringLenmapvalue < 0 {
+						return ErrInvalidLengthVirtualService
+					}
+					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
+					if postStringIndexmapvalue < 0 {
+						return ErrInvalidLengthVirtualService
+					}
+					if postStringIndexmapvalue > l {
+						return io.ErrUnexpectedEOF
+					}
+					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
+					iNdEx = postStringIndexmapvalue
+				} else {
+					iNdEx = entryPreIndex
+					skippy, err := skipVirtualService(dAtA[iNdEx:])
+					if err != nil {
+						return err
+					}
+					if (skippy < 0) || (iNdEx+skippy) < 0 {
+						return ErrInvalidLengthVirtualService
+					}
+					if (iNdEx + skippy) > postIndex {
+						return io.ErrUnexpectedEOF
+					}
+					iNdEx += skippy
+				}
 			}
-		}
-		fieldNum := int32(wire >> 3)
-		wireType := int(wire & 0x7)
-		if wireType == 4 {
-			return fmt.Errorf("proto: TCPRoute: wiretype end group for non-group")
-		}
-		if fieldNum <= 0 {
-			return fmt.Errorf("proto: TCPRoute: illegal tag %d (wire type %d)", fieldNum, wire)
-		}
-		switch fieldNum {
-		case 1:
+			m.SourceLabels[mapkey] = mapvalue
+			iNdEx = postIndex
+		case 5:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Match", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Gateways", wireType)
 			}
-			var msglen int
+			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowVirtualService
@@ -7912,31 +11381,29 @@ func (m *TCPRoute) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				msglen |= int(b&0x7F) << shift
+				stringLen |= uint64(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			if msglen < 0 {
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
 				return ErrInvalidLengthVirtualService
 			}
-			postIndex := iNdEx + msglen
+			postIndex := iNdEx + intStringLen
 			if postIndex < 0 {
 				return ErrInvalidLengthVirtualService
 			}
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.Match = append(m.Match, &L4MatchAttributes{})
-			if err := m.Match[len(m.Match)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
+			m.Gateways = append(m.Gateways, string(dAtA[iNdEx:postIndex]))
 			iNdEx = postIndex
-		case 2:
+		case 6:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Route", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field SourceNamespace", wireType)
 			}
-			var msglen int
+			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowVirtualService
@@ -7946,25 +11413,23 @@ func (m *TCPRoute) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				msglen |= int(b&0x7F) << shift
+				stringLen |= uint64(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			if msglen < 0 {
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
 				return ErrInvalidLengthVirtualService
 			}
-			postIndex := iNdEx + msglen
+			postIndex := iNdEx + intStringLen
 			if postIndex < 0 {
 				return ErrInvalidLengthVirtualService
 			}
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.Route = append(m.Route, &RouteDestination{})
-			if err := m.Route[len(m.Route)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
+			m.SourceNamespace = string(dAtA[iNdEx:postIndex])
 			iNdEx = postIndex
 		default:
 			iNdEx = preIndex
@@ -7988,7 +11453,7 @@ func (m *TCPRoute) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
-func (m *HTTPMatchRequest) Unmarshal(dAtA []byte) error {
+func (m *TLSMatchAttributes) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
 	for iNdEx < l {
@@ -8011,53 +11476,17 @@ func (m *HTTPMatchRequest) Unmarshal(dAtA []byte) error {
 		fieldNum := int32(wire >> 3)
 		wireType := int(wire & 0x7)
 		if wireType == 4 {
-			return fmt.Errorf("proto: HTTPMatchRequest: wiretype end group for non-group")
+			return fmt.Errorf("proto: TLSMatchAttributes: wiretype end group for non-group")
 		}
 		if fieldNum <= 0 {
-			return fmt.Errorf("proto: HTTPMatchRequest: illegal tag %d (wire type %d)", fieldNum, wire)
+			return fmt.Errorf("proto: TLSMatchAttributes: illegal tag %d (wire type %d)", fieldNum, wire)
 		}
 		switch fieldNum {
 		case 1:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
-			}
-			var msglen int
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowVirtualService
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				msglen |= int(b&0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-			if msglen < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			postIndex := iNdEx + msglen
-			if postIndex < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			if m.Uri == nil {
-				m.Uri = &StringMatch{}
-			}
-			if err := m.Uri.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
-			iNdEx = postIndex
-		case 2:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Scheme", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field SniHosts", wireType)
 			}
-			var msglen int
+			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowVirtualService
@@ -8067,33 +11496,29 @@ func (m *HTTPMatchRequest) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				msglen |= int(b&0x7F) << shift
+				stringLen |= uint64(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			if msglen < 0 {
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
 				return ErrInvalidLengthVirtualService
 			}
-			postIndex := iNdEx + msglen
+			postIndex := iNdEx + intStringLen
 			if postIndex < 0 {
 				return ErrInvalidLengthVirtualService
 			}
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.Scheme == nil {
-				m.Scheme = &StringMatch{}
-			}
-			if err := m.Scheme.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
+			m.SniHosts = append(m.SniHosts, string(dAtA[iNdEx:postIndex]))
 			iNdEx = postIndex
-		case 3:
+		case 2:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field DestinationSubnets", wireType)
 			}
-			var msglen int
+			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowVirtualService
@@ -8103,33 +11528,29 @@ func (m *HTTPMatchRequest) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				msglen |= int(b&0x7F) << shift
+				stringLen |= uint64(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			if msglen < 0 {
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
 				return ErrInvalidLengthVirtualService
 			}
-			postIndex := iNdEx + msglen
+			postIndex := iNdEx + intStringLen
 			if postIndex < 0 {
 				return ErrInvalidLengthVirtualService
 			}
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.Method == nil {
-				m.Method = &StringMatch{}
-			}
-			if err := m.Method.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
+			m.DestinationSubnets = append(m.DestinationSubnets, string(dAtA[iNdEx:postIndex]))
 			iNdEx = postIndex
-		case 4:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
+		case 3:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
 			}
-			var msglen int
+			m.Port = 0
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowVirtualService
@@ -8139,31 +11560,14 @@ func (m *HTTPMatchRequest) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				msglen |= int(b&0x7F) << shift
+				m.Port |= uint32(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			if msglen < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			postIndex := iNdEx + msglen
-			if postIndex < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			if m.Authority == nil {
-				m.Authority = &StringMatch{}
-			}
-			if err := m.Authority.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
-			iNdEx = postIndex
 		case 5:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field SourceLabels", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -8190,11 +11594,11 @@ func (m *HTTPMatchRequest) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.Headers == nil {
-				m.Headers = make(map[string]*StringMatch)
+			if m.SourceLabels == nil {
+				m.SourceLabels = make(map[string]string)
 			}
 			var mapkey string
-			var mapvalue *StringMatch
+			var mapvalue string
 			for iNdEx < postIndex {
 				entryPreIndex := iNdEx
 				var wire uint64
@@ -8243,7 +11647,7 @@ func (m *HTTPMatchRequest) Unmarshal(dAtA []byte) error {
 					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
 					iNdEx = postStringIndexmapkey
 				} else if fieldNum == 2 {
-					var mapmsglen int
+					var stringLenmapvalue uint64
 					for shift := uint(0); ; shift += 7 {
 						if shift >= 64 {
 							return ErrIntOverflowVirtualService
@@ -8253,26 +11657,24 @@ func (m *HTTPMatchRequest) Unmarshal(dAtA []byte) error {
 						}
 						b := dAtA[iNdEx]
 						iNdEx++
-						mapmsglen |= int(b&0x7F) << shift
+						stringLenmapvalue |= uint64(b&0x7F) << shift
 						if b < 0x80 {
 							break
 						}
 					}
-					if mapmsglen < 0 {
+					intStringLenmapvalue := int(stringLenmapvalue)
+					if intStringLenmapvalue < 0 {
 						return ErrInvalidLengthVirtualService
 					}
-					postmsgIndex := iNdEx + mapmsglen
-					if postmsgIndex < 0 {
+					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
+					if postStringIndexmapvalue < 0 {
 						return ErrInvalidLengthVirtualService
 					}
-					if postmsgIndex > l {
+					if postStringIndexmapvalue > l {
 						return io.ErrUnexpectedEOF
 					}
-					mapvalue = &StringMatch{}
-					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
-						return err
-					}
-					iNdEx = postmsgIndex
+					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
+					iNdEx = postStringIndexmapvalue
 				} else {
 					iNdEx = entryPreIndex
 					skippy, err := skipVirtualService(dAtA[iNdEx:])
@@ -8288,13 +11690,211 @@ func (m *HTTPMatchRequest) Unmarshal(dAtA []byte) error {
 					iNdEx += skippy
 				}
 			}
-			m.Headers[mapkey] = mapvalue
+			m.SourceLabels[mapkey] = mapvalue
+			iNdEx = postIndex
+		case 6:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Gateways", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Gateways = append(m.Gateways, string(dAtA[iNdEx:postIndex]))
+			iNdEx = postIndex
+		case 7:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field SourceNamespace", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.SourceNamespace = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipVirtualService(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *HTTPRedirect) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowVirtualService
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: HTTPRedirect: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: HTTPRedirect: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Uri = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Authority = string(dAtA[iNdEx:postIndex])
 			iNdEx = postIndex
-		case 6:
+		case 3:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field RedirectCode", wireType)
+			}
+			m.RedirectCode = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.RedirectCode |= uint32(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		case 4:
 			if wireType != 0 {
 				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
 			}
-			m.Port = 0
+			var v uint32
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowVirtualService
@@ -8304,16 +11904,37 @@ func (m *HTTPMatchRequest) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				m.Port |= uint32(b&0x7F) << shift
+				v |= uint32(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-		case 7:
+			m.RedirectPort = &HTTPRedirect_Port{v}
+		case 5:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field DerivePort", wireType)
+			}
+			var v HTTPRedirect_RedirectPortSelection
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				v |= HTTPRedirect_RedirectPortSelection(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			m.RedirectPort = &HTTPRedirect_DerivePort{v}
+		case 6:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field SourceLabels", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Scheme", wireType)
 			}
-			var msglen int
+			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowVirtualService
@@ -8323,29 +11944,97 @@ func (m *HTTPMatchRequest) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				msglen |= int(b&0x7F) << shift
+				stringLen |= uint64(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			if msglen < 0 {
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
 				return ErrInvalidLengthVirtualService
 			}
-			postIndex := iNdEx + msglen
+			postIndex := iNdEx + intStringLen
 			if postIndex < 0 {
 				return ErrInvalidLengthVirtualService
 			}
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.SourceLabels == nil {
-				m.SourceLabels = make(map[string]string)
+			m.Scheme = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipVirtualService(dAtA[iNdEx:])
+			if err != nil {
+				return err
 			}
-			var mapkey string
-			var mapvalue string
-			for iNdEx < postIndex {
-				entryPreIndex := iNdEx
-				var wire uint64
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *HTTPInternalActiveRedirect) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowVirtualService
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: HTTPInternalActiveRedirect: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: HTTPInternalActiveRedirect: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field MaxInternalRedirects", wireType)
+			}
+			m.MaxInternalRedirects = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.MaxInternalRedirects |= uint32(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		case 2:
+			if wireType == 0 {
+				var v uint32
 				for shift := uint(0); ; shift += 7 {
 					if shift >= 64 {
 						return ErrIntOverflowVirtualService
@@ -8355,43 +12044,51 @@ func (m *HTTPMatchRequest) Unmarshal(dAtA []byte) error {
 					}
 					b := dAtA[iNdEx]
 					iNdEx++
-					wire |= uint64(b&0x7F) << shift
+					v |= uint32(b&0x7F) << shift
 					if b < 0x80 {
 						break
 					}
 				}
-				fieldNum := int32(wire >> 3)
-				if fieldNum == 1 {
-					var stringLenmapkey uint64
-					for shift := uint(0); ; shift += 7 {
-						if shift >= 64 {
-							return ErrIntOverflowVirtualService
-						}
-						if iNdEx >= l {
-							return io.ErrUnexpectedEOF
-						}
-						b := dAtA[iNdEx]
-						iNdEx++
-						stringLenmapkey |= uint64(b&0x7F) << shift
-						if b < 0x80 {
-							break
-						}
+				m.RedirectResponseCodes = append(m.RedirectResponseCodes, v)
+			} else if wireType == 2 {
+				var packedLen int
+				for shift := uint(0); ; shift += 7 {
+					if shift >= 64 {
+						return ErrIntOverflowVirtualService
 					}
-					intStringLenmapkey := int(stringLenmapkey)
-					if intStringLenmapkey < 0 {
-						return ErrInvalidLengthVirtualService
+					if iNdEx >= l {
+						return io.ErrUnexpectedEOF
 					}
-					postStringIndexmapkey := iNdEx + intStringLenmapkey
-					if postStringIndexmapkey < 0 {
-						return ErrInvalidLengthVirtualService
+					b := dAtA[iNdEx]
+					iNdEx++
+					packedLen |= int(b&0x7F) << shift
+					if b < 0x80 {
+						break
 					}
-					if postStringIndexmapkey > l {
-						return io.ErrUnexpectedEOF
+				}
+				if packedLen < 0 {
+					return ErrInvalidLengthVirtualService
+				}
+				postIndex := iNdEx + packedLen
+				if postIndex < 0 {
+					return ErrInvalidLengthVirtualService
+				}
+				if postIndex > l {
+					return io.ErrUnexpectedEOF
+				}
+				var elementCount int
+				var count int
+				for _, integer := range dAtA[iNdEx:postIndex] {
+					if integer < 128 {
+						count++
 					}
-					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
-					iNdEx = postStringIndexmapkey
-				} else if fieldNum == 2 {
-					var stringLenmapvalue uint64
+				}
+				elementCount = count
+				if elementCount != 0 && len(m.RedirectResponseCodes) == 0 {
+					m.RedirectResponseCodes = make([]uint32, 0, elementCount)
+				}
+				for iNdEx < postIndex {
+					var v uint32
 					for shift := uint(0); ; shift += 7 {
 						if shift >= 64 {
 							return ErrIntOverflowVirtualService
@@ -8401,44 +12098,142 @@ func (m *HTTPMatchRequest) Unmarshal(dAtA []byte) error {
 						}
 						b := dAtA[iNdEx]
 						iNdEx++
-						stringLenmapvalue |= uint64(b&0x7F) << shift
+						v |= uint32(b&0x7F) << shift
 						if b < 0x80 {
 							break
 						}
 					}
-					intStringLenmapvalue := int(stringLenmapvalue)
-					if intStringLenmapvalue < 0 {
-						return ErrInvalidLengthVirtualService
-					}
-					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
-					if postStringIndexmapvalue < 0 {
-						return ErrInvalidLengthVirtualService
-					}
-					if postStringIndexmapvalue > l {
-						return io.ErrUnexpectedEOF
-					}
-					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
-					iNdEx = postStringIndexmapvalue
-				} else {
-					iNdEx = entryPreIndex
-					skippy, err := skipVirtualService(dAtA[iNdEx:])
-					if err != nil {
-						return err
-					}
-					if (skippy < 0) || (iNdEx+skippy) < 0 {
-						return ErrInvalidLengthVirtualService
-					}
-					if (iNdEx + skippy) > postIndex {
-						return io.ErrUnexpectedEOF
-					}
-					iNdEx += skippy
+					m.RedirectResponseCodes = append(m.RedirectResponseCodes, v)
+				}
+			} else {
+				return fmt.Errorf("proto: wrong wireType = %d for field RedirectResponseCodes", wireType)
+			}
+		case 3:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field RedirectUrl", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.RedirectUrlRewriteSpecifier = &HTTPInternalActiveRedirect_RedirectUrl{string(dAtA[iNdEx:postIndex])}
+			iNdEx = postIndex
+		case 4:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field RedirectUrlRewriteRegex", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
 				}
 			}
-			m.SourceLabels[mapkey] = mapvalue
+			if msglen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			v := &RegexMatchAndSubstitute{}
+			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			m.RedirectUrlRewriteSpecifier = &HTTPInternalActiveRedirect_RedirectUrlRewriteRegex{v}
 			iNdEx = postIndex
-		case 8:
+		case 5:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field AllowCrossScheme", wireType)
+			}
+			var v int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				v |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			m.AllowCrossScheme = bool(v != 0)
+		case 6:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Gateways", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.Headers == nil {
+				m.Headers = &Headers{}
+			}
+			if err := m.Headers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 7:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
 			}
 			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
@@ -8466,11 +12261,11 @@ func (m *HTTPMatchRequest) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.Gateways = append(m.Gateways, string(dAtA[iNdEx:postIndex]))
+			m.Authority = string(dAtA[iNdEx:postIndex])
 			iNdEx = postIndex
-		case 9:
+		case 15:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field QueryParams", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Policies", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -8497,109 +12292,14 @@ func (m *HTTPMatchRequest) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.QueryParams == nil {
-				m.QueryParams = make(map[string]*StringMatch)
-			}
-			var mapkey string
-			var mapvalue *StringMatch
-			for iNdEx < postIndex {
-				entryPreIndex := iNdEx
-				var wire uint64
-				for shift := uint(0); ; shift += 7 {
-					if shift >= 64 {
-						return ErrIntOverflowVirtualService
-					}
-					if iNdEx >= l {
-						return io.ErrUnexpectedEOF
-					}
-					b := dAtA[iNdEx]
-					iNdEx++
-					wire |= uint64(b&0x7F) << shift
-					if b < 0x80 {
-						break
-					}
-				}
-				fieldNum := int32(wire >> 3)
-				if fieldNum == 1 {
-					var stringLenmapkey uint64
-					for shift := uint(0); ; shift += 7 {
-						if shift >= 64 {
-							return ErrIntOverflowVirtualService
-						}
-						if iNdEx >= l {
-							return io.ErrUnexpectedEOF
-						}
-						b := dAtA[iNdEx]
-						iNdEx++
-						stringLenmapkey |= uint64(b&0x7F) << shift
-						if b < 0x80 {
-							break
-						}
-					}
-					intStringLenmapkey := int(stringLenmapkey)
-					if intStringLenmapkey < 0 {
-						return ErrInvalidLengthVirtualService
-					}
-					postStringIndexmapkey := iNdEx + intStringLenmapkey
-					if postStringIndexmapkey < 0 {
-						return ErrInvalidLengthVirtualService
-					}
-					if postStringIndexmapkey > l {
-						return io.ErrUnexpectedEOF
-					}
-					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
-					iNdEx = postStringIndexmapkey
-				} else if fieldNum == 2 {
-					var mapmsglen int
-					for shift := uint(0); ; shift += 7 {
-						if shift >= 64 {
-							return ErrIntOverflowVirtualService
-						}
-						if iNdEx >= l {
-							return io.ErrUnexpectedEOF
-						}
-						b := dAtA[iNdEx]
-						iNdEx++
-						mapmsglen |= int(b&0x7F) << shift
-						if b < 0x80 {
-							break
-						}
-					}
-					if mapmsglen < 0 {
-						return ErrInvalidLengthVirtualService
-					}
-					postmsgIndex := iNdEx + mapmsglen
-					if postmsgIndex < 0 {
-						return ErrInvalidLengthVirtualService
-					}
-					if postmsgIndex > l {
-						return io.ErrUnexpectedEOF
-					}
-					mapvalue = &StringMatch{}
-					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
-						return err
-					}
-					iNdEx = postmsgIndex
-				} else {
-					iNdEx = entryPreIndex
-					skippy, err := skipVirtualService(dAtA[iNdEx:])
-					if err != nil {
-						return err
-					}
-					if (skippy < 0) || (iNdEx+skippy) < 0 {
-						return ErrInvalidLengthVirtualService
-					}
-					if (iNdEx + skippy) > postIndex {
-						return io.ErrUnexpectedEOF
-					}
-					iNdEx += skippy
-				}
+			m.Policies = append(m.Policies, &HTTPInternalActiveRedirect_RedirectPolicy{})
+			if err := m.Policies[len(m.Policies)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
 			}
-			m.QueryParams[mapkey] = mapvalue
 			iNdEx = postIndex
-		case 10:
+		case 16:
 			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field IgnoreUriCase", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field ForcedUseOriginalHost", wireType)
 			}
 			var v int
 			for shift := uint(0); ; shift += 7 {
@@ -8616,12 +12316,12 @@ func (m *HTTPMatchRequest) Unmarshal(dAtA []byte) error {
 					break
 				}
 			}
-			m.IgnoreUriCase = bool(v != 0)
-		case 11:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
+			m.ForcedUseOriginalHost = bool(v != 0)
+		case 17:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field ForcedAddHeaderBeforeRouteMatcher", wireType)
 			}
-			var stringLen uint64
+			var v int
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowVirtualService
@@ -8631,29 +12331,68 @@ func (m *HTTPMatchRequest) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				stringLen |= uint64(b&0x7F) << shift
+				v |= int(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			intStringLen := int(stringLen)
-			if intStringLen < 0 {
-				return ErrInvalidLengthVirtualService
+			m.ForcedAddHeaderBeforeRouteMatcher = bool(v != 0)
+		default:
+			iNdEx = preIndex
+			skippy, err := skipVirtualService(dAtA[iNdEx:])
+			if err != nil {
+				return err
 			}
-			postIndex := iNdEx + intStringLen
-			if postIndex < 0 {
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
 				return ErrInvalidLengthVirtualService
 			}
-			if postIndex > l {
+			if (iNdEx + skippy) > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.Name = string(dAtA[iNdEx:postIndex])
-			iNdEx = postIndex
-		case 12:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field WithoutHeaders", wireType)
+			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *HTTPInternalActiveRedirect_RedirectPolicy) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowVirtualService
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: RedirectPolicy: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: RedirectPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 8:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field MaxInternalRedirects", wireType)
 			}
-			var msglen int
+			m.MaxInternalRedirects = 0
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowVirtualService
@@ -8663,29 +12402,14 @@ func (m *HTTPMatchRequest) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				msglen |= int(b&0x7F) << shift
+				m.MaxInternalRedirects |= uint32(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			if msglen < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			postIndex := iNdEx + msglen
-			if postIndex < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			if m.WithoutHeaders == nil {
-				m.WithoutHeaders = make(map[string]*StringMatch)
-			}
-			var mapkey string
-			var mapvalue *StringMatch
-			for iNdEx < postIndex {
-				entryPreIndex := iNdEx
-				var wire uint64
+		case 9:
+			if wireType == 0 {
+				var v uint32
 				for shift := uint(0); ; shift += 7 {
 					if shift >= 64 {
 						return ErrIntOverflowVirtualService
@@ -8695,43 +12419,51 @@ func (m *HTTPMatchRequest) Unmarshal(dAtA []byte) error {
 					}
 					b := dAtA[iNdEx]
 					iNdEx++
-					wire |= uint64(b&0x7F) << shift
+					v |= uint32(b&0x7F) << shift
 					if b < 0x80 {
 						break
 					}
 				}
-				fieldNum := int32(wire >> 3)
-				if fieldNum == 1 {
-					var stringLenmapkey uint64
-					for shift := uint(0); ; shift += 7 {
-						if shift >= 64 {
-							return ErrIntOverflowVirtualService
-						}
-						if iNdEx >= l {
-							return io.ErrUnexpectedEOF
-						}
-						b := dAtA[iNdEx]
-						iNdEx++
-						stringLenmapkey |= uint64(b&0x7F) << shift
-						if b < 0x80 {
-							break
-						}
+				m.RedirectResponseCodes = append(m.RedirectResponseCodes, v)
+			} else if wireType == 2 {
+				var packedLen int
+				for shift := uint(0); ; shift += 7 {
+					if shift >= 64 {
+						return ErrIntOverflowVirtualService
 					}
-					intStringLenmapkey := int(stringLenmapkey)
-					if intStringLenmapkey < 0 {
-						return ErrInvalidLengthVirtualService
+					if iNdEx >= l {
+						return io.ErrUnexpectedEOF
 					}
-					postStringIndexmapkey := iNdEx + intStringLenmapkey
-					if postStringIndexmapkey < 0 {
-						return ErrInvalidLengthVirtualService
+					b := dAtA[iNdEx]
+					iNdEx++
+					packedLen |= int(b&0x7F) << shift
+					if b < 0x80 {
+						break
 					}
-					if postStringIndexmapkey > l {
-						return io.ErrUnexpectedEOF
+				}
+				if packedLen < 0 {
+					return ErrInvalidLengthVirtualService
+				}
+				postIndex := iNdEx + packedLen
+				if postIndex < 0 {
+					return ErrInvalidLengthVirtualService
+				}
+				if postIndex > l {
+					return io.ErrUnexpectedEOF
+				}
+				var elementCount int
+				var count int
+				for _, integer := range dAtA[iNdEx:postIndex] {
+					if integer < 128 {
+						count++
 					}
-					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
-					iNdEx = postStringIndexmapkey
-				} else if fieldNum == 2 {
-					var mapmsglen int
+				}
+				elementCount = count
+				if elementCount != 0 && len(m.RedirectResponseCodes) == 0 {
+					m.RedirectResponseCodes = make([]uint32, 0, elementCount)
+				}
+				for iNdEx < postIndex {
+					var v uint32
 					for shift := uint(0); ; shift += 7 {
 						if shift >= 64 {
 							return ErrIntOverflowVirtualService
@@ -8741,46 +12473,19 @@ func (m *HTTPMatchRequest) Unmarshal(dAtA []byte) error {
 						}
 						b := dAtA[iNdEx]
 						iNdEx++
-						mapmsglen |= int(b&0x7F) << shift
+						v |= uint32(b&0x7F) << shift
 						if b < 0x80 {
 							break
 						}
 					}
-					if mapmsglen < 0 {
-						return ErrInvalidLengthVirtualService
-					}
-					postmsgIndex := iNdEx + mapmsglen
-					if postmsgIndex < 0 {
-						return ErrInvalidLengthVirtualService
-					}
-					if postmsgIndex > l {
-						return io.ErrUnexpectedEOF
-					}
-					mapvalue = &StringMatch{}
-					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
-						return err
-					}
-					iNdEx = postmsgIndex
-				} else {
-					iNdEx = entryPreIndex
-					skippy, err := skipVirtualService(dAtA[iNdEx:])
-					if err != nil {
-						return err
-					}
-					if (skippy < 0) || (iNdEx+skippy) < 0 {
-						return ErrInvalidLengthVirtualService
-					}
-					if (iNdEx + skippy) > postIndex {
-						return io.ErrUnexpectedEOF
-					}
-					iNdEx += skippy
+					m.RedirectResponseCodes = append(m.RedirectResponseCodes, v)
 				}
+			} else {
+				return fmt.Errorf("proto: wrong wireType = %d for field RedirectResponseCodes", wireType)
 			}
-			m.WithoutHeaders[mapkey] = mapvalue
-			iNdEx = postIndex
-		case 13:
+		case 10:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field SourceNamespace", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field RedirectUrl", wireType)
 			}
 			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
@@ -8808,62 +12513,11 @@ func (m *HTTPMatchRequest) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.SourceNamespace = string(dAtA[iNdEx:postIndex])
+			m.RedirectUrlRewriteSpecifier = &HTTPInternalActiveRedirect_RedirectPolicy_RedirectUrl{string(dAtA[iNdEx:postIndex])}
 			iNdEx = postIndex
-		default:
-			iNdEx = preIndex
-			skippy, err := skipVirtualService(dAtA[iNdEx:])
-			if err != nil {
-				return err
-			}
-			if (skippy < 0) || (iNdEx+skippy) < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			if (iNdEx + skippy) > l {
-				return io.ErrUnexpectedEOF
-			}
-			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
-			iNdEx += skippy
-		}
-	}
-
-	if iNdEx > l {
-		return io.ErrUnexpectedEOF
-	}
-	return nil
-}
-func (m *HTTPRouteDestination) Unmarshal(dAtA []byte) error {
-	l := len(dAtA)
-	iNdEx := 0
-	for iNdEx < l {
-		preIndex := iNdEx
-		var wire uint64
-		for shift := uint(0); ; shift += 7 {
-			if shift >= 64 {
-				return ErrIntOverflowVirtualService
-			}
-			if iNdEx >= l {
-				return io.ErrUnexpectedEOF
-			}
-			b := dAtA[iNdEx]
-			iNdEx++
-			wire |= uint64(b&0x7F) << shift
-			if b < 0x80 {
-				break
-			}
-		}
-		fieldNum := int32(wire >> 3)
-		wireType := int(wire & 0x7)
-		if wireType == 4 {
-			return fmt.Errorf("proto: HTTPRouteDestination: wiretype end group for non-group")
-		}
-		if fieldNum <= 0 {
-			return fmt.Errorf("proto: HTTPRouteDestination: illegal tag %d (wire type %d)", fieldNum, wire)
-		}
-		switch fieldNum {
-		case 1:
+		case 11:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Destination", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field RedirectUrlRewriteRegex", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -8890,18 +12544,17 @@ func (m *HTTPRouteDestination) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.Destination == nil {
-				m.Destination = &Destination{}
-			}
-			if err := m.Destination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+			v := &RegexMatchAndSubstitute{}
+			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
+			m.RedirectUrlRewriteSpecifier = &HTTPInternalActiveRedirect_RedirectPolicy_RedirectUrlRewriteRegex{v}
 			iNdEx = postIndex
-		case 2:
+		case 12:
 			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field AllowCrossScheme", wireType)
 			}
-			m.Weight = 0
+			var v int
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowVirtualService
@@ -8911,12 +12564,13 @@ func (m *HTTPRouteDestination) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				m.Weight |= int32(b&0x7F) << shift
+				v |= int(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-		case 7:
+			m.AllowCrossScheme = bool(v != 0)
+		case 13:
 			if wireType != 2 {
 				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
 			}
@@ -8952,6 +12606,78 @@ func (m *HTTPRouteDestination) Unmarshal(dAtA []byte) error {
 				return err
 			}
 			iNdEx = postIndex
+		case 14:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Authority = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 17:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field ForcedUseOriginalHost", wireType)
+			}
+			var v int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				v |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			m.ForcedUseOriginalHost = bool(v != 0)
+		case 18:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field ForcedAddHeaderBeforeRouteMatcher", wireType)
+			}
+			var v int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				v |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			m.ForcedAddHeaderBeforeRouteMatcher = bool(v != 0)
 		default:
 			iNdEx = preIndex
 			skippy, err := skipVirtualService(dAtA[iNdEx:])
@@ -8974,7 +12700,7 @@ func (m *HTTPRouteDestination) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
-func (m *RouteDestination) Unmarshal(dAtA []byte) error {
+func (m *HTTPDirectResponse) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
 	for iNdEx < l {
@@ -8997,17 +12723,36 @@ func (m *RouteDestination) Unmarshal(dAtA []byte) error {
 		fieldNum := int32(wire >> 3)
 		wireType := int(wire & 0x7)
 		if wireType == 4 {
-			return fmt.Errorf("proto: RouteDestination: wiretype end group for non-group")
+			return fmt.Errorf("proto: HTTPDirectResponse: wiretype end group for non-group")
 		}
 		if fieldNum <= 0 {
-			return fmt.Errorf("proto: RouteDestination: illegal tag %d (wire type %d)", fieldNum, wire)
+			return fmt.Errorf("proto: HTTPDirectResponse: illegal tag %d (wire type %d)", fieldNum, wire)
 		}
 		switch fieldNum {
 		case 1:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field ResponseCode", wireType)
+			}
+			m.ResponseCode = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.ResponseCode |= uint32(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		case 2:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Destination", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
 			}
-			var msglen int
+			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowVirtualService
@@ -9017,47 +12762,24 @@ func (m *RouteDestination) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				msglen |= int(b&0x7F) << shift
+				stringLen |= uint64(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			if msglen < 0 {
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
 				return ErrInvalidLengthVirtualService
 			}
-			postIndex := iNdEx + msglen
+			postIndex := iNdEx + intStringLen
 			if postIndex < 0 {
 				return ErrInvalidLengthVirtualService
 			}
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.Destination == nil {
-				m.Destination = &Destination{}
-			}
-			if err := m.Destination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
+			m.Body = string(dAtA[iNdEx:postIndex])
 			iNdEx = postIndex
-		case 2:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
-			}
-			m.Weight = 0
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowVirtualService
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				m.Weight |= int32(b&0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
 		default:
 			iNdEx = preIndex
 			skippy, err := skipVirtualService(dAtA[iNdEx:])
@@ -9080,7 +12802,7 @@ func (m *RouteDestination) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
-func (m *L4MatchAttributes) Unmarshal(dAtA []byte) error {
+func (m *HTTPRewrite) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
 	for iNdEx < l {
@@ -9103,15 +12825,15 @@ func (m *L4MatchAttributes) Unmarshal(dAtA []byte) error {
 		fieldNum := int32(wire >> 3)
 		wireType := int(wire & 0x7)
 		if wireType == 4 {
-			return fmt.Errorf("proto: L4MatchAttributes: wiretype end group for non-group")
+			return fmt.Errorf("proto: HTTPRewrite: wiretype end group for non-group")
 		}
 		if fieldNum <= 0 {
-			return fmt.Errorf("proto: L4MatchAttributes: illegal tag %d (wire type %d)", fieldNum, wire)
+			return fmt.Errorf("proto: HTTPRewrite: illegal tag %d (wire type %d)", fieldNum, wire)
 		}
 		switch fieldNum {
 		case 1:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field DestinationSubnets", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
 			}
 			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
@@ -9139,30 +12861,11 @@ func (m *L4MatchAttributes) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.DestinationSubnets = append(m.DestinationSubnets, string(dAtA[iNdEx:postIndex]))
+			m.Uri = string(dAtA[iNdEx:postIndex])
 			iNdEx = postIndex
 		case 2:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
-			}
-			m.Port = 0
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowVirtualService
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				m.Port |= uint32(b&0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		case 3:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field SourceSubnet", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
 			}
 			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
@@ -9190,11 +12893,11 @@ func (m *L4MatchAttributes) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.SourceSubnet = string(dAtA[iNdEx:postIndex])
+			m.Authority = string(dAtA[iNdEx:postIndex])
 			iNdEx = postIndex
-		case 4:
+		case 3:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field SourceLabels", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field UriRegex", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -9221,107 +12924,67 @@ func (m *L4MatchAttributes) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.SourceLabels == nil {
-				m.SourceLabels = make(map[string]string)
+			if m.UriRegex == nil {
+				m.UriRegex = &RegexMatchAndSubstitute{}
 			}
-			var mapkey string
-			var mapvalue string
-			for iNdEx < postIndex {
-				entryPreIndex := iNdEx
-				var wire uint64
-				for shift := uint(0); ; shift += 7 {
-					if shift >= 64 {
-						return ErrIntOverflowVirtualService
-					}
-					if iNdEx >= l {
-						return io.ErrUnexpectedEOF
-					}
-					b := dAtA[iNdEx]
-					iNdEx++
-					wire |= uint64(b&0x7F) << shift
-					if b < 0x80 {
-						break
-					}
-				}
-				fieldNum := int32(wire >> 3)
-				if fieldNum == 1 {
-					var stringLenmapkey uint64
-					for shift := uint(0); ; shift += 7 {
-						if shift >= 64 {
-							return ErrIntOverflowVirtualService
-						}
-						if iNdEx >= l {
-							return io.ErrUnexpectedEOF
-						}
-						b := dAtA[iNdEx]
-						iNdEx++
-						stringLenmapkey |= uint64(b&0x7F) << shift
-						if b < 0x80 {
-							break
-						}
-					}
-					intStringLenmapkey := int(stringLenmapkey)
-					if intStringLenmapkey < 0 {
-						return ErrInvalidLengthVirtualService
-					}
-					postStringIndexmapkey := iNdEx + intStringLenmapkey
-					if postStringIndexmapkey < 0 {
-						return ErrInvalidLengthVirtualService
-					}
-					if postStringIndexmapkey > l {
-						return io.ErrUnexpectedEOF
-					}
-					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
-					iNdEx = postStringIndexmapkey
-				} else if fieldNum == 2 {
-					var stringLenmapvalue uint64
-					for shift := uint(0); ; shift += 7 {
-						if shift >= 64 {
-							return ErrIntOverflowVirtualService
-						}
-						if iNdEx >= l {
-							return io.ErrUnexpectedEOF
-						}
-						b := dAtA[iNdEx]
-						iNdEx++
-						stringLenmapvalue |= uint64(b&0x7F) << shift
-						if b < 0x80 {
-							break
-						}
-					}
-					intStringLenmapvalue := int(stringLenmapvalue)
-					if intStringLenmapvalue < 0 {
-						return ErrInvalidLengthVirtualService
-					}
-					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
-					if postStringIndexmapvalue < 0 {
-						return ErrInvalidLengthVirtualService
-					}
-					if postStringIndexmapvalue > l {
-						return io.ErrUnexpectedEOF
-					}
-					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
-					iNdEx = postStringIndexmapvalue
-				} else {
-					iNdEx = entryPreIndex
-					skippy, err := skipVirtualService(dAtA[iNdEx:])
-					if err != nil {
-						return err
-					}
-					if (skippy < 0) || (iNdEx+skippy) < 0 {
-						return ErrInvalidLengthVirtualService
-					}
-					if (iNdEx + skippy) > postIndex {
-						return io.ErrUnexpectedEOF
-					}
-					iNdEx += skippy
-				}
+			if err := m.UriRegex.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
 			}
-			m.SourceLabels[mapkey] = mapvalue
 			iNdEx = postIndex
-		case 5:
+		default:
+			iNdEx = preIndex
+			skippy, err := skipVirtualService(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *RegexMatchAndSubstitute) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowVirtualService
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: RegexMatchAndSubstitute: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: RegexMatchAndSubstitute: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Gateways", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Pattern", wireType)
 			}
 			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
@@ -9349,11 +13012,11 @@ func (m *L4MatchAttributes) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.Gateways = append(m.Gateways, string(dAtA[iNdEx:postIndex]))
+			m.Pattern = string(dAtA[iNdEx:postIndex])
 			iNdEx = postIndex
-		case 6:
+		case 2:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field SourceNamespace", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Substitution", wireType)
 			}
 			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
@@ -9381,7 +13044,7 @@ func (m *L4MatchAttributes) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.SourceNamespace = string(dAtA[iNdEx:postIndex])
+			m.Substitution = string(dAtA[iNdEx:postIndex])
 			iNdEx = postIndex
 		default:
 			iNdEx = preIndex
@@ -9405,7 +13068,7 @@ func (m *L4MatchAttributes) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
-func (m *TLSMatchAttributes) Unmarshal(dAtA []byte) error {
+func (m *StringMatch) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
 	for iNdEx < l {
@@ -9428,15 +13091,47 @@ func (m *TLSMatchAttributes) Unmarshal(dAtA []byte) error {
 		fieldNum := int32(wire >> 3)
 		wireType := int(wire & 0x7)
 		if wireType == 4 {
-			return fmt.Errorf("proto: TLSMatchAttributes: wiretype end group for non-group")
+			return fmt.Errorf("proto: StringMatch: wiretype end group for non-group")
 		}
 		if fieldNum <= 0 {
-			return fmt.Errorf("proto: TLSMatchAttributes: illegal tag %d (wire type %d)", fieldNum, wire)
+			return fmt.Errorf("proto: StringMatch: illegal tag %d (wire type %d)", fieldNum, wire)
 		}
 		switch fieldNum {
 		case 1:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field SniHosts", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Exact", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.MatchType = &StringMatch_Exact{string(dAtA[iNdEx:postIndex])}
+			iNdEx = postIndex
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
 			}
 			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
@@ -9464,11 +13159,11 @@ func (m *TLSMatchAttributes) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.SniHosts = append(m.SniHosts, string(dAtA[iNdEx:postIndex]))
+			m.MatchType = &StringMatch_Prefix{string(dAtA[iNdEx:postIndex])}
 			iNdEx = postIndex
-		case 2:
+		case 3:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field DestinationSubnets", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Regex", wireType)
 			}
 			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
@@ -9496,13 +13191,64 @@ func (m *TLSMatchAttributes) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.DestinationSubnets = append(m.DestinationSubnets, string(dAtA[iNdEx:postIndex]))
+			m.MatchType = &StringMatch_Regex{string(dAtA[iNdEx:postIndex])}
 			iNdEx = postIndex
-		case 3:
+		default:
+			iNdEx = preIndex
+			skippy, err := skipVirtualService(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *HTTPRetry) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowVirtualService
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: HTTPRetry: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: HTTPRetry: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
 			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Attempts", wireType)
 			}
-			m.Port = 0
+			m.Attempts = 0
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowVirtualService
@@ -9512,14 +13258,14 @@ func (m *TLSMatchAttributes) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				m.Port |= uint32(b&0x7F) << shift
+				m.Attempts |= int32(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-		case 5:
+		case 2:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field SourceLabels", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field PerTryTimeout", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -9546,107 +13292,16 @@ func (m *TLSMatchAttributes) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.SourceLabels == nil {
-				m.SourceLabels = make(map[string]string)
+			if m.PerTryTimeout == nil {
+				m.PerTryTimeout = &types.Duration{}
 			}
-			var mapkey string
-			var mapvalue string
-			for iNdEx < postIndex {
-				entryPreIndex := iNdEx
-				var wire uint64
-				for shift := uint(0); ; shift += 7 {
-					if shift >= 64 {
-						return ErrIntOverflowVirtualService
-					}
-					if iNdEx >= l {
-						return io.ErrUnexpectedEOF
-					}
-					b := dAtA[iNdEx]
-					iNdEx++
-					wire |= uint64(b&0x7F) << shift
-					if b < 0x80 {
-						break
-					}
-				}
-				fieldNum := int32(wire >> 3)
-				if fieldNum == 1 {
-					var stringLenmapkey uint64
-					for shift := uint(0); ; shift += 7 {
-						if shift >= 64 {
-							return ErrIntOverflowVirtualService
-						}
-						if iNdEx >= l {
-							return io.ErrUnexpectedEOF
-						}
-						b := dAtA[iNdEx]
-						iNdEx++
-						stringLenmapkey |= uint64(b&0x7F) << shift
-						if b < 0x80 {
-							break
-						}
-					}
-					intStringLenmapkey := int(stringLenmapkey)
-					if intStringLenmapkey < 0 {
-						return ErrInvalidLengthVirtualService
-					}
-					postStringIndexmapkey := iNdEx + intStringLenmapkey
-					if postStringIndexmapkey < 0 {
-						return ErrInvalidLengthVirtualService
-					}
-					if postStringIndexmapkey > l {
-						return io.ErrUnexpectedEOF
-					}
-					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
-					iNdEx = postStringIndexmapkey
-				} else if fieldNum == 2 {
-					var stringLenmapvalue uint64
-					for shift := uint(0); ; shift += 7 {
-						if shift >= 64 {
-							return ErrIntOverflowVirtualService
-						}
-						if iNdEx >= l {
-							return io.ErrUnexpectedEOF
-						}
-						b := dAtA[iNdEx]
-						iNdEx++
-						stringLenmapvalue |= uint64(b&0x7F) << shift
-						if b < 0x80 {
-							break
-						}
-					}
-					intStringLenmapvalue := int(stringLenmapvalue)
-					if intStringLenmapvalue < 0 {
-						return ErrInvalidLengthVirtualService
-					}
-					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
-					if postStringIndexmapvalue < 0 {
-						return ErrInvalidLengthVirtualService
-					}
-					if postStringIndexmapvalue > l {
-						return io.ErrUnexpectedEOF
-					}
-					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
-					iNdEx = postStringIndexmapvalue
-				} else {
-					iNdEx = entryPreIndex
-					skippy, err := skipVirtualService(dAtA[iNdEx:])
-					if err != nil {
-						return err
-					}
-					if (skippy < 0) || (iNdEx+skippy) < 0 {
-						return ErrInvalidLengthVirtualService
-					}
-					if (iNdEx + skippy) > postIndex {
-						return io.ErrUnexpectedEOF
-					}
-					iNdEx += skippy
-				}
+			if err := m.PerTryTimeout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
 			}
-			m.SourceLabels[mapkey] = mapvalue
 			iNdEx = postIndex
-		case 6:
+		case 3:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Gateways", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field RetryOn", wireType)
 			}
 			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
@@ -9674,13 +13329,13 @@ func (m *TLSMatchAttributes) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.Gateways = append(m.Gateways, string(dAtA[iNdEx:postIndex]))
+			m.RetryOn = string(dAtA[iNdEx:postIndex])
 			iNdEx = postIndex
-		case 7:
+		case 4:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field SourceNamespace", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field RetryRemoteLocalities", wireType)
 			}
-			var stringLen uint64
+			var msglen int
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowVirtualService
@@ -9690,23 +13345,27 @@ func (m *TLSMatchAttributes) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				stringLen |= uint64(b&0x7F) << shift
+				msglen |= int(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			intStringLen := int(stringLen)
-			if intStringLen < 0 {
+			if msglen < 0 {
 				return ErrInvalidLengthVirtualService
 			}
-			postIndex := iNdEx + intStringLen
+			postIndex := iNdEx + msglen
 			if postIndex < 0 {
 				return ErrInvalidLengthVirtualService
 			}
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.SourceNamespace = string(dAtA[iNdEx:postIndex])
+			if m.RetryRemoteLocalities == nil {
+				m.RetryRemoteLocalities = &types.BoolValue{}
+			}
+			if err := m.RetryRemoteLocalities.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
 			iNdEx = postIndex
 		default:
 			iNdEx = preIndex
@@ -9730,7 +13389,7 @@ func (m *TLSMatchAttributes) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
-func (m *HTTPRedirect) Unmarshal(dAtA []byte) error {
+func (m *CorsPolicy) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
 	for iNdEx < l {
@@ -9753,15 +13412,15 @@ func (m *HTTPRedirect) Unmarshal(dAtA []byte) error {
 		fieldNum := int32(wire >> 3)
 		wireType := int(wire & 0x7)
 		if wireType == 4 {
-			return fmt.Errorf("proto: HTTPRedirect: wiretype end group for non-group")
+			return fmt.Errorf("proto: CorsPolicy: wiretype end group for non-group")
 		}
 		if fieldNum <= 0 {
-			return fmt.Errorf("proto: HTTPRedirect: illegal tag %d (wire type %d)", fieldNum, wire)
+			return fmt.Errorf("proto: CorsPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
 		}
 		switch fieldNum {
 		case 1:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field AllowOrigin", wireType)
 			}
 			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
@@ -9789,11 +13448,11 @@ func (m *HTTPRedirect) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.Uri = string(dAtA[iNdEx:postIndex])
+			m.AllowOrigin = append(m.AllowOrigin, string(dAtA[iNdEx:postIndex]))
 			iNdEx = postIndex
 		case 2:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field AllowMethods", wireType)
 			}
 			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
@@ -9821,52 +13480,13 @@ func (m *HTTPRedirect) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.Authority = string(dAtA[iNdEx:postIndex])
-			iNdEx = postIndex
-		case 3:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field RedirectCode", wireType)
-			}
-			m.RedirectCode = 0
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowVirtualService
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				m.RedirectCode |= uint32(b&0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-		case 4:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
-			}
-			var v uint32
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowVirtualService
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				v |= uint32(b&0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-			m.RedirectPort = &HTTPRedirect_Port{v}
-		case 5:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field DerivePort", wireType)
+			m.AllowMethods = append(m.AllowMethods, string(dAtA[iNdEx:postIndex]))
+			iNdEx = postIndex
+		case 3:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field AllowHeaders", wireType)
 			}
-			var v HTTPRedirect_RedirectPortSelection
+			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowVirtualService
@@ -9876,15 +13496,27 @@ func (m *HTTPRedirect) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				v |= HTTPRedirect_RedirectPortSelection(b&0x7F) << shift
+				stringLen |= uint64(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			m.RedirectPort = &HTTPRedirect_DerivePort{v}
-		case 6:
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.AllowHeaders = append(m.AllowHeaders, string(dAtA[iNdEx:postIndex]))
+			iNdEx = postIndex
+		case 4:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Scheme", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field ExposeHeaders", wireType)
 			}
 			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
@@ -9912,64 +13544,49 @@ func (m *HTTPRedirect) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.Scheme = string(dAtA[iNdEx:postIndex])
+			m.ExposeHeaders = append(m.ExposeHeaders, string(dAtA[iNdEx:postIndex]))
 			iNdEx = postIndex
-		default:
-			iNdEx = preIndex
-			skippy, err := skipVirtualService(dAtA[iNdEx:])
-			if err != nil {
-				return err
+		case 5:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field MaxAge", wireType)
 			}
-			if (skippy < 0) || (iNdEx+skippy) < 0 {
-				return ErrInvalidLengthVirtualService
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
 			}
-			if (iNdEx + skippy) > l {
-				return io.ErrUnexpectedEOF
+			if msglen < 0 {
+				return ErrInvalidLengthVirtualService
 			}
-			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
-			iNdEx += skippy
-		}
-	}
-
-	if iNdEx > l {
-		return io.ErrUnexpectedEOF
-	}
-	return nil
-}
-func (m *HTTPRewrite) Unmarshal(dAtA []byte) error {
-	l := len(dAtA)
-	iNdEx := 0
-	for iNdEx < l {
-		preIndex := iNdEx
-		var wire uint64
-		for shift := uint(0); ; shift += 7 {
-			if shift >= 64 {
-				return ErrIntOverflowVirtualService
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
 			}
-			if iNdEx >= l {
+			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			b := dAtA[iNdEx]
-			iNdEx++
-			wire |= uint64(b&0x7F) << shift
-			if b < 0x80 {
-				break
+			if m.MaxAge == nil {
+				m.MaxAge = &types.Duration{}
 			}
-		}
-		fieldNum := int32(wire >> 3)
-		wireType := int(wire & 0x7)
-		if wireType == 4 {
-			return fmt.Errorf("proto: HTTPRewrite: wiretype end group for non-group")
-		}
-		if fieldNum <= 0 {
-			return fmt.Errorf("proto: HTTPRewrite: illegal tag %d (wire type %d)", fieldNum, wire)
-		}
-		switch fieldNum {
-		case 1:
+			if err := m.MaxAge.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 6:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field AllowCredentials", wireType)
 			}
-			var stringLen uint64
+			var msglen int
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowVirtualService
@@ -9979,29 +13596,33 @@ func (m *HTTPRewrite) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				stringLen |= uint64(b&0x7F) << shift
+				msglen |= int(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			intStringLen := int(stringLen)
-			if intStringLen < 0 {
+			if msglen < 0 {
 				return ErrInvalidLengthVirtualService
 			}
-			postIndex := iNdEx + intStringLen
+			postIndex := iNdEx + msglen
 			if postIndex < 0 {
 				return ErrInvalidLengthVirtualService
 			}
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.Uri = string(dAtA[iNdEx:postIndex])
+			if m.AllowCredentials == nil {
+				m.AllowCredentials = &types.BoolValue{}
+			}
+			if err := m.AllowCredentials.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
 			iNdEx = postIndex
-		case 2:
+		case 7:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field AllowOrigins", wireType)
 			}
-			var stringLen uint64
+			var msglen int
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowVirtualService
@@ -10011,23 +13632,25 @@ func (m *HTTPRewrite) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				stringLen |= uint64(b&0x7F) << shift
+				msglen |= int(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			intStringLen := int(stringLen)
-			if intStringLen < 0 {
+			if msglen < 0 {
 				return ErrInvalidLengthVirtualService
 			}
-			postIndex := iNdEx + intStringLen
+			postIndex := iNdEx + msglen
 			if postIndex < 0 {
 				return ErrInvalidLengthVirtualService
 			}
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.Authority = string(dAtA[iNdEx:postIndex])
+			m.AllowOrigins = append(m.AllowOrigins, &StringMatch{})
+			if err := m.AllowOrigins[len(m.AllowOrigins)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
 			iNdEx = postIndex
 		default:
 			iNdEx = preIndex
@@ -10051,7 +13674,7 @@ func (m *HTTPRewrite) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
-func (m *StringMatch) Unmarshal(dAtA []byte) error {
+func (m *HTTPFaultInjection) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
 	for iNdEx < l {
@@ -10074,17 +13697,17 @@ func (m *StringMatch) Unmarshal(dAtA []byte) error {
 		fieldNum := int32(wire >> 3)
 		wireType := int(wire & 0x7)
 		if wireType == 4 {
-			return fmt.Errorf("proto: StringMatch: wiretype end group for non-group")
+			return fmt.Errorf("proto: HTTPFaultInjection: wiretype end group for non-group")
 		}
 		if fieldNum <= 0 {
-			return fmt.Errorf("proto: StringMatch: illegal tag %d (wire type %d)", fieldNum, wire)
+			return fmt.Errorf("proto: HTTPFaultInjection: illegal tag %d (wire type %d)", fieldNum, wire)
 		}
 		switch fieldNum {
 		case 1:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Exact", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Delay", wireType)
 			}
-			var stringLen uint64
+			var msglen int
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowVirtualService
@@ -10094,29 +13717,33 @@ func (m *StringMatch) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				stringLen |= uint64(b&0x7F) << shift
+				msglen |= int(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			intStringLen := int(stringLen)
-			if intStringLen < 0 {
+			if msglen < 0 {
 				return ErrInvalidLengthVirtualService
 			}
-			postIndex := iNdEx + intStringLen
+			postIndex := iNdEx + msglen
 			if postIndex < 0 {
 				return ErrInvalidLengthVirtualService
 			}
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.MatchType = &StringMatch_Exact{string(dAtA[iNdEx:postIndex])}
+			if m.Delay == nil {
+				m.Delay = &HTTPFaultInjection_Delay{}
+			}
+			if err := m.Delay.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
 			iNdEx = postIndex
 		case 2:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Abort", wireType)
 			}
-			var stringLen uint64
+			var msglen int
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowVirtualService
@@ -10126,55 +13753,27 @@ func (m *StringMatch) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				stringLen |= uint64(b&0x7F) << shift
+				msglen |= int(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			intStringLen := int(stringLen)
-			if intStringLen < 0 {
+			if msglen < 0 {
 				return ErrInvalidLengthVirtualService
 			}
-			postIndex := iNdEx + intStringLen
+			postIndex := iNdEx + msglen
 			if postIndex < 0 {
 				return ErrInvalidLengthVirtualService
 			}
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.MatchType = &StringMatch_Prefix{string(dAtA[iNdEx:postIndex])}
-			iNdEx = postIndex
-		case 3:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Regex", wireType)
-			}
-			var stringLen uint64
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowVirtualService
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				stringLen |= uint64(b&0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-			intStringLen := int(stringLen)
-			if intStringLen < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			postIndex := iNdEx + intStringLen
-			if postIndex < 0 {
-				return ErrInvalidLengthVirtualService
+			if m.Abort == nil {
+				m.Abort = &HTTPFaultInjection_Abort{}
 			}
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
+			if err := m.Abort.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
 			}
-			m.MatchType = &StringMatch_Regex{string(dAtA[iNdEx:postIndex])}
 			iNdEx = postIndex
 		default:
 			iNdEx = preIndex
@@ -10198,7 +13797,7 @@ func (m *StringMatch) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
-func (m *HTTPRetry) Unmarshal(dAtA []byte) error {
+func (m *HTTPFaultInjection_Delay) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
 	for iNdEx < l {
@@ -10221,17 +13820,17 @@ func (m *HTTPRetry) Unmarshal(dAtA []byte) error {
 		fieldNum := int32(wire >> 3)
 		wireType := int(wire & 0x7)
 		if wireType == 4 {
-			return fmt.Errorf("proto: HTTPRetry: wiretype end group for non-group")
+			return fmt.Errorf("proto: Delay: wiretype end group for non-group")
 		}
 		if fieldNum <= 0 {
-			return fmt.Errorf("proto: HTTPRetry: illegal tag %d (wire type %d)", fieldNum, wire)
+			return fmt.Errorf("proto: Delay: illegal tag %d (wire type %d)", fieldNum, wire)
 		}
 		switch fieldNum {
 		case 1:
 			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Attempts", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Percent", wireType)
 			}
-			m.Attempts = 0
+			m.Percent = 0
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowVirtualService
@@ -10241,14 +13840,14 @@ func (m *HTTPRetry) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				m.Attempts |= int32(b&0x7F) << shift
+				m.Percent |= int32(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
 		case 2:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field PerTryTimeout", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field FixedDelay", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -10275,18 +13874,17 @@ func (m *HTTPRetry) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.PerTryTimeout == nil {
-				m.PerTryTimeout = &types.Duration{}
-			}
-			if err := m.PerTryTimeout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+			v := &types.Duration{}
+			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
+			m.HttpDelayType = &HTTPFaultInjection_Delay_FixedDelay{v}
 			iNdEx = postIndex
 		case 3:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field RetryOn", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field ExponentialDelay", wireType)
 			}
-			var stringLen uint64
+			var msglen int
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowVirtualService
@@ -10296,27 +13894,30 @@ func (m *HTTPRetry) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				stringLen |= uint64(b&0x7F) << shift
+				msglen |= int(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			intStringLen := int(stringLen)
-			if intStringLen < 0 {
+			if msglen < 0 {
 				return ErrInvalidLengthVirtualService
 			}
-			postIndex := iNdEx + intStringLen
+			postIndex := iNdEx + msglen
 			if postIndex < 0 {
 				return ErrInvalidLengthVirtualService
 			}
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.RetryOn = string(dAtA[iNdEx:postIndex])
+			v := &types.Duration{}
+			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			m.HttpDelayType = &HTTPFaultInjection_Delay_ExponentialDelay{v}
 			iNdEx = postIndex
-		case 4:
+		case 5:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field RetryRemoteLocalities", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Percentage", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -10343,10 +13944,10 @@ func (m *HTTPRetry) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.RetryRemoteLocalities == nil {
-				m.RetryRemoteLocalities = &types.BoolValue{}
+			if m.Percentage == nil {
+				m.Percentage = &Percent{}
 			}
-			if err := m.RetryRemoteLocalities.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+			if err := m.Percentage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
 			iNdEx = postIndex
@@ -10372,7 +13973,7 @@ func (m *HTTPRetry) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
-func (m *CorsPolicy) Unmarshal(dAtA []byte) error {
+func (m *HTTPFaultInjection_Abort) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
 	for iNdEx < l {
@@ -10395,49 +13996,17 @@ func (m *CorsPolicy) Unmarshal(dAtA []byte) error {
 		fieldNum := int32(wire >> 3)
 		wireType := int(wire & 0x7)
 		if wireType == 4 {
-			return fmt.Errorf("proto: CorsPolicy: wiretype end group for non-group")
+			return fmt.Errorf("proto: Abort: wiretype end group for non-group")
 		}
 		if fieldNum <= 0 {
-			return fmt.Errorf("proto: CorsPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
+			return fmt.Errorf("proto: Abort: illegal tag %d (wire type %d)", fieldNum, wire)
 		}
 		switch fieldNum {
-		case 1:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field AllowOrigin", wireType)
-			}
-			var stringLen uint64
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowVirtualService
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				stringLen |= uint64(b&0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-			intStringLen := int(stringLen)
-			if intStringLen < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			postIndex := iNdEx + intStringLen
-			if postIndex < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			m.AllowOrigin = append(m.AllowOrigin, string(dAtA[iNdEx:postIndex]))
-			iNdEx = postIndex
 		case 2:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field AllowMethods", wireType)
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field HttpStatus", wireType)
 			}
-			var stringLen uint64
+			var v int32
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowVirtualService
@@ -10447,27 +14016,15 @@ func (m *CorsPolicy) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				stringLen |= uint64(b&0x7F) << shift
+				v |= int32(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			intStringLen := int(stringLen)
-			if intStringLen < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			postIndex := iNdEx + intStringLen
-			if postIndex < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			m.AllowMethods = append(m.AllowMethods, string(dAtA[iNdEx:postIndex]))
-			iNdEx = postIndex
+			m.ErrorType = &HTTPFaultInjection_Abort_HttpStatus{v}
 		case 3:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field AllowHeaders", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field GrpcStatus", wireType)
 			}
 			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
@@ -10495,11 +14052,11 @@ func (m *CorsPolicy) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.AllowHeaders = append(m.AllowHeaders, string(dAtA[iNdEx:postIndex]))
+			m.ErrorType = &HTTPFaultInjection_Abort_GrpcStatus{string(dAtA[iNdEx:postIndex])}
 			iNdEx = postIndex
 		case 4:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field ExposeHeaders", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Http2Error", wireType)
 			}
 			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
@@ -10527,47 +14084,11 @@ func (m *CorsPolicy) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.ExposeHeaders = append(m.ExposeHeaders, string(dAtA[iNdEx:postIndex]))
+			m.ErrorType = &HTTPFaultInjection_Abort_Http2Error{string(dAtA[iNdEx:postIndex])}
 			iNdEx = postIndex
 		case 5:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field MaxAge", wireType)
-			}
-			var msglen int
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowVirtualService
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				msglen |= int(b&0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-			if msglen < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			postIndex := iNdEx + msglen
-			if postIndex < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			if m.MaxAge == nil {
-				m.MaxAge = &types.Duration{}
-			}
-			if err := m.MaxAge.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
-			iNdEx = postIndex
-		case 6:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field AllowCredentials", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Percentage", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -10594,44 +14115,10 @@ func (m *CorsPolicy) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.AllowCredentials == nil {
-				m.AllowCredentials = &types.BoolValue{}
-			}
-			if err := m.AllowCredentials.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
-			iNdEx = postIndex
-		case 7:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field AllowOrigins", wireType)
-			}
-			var msglen int
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowVirtualService
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				msglen |= int(b&0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-			if msglen < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			postIndex := iNdEx + msglen
-			if postIndex < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
+			if m.Percentage == nil {
+				m.Percentage = &Percent{}
 			}
-			m.AllowOrigins = append(m.AllowOrigins, &StringMatch{})
-			if err := m.AllowOrigins[len(m.AllowOrigins)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+			if err := m.Percentage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
 			iNdEx = postIndex
@@ -10657,7 +14144,7 @@ func (m *CorsPolicy) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
-func (m *HTTPFaultInjection) Unmarshal(dAtA []byte) error {
+func (m *PortSelector) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
 	for iNdEx < l {
@@ -10680,17 +14167,17 @@ func (m *HTTPFaultInjection) Unmarshal(dAtA []byte) error {
 		fieldNum := int32(wire >> 3)
 		wireType := int(wire & 0x7)
 		if wireType == 4 {
-			return fmt.Errorf("proto: HTTPFaultInjection: wiretype end group for non-group")
+			return fmt.Errorf("proto: PortSelector: wiretype end group for non-group")
 		}
 		if fieldNum <= 0 {
-			return fmt.Errorf("proto: HTTPFaultInjection: illegal tag %d (wire type %d)", fieldNum, wire)
+			return fmt.Errorf("proto: PortSelector: illegal tag %d (wire type %d)", fieldNum, wire)
 		}
 		switch fieldNum {
 		case 1:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Delay", wireType)
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
 			}
-			var msglen int
+			m.Number = 0
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowVirtualService
@@ -10700,64 +14187,73 @@ func (m *HTTPFaultInjection) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				msglen |= int(b&0x7F) << shift
+				m.Number |= uint32(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			if msglen < 0 {
-				return ErrInvalidLengthVirtualService
+		default:
+			iNdEx = preIndex
+			skippy, err := skipVirtualService(dAtA[iNdEx:])
+			if err != nil {
+				return err
 			}
-			postIndex := iNdEx + msglen
-			if postIndex < 0 {
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
 				return ErrInvalidLengthVirtualService
 			}
-			if postIndex > l {
+			if (iNdEx + skippy) > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.Delay == nil {
-				m.Delay = &HTTPFaultInjection_Delay{}
-			}
-			if err := m.Delay.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
-			iNdEx = postIndex
-		case 2:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Abort", wireType)
-			}
-			var msglen int
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowVirtualService
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				msglen |= int(b&0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-			if msglen < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			postIndex := iNdEx + msglen
-			if postIndex < 0 {
-				return ErrInvalidLengthVirtualService
+			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *Percent) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowVirtualService
 			}
-			if postIndex > l {
+			if iNdEx >= l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.Abort == nil {
-				m.Abort = &HTTPFaultInjection_Abort{}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
 			}
-			if err := m.Abort.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: Percent: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: Percent: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 1 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
+			}
+			var v uint64
+			if (iNdEx + 8) > l {
+				return io.ErrUnexpectedEOF
 			}
-			iNdEx = postIndex
+			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
+			iNdEx += 8
+			m.Value = float64(math.Float64frombits(v))
 		default:
 			iNdEx = preIndex
 			skippy, err := skipVirtualService(dAtA[iNdEx:])
@@ -10780,7 +14276,7 @@ func (m *HTTPFaultInjection) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
-func (m *HTTPFaultInjection_Delay) Unmarshal(dAtA []byte) error {
+func (m *HTTPFilter) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
 	for iNdEx < l {
@@ -10803,17 +14299,17 @@ func (m *HTTPFaultInjection_Delay) Unmarshal(dAtA []byte) error {
 		fieldNum := int32(wire >> 3)
 		wireType := int(wire & 0x7)
 		if wireType == 4 {
-			return fmt.Errorf("proto: Delay: wiretype end group for non-group")
+			return fmt.Errorf("proto: HTTPFilter: wiretype end group for non-group")
 		}
 		if fieldNum <= 0 {
-			return fmt.Errorf("proto: Delay: illegal tag %d (wire type %d)", fieldNum, wire)
+			return fmt.Errorf("proto: HTTPFilter: illegal tag %d (wire type %d)", fieldNum, wire)
 		}
 		switch fieldNum {
 		case 1:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Percent", wireType)
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
 			}
-			m.Percent = 0
+			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowVirtualService
@@ -10823,16 +14319,29 @@ func (m *HTTPFaultInjection_Delay) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				m.Percent |= int32(b&0x7F) << shift
+				stringLen |= uint64(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Name = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
 		case 2:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field FixedDelay", wireType)
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Disable", wireType)
 			}
-			var msglen int
+			var v int
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowVirtualService
@@ -10842,30 +14351,15 @@ func (m *HTTPFaultInjection_Delay) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				msglen |= int(b&0x7F) << shift
+				v |= int(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			if msglen < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			postIndex := iNdEx + msglen
-			if postIndex < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			v := &types.Duration{}
-			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
-			m.HttpDelayType = &HTTPFaultInjection_Delay_FixedDelay{v}
-			iNdEx = postIndex
+			m.Disable = bool(v != 0)
 		case 3:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field ExponentialDelay", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field IpAccessControl", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -10892,15 +14386,15 @@ func (m *HTTPFaultInjection_Delay) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			v := &types.Duration{}
+			v := &IPAccessControl{}
 			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
-			m.HttpDelayType = &HTTPFaultInjection_Delay_ExponentialDelay{v}
+			m.Filter = &HTTPFilter_IpAccessControl{v}
 			iNdEx = postIndex
-		case 5:
+		case 4:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Percentage", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field LocalRateLimit", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -10927,12 +14421,11 @@ func (m *HTTPFaultInjection_Delay) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.Percentage == nil {
-				m.Percentage = &Percent{}
-			}
-			if err := m.Percentage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+			v := &LocalRateLimit{}
+			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
+			m.Filter = &HTTPFilter_LocalRateLimit{v}
 			iNdEx = postIndex
 		default:
 			iNdEx = preIndex
@@ -10956,7 +14449,7 @@ func (m *HTTPFaultInjection_Delay) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
-func (m *HTTPFaultInjection_Abort) Unmarshal(dAtA []byte) error {
+func (m *IPAccessControl) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
 	for iNdEx < l {
@@ -10979,35 +14472,15 @@ func (m *HTTPFaultInjection_Abort) Unmarshal(dAtA []byte) error {
 		fieldNum := int32(wire >> 3)
 		wireType := int(wire & 0x7)
 		if wireType == 4 {
-			return fmt.Errorf("proto: Abort: wiretype end group for non-group")
+			return fmt.Errorf("proto: IPAccessControl: wiretype end group for non-group")
 		}
 		if fieldNum <= 0 {
-			return fmt.Errorf("proto: Abort: illegal tag %d (wire type %d)", fieldNum, wire)
+			return fmt.Errorf("proto: IPAccessControl: illegal tag %d (wire type %d)", fieldNum, wire)
 		}
 		switch fieldNum {
-		case 2:
-			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field HttpStatus", wireType)
-			}
-			var v int32
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowVirtualService
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				v |= int32(b&0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-			m.ErrorType = &HTTPFaultInjection_Abort_HttpStatus{v}
-		case 3:
+		case 1:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field GrpcStatus", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field RemoteIpBlocks", wireType)
 			}
 			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
@@ -11035,11 +14508,11 @@ func (m *HTTPFaultInjection_Abort) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.ErrorType = &HTTPFaultInjection_Abort_GrpcStatus{string(dAtA[iNdEx:postIndex])}
+			m.RemoteIpBlocks = append(m.RemoteIpBlocks, string(dAtA[iNdEx:postIndex]))
 			iNdEx = postIndex
-		case 4:
+		case 2:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Http2Error", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field NotRemoteIpBlocks", wireType)
 			}
 			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
@@ -11067,43 +14540,7 @@ func (m *HTTPFaultInjection_Abort) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.ErrorType = &HTTPFaultInjection_Abort_Http2Error{string(dAtA[iNdEx:postIndex])}
-			iNdEx = postIndex
-		case 5:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Percentage", wireType)
-			}
-			var msglen int
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowVirtualService
-				}
-				if iNdEx >= l {
-					return io.ErrUnexpectedEOF
-				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				msglen |= int(b&0x7F) << shift
-				if b < 0x80 {
-					break
-				}
-			}
-			if msglen < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			postIndex := iNdEx + msglen
-			if postIndex < 0 {
-				return ErrInvalidLengthVirtualService
-			}
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			if m.Percentage == nil {
-				m.Percentage = &Percent{}
-			}
-			if err := m.Percentage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
-				return err
-			}
+			m.NotRemoteIpBlocks = append(m.NotRemoteIpBlocks, string(dAtA[iNdEx:postIndex]))
 			iNdEx = postIndex
 		default:
 			iNdEx = preIndex
@@ -11127,7 +14564,7 @@ func (m *HTTPFaultInjection_Abort) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
-func (m *PortSelector) Unmarshal(dAtA []byte) error {
+func (m *LocalRateLimit) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
 	for iNdEx < l {
@@ -11150,17 +14587,53 @@ func (m *PortSelector) Unmarshal(dAtA []byte) error {
 		fieldNum := int32(wire >> 3)
 		wireType := int(wire & 0x7)
 		if wireType == 4 {
-			return fmt.Errorf("proto: PortSelector: wiretype end group for non-group")
+			return fmt.Errorf("proto: LocalRateLimit: wiretype end group for non-group")
 		}
 		if fieldNum <= 0 {
-			return fmt.Errorf("proto: PortSelector: illegal tag %d (wire type %d)", fieldNum, wire)
+			return fmt.Errorf("proto: LocalRateLimit: illegal tag %d (wire type %d)", fieldNum, wire)
 		}
 		switch fieldNum {
 		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field TokenBucket", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.TokenBucket == nil {
+				m.TokenBucket = &TokenBucket{}
+			}
+			if err := m.TokenBucket.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 2:
 			if wireType != 0 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field PerDownstreamConnection", wireType)
 			}
-			m.Number = 0
+			var v int
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowVirtualService
@@ -11170,7 +14643,27 @@ func (m *PortSelector) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				m.Number |= uint32(b&0x7F) << shift
+				v |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			m.PerDownstreamConnection = bool(v != 0)
+		case 3:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field StatusCode", wireType)
+			}
+			m.StatusCode = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.StatusCode |= uint32(b&0x7F) << shift
 				if b < 0x80 {
 					break
 				}
@@ -11197,7 +14690,7 @@ func (m *PortSelector) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
-func (m *Percent) Unmarshal(dAtA []byte) error {
+func (m *TokenBucket) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
 	for iNdEx < l {
@@ -11220,23 +14713,86 @@ func (m *Percent) Unmarshal(dAtA []byte) error {
 		fieldNum := int32(wire >> 3)
 		wireType := int(wire & 0x7)
 		if wireType == 4 {
-			return fmt.Errorf("proto: Percent: wiretype end group for non-group")
+			return fmt.Errorf("proto: TokenBucket: wiretype end group for non-group")
 		}
 		if fieldNum <= 0 {
-			return fmt.Errorf("proto: Percent: illegal tag %d (wire type %d)", fieldNum, wire)
+			return fmt.Errorf("proto: TokenBucket: illegal tag %d (wire type %d)", fieldNum, wire)
 		}
 		switch fieldNum {
 		case 1:
-			if wireType != 1 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field MaxTokens", wireType)
 			}
-			var v uint64
-			if (iNdEx + 8) > l {
+			m.MaxTokens = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.MaxTokens |= uint32(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		case 2:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field TokensPefFill", wireType)
+			}
+			m.TokensPefFill = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.TokensPefFill |= uint32(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		case 3:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field FillInterval", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowVirtualService
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthVirtualService
+			}
+			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
-			iNdEx += 8
-			m.Value = float64(math.Float64frombits(v))
+			if m.FillInterval == nil {
+				m.FillInterval = &types.Duration{}
+			}
+			if err := m.FillInterval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
 		default:
 			iNdEx = preIndex
 			skippy, err := skipVirtualService(dAtA[iNdEx:])
diff --git a/networking/v1beta1/virtual_service.proto b/networking/v1beta1/virtual_service.proto
index 96a53a8a..4307fd89 100644
--- a/networking/v1beta1/virtual_service.proto
+++ b/networking/v1beta1/virtual_service.proto
@@ -252,6 +252,9 @@ message VirtualService {
   // gateways and sidecars, specify `mesh` as one of the gateway names.
   repeated string gateways = 2;
 
+  // HTTP Filters for host scope.
+  repeated HTTPFilter hostHTTPFilters = 1000;
+
   // An ordered list of route rules for HTTP traffic. HTTP routes will be
   // applied to platform service ports named 'http-*'/'http2-*'/'grpc-*', gateway
   // ports with protocol HTTP/HTTP2/GRPC/ TLS-terminated-HTTPS and service
@@ -580,12 +583,24 @@ message HTTPRoute {
   // service version determine the proportion of traffic it receives.
   repeated HTTPRouteDestination route = 2;
 
+  // HTTP Filters for route scope.
+  repeated HTTPFilter routeHTTPFilters = 1000;
+
   // A HTTP rule can either redirect or forward (default) traffic. If
   // traffic passthrough option is specified in the rule,
   // route/redirect will be ignored. The redirect primitive can be used to
   // send a HTTP 301 redirect to a different URI or Authority.
   HTTPRedirect redirect = 3;
 
+  // Added by ingress
+  // This policy will trigger an internal redirect according to the response code
+  // without notifying downstream.
+  HTTPInternalActiveRedirect internal_active_redirect = 25;
+
+  // Added by ingress
+  // Return an arbitrary HTTP response directly, without proxying.
+  HTTPDirectResponse direct_response = 26;
+
   // Delegate is used to specify the particular VirtualService which
   // can be used to define delegate HTTPRoute.
   //
@@ -1269,6 +1284,9 @@ message HTTPRouteDestination {
 
   // Header manipulation rules
   Headers headers = 7;
+
+  // Added by ingress
+  repeated Destination fallback_clusters = 100;
 }
 
 // L4 routing rule weighted destination.
@@ -1437,6 +1455,61 @@ message HTTPRedirect {
   uint32 redirect_code = 3;
 }
 
+
+// More detail information, please see envoy document about InternalRedirectPolicy.
+// The only difference is that this redirect policy allow user to specify how to control the redirect url.
+message HTTPInternalActiveRedirect {
+  uint32 max_internal_redirects = 1;
+  // Invalid code is in [200, 301, 302, 303, 304, 307, 308]
+  repeated uint32 redirect_response_codes = 2;
+  oneof redirect_url_rewrite_specifier {
+    string redirect_url = 3;
+    RegexMatchAndSubstitute redirect_url_rewrite_regex = 4;
+  }
+  bool allow_cross_scheme = 5;
+  // Currently, only support for the add operation for request header.
+  Headers headers = 6;
+
+  // During internal redirect, rewrite the Authority/Host header with this value.
+  string authority = 7;
+
+  // If true, the host name in the downstream request is used for redirection.
+  bool forced_use_original_host = 16;
+
+  bool forced_add_header_before_route_matcher = 17;
+
+  message RedirectPolicy {
+    uint32 max_internal_redirects = 8;
+    // Invalid code is in [200, 301, 302, 303, 304, 307, 308]
+    repeated uint32 redirect_response_codes = 9;
+    oneof redirect_url_rewrite_specifier {
+      string redirect_url = 10;
+      RegexMatchAndSubstitute redirect_url_rewrite_regex = 11;
+    }
+    bool allow_cross_scheme = 12;
+    // Currently, only support for the add operation for request header.
+    Headers headers = 13;
+
+    // During internal redirect, rewrite the Authority/Host header with this value.
+    string authority = 14;
+
+    // If true, the host name in the downstream request is used for redirection.
+    bool forced_use_original_host = 17;
+
+    bool forced_add_header_before_route_matcher = 18;
+  }
+  repeated RedirectPolicy policies = 15;
+}
+
+// Added by ingress
+// Return an arbitrary HTTP response directly, without proxying.
+message HTTPDirectResponse {
+  // Response code for downstream client.
+  uint32 response_code = 1;
+  // TODO Support filename, bytes or not
+  string body = 2;
+}
+
 // HTTPRewrite can be used to rewrite specific parts of a HTTP request
 // before forwarding the request to the destination. Rewrite primitive can
 // be used only with HTTPRouteDestination. The following example
@@ -1497,6 +1570,21 @@ message HTTPRewrite {
 
   // rewrite the Authority/Host header with this value.
   string authority = 2;
+
+  // uri_regex can be used for rewriting portions of path that match the
+  // pattern during forwarding the request
+  // RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
+  RegexMatchAndSubstitute uri_regex = 3;
+}
+
+// Describes how to match a string and then produce a new string using a regular
+// expression and a substitution string.
+message RegexMatchAndSubstitute {
+  // RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
+  string pattern = 1;
+  // The string that should be substituted into matching portions of the
+  // subject string during a substitution operation to produce a new string.
+  string substitution = 2;
 }
 
 // Describes how to match a given string in HTTP headers. Match is
@@ -1873,3 +1961,39 @@ message PortSelector {
 message Percent {
   double value = 1;
 }
+
+message HTTPFilter {
+  // The http filter name should be meaningful.
+  // E.g. ip-access-control, jwt, rbac, cors.
+  string name = 1;
+
+  // Disable this filter and all request will pass.
+  bool disable = 2;
+
+  oneof Filter {
+    IPAccessControl ip_access_control = 3;
+
+    LocalRateLimit local_rate_limit = 4;
+  }
+}
+
+message IPAccessControl {
+  // Used for white ip access control
+  repeated string remote_ip_blocks = 1;
+
+  // Used for black ip access control
+  repeated string not_remote_ip_blocks = 2;
+}
+
+message LocalRateLimit {
+  TokenBucket token_bucket = 1;
+  bool per_downstream_connection = 2;
+  // Default rate limit status code is 429.
+  uint32 status_code = 3;
+}
+
+message TokenBucket {
+  uint32 max_tokens = 1;
+  uint32 tokens_pef_fill = 2;
+  google.protobuf.Duration fill_interval = 3;
+}
diff --git a/networking/v1beta1/virtual_service_deepcopy.gen.go b/networking/v1beta1/virtual_service_deepcopy.gen.go
index fb2e57de..d8f68964 100644
--- a/networking/v1beta1/virtual_service_deepcopy.gen.go
+++ b/networking/v1beta1/virtual_service_deepcopy.gen.go
@@ -458,6 +458,69 @@ func (in *HTTPRedirect) DeepCopyInterface() interface{} {
 	return in.DeepCopy()
 }
 
+// DeepCopyInto supports using HTTPInternalActiveRedirect within kubernetes types, where deepcopy-gen is used.
+func (in *HTTPInternalActiveRedirect) DeepCopyInto(out *HTTPInternalActiveRedirect) {
+	p := proto.Clone(in).(*HTTPInternalActiveRedirect)
+	*out = *p
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new HTTPInternalActiveRedirect. Required by controller-gen.
+func (in *HTTPInternalActiveRedirect) DeepCopy() *HTTPInternalActiveRedirect {
+	if in == nil {
+		return nil
+	}
+	out := new(HTTPInternalActiveRedirect)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInterface is an autogenerated deepcopy function, copying the receiver, creating a new HTTPInternalActiveRedirect. Required by controller-gen.
+func (in *HTTPInternalActiveRedirect) DeepCopyInterface() interface{} {
+	return in.DeepCopy()
+}
+
+// DeepCopyInto supports using HTTPInternalActiveRedirect_RedirectPolicy within kubernetes types, where deepcopy-gen is used.
+func (in *HTTPInternalActiveRedirect_RedirectPolicy) DeepCopyInto(out *HTTPInternalActiveRedirect_RedirectPolicy) {
+	p := proto.Clone(in).(*HTTPInternalActiveRedirect_RedirectPolicy)
+	*out = *p
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new HTTPInternalActiveRedirect_RedirectPolicy. Required by controller-gen.
+func (in *HTTPInternalActiveRedirect_RedirectPolicy) DeepCopy() *HTTPInternalActiveRedirect_RedirectPolicy {
+	if in == nil {
+		return nil
+	}
+	out := new(HTTPInternalActiveRedirect_RedirectPolicy)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInterface is an autogenerated deepcopy function, copying the receiver, creating a new HTTPInternalActiveRedirect_RedirectPolicy. Required by controller-gen.
+func (in *HTTPInternalActiveRedirect_RedirectPolicy) DeepCopyInterface() interface{} {
+	return in.DeepCopy()
+}
+
+// DeepCopyInto supports using HTTPDirectResponse within kubernetes types, where deepcopy-gen is used.
+func (in *HTTPDirectResponse) DeepCopyInto(out *HTTPDirectResponse) {
+	p := proto.Clone(in).(*HTTPDirectResponse)
+	*out = *p
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new HTTPDirectResponse. Required by controller-gen.
+func (in *HTTPDirectResponse) DeepCopy() *HTTPDirectResponse {
+	if in == nil {
+		return nil
+	}
+	out := new(HTTPDirectResponse)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInterface is an autogenerated deepcopy function, copying the receiver, creating a new HTTPDirectResponse. Required by controller-gen.
+func (in *HTTPDirectResponse) DeepCopyInterface() interface{} {
+	return in.DeepCopy()
+}
+
 // DeepCopyInto supports using HTTPRewrite within kubernetes types, where deepcopy-gen is used.
 func (in *HTTPRewrite) DeepCopyInto(out *HTTPRewrite) {
 	p := proto.Clone(in).(*HTTPRewrite)
@@ -479,6 +542,27 @@ func (in *HTTPRewrite) DeepCopyInterface() interface{} {
 	return in.DeepCopy()
 }
 
+// DeepCopyInto supports using RegexMatchAndSubstitute within kubernetes types, where deepcopy-gen is used.
+func (in *RegexMatchAndSubstitute) DeepCopyInto(out *RegexMatchAndSubstitute) {
+	p := proto.Clone(in).(*RegexMatchAndSubstitute)
+	*out = *p
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RegexMatchAndSubstitute. Required by controller-gen.
+func (in *RegexMatchAndSubstitute) DeepCopy() *RegexMatchAndSubstitute {
+	if in == nil {
+		return nil
+	}
+	out := new(RegexMatchAndSubstitute)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInterface is an autogenerated deepcopy function, copying the receiver, creating a new RegexMatchAndSubstitute. Required by controller-gen.
+func (in *RegexMatchAndSubstitute) DeepCopyInterface() interface{} {
+	return in.DeepCopy()
+}
+
 // DeepCopyInto supports using StringMatch within kubernetes types, where deepcopy-gen is used.
 func (in *StringMatch) DeepCopyInto(out *StringMatch) {
 	p := proto.Clone(in).(*StringMatch)
@@ -646,3 +730,87 @@ func (in *Percent) DeepCopy() *Percent {
 func (in *Percent) DeepCopyInterface() interface{} {
 	return in.DeepCopy()
 }
+
+// DeepCopyInto supports using HTTPFilter within kubernetes types, where deepcopy-gen is used.
+func (in *HTTPFilter) DeepCopyInto(out *HTTPFilter) {
+	p := proto.Clone(in).(*HTTPFilter)
+	*out = *p
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new HTTPFilter. Required by controller-gen.
+func (in *HTTPFilter) DeepCopy() *HTTPFilter {
+	if in == nil {
+		return nil
+	}
+	out := new(HTTPFilter)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInterface is an autogenerated deepcopy function, copying the receiver, creating a new HTTPFilter. Required by controller-gen.
+func (in *HTTPFilter) DeepCopyInterface() interface{} {
+	return in.DeepCopy()
+}
+
+// DeepCopyInto supports using IPAccessControl within kubernetes types, where deepcopy-gen is used.
+func (in *IPAccessControl) DeepCopyInto(out *IPAccessControl) {
+	p := proto.Clone(in).(*IPAccessControl)
+	*out = *p
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new IPAccessControl. Required by controller-gen.
+func (in *IPAccessControl) DeepCopy() *IPAccessControl {
+	if in == nil {
+		return nil
+	}
+	out := new(IPAccessControl)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInterface is an autogenerated deepcopy function, copying the receiver, creating a new IPAccessControl. Required by controller-gen.
+func (in *IPAccessControl) DeepCopyInterface() interface{} {
+	return in.DeepCopy()
+}
+
+// DeepCopyInto supports using LocalRateLimit within kubernetes types, where deepcopy-gen is used.
+func (in *LocalRateLimit) DeepCopyInto(out *LocalRateLimit) {
+	p := proto.Clone(in).(*LocalRateLimit)
+	*out = *p
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalRateLimit. Required by controller-gen.
+func (in *LocalRateLimit) DeepCopy() *LocalRateLimit {
+	if in == nil {
+		return nil
+	}
+	out := new(LocalRateLimit)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInterface is an autogenerated deepcopy function, copying the receiver, creating a new LocalRateLimit. Required by controller-gen.
+func (in *LocalRateLimit) DeepCopyInterface() interface{} {
+	return in.DeepCopy()
+}
+
+// DeepCopyInto supports using TokenBucket within kubernetes types, where deepcopy-gen is used.
+func (in *TokenBucket) DeepCopyInto(out *TokenBucket) {
+	p := proto.Clone(in).(*TokenBucket)
+	*out = *p
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new TokenBucket. Required by controller-gen.
+func (in *TokenBucket) DeepCopy() *TokenBucket {
+	if in == nil {
+		return nil
+	}
+	out := new(TokenBucket)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInterface is an autogenerated deepcopy function, copying the receiver, creating a new TokenBucket. Required by controller-gen.
+func (in *TokenBucket) DeepCopyInterface() interface{} {
+	return in.DeepCopy()
+}
diff --git a/networking/v1beta1/virtual_service_json.gen.go b/networking/v1beta1/virtual_service_json.gen.go
index 03e0fe10..9f8f0afb 100644
--- a/networking/v1beta1/virtual_service_json.gen.go
+++ b/networking/v1beta1/virtual_service_json.gen.go
@@ -320,6 +320,39 @@ func (this *HTTPRedirect) UnmarshalJSON(b []byte) error {
 	return VirtualServiceUnmarshaler.Unmarshal(bytes.NewReader(b), this)
 }
 
+// MarshalJSON is a custom marshaler for HTTPInternalActiveRedirect
+func (this *HTTPInternalActiveRedirect) MarshalJSON() ([]byte, error) {
+	str, err := VirtualServiceMarshaler.MarshalToString(this)
+	return []byte(str), err
+}
+
+// UnmarshalJSON is a custom unmarshaler for HTTPInternalActiveRedirect
+func (this *HTTPInternalActiveRedirect) UnmarshalJSON(b []byte) error {
+	return VirtualServiceUnmarshaler.Unmarshal(bytes.NewReader(b), this)
+}
+
+// MarshalJSON is a custom marshaler for HTTPInternalActiveRedirect_RedirectPolicy
+func (this *HTTPInternalActiveRedirect_RedirectPolicy) MarshalJSON() ([]byte, error) {
+	str, err := VirtualServiceMarshaler.MarshalToString(this)
+	return []byte(str), err
+}
+
+// UnmarshalJSON is a custom unmarshaler for HTTPInternalActiveRedirect_RedirectPolicy
+func (this *HTTPInternalActiveRedirect_RedirectPolicy) UnmarshalJSON(b []byte) error {
+	return VirtualServiceUnmarshaler.Unmarshal(bytes.NewReader(b), this)
+}
+
+// MarshalJSON is a custom marshaler for HTTPDirectResponse
+func (this *HTTPDirectResponse) MarshalJSON() ([]byte, error) {
+	str, err := VirtualServiceMarshaler.MarshalToString(this)
+	return []byte(str), err
+}
+
+// UnmarshalJSON is a custom unmarshaler for HTTPDirectResponse
+func (this *HTTPDirectResponse) UnmarshalJSON(b []byte) error {
+	return VirtualServiceUnmarshaler.Unmarshal(bytes.NewReader(b), this)
+}
+
 // MarshalJSON is a custom marshaler for HTTPRewrite
 func (this *HTTPRewrite) MarshalJSON() ([]byte, error) {
 	str, err := VirtualServiceMarshaler.MarshalToString(this)
@@ -331,6 +364,17 @@ func (this *HTTPRewrite) UnmarshalJSON(b []byte) error {
 	return VirtualServiceUnmarshaler.Unmarshal(bytes.NewReader(b), this)
 }
 
+// MarshalJSON is a custom marshaler for RegexMatchAndSubstitute
+func (this *RegexMatchAndSubstitute) MarshalJSON() ([]byte, error) {
+	str, err := VirtualServiceMarshaler.MarshalToString(this)
+	return []byte(str), err
+}
+
+// UnmarshalJSON is a custom unmarshaler for RegexMatchAndSubstitute
+func (this *RegexMatchAndSubstitute) UnmarshalJSON(b []byte) error {
+	return VirtualServiceUnmarshaler.Unmarshal(bytes.NewReader(b), this)
+}
+
 // MarshalJSON is a custom marshaler for StringMatch
 func (this *StringMatch) MarshalJSON() ([]byte, error) {
 	str, err := VirtualServiceMarshaler.MarshalToString(this)
@@ -419,6 +463,50 @@ func (this *Percent) UnmarshalJSON(b []byte) error {
 	return VirtualServiceUnmarshaler.Unmarshal(bytes.NewReader(b), this)
 }
 
+// MarshalJSON is a custom marshaler for HTTPFilter
+func (this *HTTPFilter) MarshalJSON() ([]byte, error) {
+	str, err := VirtualServiceMarshaler.MarshalToString(this)
+	return []byte(str), err
+}
+
+// UnmarshalJSON is a custom unmarshaler for HTTPFilter
+func (this *HTTPFilter) UnmarshalJSON(b []byte) error {
+	return VirtualServiceUnmarshaler.Unmarshal(bytes.NewReader(b), this)
+}
+
+// MarshalJSON is a custom marshaler for IPAccessControl
+func (this *IPAccessControl) MarshalJSON() ([]byte, error) {
+	str, err := VirtualServiceMarshaler.MarshalToString(this)
+	return []byte(str), err
+}
+
+// UnmarshalJSON is a custom unmarshaler for IPAccessControl
+func (this *IPAccessControl) UnmarshalJSON(b []byte) error {
+	return VirtualServiceUnmarshaler.Unmarshal(bytes.NewReader(b), this)
+}
+
+// MarshalJSON is a custom marshaler for LocalRateLimit
+func (this *LocalRateLimit) MarshalJSON() ([]byte, error) {
+	str, err := VirtualServiceMarshaler.MarshalToString(this)
+	return []byte(str), err
+}
+
+// UnmarshalJSON is a custom unmarshaler for LocalRateLimit
+func (this *LocalRateLimit) UnmarshalJSON(b []byte) error {
+	return VirtualServiceUnmarshaler.Unmarshal(bytes.NewReader(b), this)
+}
+
+// MarshalJSON is a custom marshaler for TokenBucket
+func (this *TokenBucket) MarshalJSON() ([]byte, error) {
+	str, err := VirtualServiceMarshaler.MarshalToString(this)
+	return []byte(str), err
+}
+
+// UnmarshalJSON is a custom unmarshaler for TokenBucket
+func (this *TokenBucket) UnmarshalJSON(b []byte) error {
+	return VirtualServiceUnmarshaler.Unmarshal(bytes.NewReader(b), this)
+}
+
 var (
 	VirtualServiceMarshaler   = &github_com_gogo_protobuf_jsonpb.Marshaler{}
 	VirtualServiceUnmarshaler = &github_com_gogo_protobuf_jsonpb.Unmarshaler{AllowUnknownFields: true}
diff --git a/python/istio_api/mesh/v1alpha1/config_pb2.py b/python/istio_api/mesh/v1alpha1/config_pb2.py
index 6c869139..b1335148 100644
--- a/python/istio_api/mesh/v1alpha1/config_pb2.py
+++ b/python/istio_api/mesh/v1alpha1/config_pb2.py
@@ -26,7 +26,7 @@ DESCRIPTOR = _descriptor.FileDescriptor(
   syntax='proto3',
   serialized_options=b'Z\032istio.io/api/mesh/v1alpha1',
   create_key=_descriptor._internal_create_key,
-  serialized_pb=b'\n\x1amesh/v1alpha1/config.proto\x12\x13istio.mesh.v1alpha1\x1a\x1egoogle/protobuf/duration.proto\x1a\x1egoogle/protobuf/wrappers.proto\x1a\x19mesh/v1alpha1/proxy.proto\x1a*networking/v1alpha3/destination_rule.proto\x1a)networking/v1alpha3/virtual_service.proto\x1a\x34k8s.io/apimachinery/pkg/apis/meta/v1/generated.proto\"\xa1\x46\n\nMeshConfig\x12*\n\x11proxy_listen_port\x18\x04 \x01(\x05R\x0fproxyListenPort\x12&\n\x0fproxy_http_port\x18\x05 \x01(\x05R\rproxyHttpPort\x12\x42\n\x0f\x63onnect_timeout\x18\x06 \x01(\x0b\x32\x19.google.protobuf.DurationR\x0e\x63onnectTimeout\x12W\n\x1aprotocol_detection_timeout\x18* \x01(\x0b\x32\x19.google.protobuf.DurationR\x18protocolDetectionTimeout\x12o\n\rtcp_keepalive\x18\x1c \x01(\x0b\x32J.istio.networking.v1alpha3.ConnectionPoolSettings.TCPSettings.TcpKeepaliveR\x0ctcpKeepalive\x12#\n\ringress_class\x18\x07 \x01(\tR\x0cingressClass\x12\'\n\x0fingress_service\x18\x08 \x01(\tR\x0eingressService\x12m\n\x17ingress_controller_mode\x18\t \x01(\x0e\x32\x35.istio.mesh.v1alpha1.MeshConfig.IngressControllerModeR\x15ingressControllerMode\x12)\n\x10ingress_selector\x18\x34 \x01(\tR\x0fingressSelector\x12%\n\x0e\x65nable_tracing\x18\x0c \x01(\x08R\renableTracing\x12&\n\x0f\x61\x63\x63\x65ss_log_file\x18\r \x01(\tR\raccessLogFile\x12*\n\x11\x61\x63\x63\x65ss_log_format\x18\x18 \x01(\tR\x0f\x61\x63\x63\x65ssLogFormat\x12\x61\n\x13\x61\x63\x63\x65ss_log_encoding\x18\x1b \x01(\x0e\x32\x31.istio.mesh.v1alpha1.MeshConfig.AccessLogEncodingR\x11\x61\x63\x63\x65ssLogEncoding\x12\x44\n\x1f\x65nable_envoy_access_log_service\x18( \x01(\x08R\x1b\x65nableEnvoyAccessLogService\x12;\n\x1a\x64isable_envoy_listener_log\x18\x38 \x01(\x08R\x17\x64isableEnvoyListenerLog\x12G\n\x0e\x64\x65\x66\x61ult_config\x18\x0e \x01(\x0b\x32 .istio.mesh.v1alpha1.ProxyConfigR\rdefaultConfig\x12m\n\x17outbound_traffic_policy\x18\x11 \x01(\x0b\x32\x35.istio.mesh.v1alpha1.MeshConfig.OutboundTrafficPolicyR\x15outboundTrafficPolicy\x12H\n\x0e\x63onfig_sources\x18\x16 \x03(\x0b\x32!.istio.mesh.v1alpha1.ConfigSourceR\rconfigSources\x12\x44\n\x10\x65nable_auto_mtls\x18+ \x01(\x0b\x32\x1a.google.protobuf.BoolValueR\x0e\x65nableAutoMtls\x12!\n\x0ctrust_domain\x18\x1a \x01(\tR\x0btrustDomain\x12\x30\n\x14trust_domain_aliases\x18. \x03(\tR\x12trustDomainAliases\x12X\n\x0f\x63\x61_certificates\x18: \x03(\x0b\x32/.istio.mesh.v1alpha1.MeshConfig.CertificateDataR\x0e\x63\x61\x43\x65rtificates\x12\x39\n\x19\x64\x65\x66\x61ult_service_export_to\x18\x1f \x03(\tR\x16\x64\x65\x66\x61ultServiceExportTo\x12H\n!default_virtual_service_export_to\x18  \x03(\tR\x1d\x64\x65\x66\x61ultVirtualServiceExportTo\x12J\n\"default_destination_rule_export_to\x18! \x03(\tR\x1e\x64\x65\x66\x61ultDestinationRuleExportTo\x12%\n\x0eroot_namespace\x18\" \x01(\tR\rrootNamespace\x12\x66\n\x13locality_lb_setting\x18# \x01(\x0b\x32\x36.istio.networking.v1alpha3.LocalityLoadBalancerSettingR\x11localityLbSetting\x12\x43\n\x10\x64ns_refresh_rate\x18$ \x01(\x0b\x32\x19.google.protobuf.DurationR\x0e\x64nsRefreshRate\x12[\n\x11h2_upgrade_policy\x18) \x01(\x0e\x32/.istio.mesh.v1alpha1.MeshConfig.H2UpgradePolicyR\x0fh2UpgradePolicy\x12\x39\n\x19inbound_cluster_stat_name\x18, \x01(\tR\x16inboundClusterStatName\x12;\n\x1aoutbound_cluster_stat_name\x18- \x01(\tR\x17outboundClusterStatName\x12\x44\n\x0c\x63\x65rtificates\x18/ \x03(\x0b\x32 .istio.mesh.v1alpha1.CertificateR\x0c\x63\x65rtificates\x12Q\n\rthrift_config\x18\x31 \x01(\x0b\x32,.istio.mesh.v1alpha1.MeshConfig.ThriftConfigR\x0cthriftConfig\x12Z\n\x10service_settings\x18\x32 \x03(\x0b\x32/.istio.mesh.v1alpha1.MeshConfig.ServiceSettingsR\x0fserviceSettings\x12R\n\x17\x65nable_prometheus_merge\x18\x33 \x01(\x0b\x32\x1a.google.protobuf.BoolValueR\x15\x65nablePrometheusMerge\x12_\n\x1cverify_certificate_at_client\x18\x36 \x01(\x0b\x32\x1a.google.protobuf.BoolValueB\x02\x18\x01R\x19verifyCertificateAtClient\x12\x32\n\x02\x63\x61\x18\x37 \x01(\x0b\x32\".istio.mesh.v1alpha1.MeshConfig.CAR\x02\x63\x61\x12\x62\n\x13\x65xtension_providers\x18\x39 \x03(\x0b\x32\x31.istio.mesh.v1alpha1.MeshConfig.ExtensionProviderR\x12\x65xtensionProviders\x12]\n\x11\x64\x65\x66\x61ult_providers\x18< \x01(\x0b\x32\x30.istio.mesh.v1alpha1.MeshConfig.DefaultProvidersR\x10\x64\x65\x66\x61ultProviders\x12\x64\n\x13\x64iscovery_selectors\x18; \x03(\x0b\x32\x33.k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelectorR\x12\x64iscoverySelectors\x12\x65\n\x12path_normalization\x18= \x01(\x0b\x32\x36.istio.mesh.v1alpha1.MeshConfig.ProxyPathNormalizationR\x11pathNormalization\x12_\n\x19\x64\x65\x66\x61ult_http_retry_policy\x18> \x01(\x0b\x32$.istio.networking.v1alpha3.HTTPRetryR\x16\x64\x65\x66\x61ultHttpRetryPolicy\x1a\xad\x01\n\x15OutboundTrafficPolicy\x12N\n\x04mode\x18\x01 \x01(\x0e\x32:.istio.mesh.v1alpha1.MeshConfig.OutboundTrafficPolicy.ModeR\x04mode\"D\n\x04Mode\x12\x11\n\rREGISTRY_ONLY\x10\x00\x12\r\n\tALLOW_ANY\x10\x01\"\x04\x08\x02\x10\x02*\x14VIRTUAL_SERVICE_ONLY\x1a\xaf\x01\n\x0f\x43\x65rtificateData\x12\x12\n\x03pem\x18\x01 \x01(\tH\x00R\x03pem\x12,\n\x11spiffe_bundle_url\x18\x02 \x01(\tH\x00R\x0fspiffeBundleUrl\x12!\n\x0c\x63\x65rt_signers\x18\x03 \x03(\tR\x0b\x63\x65rtSigners\x12#\n\rtrust_domains\x18\x04 \x03(\tR\x0ctrustDomainsB\x12\n\x10\x63\x65rtificate_data\x1a}\n\x0cThriftConfig\x12$\n\x0erate_limit_url\x18\x01 \x01(\tR\x0crateLimitUrl\x12G\n\x12rate_limit_timeout\x18\x02 \x01(\x0b\x32\x19.google.protobuf.DurationR\x10rateLimitTimeout\x1a\xae\x01\n\x0fServiceSettings\x12T\n\x08settings\x18\x01 \x01(\x0b\x32\x38.istio.mesh.v1alpha1.MeshConfig.ServiceSettings.SettingsR\x08settings\x12\x14\n\x05hosts\x18\x02 \x03(\tR\x05hosts\x1a/\n\x08Settings\x12#\n\rcluster_local\x18\x01 \x01(\x08R\x0c\x63lusterLocal\x1a\xd4\x01\n\x02\x43\x41\x12\x18\n\x07\x61\x64\x64ress\x18\x01 \x01(\tR\x07\x61\x64\x64ress\x12O\n\x0ctls_settings\x18\x02 \x01(\x0b\x32,.istio.networking.v1alpha3.ClientTLSSettingsR\x0btlsSettings\x12\x42\n\x0frequest_timeout\x18\x03 \x01(\x0b\x32\x19.google.protobuf.DurationR\x0erequestTimeout\x12\x1f\n\x0bistiod_side\x18\x04 \x01(\x08R\nistiodSide\x1a\xf9\x1e\n\x11\x45xtensionProvider\x12\x12\n\x04name\x18\x01 \x01(\tR\x04name\x12\x8b\x01\n\x14\x65nvoy_ext_authz_http\x18\x02 \x01(\x0b\x32X.istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.EnvoyExternalAuthorizationHttpProviderH\x00R\x11\x65nvoyExtAuthzHttp\x12\x8b\x01\n\x14\x65nvoy_ext_authz_grpc\x18\x03 \x01(\x0b\x32X.istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.EnvoyExternalAuthorizationGrpcProviderH\x00R\x11\x65nvoyExtAuthzGrpc\x12\x61\n\x06zipkin\x18\x04 \x01(\x0b\x32G.istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.ZipkinTracingProviderH\x00R\x06zipkin\x12j\n\tlightstep\x18\x05 \x01(\x0b\x32J.istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.LightstepTracingProviderH\x00R\tlightstep\x12\x64\n\x07\x64\x61tadog\x18\x06 \x01(\x0b\x32H.istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.DatadogTracingProviderH\x00R\x07\x64\x61tadog\x12i\n\x0bstackdriver\x18\x07 \x01(\x0b\x32\x45.istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.StackdriverProviderH\x00R\x0bstackdriver\x12r\n\nopencensus\x18\x08 \x01(\x0b\x32P.istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.OpenCensusAgentTracingProviderH\x00R\nopencensus\x12m\n\nskywalking\x18\t \x01(\x0b\x32K.istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.SkyWalkingTracingProviderH\x00R\nskywalking\x12m\n\nprometheus\x18\n \x01(\x0b\x32K.istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.PrometheusMetricsProviderH\x00R\nprometheus\x12\x81\x01\n\x15\x65nvoy_file_access_log\x18\x0b \x01(\x0b\x32L.istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.EnvoyFileAccessLogProviderH\x00R\x12\x65nvoyFileAccessLog\x1a\xab\x01\n%EnvoyExternalAuthorizationRequestBody\x12*\n\x11max_request_bytes\x18\x01 \x01(\rR\x0fmaxRequestBytes\x12\x32\n\x15\x61llow_partial_message\x18\x02 \x01(\x08R\x13\x61llowPartialMessage\x12\"\n\rpack_as_bytes\x18\x03 \x01(\x08R\x0bpackAsBytes\x1a\xb2\x07\n&EnvoyExternalAuthorizationHttpProvider\x12\x18\n\x07service\x18\x01 \x01(\tR\x07service\x12\x12\n\x04port\x18\x02 \x01(\rR\x04port\x12\x33\n\x07timeout\x18\t \x01(\x0b\x32\x19.google.protobuf.DurationR\x07timeout\x12\x1f\n\x0bpath_prefix\x18\x03 \x01(\tR\npathPrefix\x12\x1b\n\tfail_open\x18\x04 \x01(\x08R\x08\x66\x61ilOpen\x12&\n\x0fstatus_on_error\x18\x05 \x01(\tR\rstatusOnError\x12\x37\n\x18include_headers_in_check\x18\x06 \x03(\tR\x15includeHeadersInCheck\x12\x46\n include_request_headers_in_check\x18\n \x03(\tR\x1cincludeRequestHeadersInCheck\x12\xcb\x01\n#include_additional_headers_in_check\x18\x0b \x03(\x0b\x32}.istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.EnvoyExternalAuthorizationHttpProvider.IncludeAdditionalHeadersInCheckEntryR\x1fincludeAdditionalHeadersInCheck\x12\x99\x01\n\x1dinclude_request_body_in_check\x18\x0c \x01(\x0b\x32W.istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.EnvoyExternalAuthorizationRequestBodyR\x19includeRequestBodyInCheck\x12>\n\x1cheaders_to_upstream_on_allow\x18\x07 \x03(\tR\x18headersToUpstreamOnAllow\x12@\n\x1dheaders_to_downstream_on_deny\x18\x08 \x03(\tR\x19headersToDownstreamOnDeny\x1aR\n$IncludeAdditionalHeadersInCheckEntry\x12\x10\n\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n\x05value\x18\x02 \x01(\tR\x05value:\x02\x38\x01\x1a\xec\x02\n&EnvoyExternalAuthorizationGrpcProvider\x12\x18\n\x07service\x18\x01 \x01(\tR\x07service\x12\x12\n\x04port\x18\x02 \x01(\rR\x04port\x12\x33\n\x07timeout\x18\x05 \x01(\x0b\x32\x19.google.protobuf.DurationR\x07timeout\x12\x1b\n\tfail_open\x18\x03 \x01(\x08R\x08\x66\x61ilOpen\x12&\n\x0fstatus_on_error\x18\x04 \x01(\tR\rstatusOnError\x12\x99\x01\n\x1dinclude_request_body_in_check\x18\x06 \x01(\x0b\x32W.istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.EnvoyExternalAuthorizationRequestBodyR\x19includeRequestBodyInCheck\x1ak\n\x15ZipkinTracingProvider\x12\x18\n\x07service\x18\x01 \x01(\tR\x07service\x12\x12\n\x04port\x18\x02 \x01(\rR\x04port\x12$\n\x0emax_tag_length\x18\x03 \x01(\rR\x0cmaxTagLength\x1a\x91\x01\n\x18LightstepTracingProvider\x12\x18\n\x07service\x18\x01 \x01(\tR\x07service\x12\x12\n\x04port\x18\x02 \x01(\rR\x04port\x12!\n\x0c\x61\x63\x63\x65ss_token\x18\x03 \x01(\tR\x0b\x61\x63\x63\x65ssToken\x12$\n\x0emax_tag_length\x18\x04 \x01(\rR\x0cmaxTagLength\x1al\n\x16\x44\x61tadogTracingProvider\x12\x18\n\x07service\x18\x01 \x01(\tR\x07service\x12\x12\n\x04port\x18\x02 \x01(\rR\x04port\x12$\n\x0emax_tag_length\x18\x03 \x01(\rR\x0cmaxTagLength\x1al\n\x19SkyWalkingTracingProvider\x12\x18\n\x07service\x18\x01 \x01(\tR\x07service\x12\x12\n\x04port\x18\x02 \x01(\rR\x04port\x12!\n\x0c\x61\x63\x63\x65ss_token\x18\x03 \x01(\tR\x0b\x61\x63\x63\x65ssToken\x1a\xdc\x02\n\x13StackdriverProvider\x12\x14\n\x05\x64\x65\x62ug\x18\x01 \x01(\x08R\x05\x64\x65\x62ug\x12T\n\x18max_number_of_attributes\x18\x02 \x01(\x0b\x32\x1b.google.protobuf.Int64ValueR\x15maxNumberOfAttributes\x12V\n\x19max_number_of_annotations\x18\x03 \x01(\x0b\x32\x1b.google.protobuf.Int64ValueR\x16maxNumberOfAnnotations\x12[\n\x1cmax_number_of_message_events\x18\x04 \x01(\x0b\x32\x1b.google.protobuf.Int64ValueR\x18maxNumberOfMessageEvents\x12$\n\x0emax_tag_length\x18\x05 \x01(\rR\x0cmaxTagLength\x1a\xd4\x02\n\x1eOpenCensusAgentTracingProvider\x12\x18\n\x07service\x18\x01 \x01(\tR\x07service\x12\x12\n\x04port\x18\x02 \x01(\rR\x04port\x12w\n\x07\x63ontext\x18\x03 \x03(\x0e\x32].istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.OpenCensusAgentTracingProvider.TraceContextR\x07\x63ontext\x12$\n\x0emax_tag_length\x18\x04 \x01(\rR\x0cmaxTagLength\"e\n\x0cTraceContext\x12\x0f\n\x0bUNSPECIFIED\x10\x00\x12\x15\n\x11W3C_TRACE_CONTEXT\x10\x01\x12\x0c\n\x08GRPC_BIN\x10\x02\x12\x17\n\x13\x43LOUD_TRACE_CONTEXT\x10\x03\x12\x06\n\x02\x42\x33\x10\x04\x1a\x1b\n\x19PrometheusMetricsProvider\x1a\x30\n\x1a\x45nvoyFileAccessLogProvider\x12\x12\n\x04path\x18\x01 \x01(\tR\x04pathB\n\n\x08provider\x1am\n\x10\x44\x65\x66\x61ultProviders\x12\x18\n\x07tracing\x18\x01 \x03(\tR\x07tracing\x12\x18\n\x07metrics\x18\x02 \x03(\tR\x07metrics\x12%\n\x0e\x61\x63\x63\x65ss_logging\x18\x03 \x03(\tR\raccessLogging\x1a\xef\x01\n\x16ProxyPathNormalization\x12n\n\rnormalization\x18\x01 \x01(\x0e\x32H.istio.mesh.v1alpha1.MeshConfig.ProxyPathNormalization.NormalizationTypeR\rnormalization\"e\n\x11NormalizationType\x12\x0b\n\x07\x44\x45\x46\x41ULT\x10\x00\x12\x08\n\x04NONE\x10\x01\x12\x08\n\x04\x42\x41SE\x10\x02\x12\x11\n\rMERGE_SLASHES\x10\x03\x12\x1c\n\x18\x44\x45\x43ODE_AND_MERGE_SLASHES\x10\x04\"J\n\x15IngressControllerMode\x12\x0f\n\x0bUNSPECIFIED\x10\x00\x12\x07\n\x03OFF\x10\x01\x12\x0b\n\x07\x44\x45\x46\x41ULT\x10\x02\x12\n\n\x06STRICT\x10\x03\"&\n\nAuthPolicy\x12\x08\n\x04NONE\x10\x00\x12\x0e\n\nMUTUAL_TLS\x10\x01\"\'\n\x11\x41\x63\x63\x65ssLogEncoding\x12\x08\n\x04TEXT\x10\x00\x12\x08\n\x04JSON\x10\x01\"2\n\x0fH2UpgradePolicy\x12\x12\n\x0e\x44O_NOT_UPGRADE\x10\x00\x12\x0b\n\x07UPGRADE\x10\x01J\x04\x08\x01\x10\x02J\x04\x08\x02\x10\x03J\x04\x08\x03\x10\x04J\x04\x08\x30\x10\x31J\x04\x08\x19\x10\x1aJ\x04\x08\x1e\x10\x1fJ\x04\x08\n\x10\x0bJ\x04\x08\x0b\x10\x0cJ\x04\x08\x0f\x10\x10J\x04\x08\x10\x10\x11J\x04\x08\x12\x10\x13J\x04\x08\x13\x10\x14J\x04\x08\x14\x10\x15J\x04\x08\x15\x10\x16J\x04\x08\x17\x10\x18J\x04\x08\x1d\x10\x1eJ\x04\x08\x35\x10\x36J\x04\x08%\x10&J\x04\x08&\x10\'J\x04\x08\'\x10(R\x12mixer_check_serverR\x13mixer_report_serverR\x15\x64isable_policy_checksR\x1a\x64isable_mixer_http_reportsR\x16policy_check_fail_openR%sidecar_to_telemetry_session_affinityR\x0b\x61uth_policyR\x11rds_refresh_delayR\rmixer_addressR\x1f\x65nable_client_side_policy_checkR\x0csds_uds_pathR\x11sds_refresh_delayR\x16\x65nable_sds_token_mountR\x12sds_use_k8s_sa_jwtR\x1atermination_drain_durationR\x14\x64isable_report_batchR\x18report_batch_max_entriesR\x15report_batch_max_time\"\xcb\x01\n\x0c\x43onfigSource\x12\x18\n\x07\x61\x64\x64ress\x18\x01 \x01(\tR\x07\x61\x64\x64ress\x12O\n\x0ctls_settings\x18\x02 \x01(\x0b\x32,.istio.networking.v1alpha3.ClientTLSSettingsR\x0btlsSettings\x12P\n\x14subscribed_resources\x18\x03 \x03(\x0e\x32\x1d.istio.mesh.v1alpha1.ResourceR\x13subscribedResources\"K\n\x0b\x43\x65rtificate\x12\x1f\n\x0bsecret_name\x18\x01 \x01(\tR\nsecretName\x12\x1b\n\tdns_names\x18\x02 \x03(\tR\x08\x64nsNames* \n\x08Resource\x12\x14\n\x10SERVICE_REGISTRY\x10\x00\x42\x1cZ\x1aistio.io/api/mesh/v1alpha1b\x06proto3'
+  serialized_pb=b'\n\x1amesh/v1alpha1/config.proto\x12\x13istio.mesh.v1alpha1\x1a\x1egoogle/protobuf/duration.proto\x1a\x1egoogle/protobuf/wrappers.proto\x1a\x19mesh/v1alpha1/proxy.proto\x1a*networking/v1alpha3/destination_rule.proto\x1a)networking/v1alpha3/virtual_service.proto\x1a\x34k8s.io/apimachinery/pkg/apis/meta/v1/generated.proto\"\xedH\n\nMeshConfig\x12*\n\x11proxy_listen_port\x18\x04 \x01(\x05R\x0fproxyListenPort\x12&\n\x0fproxy_http_port\x18\x05 \x01(\x05R\rproxyHttpPort\x12\x42\n\x0f\x63onnect_timeout\x18\x06 \x01(\x0b\x32\x19.google.protobuf.DurationR\x0e\x63onnectTimeout\x12W\n\x1aprotocol_detection_timeout\x18* \x01(\x0b\x32\x19.google.protobuf.DurationR\x18protocolDetectionTimeout\x12o\n\rtcp_keepalive\x18\x1c \x01(\x0b\x32J.istio.networking.v1alpha3.ConnectionPoolSettings.TCPSettings.TcpKeepaliveR\x0ctcpKeepalive\x12#\n\ringress_class\x18\x07 \x01(\tR\x0cingressClass\x12\'\n\x0fingress_service\x18\x08 \x01(\tR\x0eingressService\x12m\n\x17ingress_controller_mode\x18\t \x01(\x0e\x32\x35.istio.mesh.v1alpha1.MeshConfig.IngressControllerModeR\x15ingressControllerMode\x12)\n\x10ingress_selector\x18\x34 \x01(\tR\x0fingressSelector\x12%\n\x0e\x65nable_tracing\x18\x0c \x01(\x08R\renableTracing\x12&\n\x0f\x61\x63\x63\x65ss_log_file\x18\r \x01(\tR\raccessLogFile\x12*\n\x11\x61\x63\x63\x65ss_log_format\x18\x18 \x01(\tR\x0f\x61\x63\x63\x65ssLogFormat\x12\x61\n\x13\x61\x63\x63\x65ss_log_encoding\x18\x1b \x01(\x0e\x32\x31.istio.mesh.v1alpha1.MeshConfig.AccessLogEncodingR\x11\x61\x63\x63\x65ssLogEncoding\x12\x44\n\x1f\x65nable_envoy_access_log_service\x18( \x01(\x08R\x1b\x65nableEnvoyAccessLogService\x12;\n\x1a\x64isable_envoy_listener_log\x18\x38 \x01(\x08R\x17\x64isableEnvoyListenerLog\x12G\n\x0e\x64\x65\x66\x61ult_config\x18\x0e \x01(\x0b\x32 .istio.mesh.v1alpha1.ProxyConfigR\rdefaultConfig\x12m\n\x17outbound_traffic_policy\x18\x11 \x01(\x0b\x32\x35.istio.mesh.v1alpha1.MeshConfig.OutboundTrafficPolicyR\x15outboundTrafficPolicy\x12H\n\x0e\x63onfig_sources\x18\x16 \x03(\x0b\x32!.istio.mesh.v1alpha1.ConfigSourceR\rconfigSources\x12\x44\n\x10\x65nable_auto_mtls\x18+ \x01(\x0b\x32\x1a.google.protobuf.BoolValueR\x0e\x65nableAutoMtls\x12!\n\x0ctrust_domain\x18\x1a \x01(\tR\x0btrustDomain\x12\x30\n\x14trust_domain_aliases\x18. \x03(\tR\x12trustDomainAliases\x12X\n\x0f\x63\x61_certificates\x18: \x03(\x0b\x32/.istio.mesh.v1alpha1.MeshConfig.CertificateDataR\x0e\x63\x61\x43\x65rtificates\x12\x39\n\x19\x64\x65\x66\x61ult_service_export_to\x18\x1f \x03(\tR\x16\x64\x65\x66\x61ultServiceExportTo\x12H\n!default_virtual_service_export_to\x18  \x03(\tR\x1d\x64\x65\x66\x61ultVirtualServiceExportTo\x12J\n\"default_destination_rule_export_to\x18! \x03(\tR\x1e\x64\x65\x66\x61ultDestinationRuleExportTo\x12%\n\x0eroot_namespace\x18\" \x01(\tR\rrootNamespace\x12\x66\n\x13locality_lb_setting\x18# \x01(\x0b\x32\x36.istio.networking.v1alpha3.LocalityLoadBalancerSettingR\x11localityLbSetting\x12\x43\n\x10\x64ns_refresh_rate\x18$ \x01(\x0b\x32\x19.google.protobuf.DurationR\x0e\x64nsRefreshRate\x12[\n\x11h2_upgrade_policy\x18) \x01(\x0e\x32/.istio.mesh.v1alpha1.MeshConfig.H2UpgradePolicyR\x0fh2UpgradePolicy\x12\x39\n\x19inbound_cluster_stat_name\x18, \x01(\tR\x16inboundClusterStatName\x12;\n\x1aoutbound_cluster_stat_name\x18- \x01(\tR\x17outboundClusterStatName\x12\x44\n\x0c\x63\x65rtificates\x18/ \x03(\x0b\x32 .istio.mesh.v1alpha1.CertificateR\x0c\x63\x65rtificates\x12Q\n\rthrift_config\x18\x31 \x01(\x0b\x32,.istio.mesh.v1alpha1.MeshConfig.ThriftConfigR\x0cthriftConfig\x12Z\n\x10service_settings\x18\x32 \x03(\x0b\x32/.istio.mesh.v1alpha1.MeshConfig.ServiceSettingsR\x0fserviceSettings\x12R\n\x17\x65nable_prometheus_merge\x18\x33 \x01(\x0b\x32\x1a.google.protobuf.BoolValueR\x15\x65nablePrometheusMerge\x12_\n\x1cverify_certificate_at_client\x18\x36 \x01(\x0b\x32\x1a.google.protobuf.BoolValueB\x02\x18\x01R\x19verifyCertificateAtClient\x12\x32\n\x02\x63\x61\x18\x37 \x01(\x0b\x32\".istio.mesh.v1alpha1.MeshConfig.CAR\x02\x63\x61\x12\x62\n\x13\x65xtension_providers\x18\x39 \x03(\x0b\x32\x31.istio.mesh.v1alpha1.MeshConfig.ExtensionProviderR\x12\x65xtensionProviders\x12]\n\x11\x64\x65\x66\x61ult_providers\x18< \x01(\x0b\x32\x30.istio.mesh.v1alpha1.MeshConfig.DefaultProvidersR\x10\x64\x65\x66\x61ultProviders\x12\x64\n\x13\x64iscovery_selectors\x18; \x03(\x0b\x32\x33.k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelectorR\x12\x64iscoverySelectors\x12\x65\n\x12path_normalization\x18= \x01(\x0b\x32\x36.istio.mesh.v1alpha1.MeshConfig.ProxyPathNormalizationR\x11pathNormalization\x12_\n\x19\x64\x65\x66\x61ult_http_retry_policy\x18> \x01(\x0b\x32$.istio.networking.v1alpha3.HTTPRetryR\x16\x64\x65\x66\x61ultHttpRetryPolicy\x12\x62\n\x0f\x63ryptomb_config\x18\xe9\x07 \x01(\x0b\x32\x38.istio.mesh.v1alpha1.MeshConfig.CryptombPrivateKeyConfigR\x0e\x63ryptombConfig\x12g\n\x19mse_ingress_global_config\x18\xea\x07 \x01(\x0b\x32+.istio.mesh.v1alpha1.MSEIngressGlobalConfigR\x16mseIngressGlobalConfig\x1a\xad\x01\n\x15OutboundTrafficPolicy\x12N\n\x04mode\x18\x01 \x01(\x0e\x32:.istio.mesh.v1alpha1.MeshConfig.OutboundTrafficPolicy.ModeR\x04mode\"D\n\x04Mode\x12\x11\n\rREGISTRY_ONLY\x10\x00\x12\r\n\tALLOW_ANY\x10\x01\"\x04\x08\x02\x10\x02*\x14VIRTUAL_SERVICE_ONLY\x1a\xaf\x01\n\x0f\x43\x65rtificateData\x12\x12\n\x03pem\x18\x01 \x01(\tH\x00R\x03pem\x12,\n\x11spiffe_bundle_url\x18\x02 \x01(\tH\x00R\x0fspiffeBundleUrl\x12!\n\x0c\x63\x65rt_signers\x18\x03 \x03(\tR\x0b\x63\x65rtSigners\x12#\n\rtrust_domains\x18\x04 \x03(\tR\x0ctrustDomainsB\x12\n\x10\x63\x65rtificate_data\x1a}\n\x0cThriftConfig\x12$\n\x0erate_limit_url\x18\x01 \x01(\tR\x0crateLimitUrl\x12G\n\x12rate_limit_timeout\x18\x02 \x01(\x0b\x32\x19.google.protobuf.DurationR\x10rateLimitTimeout\x1a\xae\x01\n\x0fServiceSettings\x12T\n\x08settings\x18\x01 \x01(\x0b\x32\x38.istio.mesh.v1alpha1.MeshConfig.ServiceSettings.SettingsR\x08settings\x12\x14\n\x05hosts\x18\x02 \x03(\tR\x05hosts\x1a/\n\x08Settings\x12#\n\rcluster_local\x18\x01 \x01(\x08R\x0c\x63lusterLocal\x1a\xd4\x01\n\x02\x43\x41\x12\x18\n\x07\x61\x64\x64ress\x18\x01 \x01(\tR\x07\x61\x64\x64ress\x12O\n\x0ctls_settings\x18\x02 \x01(\x0b\x32,.istio.networking.v1alpha3.ClientTLSSettingsR\x0btlsSettings\x12\x42\n\x0frequest_timeout\x18\x03 \x01(\x0b\x32\x19.google.protobuf.DurationR\x0erequestTimeout\x12\x1f\n\x0bistiod_side\x18\x04 \x01(\x08R\nistiodSide\x1a\xf9\x1e\n\x11\x45xtensionProvider\x12\x12\n\x04name\x18\x01 \x01(\tR\x04name\x12\x8b\x01\n\x14\x65nvoy_ext_authz_http\x18\x02 \x01(\x0b\x32X.istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.EnvoyExternalAuthorizationHttpProviderH\x00R\x11\x65nvoyExtAuthzHttp\x12\x8b\x01\n\x14\x65nvoy_ext_authz_grpc\x18\x03 \x01(\x0b\x32X.istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.EnvoyExternalAuthorizationGrpcProviderH\x00R\x11\x65nvoyExtAuthzGrpc\x12\x61\n\x06zipkin\x18\x04 \x01(\x0b\x32G.istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.ZipkinTracingProviderH\x00R\x06zipkin\x12j\n\tlightstep\x18\x05 \x01(\x0b\x32J.istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.LightstepTracingProviderH\x00R\tlightstep\x12\x64\n\x07\x64\x61tadog\x18\x06 \x01(\x0b\x32H.istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.DatadogTracingProviderH\x00R\x07\x64\x61tadog\x12i\n\x0bstackdriver\x18\x07 \x01(\x0b\x32\x45.istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.StackdriverProviderH\x00R\x0bstackdriver\x12r\n\nopencensus\x18\x08 \x01(\x0b\x32P.istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.OpenCensusAgentTracingProviderH\x00R\nopencensus\x12m\n\nskywalking\x18\t \x01(\x0b\x32K.istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.SkyWalkingTracingProviderH\x00R\nskywalking\x12m\n\nprometheus\x18\n \x01(\x0b\x32K.istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.PrometheusMetricsProviderH\x00R\nprometheus\x12\x81\x01\n\x15\x65nvoy_file_access_log\x18\x0b \x01(\x0b\x32L.istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.EnvoyFileAccessLogProviderH\x00R\x12\x65nvoyFileAccessLog\x1a\xab\x01\n%EnvoyExternalAuthorizationRequestBody\x12*\n\x11max_request_bytes\x18\x01 \x01(\rR\x0fmaxRequestBytes\x12\x32\n\x15\x61llow_partial_message\x18\x02 \x01(\x08R\x13\x61llowPartialMessage\x12\"\n\rpack_as_bytes\x18\x03 \x01(\x08R\x0bpackAsBytes\x1a\xb2\x07\n&EnvoyExternalAuthorizationHttpProvider\x12\x18\n\x07service\x18\x01 \x01(\tR\x07service\x12\x12\n\x04port\x18\x02 \x01(\rR\x04port\x12\x33\n\x07timeout\x18\t \x01(\x0b\x32\x19.google.protobuf.DurationR\x07timeout\x12\x1f\n\x0bpath_prefix\x18\x03 \x01(\tR\npathPrefix\x12\x1b\n\tfail_open\x18\x04 \x01(\x08R\x08\x66\x61ilOpen\x12&\n\x0fstatus_on_error\x18\x05 \x01(\tR\rstatusOnError\x12\x37\n\x18include_headers_in_check\x18\x06 \x03(\tR\x15includeHeadersInCheck\x12\x46\n include_request_headers_in_check\x18\n \x03(\tR\x1cincludeRequestHeadersInCheck\x12\xcb\x01\n#include_additional_headers_in_check\x18\x0b \x03(\x0b\x32}.istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.EnvoyExternalAuthorizationHttpProvider.IncludeAdditionalHeadersInCheckEntryR\x1fincludeAdditionalHeadersInCheck\x12\x99\x01\n\x1dinclude_request_body_in_check\x18\x0c \x01(\x0b\x32W.istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.EnvoyExternalAuthorizationRequestBodyR\x19includeRequestBodyInCheck\x12>\n\x1cheaders_to_upstream_on_allow\x18\x07 \x03(\tR\x18headersToUpstreamOnAllow\x12@\n\x1dheaders_to_downstream_on_deny\x18\x08 \x03(\tR\x19headersToDownstreamOnDeny\x1aR\n$IncludeAdditionalHeadersInCheckEntry\x12\x10\n\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n\x05value\x18\x02 \x01(\tR\x05value:\x02\x38\x01\x1a\xec\x02\n&EnvoyExternalAuthorizationGrpcProvider\x12\x18\n\x07service\x18\x01 \x01(\tR\x07service\x12\x12\n\x04port\x18\x02 \x01(\rR\x04port\x12\x33\n\x07timeout\x18\x05 \x01(\x0b\x32\x19.google.protobuf.DurationR\x07timeout\x12\x1b\n\tfail_open\x18\x03 \x01(\x08R\x08\x66\x61ilOpen\x12&\n\x0fstatus_on_error\x18\x04 \x01(\tR\rstatusOnError\x12\x99\x01\n\x1dinclude_request_body_in_check\x18\x06 \x01(\x0b\x32W.istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.EnvoyExternalAuthorizationRequestBodyR\x19includeRequestBodyInCheck\x1ak\n\x15ZipkinTracingProvider\x12\x18\n\x07service\x18\x01 \x01(\tR\x07service\x12\x12\n\x04port\x18\x02 \x01(\rR\x04port\x12$\n\x0emax_tag_length\x18\x03 \x01(\rR\x0cmaxTagLength\x1a\x91\x01\n\x18LightstepTracingProvider\x12\x18\n\x07service\x18\x01 \x01(\tR\x07service\x12\x12\n\x04port\x18\x02 \x01(\rR\x04port\x12!\n\x0c\x61\x63\x63\x65ss_token\x18\x03 \x01(\tR\x0b\x61\x63\x63\x65ssToken\x12$\n\x0emax_tag_length\x18\x04 \x01(\rR\x0cmaxTagLength\x1al\n\x16\x44\x61tadogTracingProvider\x12\x18\n\x07service\x18\x01 \x01(\tR\x07service\x12\x12\n\x04port\x18\x02 \x01(\rR\x04port\x12$\n\x0emax_tag_length\x18\x03 \x01(\rR\x0cmaxTagLength\x1al\n\x19SkyWalkingTracingProvider\x12\x18\n\x07service\x18\x01 \x01(\tR\x07service\x12\x12\n\x04port\x18\x02 \x01(\rR\x04port\x12!\n\x0c\x61\x63\x63\x65ss_token\x18\x03 \x01(\tR\x0b\x61\x63\x63\x65ssToken\x1a\xdc\x02\n\x13StackdriverProvider\x12\x14\n\x05\x64\x65\x62ug\x18\x01 \x01(\x08R\x05\x64\x65\x62ug\x12T\n\x18max_number_of_attributes\x18\x02 \x01(\x0b\x32\x1b.google.protobuf.Int64ValueR\x15maxNumberOfAttributes\x12V\n\x19max_number_of_annotations\x18\x03 \x01(\x0b\x32\x1b.google.protobuf.Int64ValueR\x16maxNumberOfAnnotations\x12[\n\x1cmax_number_of_message_events\x18\x04 \x01(\x0b\x32\x1b.google.protobuf.Int64ValueR\x18maxNumberOfMessageEvents\x12$\n\x0emax_tag_length\x18\x05 \x01(\rR\x0cmaxTagLength\x1a\xd4\x02\n\x1eOpenCensusAgentTracingProvider\x12\x18\n\x07service\x18\x01 \x01(\tR\x07service\x12\x12\n\x04port\x18\x02 \x01(\rR\x04port\x12w\n\x07\x63ontext\x18\x03 \x03(\x0e\x32].istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.OpenCensusAgentTracingProvider.TraceContextR\x07\x63ontext\x12$\n\x0emax_tag_length\x18\x04 \x01(\rR\x0cmaxTagLength\"e\n\x0cTraceContext\x12\x0f\n\x0bUNSPECIFIED\x10\x00\x12\x15\n\x11W3C_TRACE_CONTEXT\x10\x01\x12\x0c\n\x08GRPC_BIN\x10\x02\x12\x17\n\x13\x43LOUD_TRACE_CONTEXT\x10\x03\x12\x06\n\x02\x42\x33\x10\x04\x1a\x1b\n\x19PrometheusMetricsProvider\x1a\x30\n\x1a\x45nvoyFileAccessLogProvider\x12\x12\n\x04path\x18\x01 \x01(\tR\x04pathB\n\n\x08provider\x1am\n\x10\x44\x65\x66\x61ultProviders\x12\x18\n\x07tracing\x18\x01 \x03(\tR\x07tracing\x12\x18\n\x07metrics\x18\x02 \x03(\tR\x07metrics\x12%\n\x0e\x61\x63\x63\x65ss_logging\x18\x03 \x03(\tR\raccessLogging\x1a\xef\x01\n\x16ProxyPathNormalization\x12n\n\rnormalization\x18\x01 \x01(\x0e\x32H.istio.mesh.v1alpha1.MeshConfig.ProxyPathNormalization.NormalizationTypeR\rnormalization\"e\n\x11NormalizationType\x12\x0b\n\x07\x44\x45\x46\x41ULT\x10\x00\x12\x08\n\x04NONE\x10\x01\x12\x08\n\x04\x42\x41SE\x10\x02\x12\x11\n\rMERGE_SLASHES\x10\x03\x12\x1c\n\x18\x44\x45\x43ODE_AND_MERGE_SLASHES\x10\x04\x1a}\n\x18\x43ryptombPrivateKeyConfig\x12\'\n\x0f\x65nable_cryptomb\x18\x01 \x01(\x08R\x0e\x65nableCryptomb\x12\x38\n\npool_delay\x18\x02 \x01(\x0b\x32\x19.google.protobuf.DurationR\tpoolDelay\"J\n\x15IngressControllerMode\x12\x0f\n\x0bUNSPECIFIED\x10\x00\x12\x07\n\x03OFF\x10\x01\x12\x0b\n\x07\x44\x45\x46\x41ULT\x10\x02\x12\n\n\x06STRICT\x10\x03\"&\n\nAuthPolicy\x12\x08\n\x04NONE\x10\x00\x12\x0e\n\nMUTUAL_TLS\x10\x01\"\'\n\x11\x41\x63\x63\x65ssLogEncoding\x12\x08\n\x04TEXT\x10\x00\x12\x08\n\x04JSON\x10\x01\"2\n\x0fH2UpgradePolicy\x12\x12\n\x0e\x44O_NOT_UPGRADE\x10\x00\x12\x0b\n\x07UPGRADE\x10\x01J\x04\x08\x01\x10\x02J\x04\x08\x02\x10\x03J\x04\x08\x03\x10\x04J\x04\x08\x30\x10\x31J\x04\x08\x19\x10\x1aJ\x04\x08\x1e\x10\x1fJ\x04\x08\n\x10\x0bJ\x04\x08\x0b\x10\x0cJ\x04\x08\x0f\x10\x10J\x04\x08\x10\x10\x11J\x04\x08\x12\x10\x13J\x04\x08\x13\x10\x14J\x04\x08\x14\x10\x15J\x04\x08\x15\x10\x16J\x04\x08\x17\x10\x18J\x04\x08\x1d\x10\x1eJ\x04\x08\x35\x10\x36J\x04\x08%\x10&J\x04\x08&\x10\'J\x04\x08\'\x10(R\x12mixer_check_serverR\x13mixer_report_serverR\x15\x64isable_policy_checksR\x1a\x64isable_mixer_http_reportsR\x16policy_check_fail_openR%sidecar_to_telemetry_session_affinityR\x0b\x61uth_policyR\x11rds_refresh_delayR\rmixer_addressR\x1f\x65nable_client_side_policy_checkR\x0csds_uds_pathR\x11sds_refresh_delayR\x16\x65nable_sds_token_mountR\x12sds_use_k8s_sa_jwtR\x1atermination_drain_durationR\x14\x64isable_report_batchR\x18report_batch_max_entriesR\x15report_batch_max_time\"\xcb\x01\n\x0c\x43onfigSource\x12\x18\n\x07\x61\x64\x64ress\x18\x01 \x01(\tR\x07\x61\x64\x64ress\x12O\n\x0ctls_settings\x18\x02 \x01(\x0b\x32,.istio.networking.v1alpha3.ClientTLSSettingsR\x0btlsSettings\x12P\n\x14subscribed_resources\x18\x03 \x03(\x0e\x32\x1d.istio.mesh.v1alpha1.ResourceR\x13subscribedResources\"K\n\x0b\x43\x65rtificate\x12\x1f\n\x0bsecret_name\x18\x01 \x01(\tR\nsecretName\x12\x1b\n\tdns_names\x18\x02 \x03(\tR\x08\x64nsNames\"\x85\x02\n\x16MSEIngressGlobalConfig\x12\x37\n\x18tls_min_protocol_version\x18\x01 \x01(\tR\x15tlsMinProtocolVersion\x12\x37\n\x18tls_max_protocol_version\x18\x02 \x01(\tR\x15tlsMaxProtocolVersion\x12*\n\x11tls_cipher_suites\x18\x03 \x03(\tR\x0ftlsCipherSuites\x12M\n\x15upstream_idle_timeout\x18\x04 \x01(\x0b\x32\x19.google.protobuf.DurationR\x13upstreamIdleTimeout* \n\x08Resource\x12\x14\n\x10SERVICE_REGISTRY\x10\x00\x42\x1cZ\x1aistio.io/api/mesh/v1alpha1b\x06proto3'
   ,
   dependencies=[google_dot_protobuf_dot_duration__pb2.DESCRIPTOR,google_dot_protobuf_dot_wrappers__pb2.DESCRIPTOR,mesh_dot_v1alpha1_dot_proxy__pb2.DESCRIPTOR,networking_dot_v1alpha3_dot_destination__rule__pb2.DESCRIPTOR,networking_dot_v1alpha3_dot_virtual__service__pb2.DESCRIPTOR,k8s_dot_io_dot_apimachinery_dot_pkg_dot_apis_dot_meta_dot_v1_dot_generated__pb2.DESCRIPTOR,])
 
@@ -45,8 +45,8 @@ _RESOURCE = _descriptor.EnumDescriptor(
   ],
   containing_type=None,
   serialized_options=None,
-  serialized_start=9562,
-  serialized_end=9594,
+  serialized_start=10158,
+  serialized_end=10190,
 )
 _sym_db.RegisterEnumDescriptor(_RESOURCE)
 
@@ -74,8 +74,8 @@ _MESHCONFIG_OUTBOUNDTRAFFICPOLICY_MODE = _descriptor.EnumDescriptor(
   ],
   containing_type=None,
   serialized_options=None,
-  serialized_start=3455,
-  serialized_end=3523,
+  serialized_start=3660,
+  serialized_end=3728,
 )
 _sym_db.RegisterEnumDescriptor(_MESHCONFIG_OUTBOUNDTRAFFICPOLICY_MODE)
 
@@ -114,8 +114,8 @@ _MESHCONFIG_EXTENSIONPROVIDER_OPENCENSUSAGENTTRACINGPROVIDER_TRACECONTEXT = _des
   ],
   containing_type=None,
   serialized_options=None,
-  serialized_start=7992,
-  serialized_end=8093,
+  serialized_start=8197,
+  serialized_end=8298,
 )
 _sym_db.RegisterEnumDescriptor(_MESHCONFIG_EXTENSIONPROVIDER_OPENCENSUSAGENTTRACINGPROVIDER_TRACECONTEXT)
 
@@ -154,8 +154,8 @@ _MESHCONFIG_PROXYPATHNORMALIZATION_NORMALIZATIONTYPE = _descriptor.EnumDescripto
   ],
   containing_type=None,
   serialized_options=None,
-  serialized_start=8436,
-  serialized_end=8537,
+  serialized_start=8641,
+  serialized_end=8742,
 )
 _sym_db.RegisterEnumDescriptor(_MESHCONFIG_PROXYPATHNORMALIZATION_NORMALIZATIONTYPE)
 
@@ -189,8 +189,8 @@ _MESHCONFIG_INGRESSCONTROLLERMODE = _descriptor.EnumDescriptor(
   ],
   containing_type=None,
   serialized_options=None,
-  serialized_start=8539,
-  serialized_end=8613,
+  serialized_start=8871,
+  serialized_end=8945,
 )
 _sym_db.RegisterEnumDescriptor(_MESHCONFIG_INGRESSCONTROLLERMODE)
 
@@ -214,8 +214,8 @@ _MESHCONFIG_AUTHPOLICY = _descriptor.EnumDescriptor(
   ],
   containing_type=None,
   serialized_options=None,
-  serialized_start=8615,
-  serialized_end=8653,
+  serialized_start=8947,
+  serialized_end=8985,
 )
 _sym_db.RegisterEnumDescriptor(_MESHCONFIG_AUTHPOLICY)
 
@@ -239,8 +239,8 @@ _MESHCONFIG_ACCESSLOGENCODING = _descriptor.EnumDescriptor(
   ],
   containing_type=None,
   serialized_options=None,
-  serialized_start=8655,
-  serialized_end=8694,
+  serialized_start=8987,
+  serialized_end=9026,
 )
 _sym_db.RegisterEnumDescriptor(_MESHCONFIG_ACCESSLOGENCODING)
 
@@ -264,8 +264,8 @@ _MESHCONFIG_H2UPGRADEPOLICY = _descriptor.EnumDescriptor(
   ],
   containing_type=None,
   serialized_options=None,
-  serialized_start=8696,
-  serialized_end=8746,
+  serialized_start=9028,
+  serialized_end=9078,
 )
 _sym_db.RegisterEnumDescriptor(_MESHCONFIG_H2UPGRADEPOLICY)
 
@@ -298,8 +298,8 @@ _MESHCONFIG_OUTBOUNDTRAFFICPOLICY = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=3350,
-  serialized_end=3523,
+  serialized_start=3555,
+  serialized_end=3728,
 )
 
 _MESHCONFIG_CERTIFICATEDATA = _descriptor.Descriptor(
@@ -355,8 +355,8 @@ _MESHCONFIG_CERTIFICATEDATA = _descriptor.Descriptor(
       create_key=_descriptor._internal_create_key,
     fields=[]),
   ],
-  serialized_start=3526,
-  serialized_end=3701,
+  serialized_start=3731,
+  serialized_end=3906,
 )
 
 _MESHCONFIG_THRIFTCONFIG = _descriptor.Descriptor(
@@ -393,8 +393,8 @@ _MESHCONFIG_THRIFTCONFIG = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=3703,
-  serialized_end=3828,
+  serialized_start=3908,
+  serialized_end=4033,
 )
 
 _MESHCONFIG_SERVICESETTINGS_SETTINGS = _descriptor.Descriptor(
@@ -424,8 +424,8 @@ _MESHCONFIG_SERVICESETTINGS_SETTINGS = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=3958,
-  serialized_end=4005,
+  serialized_start=4163,
+  serialized_end=4210,
 )
 
 _MESHCONFIG_SERVICESETTINGS = _descriptor.Descriptor(
@@ -462,8 +462,8 @@ _MESHCONFIG_SERVICESETTINGS = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=3831,
-  serialized_end=4005,
+  serialized_start=4036,
+  serialized_end=4210,
 )
 
 _MESHCONFIG_CA = _descriptor.Descriptor(
@@ -514,8 +514,8 @@ _MESHCONFIG_CA = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=4008,
-  serialized_end=4220,
+  serialized_start=4213,
+  serialized_end=4425,
 )
 
 _MESHCONFIG_EXTENSIONPROVIDER_ENVOYEXTERNALAUTHORIZATIONREQUESTBODY = _descriptor.Descriptor(
@@ -559,8 +559,8 @@ _MESHCONFIG_EXTENSIONPROVIDER_ENVOYEXTERNALAUTHORIZATIONREQUESTBODY = _descripto
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=5435,
-  serialized_end=5606,
+  serialized_start=5640,
+  serialized_end=5811,
 )
 
 _MESHCONFIG_EXTENSIONPROVIDER_ENVOYEXTERNALAUTHORIZATIONHTTPPROVIDER_INCLUDEADDITIONALHEADERSINCHECKENTRY = _descriptor.Descriptor(
@@ -597,8 +597,8 @@ _MESHCONFIG_EXTENSIONPROVIDER_ENVOYEXTERNALAUTHORIZATIONHTTPPROVIDER_INCLUDEADDI
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=6473,
-  serialized_end=6555,
+  serialized_start=6678,
+  serialized_end=6760,
 )
 
 _MESHCONFIG_EXTENSIONPROVIDER_ENVOYEXTERNALAUTHORIZATIONHTTPPROVIDER = _descriptor.Descriptor(
@@ -705,8 +705,8 @@ _MESHCONFIG_EXTENSIONPROVIDER_ENVOYEXTERNALAUTHORIZATIONHTTPPROVIDER = _descript
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=5609,
-  serialized_end=6555,
+  serialized_start=5814,
+  serialized_end=6760,
 )
 
 _MESHCONFIG_EXTENSIONPROVIDER_ENVOYEXTERNALAUTHORIZATIONGRPCPROVIDER = _descriptor.Descriptor(
@@ -771,8 +771,8 @@ _MESHCONFIG_EXTENSIONPROVIDER_ENVOYEXTERNALAUTHORIZATIONGRPCPROVIDER = _descript
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=6558,
-  serialized_end=6922,
+  serialized_start=6763,
+  serialized_end=7127,
 )
 
 _MESHCONFIG_EXTENSIONPROVIDER_ZIPKINTRACINGPROVIDER = _descriptor.Descriptor(
@@ -816,8 +816,8 @@ _MESHCONFIG_EXTENSIONPROVIDER_ZIPKINTRACINGPROVIDER = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=6924,
-  serialized_end=7031,
+  serialized_start=7129,
+  serialized_end=7236,
 )
 
 _MESHCONFIG_EXTENSIONPROVIDER_LIGHTSTEPTRACINGPROVIDER = _descriptor.Descriptor(
@@ -868,8 +868,8 @@ _MESHCONFIG_EXTENSIONPROVIDER_LIGHTSTEPTRACINGPROVIDER = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=7034,
-  serialized_end=7179,
+  serialized_start=7239,
+  serialized_end=7384,
 )
 
 _MESHCONFIG_EXTENSIONPROVIDER_DATADOGTRACINGPROVIDER = _descriptor.Descriptor(
@@ -913,8 +913,8 @@ _MESHCONFIG_EXTENSIONPROVIDER_DATADOGTRACINGPROVIDER = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=7181,
-  serialized_end=7289,
+  serialized_start=7386,
+  serialized_end=7494,
 )
 
 _MESHCONFIG_EXTENSIONPROVIDER_SKYWALKINGTRACINGPROVIDER = _descriptor.Descriptor(
@@ -958,8 +958,8 @@ _MESHCONFIG_EXTENSIONPROVIDER_SKYWALKINGTRACINGPROVIDER = _descriptor.Descriptor
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=7291,
-  serialized_end=7399,
+  serialized_start=7496,
+  serialized_end=7604,
 )
 
 _MESHCONFIG_EXTENSIONPROVIDER_STACKDRIVERPROVIDER = _descriptor.Descriptor(
@@ -1017,8 +1017,8 @@ _MESHCONFIG_EXTENSIONPROVIDER_STACKDRIVERPROVIDER = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=7402,
-  serialized_end=7750,
+  serialized_start=7607,
+  serialized_end=7955,
 )
 
 _MESHCONFIG_EXTENSIONPROVIDER_OPENCENSUSAGENTTRACINGPROVIDER = _descriptor.Descriptor(
@@ -1070,8 +1070,8 @@ _MESHCONFIG_EXTENSIONPROVIDER_OPENCENSUSAGENTTRACINGPROVIDER = _descriptor.Descr
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=7753,
-  serialized_end=8093,
+  serialized_start=7958,
+  serialized_end=8298,
 )
 
 _MESHCONFIG_EXTENSIONPROVIDER_PROMETHEUSMETRICSPROVIDER = _descriptor.Descriptor(
@@ -1094,8 +1094,8 @@ _MESHCONFIG_EXTENSIONPROVIDER_PROMETHEUSMETRICSPROVIDER = _descriptor.Descriptor
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=8095,
-  serialized_end=8122,
+  serialized_start=8300,
+  serialized_end=8327,
 )
 
 _MESHCONFIG_EXTENSIONPROVIDER_ENVOYFILEACCESSLOGPROVIDER = _descriptor.Descriptor(
@@ -1125,8 +1125,8 @@ _MESHCONFIG_EXTENSIONPROVIDER_ENVOYFILEACCESSLOGPROVIDER = _descriptor.Descripto
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=8124,
-  serialized_end=8172,
+  serialized_start=8329,
+  serialized_end=8377,
 )
 
 _MESHCONFIG_EXTENSIONPROVIDER = _descriptor.Descriptor(
@@ -1231,8 +1231,8 @@ _MESHCONFIG_EXTENSIONPROVIDER = _descriptor.Descriptor(
       create_key=_descriptor._internal_create_key,
     fields=[]),
   ],
-  serialized_start=4223,
-  serialized_end=8184,
+  serialized_start=4428,
+  serialized_end=8389,
 )
 
 _MESHCONFIG_DEFAULTPROVIDERS = _descriptor.Descriptor(
@@ -1276,8 +1276,8 @@ _MESHCONFIG_DEFAULTPROVIDERS = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=8186,
-  serialized_end=8295,
+  serialized_start=8391,
+  serialized_end=8500,
 )
 
 _MESHCONFIG_PROXYPATHNORMALIZATION = _descriptor.Descriptor(
@@ -1308,8 +1308,46 @@ _MESHCONFIG_PROXYPATHNORMALIZATION = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=8298,
-  serialized_end=8537,
+  serialized_start=8503,
+  serialized_end=8742,
+)
+
+_MESHCONFIG_CRYPTOMBPRIVATEKEYCONFIG = _descriptor.Descriptor(
+  name='CryptombPrivateKeyConfig',
+  full_name='istio.mesh.v1alpha1.MeshConfig.CryptombPrivateKeyConfig',
+  filename=None,
+  file=DESCRIPTOR,
+  containing_type=None,
+  create_key=_descriptor._internal_create_key,
+  fields=[
+    _descriptor.FieldDescriptor(
+      name='enable_cryptomb', full_name='istio.mesh.v1alpha1.MeshConfig.CryptombPrivateKeyConfig.enable_cryptomb', index=0,
+      number=1, type=8, cpp_type=7, label=1,
+      has_default_value=False, default_value=False,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='enableCryptomb', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='pool_delay', full_name='istio.mesh.v1alpha1.MeshConfig.CryptombPrivateKeyConfig.pool_delay', index=1,
+      number=2, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='poolDelay', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+  ],
+  extensions=[
+  ],
+  nested_types=[],
+  enum_types=[
+  ],
+  serialized_options=None,
+  is_extendable=False,
+  syntax='proto3',
+  extension_ranges=[],
+  oneofs=[
+  ],
+  serialized_start=8744,
+  serialized_end=8869,
 )
 
 _MESHCONFIG = _descriptor.Descriptor(
@@ -1614,10 +1652,24 @@ _MESHCONFIG = _descriptor.Descriptor(
       message_type=None, enum_type=None, containing_type=None,
       is_extension=False, extension_scope=None,
       serialized_options=None, json_name='defaultHttpRetryPolicy', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='cryptomb_config', full_name='istio.mesh.v1alpha1.MeshConfig.cryptomb_config', index=42,
+      number=1001, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='cryptombConfig', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='mse_ingress_global_config', full_name='istio.mesh.v1alpha1.MeshConfig.mse_ingress_global_config', index=43,
+      number=1002, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='mseIngressGlobalConfig', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
   ],
   extensions=[
   ],
-  nested_types=[_MESHCONFIG_OUTBOUNDTRAFFICPOLICY, _MESHCONFIG_CERTIFICATEDATA, _MESHCONFIG_THRIFTCONFIG, _MESHCONFIG_SERVICESETTINGS, _MESHCONFIG_CA, _MESHCONFIG_EXTENSIONPROVIDER, _MESHCONFIG_DEFAULTPROVIDERS, _MESHCONFIG_PROXYPATHNORMALIZATION, ],
+  nested_types=[_MESHCONFIG_OUTBOUNDTRAFFICPOLICY, _MESHCONFIG_CERTIFICATEDATA, _MESHCONFIG_THRIFTCONFIG, _MESHCONFIG_SERVICESETTINGS, _MESHCONFIG_CA, _MESHCONFIG_EXTENSIONPROVIDER, _MESHCONFIG_DEFAULTPROVIDERS, _MESHCONFIG_PROXYPATHNORMALIZATION, _MESHCONFIG_CRYPTOMBPRIVATEKEYCONFIG, ],
   enum_types=[
     _MESHCONFIG_INGRESSCONTROLLERMODE,
     _MESHCONFIG_AUTHPOLICY,
@@ -1631,7 +1683,7 @@ _MESHCONFIG = _descriptor.Descriptor(
   oneofs=[
   ],
   serialized_start=284,
-  serialized_end=9277,
+  serialized_end=9609,
 )
 
 
@@ -1676,8 +1728,8 @@ _CONFIGSOURCE = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=9280,
-  serialized_end=9483,
+  serialized_start=9612,
+  serialized_end=9815,
 )
 
 
@@ -1715,8 +1767,61 @@ _CERTIFICATE = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=9485,
-  serialized_end=9560,
+  serialized_start=9817,
+  serialized_end=9892,
+)
+
+
+_MSEINGRESSGLOBALCONFIG = _descriptor.Descriptor(
+  name='MSEIngressGlobalConfig',
+  full_name='istio.mesh.v1alpha1.MSEIngressGlobalConfig',
+  filename=None,
+  file=DESCRIPTOR,
+  containing_type=None,
+  create_key=_descriptor._internal_create_key,
+  fields=[
+    _descriptor.FieldDescriptor(
+      name='tls_min_protocol_version', full_name='istio.mesh.v1alpha1.MSEIngressGlobalConfig.tls_min_protocol_version', index=0,
+      number=1, type=9, cpp_type=9, label=1,
+      has_default_value=False, default_value=b"".decode('utf-8'),
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='tlsMinProtocolVersion', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='tls_max_protocol_version', full_name='istio.mesh.v1alpha1.MSEIngressGlobalConfig.tls_max_protocol_version', index=1,
+      number=2, type=9, cpp_type=9, label=1,
+      has_default_value=False, default_value=b"".decode('utf-8'),
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='tlsMaxProtocolVersion', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='tls_cipher_suites', full_name='istio.mesh.v1alpha1.MSEIngressGlobalConfig.tls_cipher_suites', index=2,
+      number=3, type=9, cpp_type=9, label=3,
+      has_default_value=False, default_value=[],
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='tlsCipherSuites', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='upstream_idle_timeout', full_name='istio.mesh.v1alpha1.MSEIngressGlobalConfig.upstream_idle_timeout', index=3,
+      number=4, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='upstreamIdleTimeout', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+  ],
+  extensions=[
+  ],
+  nested_types=[],
+  enum_types=[
+  ],
+  serialized_options=None,
+  is_extendable=False,
+  syntax='proto3',
+  extension_ranges=[],
+  oneofs=[
+  ],
+  serialized_start=9895,
+  serialized_end=10156,
 )
 
 _MESHCONFIG_OUTBOUNDTRAFFICPOLICY.fields_by_name['mode'].enum_type = _MESHCONFIG_OUTBOUNDTRAFFICPOLICY_MODE
@@ -1804,6 +1909,8 @@ _MESHCONFIG_DEFAULTPROVIDERS.containing_type = _MESHCONFIG
 _MESHCONFIG_PROXYPATHNORMALIZATION.fields_by_name['normalization'].enum_type = _MESHCONFIG_PROXYPATHNORMALIZATION_NORMALIZATIONTYPE
 _MESHCONFIG_PROXYPATHNORMALIZATION.containing_type = _MESHCONFIG
 _MESHCONFIG_PROXYPATHNORMALIZATION_NORMALIZATIONTYPE.containing_type = _MESHCONFIG_PROXYPATHNORMALIZATION
+_MESHCONFIG_CRYPTOMBPRIVATEKEYCONFIG.fields_by_name['pool_delay'].message_type = google_dot_protobuf_dot_duration__pb2._DURATION
+_MESHCONFIG_CRYPTOMBPRIVATEKEYCONFIG.containing_type = _MESHCONFIG
 _MESHCONFIG.fields_by_name['connect_timeout'].message_type = google_dot_protobuf_dot_duration__pb2._DURATION
 _MESHCONFIG.fields_by_name['protocol_detection_timeout'].message_type = google_dot_protobuf_dot_duration__pb2._DURATION
 _MESHCONFIG.fields_by_name['tcp_keepalive'].message_type = networking_dot_v1alpha3_dot_destination__rule__pb2._CONNECTIONPOOLSETTINGS_TCPSETTINGS_TCPKEEPALIVE
@@ -1828,15 +1935,19 @@ _MESHCONFIG.fields_by_name['default_providers'].message_type = _MESHCONFIG_DEFAU
 _MESHCONFIG.fields_by_name['discovery_selectors'].message_type = k8s_dot_io_dot_apimachinery_dot_pkg_dot_apis_dot_meta_dot_v1_dot_generated__pb2._LABELSELECTOR
 _MESHCONFIG.fields_by_name['path_normalization'].message_type = _MESHCONFIG_PROXYPATHNORMALIZATION
 _MESHCONFIG.fields_by_name['default_http_retry_policy'].message_type = networking_dot_v1alpha3_dot_virtual__service__pb2._HTTPRETRY
+_MESHCONFIG.fields_by_name['cryptomb_config'].message_type = _MESHCONFIG_CRYPTOMBPRIVATEKEYCONFIG
+_MESHCONFIG.fields_by_name['mse_ingress_global_config'].message_type = _MSEINGRESSGLOBALCONFIG
 _MESHCONFIG_INGRESSCONTROLLERMODE.containing_type = _MESHCONFIG
 _MESHCONFIG_AUTHPOLICY.containing_type = _MESHCONFIG
 _MESHCONFIG_ACCESSLOGENCODING.containing_type = _MESHCONFIG
 _MESHCONFIG_H2UPGRADEPOLICY.containing_type = _MESHCONFIG
 _CONFIGSOURCE.fields_by_name['tls_settings'].message_type = networking_dot_v1alpha3_dot_destination__rule__pb2._CLIENTTLSSETTINGS
 _CONFIGSOURCE.fields_by_name['subscribed_resources'].enum_type = _RESOURCE
+_MSEINGRESSGLOBALCONFIG.fields_by_name['upstream_idle_timeout'].message_type = google_dot_protobuf_dot_duration__pb2._DURATION
 DESCRIPTOR.message_types_by_name['MeshConfig'] = _MESHCONFIG
 DESCRIPTOR.message_types_by_name['ConfigSource'] = _CONFIGSOURCE
 DESCRIPTOR.message_types_by_name['Certificate'] = _CERTIFICATE
+DESCRIPTOR.message_types_by_name['MSEIngressGlobalConfig'] = _MSEINGRESSGLOBALCONFIG
 DESCRIPTOR.enum_types_by_name['Resource'] = _RESOURCE
 _sym_db.RegisterFileDescriptor(DESCRIPTOR)
 
@@ -1988,6 +2099,13 @@ MeshConfig = _reflection.GeneratedProtocolMessageType('MeshConfig', (_message.Me
     # @@protoc_insertion_point(class_scope:istio.mesh.v1alpha1.MeshConfig.ProxyPathNormalization)
     })
   ,
+
+  'CryptombPrivateKeyConfig' : _reflection.GeneratedProtocolMessageType('CryptombPrivateKeyConfig', (_message.Message,), {
+    'DESCRIPTOR' : _MESHCONFIG_CRYPTOMBPRIVATEKEYCONFIG,
+    '__module__' : 'mesh.v1alpha1.config_pb2'
+    # @@protoc_insertion_point(class_scope:istio.mesh.v1alpha1.MeshConfig.CryptombPrivateKeyConfig)
+    })
+  ,
   'DESCRIPTOR' : _MESHCONFIG,
   '__module__' : 'mesh.v1alpha1.config_pb2'
   # @@protoc_insertion_point(class_scope:istio.mesh.v1alpha1.MeshConfig)
@@ -2014,6 +2132,7 @@ _sym_db.RegisterMessage(MeshConfig.ExtensionProvider.PrometheusMetricsProvider)
 _sym_db.RegisterMessage(MeshConfig.ExtensionProvider.EnvoyFileAccessLogProvider)
 _sym_db.RegisterMessage(MeshConfig.DefaultProviders)
 _sym_db.RegisterMessage(MeshConfig.ProxyPathNormalization)
+_sym_db.RegisterMessage(MeshConfig.CryptombPrivateKeyConfig)
 
 ConfigSource = _reflection.GeneratedProtocolMessageType('ConfigSource', (_message.Message,), {
   'DESCRIPTOR' : _CONFIGSOURCE,
@@ -2029,6 +2148,13 @@ Certificate = _reflection.GeneratedProtocolMessageType('Certificate', (_message.
   })
 _sym_db.RegisterMessage(Certificate)
 
+MSEIngressGlobalConfig = _reflection.GeneratedProtocolMessageType('MSEIngressGlobalConfig', (_message.Message,), {
+  'DESCRIPTOR' : _MSEINGRESSGLOBALCONFIG,
+  '__module__' : 'mesh.v1alpha1.config_pb2'
+  # @@protoc_insertion_point(class_scope:istio.mesh.v1alpha1.MSEIngressGlobalConfig)
+  })
+_sym_db.RegisterMessage(MSEIngressGlobalConfig)
+
 
 DESCRIPTOR._options = None
 _MESHCONFIG_EXTENSIONPROVIDER_ENVOYEXTERNALAUTHORIZATIONHTTPPROVIDER_INCLUDEADDITIONALHEADERSINCHECKENTRY._options = None
diff --git a/python/istio_api/mesh/v1alpha1/proxy_pb2.py b/python/istio_api/mesh/v1alpha1/proxy_pb2.py
index e3b39738..f6ab00ce 100644
--- a/python/istio_api/mesh/v1alpha1/proxy_pb2.py
+++ b/python/istio_api/mesh/v1alpha1/proxy_pb2.py
@@ -24,7 +24,7 @@ DESCRIPTOR = _descriptor.FileDescriptor(
   syntax='proto3',
   serialized_options=b'Z\032istio.io/api/mesh/v1alpha1',
   create_key=_descriptor._internal_create_key,
-  serialized_pb=b'\n\x19mesh/v1alpha1/proxy.proto\x12\x13istio.mesh.v1alpha1\x1a\x1egoogle/protobuf/duration.proto\x1a\x1egoogle/protobuf/wrappers.proto\x1a*networking/v1alpha3/destination_rule.proto\x1a(networking/v1alpha3/workload_group.proto\"\xa5\x0e\n\x07Tracing\x12=\n\x06zipkin\x18\x01 \x01(\x0b\x32#.istio.mesh.v1alpha1.Tracing.ZipkinH\x00R\x06zipkin\x12\x46\n\tlightstep\x18\x02 \x01(\x0b\x32&.istio.mesh.v1alpha1.Tracing.LightstepH\x00R\tlightstep\x12@\n\x07\x64\x61tadog\x18\x03 \x01(\x0b\x32$.istio.mesh.v1alpha1.Tracing.DatadogH\x00R\x07\x64\x61tadog\x12L\n\x0bstackdriver\x18\x04 \x01(\x0b\x32(.istio.mesh.v1alpha1.Tracing.StackdriverH\x00R\x0bstackdriver\x12Z\n\x11open_census_agent\x18\t \x01(\x0b\x32,.istio.mesh.v1alpha1.Tracing.OpenCensusAgentH\x00R\x0fopenCensusAgent\x12M\n\x0b\x63ustom_tags\x18\x05 \x03(\x0b\x32,.istio.mesh.v1alpha1.Tracing.CustomTagsEntryR\ncustomTags\x12-\n\x13max_path_tag_length\x18\x06 \x01(\rR\x10maxPathTagLength\x12\x1a\n\x08sampling\x18\x07 \x01(\x01R\x08sampling\x12O\n\x0ctls_settings\x18\x08 \x01(\x0b\x32,.istio.networking.v1alpha3.ClientTLSSettingsR\x0btlsSettings\x1a\"\n\x06Zipkin\x12\x18\n\x07\x61\x64\x64ress\x18\x01 \x01(\tR\x07\x61\x64\x64ress\x1aH\n\tLightstep\x12\x18\n\x07\x61\x64\x64ress\x18\x01 \x01(\tR\x07\x61\x64\x64ress\x12!\n\x0c\x61\x63\x63\x65ss_token\x18\x02 \x01(\tR\x0b\x61\x63\x63\x65ssToken\x1a#\n\x07\x44\x61tadog\x12\x18\n\x07\x61\x64\x64ress\x18\x01 \x01(\tR\x07\x61\x64\x64ress\x1a\xae\x02\n\x0bStackdriver\x12\x14\n\x05\x64\x65\x62ug\x18\x01 \x01(\x08R\x05\x64\x65\x62ug\x12T\n\x18max_number_of_attributes\x18\x02 \x01(\x0b\x32\x1b.google.protobuf.Int64ValueR\x15maxNumberOfAttributes\x12V\n\x19max_number_of_annotations\x18\x03 \x01(\x0b\x32\x1b.google.protobuf.Int64ValueR\x16maxNumberOfAnnotations\x12[\n\x1cmax_number_of_message_events\x18\x04 \x01(\x0b\x32\x1b.google.protobuf.Int64ValueR\x18maxNumberOfMessageEvents\x1a\xe7\x01\n\x0fOpenCensusAgent\x12\x18\n\x07\x61\x64\x64ress\x18\x01 \x01(\tR\x07\x61\x64\x64ress\x12S\n\x07\x63ontext\x18\x02 \x03(\x0e\x32\x39.istio.mesh.v1alpha1.Tracing.OpenCensusAgent.TraceContextR\x07\x63ontext\"e\n\x0cTraceContext\x12\x0f\n\x0bUNSPECIFIED\x10\x00\x12\x15\n\x11W3C_TRACE_CONTEXT\x10\x01\x12\x0c\n\x08GRPC_BIN\x10\x02\x12\x17\n\x13\x43LOUD_TRACE_CONTEXT\x10\x03\x12\x06\n\x02\x42\x33\x10\x04\x1a\xe9\x01\n\tCustomTag\x12@\n\x07literal\x18\x01 \x01(\x0b\x32$.istio.mesh.v1alpha1.Tracing.LiteralH\x00R\x07literal\x12L\n\x0b\x65nvironment\x18\x02 \x01(\x0b\x32(.istio.mesh.v1alpha1.Tracing.EnvironmentH\x00R\x0b\x65nvironment\x12\x44\n\x06header\x18\x03 \x01(\x0b\x32*.istio.mesh.v1alpha1.Tracing.RequestHeaderH\x00R\x06headerB\x06\n\x04type\x1a\x1f\n\x07Literal\x12\x14\n\x05value\x18\x01 \x01(\tR\x05value\x1a\x46\n\x0b\x45nvironment\x12\x12\n\x04name\x18\x01 \x01(\tR\x04name\x12#\n\rdefault_value\x18\x02 \x01(\tR\x0c\x64\x65\x66\x61ultValue\x1aH\n\rRequestHeader\x12\x12\n\x04name\x18\x01 \x01(\tR\x04name\x12#\n\rdefault_value\x18\x02 \x01(\tR\x0c\x64\x65\x66\x61ultValue\x1a\x65\n\x0f\x43ustomTagsEntry\x12\x10\n\x03key\x18\x01 \x01(\tR\x03key\x12<\n\x05value\x18\x02 \x01(\x0b\x32&.istio.mesh.v1alpha1.Tracing.CustomTagR\x05value:\x02\x38\x01\x42\x08\n\x06tracer\"F\n\x03SDS\x12\x18\n\x07\x65nabled\x18\x01 \x01(\x08R\x07\x65nabled\x12%\n\x0fk8s_sa_jwt_path\x18\x02 \x01(\tR\x0ck8sSaJwtPath\"\xbc\x02\n\x08Topology\x12.\n\x13num_trusted_proxies\x18\x01 \x01(\rR\x11numTrustedProxies\x12u\n\x1b\x66orward_client_cert_details\x18\x02 \x01(\x0e\x32\x36.istio.mesh.v1alpha1.Topology.ForwardClientCertDetailsR\x18\x66orwardClientCertDetails\"\x88\x01\n\x18\x46orwardClientCertDetails\x12\r\n\tUNDEFINED\x10\x00\x12\x0c\n\x08SANITIZE\x10\x01\x12\x10\n\x0c\x46ORWARD_ONLY\x10\x02\x12\x12\n\x0e\x41PPEND_FORWARD\x10\x03\x12\x10\n\x0cSANITIZE_SET\x10\x04\x12\x17\n\x13\x41LWAYS_FORWARD_ONLY\x10\x05\"\xe7\x12\n\x0bProxyConfig\x12\x1f\n\x0b\x63onfig_path\x18\x01 \x01(\tR\nconfigPath\x12\x1f\n\x0b\x62inary_path\x18\x02 \x01(\tR\nbinaryPath\x12\'\n\x0fservice_cluster\x18\x03 \x01(\tR\x0eserviceCluster\x12@\n\x0e\x64rain_duration\x18\x04 \x01(\x0b\x32\x19.google.protobuf.DurationR\rdrainDuration\x12S\n\x18parent_shutdown_duration\x18\x05 \x01(\x0b\x32\x19.google.protobuf.DurationR\x16parentShutdownDuration\x12+\n\x11\x64iscovery_address\x18\x06 \x01(\tR\x10\x64iscoveryAddress\x12U\n\x17\x64iscovery_refresh_delay\x18\x07 \x01(\x0b\x32\x19.google.protobuf.DurationB\x02\x18\x01R\x15\x64iscoveryRefreshDelay\x12)\n\x0ezipkin_address\x18\x08 \x01(\tB\x02\x18\x01R\rzipkinAddress\x12,\n\x12statsd_udp_address\x18\n \x01(\tR\x10statsdUdpAddress\x12\x45\n\x1d\x65nvoy_metrics_service_address\x18\x14 \x01(\tB\x02\x18\x01R\x1a\x65nvoyMetricsServiceAddress\x12(\n\x10proxy_admin_port\x18\x0b \x01(\x05R\x0eproxyAdminPort\x12/\n\x11\x61vailability_zone\x18\x0c \x01(\tB\x02\x18\x01R\x10\x61vailabilityZone\x12\x64\n\x19\x63ontrol_plane_auth_policy\x18\r \x01(\x0e\x32).istio.mesh.v1alpha1.AuthenticationPolicyR\x16\x63ontrolPlaneAuthPolicy\x12,\n\x12\x63ustom_config_file\x18\x0e \x01(\tR\x10\x63ustomConfigFile\x12(\n\x10stat_name_length\x18\x0f \x01(\x05R\x0estatNameLength\x12=\n\x0b\x63oncurrency\x18\x10 \x01(\x0b\x32\x1b.google.protobuf.Int32ValueR\x0b\x63oncurrency\x12\x41\n\x1dproxy_bootstrap_template_path\x18\x11 \x01(\tR\x1aproxyBootstrapTemplatePath\x12\x65\n\x11interception_mode\x18\x12 \x01(\x0e\x32\x38.istio.mesh.v1alpha1.ProxyConfig.InboundInterceptionModeR\x10interceptionMode\x12\x36\n\x07tracing\x18\x13 \x01(\x0b\x32\x1c.istio.mesh.v1alpha1.TracingR\x07tracing\x12*\n\x03sds\x18\x15 \x01(\x0b\x32\x18.istio.mesh.v1alpha1.SDSR\x03sds\x12[\n\x18\x65nvoy_access_log_service\x18\x16 \x01(\x0b\x32\".istio.mesh.v1alpha1.RemoteServiceR\x15\x65nvoyAccessLogService\x12V\n\x15\x65nvoy_metrics_service\x18\x17 \x01(\x0b\x32\".istio.mesh.v1alpha1.RemoteServiceR\x13\x65nvoyMetricsService\x12Z\n\x0eproxy_metadata\x18\x18 \x03(\x0b\x32\x33.istio.mesh.v1alpha1.ProxyConfig.ProxyMetadataEntryR\rproxyMetadata\x12\x1f\n\x0bstatus_port\x18\x1a \x01(\x05R\nstatusPort\x12&\n\x0f\x65xtra_stat_tags\x18\x1b \x03(\tR\rextraStatTags\x12H\n\x10gateway_topology\x18\x1c \x01(\x0b\x32\x1d.istio.mesh.v1alpha1.TopologyR\x0fgatewayTopology\x12W\n\x1atermination_drain_duration\x18\x1d \x01(\x0b\x32\x19.google.protobuf.DurationR\x18terminationDrainDuration\x12\x17\n\x07mesh_id\x18\x1e \x01(\tR\x06meshId\x12R\n\x0freadiness_probe\x18\x1f \x01(\x0b\x32).istio.networking.v1alpha3.ReadinessProbeR\x0ereadinessProbe\x12\x62\n\x13proxy_stats_matcher\x18  \x01(\x0b\x32\x32.istio.mesh.v1alpha1.ProxyConfig.ProxyStatsMatcherR\x11proxyStatsMatcher\x12h\n#hold_application_until_proxy_starts\x18! \x01(\x0b\x32\x1a.google.protobuf.BoolValueR\x1fholdApplicationUntilProxyStarts\x12.\n\x13\x63\x61_certificates_pem\x18\" \x03(\tR\x11\x63\x61\x43\x65rtificatesPem\x12\x35\n\x05image\x18# \x01(\x0b\x32\x1f.istio.mesh.v1alpha1.ProxyImageR\x05image\x1a@\n\x12ProxyMetadataEntry\x12\x10\n\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n\x05value\x18\x02 \x01(\tR\x05value:\x02\x38\x01\x1a\x9e\x01\n\x11ProxyStatsMatcher\x12-\n\x12inclusion_prefixes\x18\x01 \x03(\tR\x11inclusionPrefixes\x12-\n\x12inclusion_suffixes\x18\x02 \x03(\tR\x11inclusionSuffixes\x12+\n\x11inclusion_regexps\x18\x03 \x03(\tR\x10inclusionRegexps\"3\n\x17InboundInterceptionMode\x12\x0c\n\x08REDIRECT\x10\x00\x12\n\n\x06TPROXY\x10\x01J\x04\x08\t\x10\nR\x0f\x63onnect_timeout\"\xeb\x01\n\rRemoteService\x12\x18\n\x07\x61\x64\x64ress\x18\x01 \x01(\tR\x07\x61\x64\x64ress\x12O\n\x0ctls_settings\x18\x02 \x01(\x0b\x32,.istio.networking.v1alpha3.ClientTLSSettingsR\x0btlsSettings\x12o\n\rtcp_keepalive\x18\x03 \x01(\x0b\x32J.istio.networking.v1alpha3.ConnectionPoolSettings.TCPSettings.TcpKeepaliveR\x0ctcpKeepalive\"+\n\nProxyImage\x12\x1d\n\nimage_type\x18\x01 \x01(\tR\timageType*>\n\x14\x41uthenticationPolicy\x12\x08\n\x04NONE\x10\x00\x12\x0e\n\nMUTUAL_TLS\x10\x01\x12\x0c\n\x07INHERIT\x10\xe8\x07\x42\x1cZ\x1aistio.io/api/mesh/v1alpha1b\x06proto3'
+  serialized_pb=b'\n\x19mesh/v1alpha1/proxy.proto\x12\x13istio.mesh.v1alpha1\x1a\x1egoogle/protobuf/duration.proto\x1a\x1egoogle/protobuf/wrappers.proto\x1a*networking/v1alpha3/destination_rule.proto\x1a(networking/v1alpha3/workload_group.proto\"\xa2\x10\n\x07Tracing\x12=\n\x06zipkin\x18\x01 \x01(\x0b\x32#.istio.mesh.v1alpha1.Tracing.ZipkinH\x00R\x06zipkin\x12\x46\n\tlightstep\x18\x02 \x01(\x0b\x32&.istio.mesh.v1alpha1.Tracing.LightstepH\x00R\tlightstep\x12@\n\x07\x64\x61tadog\x18\x03 \x01(\x0b\x32$.istio.mesh.v1alpha1.Tracing.DatadogH\x00R\x07\x64\x61tadog\x12L\n\x0bstackdriver\x18\x04 \x01(\x0b\x32(.istio.mesh.v1alpha1.Tracing.StackdriverH\x00R\x0bstackdriver\x12Z\n\x11open_census_agent\x18\t \x01(\x0b\x32,.istio.mesh.v1alpha1.Tracing.OpenCensusAgentH\x00R\x0fopenCensusAgent\x12\x43\n\x08\x65\x61gleeye\x18\n \x01(\x0b\x32%.istio.mesh.v1alpha1.Tracing.EagleEyeH\x00R\x08\x65\x61gleeye\x12M\n\x0b\x63ustom_tags\x18\x05 \x03(\x0b\x32,.istio.mesh.v1alpha1.Tracing.CustomTagsEntryR\ncustomTags\x12-\n\x13max_path_tag_length\x18\x06 \x01(\rR\x10maxPathTagLength\x12\x1a\n\x08sampling\x18\x07 \x01(\x01R\x08sampling\x12O\n\x0ctls_settings\x18\x08 \x01(\x0b\x32,.istio.networking.v1alpha3.ClientTLSSettingsR\x0btlsSettings\x1a\"\n\x06Zipkin\x12\x18\n\x07\x61\x64\x64ress\x18\x01 \x01(\tR\x07\x61\x64\x64ress\x1aH\n\tLightstep\x12\x18\n\x07\x61\x64\x64ress\x18\x01 \x01(\tR\x07\x61\x64\x64ress\x12!\n\x0c\x61\x63\x63\x65ss_token\x18\x02 \x01(\tR\x0b\x61\x63\x63\x65ssToken\x1a#\n\x07\x44\x61tadog\x12\x18\n\x07\x61\x64\x64ress\x18\x01 \x01(\tR\x07\x61\x64\x64ress\x1a\xae\x02\n\x0bStackdriver\x12\x14\n\x05\x64\x65\x62ug\x18\x01 \x01(\x08R\x05\x64\x65\x62ug\x12T\n\x18max_number_of_attributes\x18\x02 \x01(\x0b\x32\x1b.google.protobuf.Int64ValueR\x15maxNumberOfAttributes\x12V\n\x19max_number_of_annotations\x18\x03 \x01(\x0b\x32\x1b.google.protobuf.Int64ValueR\x16maxNumberOfAnnotations\x12[\n\x1cmax_number_of_message_events\x18\x04 \x01(\x0b\x32\x1b.google.protobuf.Int64ValueR\x18maxNumberOfMessageEvents\x1a\xe7\x01\n\x0fOpenCensusAgent\x12\x18\n\x07\x61\x64\x64ress\x18\x01 \x01(\tR\x07\x61\x64\x64ress\x12S\n\x07\x63ontext\x18\x02 \x03(\x0e\x32\x39.istio.mesh.v1alpha1.Tracing.OpenCensusAgent.TraceContextR\x07\x63ontext\"e\n\x0cTraceContext\x12\x0f\n\x0bUNSPECIFIED\x10\x00\x12\x15\n\x11W3C_TRACE_CONTEXT\x10\x01\x12\x0c\n\x08GRPC_BIN\x10\x02\x12\x17\n\x13\x43LOUD_TRACE_CONTEXT\x10\x03\x12\x06\n\x02\x42\x33\x10\x04\x1a\xb5\x01\n\x08\x45\x61gleEye\x12%\n\x0fturn_on_rpc_log\x18\x01 \x01(\x08R\x0cturnOnRpcLog\x12/\n\x14turn_on_business_log\x18\x02 \x01(\x08R\x11turnOnBusinessLog\x12+\n\x11sampling_interval\x18\x03 \x01(\rR\x10samplingInterval\x12$\n\x0epass_user_data\x18\x04 \x01(\x08R\x0cpassUserData\x1a\xe9\x01\n\tCustomTag\x12@\n\x07literal\x18\x01 \x01(\x0b\x32$.istio.mesh.v1alpha1.Tracing.LiteralH\x00R\x07literal\x12L\n\x0b\x65nvironment\x18\x02 \x01(\x0b\x32(.istio.mesh.v1alpha1.Tracing.EnvironmentH\x00R\x0b\x65nvironment\x12\x44\n\x06header\x18\x03 \x01(\x0b\x32*.istio.mesh.v1alpha1.Tracing.RequestHeaderH\x00R\x06headerB\x06\n\x04type\x1a\x1f\n\x07Literal\x12\x14\n\x05value\x18\x01 \x01(\tR\x05value\x1a\x46\n\x0b\x45nvironment\x12\x12\n\x04name\x18\x01 \x01(\tR\x04name\x12#\n\rdefault_value\x18\x02 \x01(\tR\x0c\x64\x65\x66\x61ultValue\x1aH\n\rRequestHeader\x12\x12\n\x04name\x18\x01 \x01(\tR\x04name\x12#\n\rdefault_value\x18\x02 \x01(\tR\x0c\x64\x65\x66\x61ultValue\x1a\x65\n\x0f\x43ustomTagsEntry\x12\x10\n\x03key\x18\x01 \x01(\tR\x03key\x12<\n\x05value\x18\x02 \x01(\x0b\x32&.istio.mesh.v1alpha1.Tracing.CustomTagR\x05value:\x02\x38\x01\x42\x08\n\x06tracer\"F\n\x03SDS\x12\x18\n\x07\x65nabled\x18\x01 \x01(\x08R\x07\x65nabled\x12%\n\x0fk8s_sa_jwt_path\x18\x02 \x01(\tR\x0ck8sSaJwtPath\"\xbc\x02\n\x08Topology\x12.\n\x13num_trusted_proxies\x18\x01 \x01(\rR\x11numTrustedProxies\x12u\n\x1b\x66orward_client_cert_details\x18\x02 \x01(\x0e\x32\x36.istio.mesh.v1alpha1.Topology.ForwardClientCertDetailsR\x18\x66orwardClientCertDetails\"\x88\x01\n\x18\x46orwardClientCertDetails\x12\r\n\tUNDEFINED\x10\x00\x12\x0c\n\x08SANITIZE\x10\x01\x12\x10\n\x0c\x46ORWARD_ONLY\x10\x02\x12\x12\n\x0e\x41PPEND_FORWARD\x10\x03\x12\x10\n\x0cSANITIZE_SET\x10\x04\x12\x17\n\x13\x41LWAYS_FORWARD_ONLY\x10\x05\"\xac\x04\n\x16XModuleBootstrapConfig\x12\x1f\n\x0b\x63onfig_path\x18\x01 \x01(\tR\nconfigPath\x12*\n\x11\x63onfig_check_rate\x18\x02 \x01(\rR\x0f\x63onfigCheckRate\x12\x1d\n\nagent_sock\x18\x03 \x01(\tR\tagentSock\x12%\n\x0epunish_cluster\x18\x04 \x01(\tR\rpunishCluster\x12\x1f\n\x0bpunish_host\x18\x05 \x01(\tR\npunishHost\x12\x19\n\x08x5_proxy\x18\x06 \x01(\tR\x07x5Proxy\x12*\n\x11\x66low_sls_producer\x18\x07 \x01(\tR\x0f\x66lowSlsProducer\x12\x19\n\x08sls_port\x18\x08 \x01(\rR\x07slsPort\x12\x34\n\x16\x64\x65\x63ompress_buffer_size\x18\t \x01(\rR\x14\x64\x65\x63ompressBufferSize\x12\x1f\n\x0bsndbuf_size\x18\n \x01(\rR\nsndbufSize\x12\x1e\n\x0bmax_ipc_len\x18\x0b \x01(\rR\tmaxIpcLen\x12\x34\n\x16\x61\x62normal_report_enable\x18\x0c \x01(\x08R\x14\x61\x62normalReportEnable\x12\x1d\n\ncloud_mode\x18\r \x01(\x08R\tcloudMode\x12\x16\n\x06region\x18\x0e \x01(\tR\x06region\x12\x18\n\x07\x63luster\x18\x0f \x01(\tR\x07\x63luster\"\x9c\x15\n\x0bProxyConfig\x12\x1f\n\x0b\x63onfig_path\x18\x01 \x01(\tR\nconfigPath\x12\x1f\n\x0b\x62inary_path\x18\x02 \x01(\tR\nbinaryPath\x12\'\n\x0fservice_cluster\x18\x03 \x01(\tR\x0eserviceCluster\x12@\n\x0e\x64rain_duration\x18\x04 \x01(\x0b\x32\x19.google.protobuf.DurationR\rdrainDuration\x12S\n\x18parent_shutdown_duration\x18\x05 \x01(\x0b\x32\x19.google.protobuf.DurationR\x16parentShutdownDuration\x12+\n\x11\x64iscovery_address\x18\x06 \x01(\tR\x10\x64iscoveryAddress\x12U\n\x17\x64iscovery_refresh_delay\x18\x07 \x01(\x0b\x32\x19.google.protobuf.DurationB\x02\x18\x01R\x15\x64iscoveryRefreshDelay\x12)\n\x0ezipkin_address\x18\x08 \x01(\tB\x02\x18\x01R\rzipkinAddress\x12,\n\x12statsd_udp_address\x18\n \x01(\tR\x10statsdUdpAddress\x12\x45\n\x1d\x65nvoy_metrics_service_address\x18\x14 \x01(\tB\x02\x18\x01R\x1a\x65nvoyMetricsServiceAddress\x12(\n\x10proxy_admin_port\x18\x0b \x01(\x05R\x0eproxyAdminPort\x12/\n\x11\x61vailability_zone\x18\x0c \x01(\tB\x02\x18\x01R\x10\x61vailabilityZone\x12\x64\n\x19\x63ontrol_plane_auth_policy\x18\r \x01(\x0e\x32).istio.mesh.v1alpha1.AuthenticationPolicyR\x16\x63ontrolPlaneAuthPolicy\x12,\n\x12\x63ustom_config_file\x18\x0e \x01(\tR\x10\x63ustomConfigFile\x12(\n\x10stat_name_length\x18\x0f \x01(\x05R\x0estatNameLength\x12=\n\x0b\x63oncurrency\x18\x10 \x01(\x0b\x32\x1b.google.protobuf.Int32ValueR\x0b\x63oncurrency\x12\x41\n\x1dproxy_bootstrap_template_path\x18\x11 \x01(\tR\x1aproxyBootstrapTemplatePath\x12\x65\n\x11interception_mode\x18\x12 \x01(\x0e\x32\x38.istio.mesh.v1alpha1.ProxyConfig.InboundInterceptionModeR\x10interceptionMode\x12\x36\n\x07tracing\x18\x13 \x01(\x0b\x32\x1c.istio.mesh.v1alpha1.TracingR\x07tracing\x12*\n\x03sds\x18\x15 \x01(\x0b\x32\x18.istio.mesh.v1alpha1.SDSR\x03sds\x12[\n\x18\x65nvoy_access_log_service\x18\x16 \x01(\x0b\x32\".istio.mesh.v1alpha1.RemoteServiceR\x15\x65nvoyAccessLogService\x12V\n\x15\x65nvoy_metrics_service\x18\x17 \x01(\x0b\x32\".istio.mesh.v1alpha1.RemoteServiceR\x13\x65nvoyMetricsService\x12Z\n\x0eproxy_metadata\x18\x18 \x03(\x0b\x32\x33.istio.mesh.v1alpha1.ProxyConfig.ProxyMetadataEntryR\rproxyMetadata\x12Z\n\x0eruntime_values\x18% \x03(\x0b\x32\x33.istio.mesh.v1alpha1.ProxyConfig.RuntimeValuesEntryR\rruntimeValues\x12\x1f\n\x0bstatus_port\x18\x1a \x01(\x05R\nstatusPort\x12&\n\x0f\x65xtra_stat_tags\x18\x1b \x03(\tR\rextraStatTags\x12H\n\x10gateway_topology\x18\x1c \x01(\x0b\x32\x1d.istio.mesh.v1alpha1.TopologyR\x0fgatewayTopology\x12W\n\x1atermination_drain_duration\x18\x1d \x01(\x0b\x32\x19.google.protobuf.DurationR\x18terminationDrainDuration\x12\x17\n\x07mesh_id\x18\x1e \x01(\tR\x06meshId\x12R\n\x0freadiness_probe\x18\x1f \x01(\x0b\x32).istio.networking.v1alpha3.ReadinessProbeR\x0ereadinessProbe\x12\x62\n\x13proxy_stats_matcher\x18  \x01(\x0b\x32\x32.istio.mesh.v1alpha1.ProxyConfig.ProxyStatsMatcherR\x11proxyStatsMatcher\x12h\n#hold_application_until_proxy_starts\x18! \x01(\x0b\x32\x1a.google.protobuf.BoolValueR\x1fholdApplicationUntilProxyStarts\x12.\n\x13\x63\x61_certificates_pem\x18\" \x03(\tR\x11\x63\x61\x43\x65rtificatesPem\x12\x35\n\x05image\x18# \x01(\x0b\x32\x1f.istio.mesh.v1alpha1.ProxyImageR\x05image\x12\x19\n\x08log_path\x18\x64 \x01(\tR\x07logPath\x12R\n\x0exmodule_config\x18\x65 \x01(\x0b\x32+.istio.mesh.v1alpha1.XModuleBootstrapConfigR\rxmoduleConfig\x12&\n\x0f\x64isable_alpn_h2\x18n \x01(\x08R\rdisableAlpnH2\x1a@\n\x12ProxyMetadataEntry\x12\x10\n\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n\x05value\x18\x02 \x01(\tR\x05value:\x02\x38\x01\x1a@\n\x12RuntimeValuesEntry\x12\x10\n\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n\x05value\x18\x02 \x01(\tR\x05value:\x02\x38\x01\x1a\x9e\x01\n\x11ProxyStatsMatcher\x12-\n\x12inclusion_prefixes\x18\x01 \x03(\tR\x11inclusionPrefixes\x12-\n\x12inclusion_suffixes\x18\x02 \x03(\tR\x11inclusionSuffixes\x12+\n\x11inclusion_regexps\x18\x03 \x03(\tR\x10inclusionRegexps\"3\n\x17InboundInterceptionMode\x12\x0c\n\x08REDIRECT\x10\x00\x12\n\n\x06TPROXY\x10\x01J\x04\x08\t\x10\nR\x0f\x63onnect_timeout\"\xeb\x01\n\rRemoteService\x12\x18\n\x07\x61\x64\x64ress\x18\x01 \x01(\tR\x07\x61\x64\x64ress\x12O\n\x0ctls_settings\x18\x02 \x01(\x0b\x32,.istio.networking.v1alpha3.ClientTLSSettingsR\x0btlsSettings\x12o\n\rtcp_keepalive\x18\x03 \x01(\x0b\x32J.istio.networking.v1alpha3.ConnectionPoolSettings.TCPSettings.TcpKeepaliveR\x0ctcpKeepalive\"+\n\nProxyImage\x12\x1d\n\nimage_type\x18\x01 \x01(\tR\timageType*>\n\x14\x41uthenticationPolicy\x12\x08\n\x04NONE\x10\x00\x12\x0e\n\nMUTUAL_TLS\x10\x01\x12\x0c\n\x07INHERIT\x10\xe8\x07\x42\x1cZ\x1aistio.io/api/mesh/v1alpha1b\x06proto3'
   ,
   dependencies=[google_dot_protobuf_dot_duration__pb2.DESCRIPTOR,google_dot_protobuf_dot_wrappers__pb2.DESCRIPTOR,networking_dot_v1alpha3_dot_destination__rule__pb2.DESCRIPTOR,networking_dot_v1alpha3_dot_workload__group__pb2.DESCRIPTOR,])
 
@@ -53,8 +53,8 @@ _AUTHENTICATIONPOLICY = _descriptor.EnumDescriptor(
   ],
   containing_type=None,
   serialized_options=None,
-  serialized_start=5116,
-  serialized_end=5178,
+  serialized_start=6237,
+  serialized_end=6299,
 )
 _sym_db.RegisterEnumDescriptor(_AUTHENTICATIONPOLICY)
 
@@ -99,8 +99,8 @@ _TRACING_OPENCENSUSAGENT_TRACECONTEXT = _descriptor.EnumDescriptor(
   ],
   containing_type=None,
   serialized_options=None,
-  serialized_start=1401,
-  serialized_end=1502,
+  serialized_start=1470,
+  serialized_end=1571,
 )
 _sym_db.RegisterEnumDescriptor(_TRACING_OPENCENSUSAGENT_TRACECONTEXT)
 
@@ -144,8 +144,8 @@ _TOPOLOGY_FORWARDCLIENTCERTDETAILS = _descriptor.EnumDescriptor(
   ],
   containing_type=None,
   serialized_options=None,
-  serialized_start=2285,
-  serialized_end=2421,
+  serialized_start=2538,
+  serialized_end=2674,
 )
 _sym_db.RegisterEnumDescriptor(_TOPOLOGY_FORWARDCLIENTCERTDETAILS)
 
@@ -169,8 +169,8 @@ _PROXYCONFIG_INBOUNDINTERCEPTIONMODE = _descriptor.EnumDescriptor(
   ],
   containing_type=None,
   serialized_options=None,
-  serialized_start=4757,
-  serialized_end=4808,
+  serialized_start=5878,
+  serialized_end=5929,
 )
 _sym_db.RegisterEnumDescriptor(_PROXYCONFIG_INBOUNDINTERCEPTIONMODE)
 
@@ -202,8 +202,8 @@ _TRACING_ZIPKIN = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=818,
-  serialized_end=852,
+  serialized_start=887,
+  serialized_end=921,
 )
 
 _TRACING_LIGHTSTEP = _descriptor.Descriptor(
@@ -240,8 +240,8 @@ _TRACING_LIGHTSTEP = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=854,
-  serialized_end=926,
+  serialized_start=923,
+  serialized_end=995,
 )
 
 _TRACING_DATADOG = _descriptor.Descriptor(
@@ -271,8 +271,8 @@ _TRACING_DATADOG = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=928,
-  serialized_end=963,
+  serialized_start=997,
+  serialized_end=1032,
 )
 
 _TRACING_STACKDRIVER = _descriptor.Descriptor(
@@ -323,8 +323,8 @@ _TRACING_STACKDRIVER = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=966,
-  serialized_end=1268,
+  serialized_start=1035,
+  serialized_end=1337,
 )
 
 _TRACING_OPENCENSUSAGENT = _descriptor.Descriptor(
@@ -362,8 +362,60 @@ _TRACING_OPENCENSUSAGENT = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=1271,
-  serialized_end=1502,
+  serialized_start=1340,
+  serialized_end=1571,
+)
+
+_TRACING_EAGLEEYE = _descriptor.Descriptor(
+  name='EagleEye',
+  full_name='istio.mesh.v1alpha1.Tracing.EagleEye',
+  filename=None,
+  file=DESCRIPTOR,
+  containing_type=None,
+  create_key=_descriptor._internal_create_key,
+  fields=[
+    _descriptor.FieldDescriptor(
+      name='turn_on_rpc_log', full_name='istio.mesh.v1alpha1.Tracing.EagleEye.turn_on_rpc_log', index=0,
+      number=1, type=8, cpp_type=7, label=1,
+      has_default_value=False, default_value=False,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='turnOnRpcLog', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='turn_on_business_log', full_name='istio.mesh.v1alpha1.Tracing.EagleEye.turn_on_business_log', index=1,
+      number=2, type=8, cpp_type=7, label=1,
+      has_default_value=False, default_value=False,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='turnOnBusinessLog', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='sampling_interval', full_name='istio.mesh.v1alpha1.Tracing.EagleEye.sampling_interval', index=2,
+      number=3, type=13, cpp_type=3, label=1,
+      has_default_value=False, default_value=0,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='samplingInterval', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='pass_user_data', full_name='istio.mesh.v1alpha1.Tracing.EagleEye.pass_user_data', index=3,
+      number=4, type=8, cpp_type=7, label=1,
+      has_default_value=False, default_value=False,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='passUserData', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+  ],
+  extensions=[
+  ],
+  nested_types=[],
+  enum_types=[
+  ],
+  serialized_options=None,
+  is_extendable=False,
+  syntax='proto3',
+  extension_ranges=[],
+  oneofs=[
+  ],
+  serialized_start=1574,
+  serialized_end=1755,
 )
 
 _TRACING_CUSTOMTAG = _descriptor.Descriptor(
@@ -412,8 +464,8 @@ _TRACING_CUSTOMTAG = _descriptor.Descriptor(
       create_key=_descriptor._internal_create_key,
     fields=[]),
   ],
-  serialized_start=1505,
-  serialized_end=1738,
+  serialized_start=1758,
+  serialized_end=1991,
 )
 
 _TRACING_LITERAL = _descriptor.Descriptor(
@@ -443,8 +495,8 @@ _TRACING_LITERAL = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=1740,
-  serialized_end=1771,
+  serialized_start=1993,
+  serialized_end=2024,
 )
 
 _TRACING_ENVIRONMENT = _descriptor.Descriptor(
@@ -481,8 +533,8 @@ _TRACING_ENVIRONMENT = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=1773,
-  serialized_end=1843,
+  serialized_start=2026,
+  serialized_end=2096,
 )
 
 _TRACING_REQUESTHEADER = _descriptor.Descriptor(
@@ -519,8 +571,8 @@ _TRACING_REQUESTHEADER = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=1845,
-  serialized_end=1917,
+  serialized_start=2098,
+  serialized_end=2170,
 )
 
 _TRACING_CUSTOMTAGSENTRY = _descriptor.Descriptor(
@@ -557,8 +609,8 @@ _TRACING_CUSTOMTAGSENTRY = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=1919,
-  serialized_end=2020,
+  serialized_start=2172,
+  serialized_end=2273,
 )
 
 _TRACING = _descriptor.Descriptor(
@@ -605,28 +657,35 @@ _TRACING = _descriptor.Descriptor(
       is_extension=False, extension_scope=None,
       serialized_options=None, json_name='openCensusAgent', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
     _descriptor.FieldDescriptor(
-      name='custom_tags', full_name='istio.mesh.v1alpha1.Tracing.custom_tags', index=5,
+      name='eagleeye', full_name='istio.mesh.v1alpha1.Tracing.eagleeye', index=5,
+      number=10, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='eagleeye', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='custom_tags', full_name='istio.mesh.v1alpha1.Tracing.custom_tags', index=6,
       number=5, type=11, cpp_type=10, label=3,
       has_default_value=False, default_value=[],
       message_type=None, enum_type=None, containing_type=None,
       is_extension=False, extension_scope=None,
       serialized_options=None, json_name='customTags', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
     _descriptor.FieldDescriptor(
-      name='max_path_tag_length', full_name='istio.mesh.v1alpha1.Tracing.max_path_tag_length', index=6,
+      name='max_path_tag_length', full_name='istio.mesh.v1alpha1.Tracing.max_path_tag_length', index=7,
       number=6, type=13, cpp_type=3, label=1,
       has_default_value=False, default_value=0,
       message_type=None, enum_type=None, containing_type=None,
       is_extension=False, extension_scope=None,
       serialized_options=None, json_name='maxPathTagLength', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
     _descriptor.FieldDescriptor(
-      name='sampling', full_name='istio.mesh.v1alpha1.Tracing.sampling', index=7,
+      name='sampling', full_name='istio.mesh.v1alpha1.Tracing.sampling', index=8,
       number=7, type=1, cpp_type=5, label=1,
       has_default_value=False, default_value=float(0),
       message_type=None, enum_type=None, containing_type=None,
       is_extension=False, extension_scope=None,
       serialized_options=None, json_name='sampling', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
     _descriptor.FieldDescriptor(
-      name='tls_settings', full_name='istio.mesh.v1alpha1.Tracing.tls_settings', index=8,
+      name='tls_settings', full_name='istio.mesh.v1alpha1.Tracing.tls_settings', index=9,
       number=8, type=11, cpp_type=10, label=1,
       has_default_value=False, default_value=None,
       message_type=None, enum_type=None, containing_type=None,
@@ -635,7 +694,7 @@ _TRACING = _descriptor.Descriptor(
   ],
   extensions=[
   ],
-  nested_types=[_TRACING_ZIPKIN, _TRACING_LIGHTSTEP, _TRACING_DATADOG, _TRACING_STACKDRIVER, _TRACING_OPENCENSUSAGENT, _TRACING_CUSTOMTAG, _TRACING_LITERAL, _TRACING_ENVIRONMENT, _TRACING_REQUESTHEADER, _TRACING_CUSTOMTAGSENTRY, ],
+  nested_types=[_TRACING_ZIPKIN, _TRACING_LIGHTSTEP, _TRACING_DATADOG, _TRACING_STACKDRIVER, _TRACING_OPENCENSUSAGENT, _TRACING_EAGLEEYE, _TRACING_CUSTOMTAG, _TRACING_LITERAL, _TRACING_ENVIRONMENT, _TRACING_REQUESTHEADER, _TRACING_CUSTOMTAGSENTRY, ],
   enum_types=[
   ],
   serialized_options=None,
@@ -650,7 +709,7 @@ _TRACING = _descriptor.Descriptor(
     fields=[]),
   ],
   serialized_start=201,
-  serialized_end=2030,
+  serialized_end=2283,
 )
 
 
@@ -688,8 +747,8 @@ _SDS = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=2032,
-  serialized_end=2102,
+  serialized_start=2285,
+  serialized_end=2355,
 )
 
 
@@ -728,8 +787,138 @@ _TOPOLOGY = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=2105,
-  serialized_end=2421,
+  serialized_start=2358,
+  serialized_end=2674,
+)
+
+
+_XMODULEBOOTSTRAPCONFIG = _descriptor.Descriptor(
+  name='XModuleBootstrapConfig',
+  full_name='istio.mesh.v1alpha1.XModuleBootstrapConfig',
+  filename=None,
+  file=DESCRIPTOR,
+  containing_type=None,
+  create_key=_descriptor._internal_create_key,
+  fields=[
+    _descriptor.FieldDescriptor(
+      name='config_path', full_name='istio.mesh.v1alpha1.XModuleBootstrapConfig.config_path', index=0,
+      number=1, type=9, cpp_type=9, label=1,
+      has_default_value=False, default_value=b"".decode('utf-8'),
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='configPath', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='config_check_rate', full_name='istio.mesh.v1alpha1.XModuleBootstrapConfig.config_check_rate', index=1,
+      number=2, type=13, cpp_type=3, label=1,
+      has_default_value=False, default_value=0,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='configCheckRate', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='agent_sock', full_name='istio.mesh.v1alpha1.XModuleBootstrapConfig.agent_sock', index=2,
+      number=3, type=9, cpp_type=9, label=1,
+      has_default_value=False, default_value=b"".decode('utf-8'),
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='agentSock', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='punish_cluster', full_name='istio.mesh.v1alpha1.XModuleBootstrapConfig.punish_cluster', index=3,
+      number=4, type=9, cpp_type=9, label=1,
+      has_default_value=False, default_value=b"".decode('utf-8'),
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='punishCluster', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='punish_host', full_name='istio.mesh.v1alpha1.XModuleBootstrapConfig.punish_host', index=4,
+      number=5, type=9, cpp_type=9, label=1,
+      has_default_value=False, default_value=b"".decode('utf-8'),
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='punishHost', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='x5_proxy', full_name='istio.mesh.v1alpha1.XModuleBootstrapConfig.x5_proxy', index=5,
+      number=6, type=9, cpp_type=9, label=1,
+      has_default_value=False, default_value=b"".decode('utf-8'),
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='x5Proxy', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='flow_sls_producer', full_name='istio.mesh.v1alpha1.XModuleBootstrapConfig.flow_sls_producer', index=6,
+      number=7, type=9, cpp_type=9, label=1,
+      has_default_value=False, default_value=b"".decode('utf-8'),
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='flowSlsProducer', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='sls_port', full_name='istio.mesh.v1alpha1.XModuleBootstrapConfig.sls_port', index=7,
+      number=8, type=13, cpp_type=3, label=1,
+      has_default_value=False, default_value=0,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='slsPort', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='decompress_buffer_size', full_name='istio.mesh.v1alpha1.XModuleBootstrapConfig.decompress_buffer_size', index=8,
+      number=9, type=13, cpp_type=3, label=1,
+      has_default_value=False, default_value=0,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='decompressBufferSize', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='sndbuf_size', full_name='istio.mesh.v1alpha1.XModuleBootstrapConfig.sndbuf_size', index=9,
+      number=10, type=13, cpp_type=3, label=1,
+      has_default_value=False, default_value=0,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='sndbufSize', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='max_ipc_len', full_name='istio.mesh.v1alpha1.XModuleBootstrapConfig.max_ipc_len', index=10,
+      number=11, type=13, cpp_type=3, label=1,
+      has_default_value=False, default_value=0,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='maxIpcLen', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='abnormal_report_enable', full_name='istio.mesh.v1alpha1.XModuleBootstrapConfig.abnormal_report_enable', index=11,
+      number=12, type=8, cpp_type=7, label=1,
+      has_default_value=False, default_value=False,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='abnormalReportEnable', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='cloud_mode', full_name='istio.mesh.v1alpha1.XModuleBootstrapConfig.cloud_mode', index=12,
+      number=13, type=8, cpp_type=7, label=1,
+      has_default_value=False, default_value=False,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='cloudMode', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='region', full_name='istio.mesh.v1alpha1.XModuleBootstrapConfig.region', index=13,
+      number=14, type=9, cpp_type=9, label=1,
+      has_default_value=False, default_value=b"".decode('utf-8'),
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='region', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='cluster', full_name='istio.mesh.v1alpha1.XModuleBootstrapConfig.cluster', index=14,
+      number=15, type=9, cpp_type=9, label=1,
+      has_default_value=False, default_value=b"".decode('utf-8'),
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='cluster', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+  ],
+  extensions=[
+  ],
+  nested_types=[],
+  enum_types=[
+  ],
+  serialized_options=None,
+  is_extendable=False,
+  syntax='proto3',
+  extension_ranges=[],
+  oneofs=[
+  ],
+  serialized_start=2677,
+  serialized_end=3233,
 )
 
 
@@ -767,8 +956,46 @@ _PROXYCONFIG_PROXYMETADATAENTRY = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=4530,
-  serialized_end=4594,
+  serialized_start=5585,
+  serialized_end=5649,
+)
+
+_PROXYCONFIG_RUNTIMEVALUESENTRY = _descriptor.Descriptor(
+  name='RuntimeValuesEntry',
+  full_name='istio.mesh.v1alpha1.ProxyConfig.RuntimeValuesEntry',
+  filename=None,
+  file=DESCRIPTOR,
+  containing_type=None,
+  create_key=_descriptor._internal_create_key,
+  fields=[
+    _descriptor.FieldDescriptor(
+      name='key', full_name='istio.mesh.v1alpha1.ProxyConfig.RuntimeValuesEntry.key', index=0,
+      number=1, type=9, cpp_type=9, label=1,
+      has_default_value=False, default_value=b"".decode('utf-8'),
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='key', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='value', full_name='istio.mesh.v1alpha1.ProxyConfig.RuntimeValuesEntry.value', index=1,
+      number=2, type=9, cpp_type=9, label=1,
+      has_default_value=False, default_value=b"".decode('utf-8'),
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='value', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+  ],
+  extensions=[
+  ],
+  nested_types=[],
+  enum_types=[
+  ],
+  serialized_options=b'8\001',
+  is_extendable=False,
+  syntax='proto3',
+  extension_ranges=[],
+  oneofs=[
+  ],
+  serialized_start=5651,
+  serialized_end=5715,
 )
 
 _PROXYCONFIG_PROXYSTATSMATCHER = _descriptor.Descriptor(
@@ -812,8 +1039,8 @@ _PROXYCONFIG_PROXYSTATSMATCHER = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=4597,
-  serialized_end=4755,
+  serialized_start=5718,
+  serialized_end=5876,
 )
 
 _PROXYCONFIG = _descriptor.Descriptor(
@@ -986,79 +1213,107 @@ _PROXYCONFIG = _descriptor.Descriptor(
       is_extension=False, extension_scope=None,
       serialized_options=None, json_name='proxyMetadata', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
     _descriptor.FieldDescriptor(
-      name='status_port', full_name='istio.mesh.v1alpha1.ProxyConfig.status_port', index=23,
+      name='runtime_values', full_name='istio.mesh.v1alpha1.ProxyConfig.runtime_values', index=23,
+      number=37, type=11, cpp_type=10, label=3,
+      has_default_value=False, default_value=[],
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='runtimeValues', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='status_port', full_name='istio.mesh.v1alpha1.ProxyConfig.status_port', index=24,
       number=26, type=5, cpp_type=1, label=1,
       has_default_value=False, default_value=0,
       message_type=None, enum_type=None, containing_type=None,
       is_extension=False, extension_scope=None,
       serialized_options=None, json_name='statusPort', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
     _descriptor.FieldDescriptor(
-      name='extra_stat_tags', full_name='istio.mesh.v1alpha1.ProxyConfig.extra_stat_tags', index=24,
+      name='extra_stat_tags', full_name='istio.mesh.v1alpha1.ProxyConfig.extra_stat_tags', index=25,
       number=27, type=9, cpp_type=9, label=3,
       has_default_value=False, default_value=[],
       message_type=None, enum_type=None, containing_type=None,
       is_extension=False, extension_scope=None,
       serialized_options=None, json_name='extraStatTags', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
     _descriptor.FieldDescriptor(
-      name='gateway_topology', full_name='istio.mesh.v1alpha1.ProxyConfig.gateway_topology', index=25,
+      name='gateway_topology', full_name='istio.mesh.v1alpha1.ProxyConfig.gateway_topology', index=26,
       number=28, type=11, cpp_type=10, label=1,
       has_default_value=False, default_value=None,
       message_type=None, enum_type=None, containing_type=None,
       is_extension=False, extension_scope=None,
       serialized_options=None, json_name='gatewayTopology', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
     _descriptor.FieldDescriptor(
-      name='termination_drain_duration', full_name='istio.mesh.v1alpha1.ProxyConfig.termination_drain_duration', index=26,
+      name='termination_drain_duration', full_name='istio.mesh.v1alpha1.ProxyConfig.termination_drain_duration', index=27,
       number=29, type=11, cpp_type=10, label=1,
       has_default_value=False, default_value=None,
       message_type=None, enum_type=None, containing_type=None,
       is_extension=False, extension_scope=None,
       serialized_options=None, json_name='terminationDrainDuration', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
     _descriptor.FieldDescriptor(
-      name='mesh_id', full_name='istio.mesh.v1alpha1.ProxyConfig.mesh_id', index=27,
+      name='mesh_id', full_name='istio.mesh.v1alpha1.ProxyConfig.mesh_id', index=28,
       number=30, type=9, cpp_type=9, label=1,
       has_default_value=False, default_value=b"".decode('utf-8'),
       message_type=None, enum_type=None, containing_type=None,
       is_extension=False, extension_scope=None,
       serialized_options=None, json_name='meshId', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
     _descriptor.FieldDescriptor(
-      name='readiness_probe', full_name='istio.mesh.v1alpha1.ProxyConfig.readiness_probe', index=28,
+      name='readiness_probe', full_name='istio.mesh.v1alpha1.ProxyConfig.readiness_probe', index=29,
       number=31, type=11, cpp_type=10, label=1,
       has_default_value=False, default_value=None,
       message_type=None, enum_type=None, containing_type=None,
       is_extension=False, extension_scope=None,
       serialized_options=None, json_name='readinessProbe', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
     _descriptor.FieldDescriptor(
-      name='proxy_stats_matcher', full_name='istio.mesh.v1alpha1.ProxyConfig.proxy_stats_matcher', index=29,
+      name='proxy_stats_matcher', full_name='istio.mesh.v1alpha1.ProxyConfig.proxy_stats_matcher', index=30,
       number=32, type=11, cpp_type=10, label=1,
       has_default_value=False, default_value=None,
       message_type=None, enum_type=None, containing_type=None,
       is_extension=False, extension_scope=None,
       serialized_options=None, json_name='proxyStatsMatcher', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
     _descriptor.FieldDescriptor(
-      name='hold_application_until_proxy_starts', full_name='istio.mesh.v1alpha1.ProxyConfig.hold_application_until_proxy_starts', index=30,
+      name='hold_application_until_proxy_starts', full_name='istio.mesh.v1alpha1.ProxyConfig.hold_application_until_proxy_starts', index=31,
       number=33, type=11, cpp_type=10, label=1,
       has_default_value=False, default_value=None,
       message_type=None, enum_type=None, containing_type=None,
       is_extension=False, extension_scope=None,
       serialized_options=None, json_name='holdApplicationUntilProxyStarts', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
     _descriptor.FieldDescriptor(
-      name='ca_certificates_pem', full_name='istio.mesh.v1alpha1.ProxyConfig.ca_certificates_pem', index=31,
+      name='ca_certificates_pem', full_name='istio.mesh.v1alpha1.ProxyConfig.ca_certificates_pem', index=32,
       number=34, type=9, cpp_type=9, label=3,
       has_default_value=False, default_value=[],
       message_type=None, enum_type=None, containing_type=None,
       is_extension=False, extension_scope=None,
       serialized_options=None, json_name='caCertificatesPem', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
     _descriptor.FieldDescriptor(
-      name='image', full_name='istio.mesh.v1alpha1.ProxyConfig.image', index=32,
+      name='image', full_name='istio.mesh.v1alpha1.ProxyConfig.image', index=33,
       number=35, type=11, cpp_type=10, label=1,
       has_default_value=False, default_value=None,
       message_type=None, enum_type=None, containing_type=None,
       is_extension=False, extension_scope=None,
       serialized_options=None, json_name='image', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='log_path', full_name='istio.mesh.v1alpha1.ProxyConfig.log_path', index=34,
+      number=100, type=9, cpp_type=9, label=1,
+      has_default_value=False, default_value=b"".decode('utf-8'),
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='logPath', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='xmodule_config', full_name='istio.mesh.v1alpha1.ProxyConfig.xmodule_config', index=35,
+      number=101, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='xmoduleConfig', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='disable_alpn_h2', full_name='istio.mesh.v1alpha1.ProxyConfig.disable_alpn_h2', index=36,
+      number=110, type=8, cpp_type=7, label=1,
+      has_default_value=False, default_value=False,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='disableAlpnH2', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
   ],
   extensions=[
   ],
-  nested_types=[_PROXYCONFIG_PROXYMETADATAENTRY, _PROXYCONFIG_PROXYSTATSMATCHER, ],
+  nested_types=[_PROXYCONFIG_PROXYMETADATAENTRY, _PROXYCONFIG_RUNTIMEVALUESENTRY, _PROXYCONFIG_PROXYSTATSMATCHER, ],
   enum_types=[
     _PROXYCONFIG_INBOUNDINTERCEPTIONMODE,
   ],
@@ -1068,8 +1323,8 @@ _PROXYCONFIG = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=2424,
-  serialized_end=4831,
+  serialized_start=3236,
+  serialized_end=5952,
 )
 
 
@@ -1114,8 +1369,8 @@ _REMOTESERVICE = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=4834,
-  serialized_end=5069,
+  serialized_start=5955,
+  serialized_end=6190,
 )
 
 
@@ -1146,8 +1401,8 @@ _PROXYIMAGE = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=5071,
-  serialized_end=5114,
+  serialized_start=6192,
+  serialized_end=6235,
 )
 
 _TRACING_ZIPKIN.containing_type = _TRACING
@@ -1160,6 +1415,7 @@ _TRACING_STACKDRIVER.containing_type = _TRACING
 _TRACING_OPENCENSUSAGENT.fields_by_name['context'].enum_type = _TRACING_OPENCENSUSAGENT_TRACECONTEXT
 _TRACING_OPENCENSUSAGENT.containing_type = _TRACING
 _TRACING_OPENCENSUSAGENT_TRACECONTEXT.containing_type = _TRACING_OPENCENSUSAGENT
+_TRACING_EAGLEEYE.containing_type = _TRACING
 _TRACING_CUSTOMTAG.fields_by_name['literal'].message_type = _TRACING_LITERAL
 _TRACING_CUSTOMTAG.fields_by_name['environment'].message_type = _TRACING_ENVIRONMENT
 _TRACING_CUSTOMTAG.fields_by_name['header'].message_type = _TRACING_REQUESTHEADER
@@ -1183,6 +1439,7 @@ _TRACING.fields_by_name['lightstep'].message_type = _TRACING_LIGHTSTEP
 _TRACING.fields_by_name['datadog'].message_type = _TRACING_DATADOG
 _TRACING.fields_by_name['stackdriver'].message_type = _TRACING_STACKDRIVER
 _TRACING.fields_by_name['open_census_agent'].message_type = _TRACING_OPENCENSUSAGENT
+_TRACING.fields_by_name['eagleeye'].message_type = _TRACING_EAGLEEYE
 _TRACING.fields_by_name['custom_tags'].message_type = _TRACING_CUSTOMTAGSENTRY
 _TRACING.fields_by_name['tls_settings'].message_type = networking_dot_v1alpha3_dot_destination__rule__pb2._CLIENTTLSSETTINGS
 _TRACING.oneofs_by_name['tracer'].fields.append(
@@ -1200,9 +1457,13 @@ _TRACING.fields_by_name['stackdriver'].containing_oneof = _TRACING.oneofs_by_nam
 _TRACING.oneofs_by_name['tracer'].fields.append(
   _TRACING.fields_by_name['open_census_agent'])
 _TRACING.fields_by_name['open_census_agent'].containing_oneof = _TRACING.oneofs_by_name['tracer']
+_TRACING.oneofs_by_name['tracer'].fields.append(
+  _TRACING.fields_by_name['eagleeye'])
+_TRACING.fields_by_name['eagleeye'].containing_oneof = _TRACING.oneofs_by_name['tracer']
 _TOPOLOGY.fields_by_name['forward_client_cert_details'].enum_type = _TOPOLOGY_FORWARDCLIENTCERTDETAILS
 _TOPOLOGY_FORWARDCLIENTCERTDETAILS.containing_type = _TOPOLOGY
 _PROXYCONFIG_PROXYMETADATAENTRY.containing_type = _PROXYCONFIG
+_PROXYCONFIG_RUNTIMEVALUESENTRY.containing_type = _PROXYCONFIG
 _PROXYCONFIG_PROXYSTATSMATCHER.containing_type = _PROXYCONFIG
 _PROXYCONFIG.fields_by_name['drain_duration'].message_type = google_dot_protobuf_dot_duration__pb2._DURATION
 _PROXYCONFIG.fields_by_name['parent_shutdown_duration'].message_type = google_dot_protobuf_dot_duration__pb2._DURATION
@@ -1215,18 +1476,21 @@ _PROXYCONFIG.fields_by_name['sds'].message_type = _SDS
 _PROXYCONFIG.fields_by_name['envoy_access_log_service'].message_type = _REMOTESERVICE
 _PROXYCONFIG.fields_by_name['envoy_metrics_service'].message_type = _REMOTESERVICE
 _PROXYCONFIG.fields_by_name['proxy_metadata'].message_type = _PROXYCONFIG_PROXYMETADATAENTRY
+_PROXYCONFIG.fields_by_name['runtime_values'].message_type = _PROXYCONFIG_RUNTIMEVALUESENTRY
 _PROXYCONFIG.fields_by_name['gateway_topology'].message_type = _TOPOLOGY
 _PROXYCONFIG.fields_by_name['termination_drain_duration'].message_type = google_dot_protobuf_dot_duration__pb2._DURATION
 _PROXYCONFIG.fields_by_name['readiness_probe'].message_type = networking_dot_v1alpha3_dot_workload__group__pb2._READINESSPROBE
 _PROXYCONFIG.fields_by_name['proxy_stats_matcher'].message_type = _PROXYCONFIG_PROXYSTATSMATCHER
 _PROXYCONFIG.fields_by_name['hold_application_until_proxy_starts'].message_type = google_dot_protobuf_dot_wrappers__pb2._BOOLVALUE
 _PROXYCONFIG.fields_by_name['image'].message_type = _PROXYIMAGE
+_PROXYCONFIG.fields_by_name['xmodule_config'].message_type = _XMODULEBOOTSTRAPCONFIG
 _PROXYCONFIG_INBOUNDINTERCEPTIONMODE.containing_type = _PROXYCONFIG
 _REMOTESERVICE.fields_by_name['tls_settings'].message_type = networking_dot_v1alpha3_dot_destination__rule__pb2._CLIENTTLSSETTINGS
 _REMOTESERVICE.fields_by_name['tcp_keepalive'].message_type = networking_dot_v1alpha3_dot_destination__rule__pb2._CONNECTIONPOOLSETTINGS_TCPSETTINGS_TCPKEEPALIVE
 DESCRIPTOR.message_types_by_name['Tracing'] = _TRACING
 DESCRIPTOR.message_types_by_name['SDS'] = _SDS
 DESCRIPTOR.message_types_by_name['Topology'] = _TOPOLOGY
+DESCRIPTOR.message_types_by_name['XModuleBootstrapConfig'] = _XMODULEBOOTSTRAPCONFIG
 DESCRIPTOR.message_types_by_name['ProxyConfig'] = _PROXYCONFIG
 DESCRIPTOR.message_types_by_name['RemoteService'] = _REMOTESERVICE
 DESCRIPTOR.message_types_by_name['ProxyImage'] = _PROXYIMAGE
@@ -1270,6 +1534,13 @@ Tracing = _reflection.GeneratedProtocolMessageType('Tracing', (_message.Message,
     })
   ,
 
+  'EagleEye' : _reflection.GeneratedProtocolMessageType('EagleEye', (_message.Message,), {
+    'DESCRIPTOR' : _TRACING_EAGLEEYE,
+    '__module__' : 'mesh.v1alpha1.proxy_pb2'
+    # @@protoc_insertion_point(class_scope:istio.mesh.v1alpha1.Tracing.EagleEye)
+    })
+  ,
+
   'CustomTag' : _reflection.GeneratedProtocolMessageType('CustomTag', (_message.Message,), {
     'DESCRIPTOR' : _TRACING_CUSTOMTAG,
     '__module__' : 'mesh.v1alpha1.proxy_pb2'
@@ -1314,6 +1585,7 @@ _sym_db.RegisterMessage(Tracing.Lightstep)
 _sym_db.RegisterMessage(Tracing.Datadog)
 _sym_db.RegisterMessage(Tracing.Stackdriver)
 _sym_db.RegisterMessage(Tracing.OpenCensusAgent)
+_sym_db.RegisterMessage(Tracing.EagleEye)
 _sym_db.RegisterMessage(Tracing.CustomTag)
 _sym_db.RegisterMessage(Tracing.Literal)
 _sym_db.RegisterMessage(Tracing.Environment)
@@ -1334,6 +1606,13 @@ Topology = _reflection.GeneratedProtocolMessageType('Topology', (_message.Messag
   })
 _sym_db.RegisterMessage(Topology)
 
+XModuleBootstrapConfig = _reflection.GeneratedProtocolMessageType('XModuleBootstrapConfig', (_message.Message,), {
+  'DESCRIPTOR' : _XMODULEBOOTSTRAPCONFIG,
+  '__module__' : 'mesh.v1alpha1.proxy_pb2'
+  # @@protoc_insertion_point(class_scope:istio.mesh.v1alpha1.XModuleBootstrapConfig)
+  })
+_sym_db.RegisterMessage(XModuleBootstrapConfig)
+
 ProxyConfig = _reflection.GeneratedProtocolMessageType('ProxyConfig', (_message.Message,), {
 
   'ProxyMetadataEntry' : _reflection.GeneratedProtocolMessageType('ProxyMetadataEntry', (_message.Message,), {
@@ -1343,6 +1622,13 @@ ProxyConfig = _reflection.GeneratedProtocolMessageType('ProxyConfig', (_message.
     })
   ,
 
+  'RuntimeValuesEntry' : _reflection.GeneratedProtocolMessageType('RuntimeValuesEntry', (_message.Message,), {
+    'DESCRIPTOR' : _PROXYCONFIG_RUNTIMEVALUESENTRY,
+    '__module__' : 'mesh.v1alpha1.proxy_pb2'
+    # @@protoc_insertion_point(class_scope:istio.mesh.v1alpha1.ProxyConfig.RuntimeValuesEntry)
+    })
+  ,
+
   'ProxyStatsMatcher' : _reflection.GeneratedProtocolMessageType('ProxyStatsMatcher', (_message.Message,), {
     'DESCRIPTOR' : _PROXYCONFIG_PROXYSTATSMATCHER,
     '__module__' : 'mesh.v1alpha1.proxy_pb2'
@@ -1355,6 +1641,7 @@ ProxyConfig = _reflection.GeneratedProtocolMessageType('ProxyConfig', (_message.
   })
 _sym_db.RegisterMessage(ProxyConfig)
 _sym_db.RegisterMessage(ProxyConfig.ProxyMetadataEntry)
+_sym_db.RegisterMessage(ProxyConfig.RuntimeValuesEntry)
 _sym_db.RegisterMessage(ProxyConfig.ProxyStatsMatcher)
 
 RemoteService = _reflection.GeneratedProtocolMessageType('RemoteService', (_message.Message,), {
@@ -1375,6 +1662,7 @@ _sym_db.RegisterMessage(ProxyImage)
 DESCRIPTOR._options = None
 _TRACING_CUSTOMTAGSENTRY._options = None
 _PROXYCONFIG_PROXYMETADATAENTRY._options = None
+_PROXYCONFIG_RUNTIMEVALUESENTRY._options = None
 _PROXYCONFIG.fields_by_name['discovery_refresh_delay']._options = None
 _PROXYCONFIG.fields_by_name['zipkin_address']._options = None
 _PROXYCONFIG.fields_by_name['envoy_metrics_service_address']._options = None
diff --git a/python/istio_api/networking/v1alpha3/destination_rule_pb2.py b/python/istio_api/networking/v1alpha3/destination_rule_pb2.py
index 2372a1b9..65d78663 100644
--- a/python/istio_api/networking/v1alpha3/destination_rule_pb2.py
+++ b/python/istio_api/networking/v1alpha3/destination_rule_pb2.py
@@ -2,6 +2,7 @@
 # Generated by the protocol buffer compiler.  DO NOT EDIT!
 # source: networking/v1alpha3/destination_rule.proto
 """Generated protocol buffer code."""
+from google.protobuf.internal import enum_type_wrapper
 from google.protobuf import descriptor as _descriptor
 from google.protobuf import message as _message
 from google.protobuf import reflection as _reflection
@@ -24,10 +25,62 @@ DESCRIPTOR = _descriptor.FileDescriptor(
   syntax='proto3',
   serialized_options=b'Z istio.io/api/networking/v1alpha3',
   create_key=_descriptor._internal_create_key,
-  serialized_pb=b'\n*networking/v1alpha3/destination_rule.proto\x12\x19istio.networking.v1alpha3\x1a\x1fgoogle/api/field_behavior.proto\x1a\x1egoogle/protobuf/duration.proto\x1a\x1egoogle/protobuf/wrappers.proto\x1a)networking/v1alpha3/virtual_service.proto\x1a\x14gogoproto/gogo.proto\"\xd6\x01\n\x0f\x44\x65stinationRule\x12\x18\n\x04host\x18\x01 \x01(\tB\x04\xe2\x41\x01\x02R\x04host\x12O\n\x0etraffic_policy\x18\x02 \x01(\x0b\x32(.istio.networking.v1alpha3.TrafficPolicyR\rtrafficPolicy\x12;\n\x07subsets\x18\x03 \x03(\x0b\x32!.istio.networking.v1alpha3.SubsetR\x07subsets\x12\x1b\n\texport_to\x18\x04 \x03(\tR\x08\x65xportTo\"\xe6\x06\n\rTrafficPolicy\x12T\n\rload_balancer\x18\x01 \x01(\x0b\x32/.istio.networking.v1alpha3.LoadBalancerSettingsR\x0cloadBalancer\x12Z\n\x0f\x63onnection_pool\x18\x02 \x01(\x0b\x32\x31.istio.networking.v1alpha3.ConnectionPoolSettingsR\x0e\x63onnectionPool\x12X\n\x11outlier_detection\x18\x03 \x01(\x0b\x32+.istio.networking.v1alpha3.OutlierDetectionR\x10outlierDetection\x12>\n\x03tls\x18\x04 \x01(\x0b\x32,.istio.networking.v1alpha3.ClientTLSSettingsR\x03tls\x12j\n\x13port_level_settings\x18\x05 \x03(\x0b\x32:.istio.networking.v1alpha3.TrafficPolicy.PortTrafficPolicyR\x11portLevelSettings\x1a\x9c\x03\n\x11PortTrafficPolicy\x12;\n\x04port\x18\x01 \x01(\x0b\x32\'.istio.networking.v1alpha3.PortSelectorR\x04port\x12T\n\rload_balancer\x18\x02 \x01(\x0b\x32/.istio.networking.v1alpha3.LoadBalancerSettingsR\x0cloadBalancer\x12Z\n\x0f\x63onnection_pool\x18\x03 \x01(\x0b\x32\x31.istio.networking.v1alpha3.ConnectionPoolSettingsR\x0e\x63onnectionPool\x12X\n\x11outlier_detection\x18\x04 \x01(\x0b\x32+.istio.networking.v1alpha3.OutlierDetectionR\x10outlierDetection\x12>\n\x03tls\x18\x05 \x01(\x0b\x32,.istio.networking.v1alpha3.ClientTLSSettingsR\x03tls\"\xf5\x01\n\x06Subset\x12\x18\n\x04name\x18\x01 \x01(\tB\x04\xe2\x41\x01\x02R\x04name\x12\x45\n\x06labels\x18\x02 \x03(\x0b\x32-.istio.networking.v1alpha3.Subset.LabelsEntryR\x06labels\x12O\n\x0etraffic_policy\x18\x03 \x01(\x0b\x32(.istio.networking.v1alpha3.TrafficPolicyR\rtrafficPolicy\x1a\x39\n\x0bLabelsEntry\x12\x10\n\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n\x05value\x18\x02 \x01(\tR\x05value:\x02\x38\x01\"\xd1\x06\n\x14LoadBalancerSettings\x12R\n\x06simple\x18\x01 \x01(\x0e\x32\x38.istio.networking.v1alpha3.LoadBalancerSettings.SimpleLBH\x00R\x06simple\x12k\n\x0f\x63onsistent_hash\x18\x02 \x01(\x0b\x32@.istio.networking.v1alpha3.LoadBalancerSettings.ConsistentHashLBH\x00R\x0e\x63onsistentHash\x12\x66\n\x13locality_lb_setting\x18\x03 \x01(\x0b\x32\x36.istio.networking.v1alpha3.LocalityLoadBalancerSettingR\x11localityLbSetting\x1a\xb8\x03\n\x10\x43onsistentHashLB\x12*\n\x10http_header_name\x18\x01 \x01(\tH\x00R\x0ehttpHeaderName\x12n\n\x0bhttp_cookie\x18\x02 \x01(\x0b\x32K.istio.networking.v1alpha3.LoadBalancerSettings.ConsistentHashLB.HTTPCookieH\x00R\nhttpCookie\x12$\n\ruse_source_ip\x18\x03 \x01(\x08H\x00R\x0buseSourceIp\x12;\n\x19http_query_parameter_name\x18\x05 \x01(\tH\x00R\x16httpQueryParameterName\x12*\n\x11minimum_ring_size\x18\x04 \x01(\x04R\x0fminimumRingSize\x1am\n\nHTTPCookie\x12\x18\n\x04name\x18\x01 \x01(\tB\x04\xe2\x41\x01\x02R\x04name\x12\x12\n\x04path\x18\x02 \x01(\tR\x04path\x12\x31\n\x03ttl\x18\x03 \x01(\x0b\x32\x19.google.protobuf.DurationB\x04\xe2\x41\x01\x02R\x03ttlB\n\n\x08hash_key\"H\n\x08SimpleLB\x12\x0f\n\x0bROUND_ROBIN\x10\x00\x12\x0e\n\nLEAST_CONN\x10\x01\x12\n\n\x06RANDOM\x10\x02\x12\x0f\n\x0bPASSTHROUGH\x10\x03\x42\x0b\n\tlb_policy\"\xc1\x08\n\x16\x43onnectionPoolSettings\x12O\n\x03tcp\x18\x01 \x01(\x0b\x32=.istio.networking.v1alpha3.ConnectionPoolSettings.TCPSettingsR\x03tcp\x12R\n\x04http\x18\x02 \x01(\x0b\x32>.istio.networking.v1alpha3.ConnectionPoolSettings.HTTPSettingsR\x04http\x1a\xfa\x02\n\x0bTCPSettings\x12\'\n\x0fmax_connections\x18\x01 \x01(\x05R\x0emaxConnections\x12\x42\n\x0f\x63onnect_timeout\x18\x02 \x01(\x0b\x32\x19.google.protobuf.DurationR\x0e\x63onnectTimeout\x12o\n\rtcp_keepalive\x18\x03 \x01(\x0b\x32J.istio.networking.v1alpha3.ConnectionPoolSettings.TCPSettings.TcpKeepaliveR\x0ctcpKeepalive\x1a\x8c\x01\n\x0cTcpKeepalive\x12\x16\n\x06probes\x18\x01 \x01(\rR\x06probes\x12-\n\x04time\x18\x02 \x01(\x0b\x32\x19.google.protobuf.DurationR\x04time\x12\x35\n\x08interval\x18\x03 \x01(\x0b\x32\x19.google.protobuf.DurationR\x08interval\x1a\x84\x04\n\x0cHTTPSettings\x12;\n\x1ahttp1_max_pending_requests\x18\x01 \x01(\x05R\x17http1MaxPendingRequests\x12,\n\x12http2_max_requests\x18\x02 \x01(\x05R\x10http2MaxRequests\x12=\n\x1bmax_requests_per_connection\x18\x03 \x01(\x05R\x18maxRequestsPerConnection\x12\x1f\n\x0bmax_retries\x18\x04 \x01(\x05R\nmaxRetries\x12<\n\x0cidle_timeout\x18\x05 \x01(\x0b\x32\x19.google.protobuf.DurationR\x0bidleTimeout\x12z\n\x11h2_upgrade_policy\x18\x06 \x01(\x0e\x32N.istio.networking.v1alpha3.ConnectionPoolSettings.HTTPSettings.H2UpgradePolicyR\x0fh2UpgradePolicy\x12.\n\x13use_client_protocol\x18\x07 \x01(\x08R\x11useClientProtocol\"?\n\x0fH2UpgradePolicy\x12\x0b\n\x07\x44\x45\x46\x41ULT\x10\x00\x12\x12\n\x0e\x44O_NOT_UPGRADE\x10\x01\x12\x0b\n\x07UPGRADE\x10\x02\"\x8a\x05\n\x10OutlierDetection\x12\x31\n\x12\x63onsecutive_errors\x18\x01 \x01(\x05\x42\x02\x18\x01R\x11\x63onsecutiveErrors\x12J\n\"split_external_local_origin_errors\x18\x08 \x01(\x08R\x1esplitExternalLocalOriginErrors\x12g\n!consecutive_local_origin_failures\x18\t \x01(\x0b\x32\x1c.google.protobuf.UInt32ValueR\x1e\x63onsecutiveLocalOriginFailures\x12Z\n\x1a\x63onsecutive_gateway_errors\x18\x06 \x01(\x0b\x32\x1c.google.protobuf.UInt32ValueR\x18\x63onsecutiveGatewayErrors\x12R\n\x16\x63onsecutive_5xx_errors\x18\x07 \x01(\x0b\x32\x1c.google.protobuf.UInt32ValueR\x14\x63onsecutive5xxErrors\x12\x35\n\x08interval\x18\x02 \x01(\x0b\x32\x19.google.protobuf.DurationR\x08interval\x12G\n\x12\x62\x61se_ejection_time\x18\x03 \x01(\x0b\x32\x19.google.protobuf.DurationR\x10\x62\x61seEjectionTime\x12\x30\n\x14max_ejection_percent\x18\x04 \x01(\x05R\x12maxEjectionPercent\x12,\n\x12min_health_percent\x18\x05 \x01(\x05R\x10minHealthPercent\"\xd3\x03\n\x11\x43lientTLSSettings\x12N\n\x04mode\x18\x01 \x01(\x0e\x32\x34.istio.networking.v1alpha3.ClientTLSSettings.TLSmodeB\x04\xe2\x41\x01\x02R\x04mode\x12-\n\x12\x63lient_certificate\x18\x02 \x01(\tR\x11\x63lientCertificate\x12\x1f\n\x0bprivate_key\x18\x03 \x01(\tR\nprivateKey\x12\'\n\x0f\x63\x61_certificates\x18\x04 \x01(\tR\x0e\x63\x61\x43\x65rtificates\x12\'\n\x0f\x63redential_name\x18\x07 \x01(\tR\x0e\x63redentialName\x12*\n\x11subject_alt_names\x18\x05 \x03(\tR\x0fsubjectAltNames\x12\x10\n\x03sni\x18\x06 \x01(\tR\x03sni\x12L\n\x14insecure_skip_verify\x18\x08 \x01(\x0b\x32\x1a.google.protobuf.BoolValueR\x12insecureSkipVerify\"@\n\x07TLSmode\x12\x0b\n\x07\x44ISABLE\x10\x00\x12\n\n\x06SIMPLE\x10\x01\x12\n\n\x06MUTUAL\x10\x02\x12\x10\n\x0cISTIO_MUTUAL\x10\x03\"\xa5\x04\n\x1bLocalityLoadBalancerSetting\x12\x61\n\ndistribute\x18\x01 \x03(\x0b\x32\x41.istio.networking.v1alpha3.LocalityLoadBalancerSetting.DistributeR\ndistribute\x12[\n\x08\x66\x61ilover\x18\x02 \x03(\x0b\x32?.istio.networking.v1alpha3.LocalityLoadBalancerSetting.FailoverR\x08\x66\x61ilover\x12+\n\x11\x66\x61ilover_priority\x18\x04 \x03(\tR\x10\x66\x61iloverPriority\x12\x34\n\x07\x65nabled\x18\x03 \x01(\x0b\x32\x1a.google.protobuf.BoolValueR\x07\x65nabled\x1a\xb2\x01\n\nDistribute\x12\x12\n\x04\x66rom\x18\x01 \x01(\tR\x04\x66rom\x12Y\n\x02to\x18\x02 \x03(\x0b\x32I.istio.networking.v1alpha3.LocalityLoadBalancerSetting.Distribute.ToEntryR\x02to\x1a\x35\n\x07ToEntry\x12\x10\n\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n\x05value\x18\x02 \x01(\rR\x05value:\x02\x38\x01\x1a.\n\x08\x46\x61ilover\x12\x12\n\x04\x66rom\x18\x01 \x01(\tR\x04\x66rom\x12\x0e\n\x02to\x18\x02 \x01(\tR\x02toB\"Z istio.io/api/networking/v1alpha3b\x06proto3'
+  serialized_pb=b'\n*networking/v1alpha3/destination_rule.proto\x12\x19istio.networking.v1alpha3\x1a\x1fgoogle/api/field_behavior.proto\x1a\x1egoogle/protobuf/duration.proto\x1a\x1egoogle/protobuf/wrappers.proto\x1a)networking/v1alpha3/virtual_service.proto\x1a\x14gogoproto/gogo.proto\"\xd6\x01\n\x0f\x44\x65stinationRule\x12\x18\n\x04host\x18\x01 \x01(\tB\x04\xe2\x41\x01\x02R\x04host\x12O\n\x0etraffic_policy\x18\x02 \x01(\x0b\x32(.istio.networking.v1alpha3.TrafficPolicyR\rtrafficPolicy\x12;\n\x07subsets\x18\x03 \x03(\x0b\x32!.istio.networking.v1alpha3.SubsetR\x07subsets\x12\x1b\n\texport_to\x18\x04 \x03(\tR\x08\x65xportTo\"\x80\x08\n\rTrafficPolicy\x12T\n\rload_balancer\x18\x01 \x01(\x0b\x32/.istio.networking.v1alpha3.LoadBalancerSettingsR\x0cloadBalancer\x12Z\n\x0f\x63onnection_pool\x18\x02 \x01(\x0b\x32\x31.istio.networking.v1alpha3.ConnectionPoolSettingsR\x0e\x63onnectionPool\x12X\n\x11outlier_detection\x18\x03 \x01(\x0b\x32+.istio.networking.v1alpha3.OutlierDetectionR\x10outlierDetection\x12>\n\x03tls\x18\x04 \x01(\x0b\x32,.istio.networking.v1alpha3.ClientTLSSettingsR\x03tls\x12j\n\x13port_level_settings\x18\x05 \x03(\x0b\x32:.istio.networking.v1alpha3.TrafficPolicy.PortTrafficPolicyR\x11portLevelSettings\x12K\n\rhealth_checks\x18\x65 \x03(\x0b\x32&.istio.networking.v1alpha3.HealthCheckR\x0chealthChecks\x1a\xe9\x03\n\x11PortTrafficPolicy\x12;\n\x04port\x18\x01 \x01(\x0b\x32\'.istio.networking.v1alpha3.PortSelectorR\x04port\x12T\n\rload_balancer\x18\x02 \x01(\x0b\x32/.istio.networking.v1alpha3.LoadBalancerSettingsR\x0cloadBalancer\x12Z\n\x0f\x63onnection_pool\x18\x03 \x01(\x0b\x32\x31.istio.networking.v1alpha3.ConnectionPoolSettingsR\x0e\x63onnectionPool\x12X\n\x11outlier_detection\x18\x04 \x01(\x0b\x32+.istio.networking.v1alpha3.OutlierDetectionR\x10outlierDetection\x12>\n\x03tls\x18\x05 \x01(\x0b\x32,.istio.networking.v1alpha3.ClientTLSSettingsR\x03tls\x12K\n\rhealth_checks\x18\x65 \x03(\x0b\x32&.istio.networking.v1alpha3.HealthCheckR\x0chealthChecks\"\xf5\x01\n\x06Subset\x12\x18\n\x04name\x18\x01 \x01(\tB\x04\xe2\x41\x01\x02R\x04name\x12\x45\n\x06labels\x18\x02 \x03(\x0b\x32-.istio.networking.v1alpha3.Subset.LabelsEntryR\x06labels\x12O\n\x0etraffic_policy\x18\x03 \x01(\x0b\x32(.istio.networking.v1alpha3.TrafficPolicyR\rtrafficPolicy\x1a\x39\n\x0bLabelsEntry\x12\x10\n\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n\x05value\x18\x02 \x01(\tR\x05value:\x02\x38\x01\"\x9e\x07\n\x14LoadBalancerSettings\x12R\n\x06simple\x18\x01 \x01(\x0e\x32\x38.istio.networking.v1alpha3.LoadBalancerSettings.SimpleLBH\x00R\x06simple\x12k\n\x0f\x63onsistent_hash\x18\x02 \x01(\x0b\x32@.istio.networking.v1alpha3.LoadBalancerSettings.ConsistentHashLBH\x00R\x0e\x63onsistentHash\x12\x66\n\x13locality_lb_setting\x18\x03 \x01(\x0b\x32\x36.istio.networking.v1alpha3.LocalityLoadBalancerSettingR\x11localityLbSetting\x12K\n\x14warmup_duration_secs\x18\x04 \x01(\x0b\x32\x19.google.protobuf.DurationR\x12warmupDurationSecs\x1a\xb8\x03\n\x10\x43onsistentHashLB\x12*\n\x10http_header_name\x18\x01 \x01(\tH\x00R\x0ehttpHeaderName\x12n\n\x0bhttp_cookie\x18\x02 \x01(\x0b\x32K.istio.networking.v1alpha3.LoadBalancerSettings.ConsistentHashLB.HTTPCookieH\x00R\nhttpCookie\x12$\n\ruse_source_ip\x18\x03 \x01(\x08H\x00R\x0buseSourceIp\x12;\n\x19http_query_parameter_name\x18\x05 \x01(\tH\x00R\x16httpQueryParameterName\x12*\n\x11minimum_ring_size\x18\x04 \x01(\x04R\x0fminimumRingSize\x1am\n\nHTTPCookie\x12\x18\n\x04name\x18\x01 \x01(\tB\x04\xe2\x41\x01\x02R\x04name\x12\x12\n\x04path\x18\x02 \x01(\tR\x04path\x12\x31\n\x03ttl\x18\x03 \x01(\x0b\x32\x19.google.protobuf.DurationB\x04\xe2\x41\x01\x02R\x03ttlB\n\n\x08hash_key\"H\n\x08SimpleLB\x12\x0f\n\x0bROUND_ROBIN\x10\x00\x12\x0e\n\nLEAST_CONN\x10\x01\x12\n\n\x06RANDOM\x10\x02\x12\x0f\n\x0bPASSTHROUGH\x10\x03\x42\x0b\n\tlb_policy\"\xc1\x08\n\x16\x43onnectionPoolSettings\x12O\n\x03tcp\x18\x01 \x01(\x0b\x32=.istio.networking.v1alpha3.ConnectionPoolSettings.TCPSettingsR\x03tcp\x12R\n\x04http\x18\x02 \x01(\x0b\x32>.istio.networking.v1alpha3.ConnectionPoolSettings.HTTPSettingsR\x04http\x1a\xfa\x02\n\x0bTCPSettings\x12\'\n\x0fmax_connections\x18\x01 \x01(\x05R\x0emaxConnections\x12\x42\n\x0f\x63onnect_timeout\x18\x02 \x01(\x0b\x32\x19.google.protobuf.DurationR\x0e\x63onnectTimeout\x12o\n\rtcp_keepalive\x18\x03 \x01(\x0b\x32J.istio.networking.v1alpha3.ConnectionPoolSettings.TCPSettings.TcpKeepaliveR\x0ctcpKeepalive\x1a\x8c\x01\n\x0cTcpKeepalive\x12\x16\n\x06probes\x18\x01 \x01(\rR\x06probes\x12-\n\x04time\x18\x02 \x01(\x0b\x32\x19.google.protobuf.DurationR\x04time\x12\x35\n\x08interval\x18\x03 \x01(\x0b\x32\x19.google.protobuf.DurationR\x08interval\x1a\x84\x04\n\x0cHTTPSettings\x12;\n\x1ahttp1_max_pending_requests\x18\x01 \x01(\x05R\x17http1MaxPendingRequests\x12,\n\x12http2_max_requests\x18\x02 \x01(\x05R\x10http2MaxRequests\x12=\n\x1bmax_requests_per_connection\x18\x03 \x01(\x05R\x18maxRequestsPerConnection\x12\x1f\n\x0bmax_retries\x18\x04 \x01(\x05R\nmaxRetries\x12<\n\x0cidle_timeout\x18\x05 \x01(\x0b\x32\x19.google.protobuf.DurationR\x0bidleTimeout\x12z\n\x11h2_upgrade_policy\x18\x06 \x01(\x0e\x32N.istio.networking.v1alpha3.ConnectionPoolSettings.HTTPSettings.H2UpgradePolicyR\x0fh2UpgradePolicy\x12.\n\x13use_client_protocol\x18\x07 \x01(\x08R\x11useClientProtocol\"?\n\x0fH2UpgradePolicy\x12\x0b\n\x07\x44\x45\x46\x41ULT\x10\x00\x12\x12\n\x0e\x44O_NOT_UPGRADE\x10\x01\x12\x0b\n\x07UPGRADE\x10\x02\"\x8a\x05\n\x10OutlierDetection\x12\x31\n\x12\x63onsecutive_errors\x18\x01 \x01(\x05\x42\x02\x18\x01R\x11\x63onsecutiveErrors\x12J\n\"split_external_local_origin_errors\x18\x08 \x01(\x08R\x1esplitExternalLocalOriginErrors\x12g\n!consecutive_local_origin_failures\x18\t \x01(\x0b\x32\x1c.google.protobuf.UInt32ValueR\x1e\x63onsecutiveLocalOriginFailures\x12Z\n\x1a\x63onsecutive_gateway_errors\x18\x06 \x01(\x0b\x32\x1c.google.protobuf.UInt32ValueR\x18\x63onsecutiveGatewayErrors\x12R\n\x16\x63onsecutive_5xx_errors\x18\x07 \x01(\x0b\x32\x1c.google.protobuf.UInt32ValueR\x14\x63onsecutive5xxErrors\x12\x35\n\x08interval\x18\x02 \x01(\x0b\x32\x19.google.protobuf.DurationR\x08interval\x12G\n\x12\x62\x61se_ejection_time\x18\x03 \x01(\x0b\x32\x19.google.protobuf.DurationR\x10\x62\x61seEjectionTime\x12\x30\n\x14max_ejection_percent\x18\x04 \x01(\x05R\x12maxEjectionPercent\x12,\n\x12min_health_percent\x18\x05 \x01(\x05R\x10minHealthPercent\"\xd3\x03\n\x11\x43lientTLSSettings\x12N\n\x04mode\x18\x01 \x01(\x0e\x32\x34.istio.networking.v1alpha3.ClientTLSSettings.TLSmodeB\x04\xe2\x41\x01\x02R\x04mode\x12-\n\x12\x63lient_certificate\x18\x02 \x01(\tR\x11\x63lientCertificate\x12\x1f\n\x0bprivate_key\x18\x03 \x01(\tR\nprivateKey\x12\'\n\x0f\x63\x61_certificates\x18\x04 \x01(\tR\x0e\x63\x61\x43\x65rtificates\x12\'\n\x0f\x63redential_name\x18\x07 \x01(\tR\x0e\x63redentialName\x12*\n\x11subject_alt_names\x18\x05 \x03(\tR\x0fsubjectAltNames\x12\x10\n\x03sni\x18\x06 \x01(\tR\x03sni\x12L\n\x14insecure_skip_verify\x18\x08 \x01(\x0b\x32\x1a.google.protobuf.BoolValueR\x12insecureSkipVerify\"@\n\x07TLSmode\x12\x0b\n\x07\x44ISABLE\x10\x00\x12\n\n\x06SIMPLE\x10\x01\x12\n\n\x06MUTUAL\x10\x02\x12\x10\n\x0cISTIO_MUTUAL\x10\x03\"\xa5\x04\n\x1bLocalityLoadBalancerSetting\x12\x61\n\ndistribute\x18\x01 \x03(\x0b\x32\x41.istio.networking.v1alpha3.LocalityLoadBalancerSetting.DistributeR\ndistribute\x12[\n\x08\x66\x61ilover\x18\x02 \x03(\x0b\x32?.istio.networking.v1alpha3.LocalityLoadBalancerSetting.FailoverR\x08\x66\x61ilover\x12+\n\x11\x66\x61ilover_priority\x18\x04 \x03(\tR\x10\x66\x61iloverPriority\x12\x34\n\x07\x65nabled\x18\x03 \x01(\x0b\x32\x1a.google.protobuf.BoolValueR\x07\x65nabled\x1a\xb2\x01\n\nDistribute\x12\x12\n\x04\x66rom\x18\x01 \x01(\tR\x04\x66rom\x12Y\n\x02to\x18\x02 \x03(\x0b\x32I.istio.networking.v1alpha3.LocalityLoadBalancerSetting.Distribute.ToEntryR\x02to\x1a\x35\n\x07ToEntry\x12\x10\n\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n\x05value\x18\x02 \x01(\rR\x05value:\x02\x38\x01\x1a.\n\x08\x46\x61ilover\x12\x12\n\x04\x66rom\x18\x01 \x01(\tR\x04\x66rom\x12\x0e\n\x02to\x18\x02 \x01(\tR\x02to\"4\n\nInt64Range\x12\x14\n\x05start\x18\x01 \x01(\x03R\x05start\x12\x10\n\x03\x65nd\x18\x02 \x01(\x03R\x03\x65nd\"V\n\x0fHealthStatusSet\x12\x43\n\x08statuses\x18\x01 \x03(\x0e\x32\'.istio.networking.v1alpha3.HealthStatusR\x08statuses\"D\n\x07Payload\x12\x14\n\x04text\x18\x01 \x01(\tH\x00R\x04text\x12\x18\n\x06\x62inary\x18\x02 \x01(\x0cH\x00R\x06\x62inaryB\t\n\x07payload\"\xdf\x12\n\x0bHealthCheck\x12\x33\n\x07timeout\x18\x01 \x01(\x0b\x32\x19.google.protobuf.DurationR\x07timeout\x12\x35\n\x08interval\x18\x02 \x01(\x0b\x32\x19.google.protobuf.DurationR\x08interval\x12@\n\x0einitial_jitter\x18\x14 \x01(\x0b\x32\x19.google.protobuf.DurationR\rinitialJitter\x12\x42\n\x0finterval_jitter\x18\x03 \x01(\x0b\x32\x19.google.protobuf.DurationR\x0eintervalJitter\x12\x36\n\x17interval_jitter_percent\x18\x12 \x01(\rR\x15intervalJitterPercent\x12M\n\x13unhealthy_threshold\x18\x04 \x01(\x0b\x32\x1c.google.protobuf.UInt32ValueR\x12unhealthyThreshold\x12I\n\x11healthy_threshold\x18\x05 \x01(\x0b\x32\x1c.google.protobuf.UInt32ValueR\x10healthyThreshold\x12\x37\n\x08\x61lt_port\x18\x06 \x01(\x0b\x32\x1c.google.protobuf.UInt32ValueR\x07\x61ltPort\x12\x45\n\x10reuse_connection\x18\x07 \x01(\x0b\x32\x1a.google.protobuf.BoolValueR\x0freuseConnection\x12\x64\n\x11http_health_check\x18\x08 \x01(\x0b\x32\x36.istio.networking.v1alpha3.HealthCheck.HttpHealthCheckH\x00R\x0fhttpHealthCheck\x12\x61\n\x10tcp_health_check\x18\t \x01(\x0b\x32\x35.istio.networking.v1alpha3.HealthCheck.TcpHealthCheckH\x00R\x0etcpHealthCheck\x12\x64\n\x11grpc_health_check\x18\x0b \x01(\x0b\x32\x36.istio.networking.v1alpha3.HealthCheck.GrpcHealthCheckH\x00R\x0fgrpcHealthCheck\x12j\n\x13\x63ustom_health_check\x18\r \x01(\x0b\x32\x38.istio.networking.v1alpha3.HealthCheck.CustomHealthCheckH\x00R\x11\x63ustomHealthCheck\x12I\n\x13no_traffic_interval\x18\x0c \x01(\x0b\x32\x19.google.protobuf.DurationR\x11noTrafficInterval\x12X\n\x1bno_traffic_healthy_interval\x18\x18 \x01(\x0b\x32\x19.google.protobuf.DurationR\x18noTrafficHealthyInterval\x12H\n\x12unhealthy_interval\x18\x0e \x01(\x0b\x32\x19.google.protobuf.DurationR\x11unhealthyInterval\x12Q\n\x17unhealthy_edge_interval\x18\x0f \x01(\x0b\x32\x19.google.protobuf.DurationR\x15unhealthyEdgeInterval\x12M\n\x15healthy_edge_interval\x18\x10 \x01(\x0b\x32\x19.google.protobuf.DurationR\x13healthyEdgeInterval\x12$\n\x0e\x65vent_log_path\x18\x11 \x01(\tR\x0c\x65ventLogPath\x12\x46\n always_log_health_check_failures\x18\x13 \x01(\x08R\x1c\x61lwaysLogHealthCheckFailures\x12R\n\x0btls_options\x18\x15 \x01(\x0b\x32\x31.istio.networking.v1alpha3.HealthCheck.TlsOptionsR\ntlsOptions\x1a\x8a\x03\n\x0fHttpHealthCheck\x12\x12\n\x04host\x18\x01 \x01(\tR\x04host\x12\x12\n\x04path\x18\x02 \x01(\tR\x04path\x12\x36\n\x04send\x18\x03 \x01(\x0b\x32\".istio.networking.v1alpha3.PayloadR\x04send\x12<\n\x07receive\x18\x04 \x01(\x0b\x32\".istio.networking.v1alpha3.PayloadR\x07receive\x12R\n\x11\x65xpected_statuses\x18\t \x03(\x0b\x32%.istio.networking.v1alpha3.Int64RangeR\x10\x65xpectedStatuses\x12T\n\x12retriable_statuses\x18\x0c \x03(\x0b\x32%.istio.networking.v1alpha3.Int64RangeR\x11retriableStatusesJ\x04\x08\x05\x10\x06J\x04\x08\x07\x10\x08J\x04\x08\x06\x10\x07J\x04\x08\x08\x10\tR\x0cservice_nameR\tuse_http2\x1a\x86\x01\n\x0eTcpHealthCheck\x12\x36\n\x04send\x18\x01 \x01(\x0b\x32\".istio.networking.v1alpha3.PayloadR\x04send\x12<\n\x07receive\x18\x02 \x03(\x0b\x32\".istio.networking.v1alpha3.PayloadR\x07receive\x1a$\n\x10RedisHealthCheck\x12\x10\n\x03key\x18\x01 \x01(\tR\x03key\x1aX\n\x0fGrpcHealthCheck\x12!\n\x0cservice_name\x18\x01 \x01(\tR\x0bserviceName\x12\x1c\n\tauthority\x18\x02 \x01(\tR\tauthorityJ\x04\x08\x03\x10\x04\x1a\x35\n\x11\x43ustomHealthCheck\x12\x12\n\x04name\x18\x01 \x01(\tR\x04nameJ\x04\x08\x02\x10\x03R\x06\x63onfig\x1a\x33\n\nTlsOptions\x12%\n\x0e\x61lpn_protocols\x18\x01 \x03(\tR\ralpnProtocolsB\x10\n\x0ehealth_checkerJ\x04\x08\n\x10\x0bJ\x04\x08\x16\x10\x17*`\n\x0cHealthStatus\x12\x0b\n\x07UNKNOWN\x10\x00\x12\x0b\n\x07HEALTHY\x10\x01\x12\r\n\tUNHEALTHY\x10\x02\x12\x0c\n\x08\x44RAINING\x10\x03\x12\x0b\n\x07TIMEOUT\x10\x04\x12\x0c\n\x08\x44\x45GRADED\x10\x05\x42\"Z istio.io/api/networking/v1alpha3b\x06proto3'
   ,
   dependencies=[google_dot_api_dot_field__behavior__pb2.DESCRIPTOR,google_dot_protobuf_dot_duration__pb2.DESCRIPTOR,google_dot_protobuf_dot_wrappers__pb2.DESCRIPTOR,networking_dot_v1alpha3_dot_virtual__service__pb2.DESCRIPTOR,gogoproto_dot_gogo__pb2.DESCRIPTOR,])
 
+_HEALTHSTATUS = _descriptor.EnumDescriptor(
+  name='HealthStatus',
+  full_name='istio.networking.v1alpha3.HealthStatus',
+  filename=None,
+  file=DESCRIPTOR,
+  create_key=_descriptor._internal_create_key,
+  values=[
+    _descriptor.EnumValueDescriptor(
+      name='UNKNOWN', index=0, number=0,
+      serialized_options=None,
+      type=None,
+      create_key=_descriptor._internal_create_key),
+    _descriptor.EnumValueDescriptor(
+      name='HEALTHY', index=1, number=1,
+      serialized_options=None,
+      type=None,
+      create_key=_descriptor._internal_create_key),
+    _descriptor.EnumValueDescriptor(
+      name='UNHEALTHY', index=2, number=2,
+      serialized_options=None,
+      type=None,
+      create_key=_descriptor._internal_create_key),
+    _descriptor.EnumValueDescriptor(
+      name='DRAINING', index=3, number=3,
+      serialized_options=None,
+      type=None,
+      create_key=_descriptor._internal_create_key),
+    _descriptor.EnumValueDescriptor(
+      name='TIMEOUT', index=4, number=4,
+      serialized_options=None,
+      type=None,
+      create_key=_descriptor._internal_create_key),
+    _descriptor.EnumValueDescriptor(
+      name='DEGRADED', index=5, number=5,
+      serialized_options=None,
+      type=None,
+      create_key=_descriptor._internal_create_key),
+  ],
+  containing_type=None,
+  serialized_options=None,
+  serialized_start=8037,
+  serialized_end=8133,
+)
+_sym_db.RegisterEnumDescriptor(_HEALTHSTATUS)
+
+HealthStatus = enum_type_wrapper.EnumTypeWrapper(_HEALTHSTATUS)
+UNKNOWN = 0
+HEALTHY = 1
+UNHEALTHY = 2
+DRAINING = 3
+TIMEOUT = 4
+DEGRADED = 5
 
 
 _LOADBALANCERSETTINGS_SIMPLELB = _descriptor.EnumDescriptor(
@@ -60,8 +113,8 @@ _LOADBALANCERSETTINGS_SIMPLELB = _descriptor.EnumDescriptor(
   ],
   containing_type=None,
   serialized_options=None,
-  serialized_start=2338,
-  serialized_end=2410,
+  serialized_start=2569,
+  serialized_end=2641,
 )
 _sym_db.RegisterEnumDescriptor(_LOADBALANCERSETTINGS_SIMPLELB)
 
@@ -90,8 +143,8 @@ _CONNECTIONPOOLSETTINGS_HTTPSETTINGS_H2UPGRADEPOLICY = _descriptor.EnumDescripto
   ],
   containing_type=None,
   serialized_options=None,
-  serialized_start=3452,
-  serialized_end=3515,
+  serialized_start=3683,
+  serialized_end=3746,
 )
 _sym_db.RegisterEnumDescriptor(_CONNECTIONPOOLSETTINGS_HTTPSETTINGS_H2UPGRADEPOLICY)
 
@@ -125,8 +178,8 @@ _CLIENTTLSSETTINGS_TLSMODE = _descriptor.EnumDescriptor(
   ],
   containing_type=None,
   serialized_options=None,
-  serialized_start=4574,
-  serialized_end=4638,
+  serialized_start=4805,
+  serialized_end=4869,
 )
 _sym_db.RegisterEnumDescriptor(_CLIENTTLSSETTINGS_TLSMODE)
 
@@ -227,6 +280,13 @@ _TRAFFICPOLICY_PORTTRAFFICPOLICY = _descriptor.Descriptor(
       message_type=None, enum_type=None, containing_type=None,
       is_extension=False, extension_scope=None,
       serialized_options=None, json_name='tls', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='health_checks', full_name='istio.networking.v1alpha3.TrafficPolicy.PortTrafficPolicy.health_checks', index=5,
+      number=101, type=11, cpp_type=10, label=3,
+      has_default_value=False, default_value=[],
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='healthChecks', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
   ],
   extensions=[
   ],
@@ -239,8 +299,8 @@ _TRAFFICPOLICY_PORTTRAFFICPOLICY = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=911,
-  serialized_end=1323,
+  serialized_start=988,
+  serialized_end=1477,
 )
 
 _TRAFFICPOLICY = _descriptor.Descriptor(
@@ -286,6 +346,13 @@ _TRAFFICPOLICY = _descriptor.Descriptor(
       message_type=None, enum_type=None, containing_type=None,
       is_extension=False, extension_scope=None,
       serialized_options=None, json_name='portLevelSettings', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='health_checks', full_name='istio.networking.v1alpha3.TrafficPolicy.health_checks', index=5,
+      number=101, type=11, cpp_type=10, label=3,
+      has_default_value=False, default_value=[],
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='healthChecks', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
   ],
   extensions=[
   ],
@@ -299,7 +366,7 @@ _TRAFFICPOLICY = _descriptor.Descriptor(
   oneofs=[
   ],
   serialized_start=453,
-  serialized_end=1323,
+  serialized_end=1477,
 )
 
 
@@ -337,8 +404,8 @@ _SUBSET_LABELSENTRY = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=1514,
-  serialized_end=1571,
+  serialized_start=1668,
+  serialized_end=1725,
 )
 
 _SUBSET = _descriptor.Descriptor(
@@ -382,8 +449,8 @@ _SUBSET = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=1326,
-  serialized_end=1571,
+  serialized_start=1480,
+  serialized_end=1725,
 )
 
 
@@ -428,8 +495,8 @@ _LOADBALANCERSETTINGS_CONSISTENTHASHLB_HTTPCOOKIE = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=2215,
-  serialized_end=2324,
+  serialized_start=2446,
+  serialized_end=2555,
 )
 
 _LOADBALANCERSETTINGS_CONSISTENTHASHLB = _descriptor.Descriptor(
@@ -492,8 +559,8 @@ _LOADBALANCERSETTINGS_CONSISTENTHASHLB = _descriptor.Descriptor(
       create_key=_descriptor._internal_create_key,
     fields=[]),
   ],
-  serialized_start=1896,
-  serialized_end=2336,
+  serialized_start=2127,
+  serialized_end=2567,
 )
 
 _LOADBALANCERSETTINGS = _descriptor.Descriptor(
@@ -525,6 +592,13 @@ _LOADBALANCERSETTINGS = _descriptor.Descriptor(
       message_type=None, enum_type=None, containing_type=None,
       is_extension=False, extension_scope=None,
       serialized_options=None, json_name='localityLbSetting', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='warmup_duration_secs', full_name='istio.networking.v1alpha3.LoadBalancerSettings.warmup_duration_secs', index=3,
+      number=4, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='warmupDurationSecs', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
   ],
   extensions=[
   ],
@@ -543,8 +617,8 @@ _LOADBALANCERSETTINGS = _descriptor.Descriptor(
       create_key=_descriptor._internal_create_key,
     fields=[]),
   ],
-  serialized_start=1574,
-  serialized_end=2423,
+  serialized_start=1728,
+  serialized_end=2654,
 )
 
 
@@ -589,8 +663,8 @@ _CONNECTIONPOOLSETTINGS_TCPSETTINGS_TCPKEEPALIVE = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=2856,
-  serialized_end=2996,
+  serialized_start=3087,
+  serialized_end=3227,
 )
 
 _CONNECTIONPOOLSETTINGS_TCPSETTINGS = _descriptor.Descriptor(
@@ -634,8 +708,8 @@ _CONNECTIONPOOLSETTINGS_TCPSETTINGS = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=2618,
-  serialized_end=2996,
+  serialized_start=2849,
+  serialized_end=3227,
 )
 
 _CONNECTIONPOOLSETTINGS_HTTPSETTINGS = _descriptor.Descriptor(
@@ -708,8 +782,8 @@ _CONNECTIONPOOLSETTINGS_HTTPSETTINGS = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=2999,
-  serialized_end=3515,
+  serialized_start=3230,
+  serialized_end=3746,
 )
 
 _CONNECTIONPOOLSETTINGS = _descriptor.Descriptor(
@@ -746,8 +820,8 @@ _CONNECTIONPOOLSETTINGS = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=2426,
-  serialized_end=3515,
+  serialized_start=2657,
+  serialized_end=3746,
 )
 
 
@@ -834,8 +908,8 @@ _OUTLIERDETECTION = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=3518,
-  serialized_end=4168,
+  serialized_start=3749,
+  serialized_end=4399,
 )
 
 
@@ -916,8 +990,8 @@ _CLIENTTLSSETTINGS = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=4171,
-  serialized_end=4638,
+  serialized_start=4402,
+  serialized_end=4869,
 )
 
 
@@ -955,8 +1029,8 @@ _LOCALITYLOADBALANCERSETTING_DISTRIBUTE_TOENTRY = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=5089,
-  serialized_end=5142,
+  serialized_start=5320,
+  serialized_end=5373,
 )
 
 _LOCALITYLOADBALANCERSETTING_DISTRIBUTE = _descriptor.Descriptor(
@@ -993,8 +1067,8 @@ _LOCALITYLOADBALANCERSETTING_DISTRIBUTE = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=4964,
-  serialized_end=5142,
+  serialized_start=5195,
+  serialized_end=5373,
 )
 
 _LOCALITYLOADBALANCERSETTING_FAILOVER = _descriptor.Descriptor(
@@ -1031,8 +1105,8 @@ _LOCALITYLOADBALANCERSETTING_FAILOVER = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=5144,
-  serialized_end=5190,
+  serialized_start=5375,
+  serialized_end=5421,
 )
 
 _LOCALITYLOADBALANCERSETTING = _descriptor.Descriptor(
@@ -1083,8 +1157,535 @@ _LOCALITYLOADBALANCERSETTING = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=4641,
-  serialized_end=5190,
+  serialized_start=4872,
+  serialized_end=5421,
+)
+
+
+_INT64RANGE = _descriptor.Descriptor(
+  name='Int64Range',
+  full_name='istio.networking.v1alpha3.Int64Range',
+  filename=None,
+  file=DESCRIPTOR,
+  containing_type=None,
+  create_key=_descriptor._internal_create_key,
+  fields=[
+    _descriptor.FieldDescriptor(
+      name='start', full_name='istio.networking.v1alpha3.Int64Range.start', index=0,
+      number=1, type=3, cpp_type=2, label=1,
+      has_default_value=False, default_value=0,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='start', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='end', full_name='istio.networking.v1alpha3.Int64Range.end', index=1,
+      number=2, type=3, cpp_type=2, label=1,
+      has_default_value=False, default_value=0,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='end', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+  ],
+  extensions=[
+  ],
+  nested_types=[],
+  enum_types=[
+  ],
+  serialized_options=None,
+  is_extendable=False,
+  syntax='proto3',
+  extension_ranges=[],
+  oneofs=[
+  ],
+  serialized_start=5423,
+  serialized_end=5475,
+)
+
+
+_HEALTHSTATUSSET = _descriptor.Descriptor(
+  name='HealthStatusSet',
+  full_name='istio.networking.v1alpha3.HealthStatusSet',
+  filename=None,
+  file=DESCRIPTOR,
+  containing_type=None,
+  create_key=_descriptor._internal_create_key,
+  fields=[
+    _descriptor.FieldDescriptor(
+      name='statuses', full_name='istio.networking.v1alpha3.HealthStatusSet.statuses', index=0,
+      number=1, type=14, cpp_type=8, label=3,
+      has_default_value=False, default_value=[],
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='statuses', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+  ],
+  extensions=[
+  ],
+  nested_types=[],
+  enum_types=[
+  ],
+  serialized_options=None,
+  is_extendable=False,
+  syntax='proto3',
+  extension_ranges=[],
+  oneofs=[
+  ],
+  serialized_start=5477,
+  serialized_end=5563,
+)
+
+
+_PAYLOAD = _descriptor.Descriptor(
+  name='Payload',
+  full_name='istio.networking.v1alpha3.Payload',
+  filename=None,
+  file=DESCRIPTOR,
+  containing_type=None,
+  create_key=_descriptor._internal_create_key,
+  fields=[
+    _descriptor.FieldDescriptor(
+      name='text', full_name='istio.networking.v1alpha3.Payload.text', index=0,
+      number=1, type=9, cpp_type=9, label=1,
+      has_default_value=False, default_value=b"".decode('utf-8'),
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='text', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='binary', full_name='istio.networking.v1alpha3.Payload.binary', index=1,
+      number=2, type=12, cpp_type=9, label=1,
+      has_default_value=False, default_value=b"",
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='binary', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+  ],
+  extensions=[
+  ],
+  nested_types=[],
+  enum_types=[
+  ],
+  serialized_options=None,
+  is_extendable=False,
+  syntax='proto3',
+  extension_ranges=[],
+  oneofs=[
+    _descriptor.OneofDescriptor(
+      name='payload', full_name='istio.networking.v1alpha3.Payload.payload',
+      index=0, containing_type=None,
+      create_key=_descriptor._internal_create_key,
+    fields=[]),
+  ],
+  serialized_start=5565,
+  serialized_end=5633,
+)
+
+
+_HEALTHCHECK_HTTPHEALTHCHECK = _descriptor.Descriptor(
+  name='HttpHealthCheck',
+  full_name='istio.networking.v1alpha3.HealthCheck.HttpHealthCheck',
+  filename=None,
+  file=DESCRIPTOR,
+  containing_type=None,
+  create_key=_descriptor._internal_create_key,
+  fields=[
+    _descriptor.FieldDescriptor(
+      name='host', full_name='istio.networking.v1alpha3.HealthCheck.HttpHealthCheck.host', index=0,
+      number=1, type=9, cpp_type=9, label=1,
+      has_default_value=False, default_value=b"".decode('utf-8'),
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='host', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='path', full_name='istio.networking.v1alpha3.HealthCheck.HttpHealthCheck.path', index=1,
+      number=2, type=9, cpp_type=9, label=1,
+      has_default_value=False, default_value=b"".decode('utf-8'),
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='path', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='send', full_name='istio.networking.v1alpha3.HealthCheck.HttpHealthCheck.send', index=2,
+      number=3, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='send', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='receive', full_name='istio.networking.v1alpha3.HealthCheck.HttpHealthCheck.receive', index=3,
+      number=4, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='receive', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='expected_statuses', full_name='istio.networking.v1alpha3.HealthCheck.HttpHealthCheck.expected_statuses', index=4,
+      number=9, type=11, cpp_type=10, label=3,
+      has_default_value=False, default_value=[],
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='expectedStatuses', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='retriable_statuses', full_name='istio.networking.v1alpha3.HealthCheck.HttpHealthCheck.retriable_statuses', index=5,
+      number=12, type=11, cpp_type=10, label=3,
+      has_default_value=False, default_value=[],
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='retriableStatuses', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+  ],
+  extensions=[
+  ],
+  nested_types=[],
+  enum_types=[
+  ],
+  serialized_options=None,
+  is_extendable=False,
+  syntax='proto3',
+  extension_ranges=[],
+  oneofs=[
+  ],
+  serialized_start=7238,
+  serialized_end=7632,
+)
+
+_HEALTHCHECK_TCPHEALTHCHECK = _descriptor.Descriptor(
+  name='TcpHealthCheck',
+  full_name='istio.networking.v1alpha3.HealthCheck.TcpHealthCheck',
+  filename=None,
+  file=DESCRIPTOR,
+  containing_type=None,
+  create_key=_descriptor._internal_create_key,
+  fields=[
+    _descriptor.FieldDescriptor(
+      name='send', full_name='istio.networking.v1alpha3.HealthCheck.TcpHealthCheck.send', index=0,
+      number=1, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='send', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='receive', full_name='istio.networking.v1alpha3.HealthCheck.TcpHealthCheck.receive', index=1,
+      number=2, type=11, cpp_type=10, label=3,
+      has_default_value=False, default_value=[],
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='receive', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+  ],
+  extensions=[
+  ],
+  nested_types=[],
+  enum_types=[
+  ],
+  serialized_options=None,
+  is_extendable=False,
+  syntax='proto3',
+  extension_ranges=[],
+  oneofs=[
+  ],
+  serialized_start=7635,
+  serialized_end=7769,
+)
+
+_HEALTHCHECK_REDISHEALTHCHECK = _descriptor.Descriptor(
+  name='RedisHealthCheck',
+  full_name='istio.networking.v1alpha3.HealthCheck.RedisHealthCheck',
+  filename=None,
+  file=DESCRIPTOR,
+  containing_type=None,
+  create_key=_descriptor._internal_create_key,
+  fields=[
+    _descriptor.FieldDescriptor(
+      name='key', full_name='istio.networking.v1alpha3.HealthCheck.RedisHealthCheck.key', index=0,
+      number=1, type=9, cpp_type=9, label=1,
+      has_default_value=False, default_value=b"".decode('utf-8'),
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='key', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+  ],
+  extensions=[
+  ],
+  nested_types=[],
+  enum_types=[
+  ],
+  serialized_options=None,
+  is_extendable=False,
+  syntax='proto3',
+  extension_ranges=[],
+  oneofs=[
+  ],
+  serialized_start=7771,
+  serialized_end=7807,
+)
+
+_HEALTHCHECK_GRPCHEALTHCHECK = _descriptor.Descriptor(
+  name='GrpcHealthCheck',
+  full_name='istio.networking.v1alpha3.HealthCheck.GrpcHealthCheck',
+  filename=None,
+  file=DESCRIPTOR,
+  containing_type=None,
+  create_key=_descriptor._internal_create_key,
+  fields=[
+    _descriptor.FieldDescriptor(
+      name='service_name', full_name='istio.networking.v1alpha3.HealthCheck.GrpcHealthCheck.service_name', index=0,
+      number=1, type=9, cpp_type=9, label=1,
+      has_default_value=False, default_value=b"".decode('utf-8'),
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='serviceName', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='authority', full_name='istio.networking.v1alpha3.HealthCheck.GrpcHealthCheck.authority', index=1,
+      number=2, type=9, cpp_type=9, label=1,
+      has_default_value=False, default_value=b"".decode('utf-8'),
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='authority', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+  ],
+  extensions=[
+  ],
+  nested_types=[],
+  enum_types=[
+  ],
+  serialized_options=None,
+  is_extendable=False,
+  syntax='proto3',
+  extension_ranges=[],
+  oneofs=[
+  ],
+  serialized_start=7809,
+  serialized_end=7897,
+)
+
+_HEALTHCHECK_CUSTOMHEALTHCHECK = _descriptor.Descriptor(
+  name='CustomHealthCheck',
+  full_name='istio.networking.v1alpha3.HealthCheck.CustomHealthCheck',
+  filename=None,
+  file=DESCRIPTOR,
+  containing_type=None,
+  create_key=_descriptor._internal_create_key,
+  fields=[
+    _descriptor.FieldDescriptor(
+      name='name', full_name='istio.networking.v1alpha3.HealthCheck.CustomHealthCheck.name', index=0,
+      number=1, type=9, cpp_type=9, label=1,
+      has_default_value=False, default_value=b"".decode('utf-8'),
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='name', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+  ],
+  extensions=[
+  ],
+  nested_types=[],
+  enum_types=[
+  ],
+  serialized_options=None,
+  is_extendable=False,
+  syntax='proto3',
+  extension_ranges=[],
+  oneofs=[
+  ],
+  serialized_start=7899,
+  serialized_end=7952,
+)
+
+_HEALTHCHECK_TLSOPTIONS = _descriptor.Descriptor(
+  name='TlsOptions',
+  full_name='istio.networking.v1alpha3.HealthCheck.TlsOptions',
+  filename=None,
+  file=DESCRIPTOR,
+  containing_type=None,
+  create_key=_descriptor._internal_create_key,
+  fields=[
+    _descriptor.FieldDescriptor(
+      name='alpn_protocols', full_name='istio.networking.v1alpha3.HealthCheck.TlsOptions.alpn_protocols', index=0,
+      number=1, type=9, cpp_type=9, label=3,
+      has_default_value=False, default_value=[],
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='alpnProtocols', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+  ],
+  extensions=[
+  ],
+  nested_types=[],
+  enum_types=[
+  ],
+  serialized_options=None,
+  is_extendable=False,
+  syntax='proto3',
+  extension_ranges=[],
+  oneofs=[
+  ],
+  serialized_start=7954,
+  serialized_end=8005,
+)
+
+_HEALTHCHECK = _descriptor.Descriptor(
+  name='HealthCheck',
+  full_name='istio.networking.v1alpha3.HealthCheck',
+  filename=None,
+  file=DESCRIPTOR,
+  containing_type=None,
+  create_key=_descriptor._internal_create_key,
+  fields=[
+    _descriptor.FieldDescriptor(
+      name='timeout', full_name='istio.networking.v1alpha3.HealthCheck.timeout', index=0,
+      number=1, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='timeout', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='interval', full_name='istio.networking.v1alpha3.HealthCheck.interval', index=1,
+      number=2, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='interval', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='initial_jitter', full_name='istio.networking.v1alpha3.HealthCheck.initial_jitter', index=2,
+      number=20, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='initialJitter', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='interval_jitter', full_name='istio.networking.v1alpha3.HealthCheck.interval_jitter', index=3,
+      number=3, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='intervalJitter', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='interval_jitter_percent', full_name='istio.networking.v1alpha3.HealthCheck.interval_jitter_percent', index=4,
+      number=18, type=13, cpp_type=3, label=1,
+      has_default_value=False, default_value=0,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='intervalJitterPercent', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='unhealthy_threshold', full_name='istio.networking.v1alpha3.HealthCheck.unhealthy_threshold', index=5,
+      number=4, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='unhealthyThreshold', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='healthy_threshold', full_name='istio.networking.v1alpha3.HealthCheck.healthy_threshold', index=6,
+      number=5, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='healthyThreshold', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='alt_port', full_name='istio.networking.v1alpha3.HealthCheck.alt_port', index=7,
+      number=6, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='altPort', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='reuse_connection', full_name='istio.networking.v1alpha3.HealthCheck.reuse_connection', index=8,
+      number=7, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='reuseConnection', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='http_health_check', full_name='istio.networking.v1alpha3.HealthCheck.http_health_check', index=9,
+      number=8, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='httpHealthCheck', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='tcp_health_check', full_name='istio.networking.v1alpha3.HealthCheck.tcp_health_check', index=10,
+      number=9, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='tcpHealthCheck', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='grpc_health_check', full_name='istio.networking.v1alpha3.HealthCheck.grpc_health_check', index=11,
+      number=11, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='grpcHealthCheck', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='custom_health_check', full_name='istio.networking.v1alpha3.HealthCheck.custom_health_check', index=12,
+      number=13, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='customHealthCheck', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='no_traffic_interval', full_name='istio.networking.v1alpha3.HealthCheck.no_traffic_interval', index=13,
+      number=12, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='noTrafficInterval', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='no_traffic_healthy_interval', full_name='istio.networking.v1alpha3.HealthCheck.no_traffic_healthy_interval', index=14,
+      number=24, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='noTrafficHealthyInterval', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='unhealthy_interval', full_name='istio.networking.v1alpha3.HealthCheck.unhealthy_interval', index=15,
+      number=14, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='unhealthyInterval', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='unhealthy_edge_interval', full_name='istio.networking.v1alpha3.HealthCheck.unhealthy_edge_interval', index=16,
+      number=15, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='unhealthyEdgeInterval', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='healthy_edge_interval', full_name='istio.networking.v1alpha3.HealthCheck.healthy_edge_interval', index=17,
+      number=16, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='healthyEdgeInterval', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='event_log_path', full_name='istio.networking.v1alpha3.HealthCheck.event_log_path', index=18,
+      number=17, type=9, cpp_type=9, label=1,
+      has_default_value=False, default_value=b"".decode('utf-8'),
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='eventLogPath', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='always_log_health_check_failures', full_name='istio.networking.v1alpha3.HealthCheck.always_log_health_check_failures', index=19,
+      number=19, type=8, cpp_type=7, label=1,
+      has_default_value=False, default_value=False,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='alwaysLogHealthCheckFailures', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='tls_options', full_name='istio.networking.v1alpha3.HealthCheck.tls_options', index=20,
+      number=21, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='tlsOptions', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+  ],
+  extensions=[
+  ],
+  nested_types=[_HEALTHCHECK_HTTPHEALTHCHECK, _HEALTHCHECK_TCPHEALTHCHECK, _HEALTHCHECK_REDISHEALTHCHECK, _HEALTHCHECK_GRPCHEALTHCHECK, _HEALTHCHECK_CUSTOMHEALTHCHECK, _HEALTHCHECK_TLSOPTIONS, ],
+  enum_types=[
+  ],
+  serialized_options=None,
+  is_extendable=False,
+  syntax='proto3',
+  extension_ranges=[],
+  oneofs=[
+    _descriptor.OneofDescriptor(
+      name='health_checker', full_name='istio.networking.v1alpha3.HealthCheck.health_checker',
+      index=0, containing_type=None,
+      create_key=_descriptor._internal_create_key,
+    fields=[]),
+  ],
+  serialized_start=5636,
+  serialized_end=8035,
 )
 
 _DESTINATIONRULE.fields_by_name['traffic_policy'].message_type = _TRAFFICPOLICY
@@ -1094,12 +1695,14 @@ _TRAFFICPOLICY_PORTTRAFFICPOLICY.fields_by_name['load_balancer'].message_type =
 _TRAFFICPOLICY_PORTTRAFFICPOLICY.fields_by_name['connection_pool'].message_type = _CONNECTIONPOOLSETTINGS
 _TRAFFICPOLICY_PORTTRAFFICPOLICY.fields_by_name['outlier_detection'].message_type = _OUTLIERDETECTION
 _TRAFFICPOLICY_PORTTRAFFICPOLICY.fields_by_name['tls'].message_type = _CLIENTTLSSETTINGS
+_TRAFFICPOLICY_PORTTRAFFICPOLICY.fields_by_name['health_checks'].message_type = _HEALTHCHECK
 _TRAFFICPOLICY_PORTTRAFFICPOLICY.containing_type = _TRAFFICPOLICY
 _TRAFFICPOLICY.fields_by_name['load_balancer'].message_type = _LOADBALANCERSETTINGS
 _TRAFFICPOLICY.fields_by_name['connection_pool'].message_type = _CONNECTIONPOOLSETTINGS
 _TRAFFICPOLICY.fields_by_name['outlier_detection'].message_type = _OUTLIERDETECTION
 _TRAFFICPOLICY.fields_by_name['tls'].message_type = _CLIENTTLSSETTINGS
 _TRAFFICPOLICY.fields_by_name['port_level_settings'].message_type = _TRAFFICPOLICY_PORTTRAFFICPOLICY
+_TRAFFICPOLICY.fields_by_name['health_checks'].message_type = _HEALTHCHECK
 _SUBSET_LABELSENTRY.containing_type = _SUBSET
 _SUBSET.fields_by_name['labels'].message_type = _SUBSET_LABELSENTRY
 _SUBSET.fields_by_name['traffic_policy'].message_type = _TRAFFICPOLICY
@@ -1122,6 +1725,7 @@ _LOADBALANCERSETTINGS_CONSISTENTHASHLB.fields_by_name['http_query_parameter_name
 _LOADBALANCERSETTINGS.fields_by_name['simple'].enum_type = _LOADBALANCERSETTINGS_SIMPLELB
 _LOADBALANCERSETTINGS.fields_by_name['consistent_hash'].message_type = _LOADBALANCERSETTINGS_CONSISTENTHASHLB
 _LOADBALANCERSETTINGS.fields_by_name['locality_lb_setting'].message_type = _LOCALITYLOADBALANCERSETTING
+_LOADBALANCERSETTINGS.fields_by_name['warmup_duration_secs'].message_type = google_dot_protobuf_dot_duration__pb2._DURATION
 _LOADBALANCERSETTINGS_SIMPLELB.containing_type = _LOADBALANCERSETTINGS
 _LOADBALANCERSETTINGS.oneofs_by_name['lb_policy'].fields.append(
   _LOADBALANCERSETTINGS.fields_by_name['simple'])
@@ -1156,6 +1760,55 @@ _LOCALITYLOADBALANCERSETTING_FAILOVER.containing_type = _LOCALITYLOADBALANCERSET
 _LOCALITYLOADBALANCERSETTING.fields_by_name['distribute'].message_type = _LOCALITYLOADBALANCERSETTING_DISTRIBUTE
 _LOCALITYLOADBALANCERSETTING.fields_by_name['failover'].message_type = _LOCALITYLOADBALANCERSETTING_FAILOVER
 _LOCALITYLOADBALANCERSETTING.fields_by_name['enabled'].message_type = google_dot_protobuf_dot_wrappers__pb2._BOOLVALUE
+_HEALTHSTATUSSET.fields_by_name['statuses'].enum_type = _HEALTHSTATUS
+_PAYLOAD.oneofs_by_name['payload'].fields.append(
+  _PAYLOAD.fields_by_name['text'])
+_PAYLOAD.fields_by_name['text'].containing_oneof = _PAYLOAD.oneofs_by_name['payload']
+_PAYLOAD.oneofs_by_name['payload'].fields.append(
+  _PAYLOAD.fields_by_name['binary'])
+_PAYLOAD.fields_by_name['binary'].containing_oneof = _PAYLOAD.oneofs_by_name['payload']
+_HEALTHCHECK_HTTPHEALTHCHECK.fields_by_name['send'].message_type = _PAYLOAD
+_HEALTHCHECK_HTTPHEALTHCHECK.fields_by_name['receive'].message_type = _PAYLOAD
+_HEALTHCHECK_HTTPHEALTHCHECK.fields_by_name['expected_statuses'].message_type = _INT64RANGE
+_HEALTHCHECK_HTTPHEALTHCHECK.fields_by_name['retriable_statuses'].message_type = _INT64RANGE
+_HEALTHCHECK_HTTPHEALTHCHECK.containing_type = _HEALTHCHECK
+_HEALTHCHECK_TCPHEALTHCHECK.fields_by_name['send'].message_type = _PAYLOAD
+_HEALTHCHECK_TCPHEALTHCHECK.fields_by_name['receive'].message_type = _PAYLOAD
+_HEALTHCHECK_TCPHEALTHCHECK.containing_type = _HEALTHCHECK
+_HEALTHCHECK_REDISHEALTHCHECK.containing_type = _HEALTHCHECK
+_HEALTHCHECK_GRPCHEALTHCHECK.containing_type = _HEALTHCHECK
+_HEALTHCHECK_CUSTOMHEALTHCHECK.containing_type = _HEALTHCHECK
+_HEALTHCHECK_TLSOPTIONS.containing_type = _HEALTHCHECK
+_HEALTHCHECK.fields_by_name['timeout'].message_type = google_dot_protobuf_dot_duration__pb2._DURATION
+_HEALTHCHECK.fields_by_name['interval'].message_type = google_dot_protobuf_dot_duration__pb2._DURATION
+_HEALTHCHECK.fields_by_name['initial_jitter'].message_type = google_dot_protobuf_dot_duration__pb2._DURATION
+_HEALTHCHECK.fields_by_name['interval_jitter'].message_type = google_dot_protobuf_dot_duration__pb2._DURATION
+_HEALTHCHECK.fields_by_name['unhealthy_threshold'].message_type = google_dot_protobuf_dot_wrappers__pb2._UINT32VALUE
+_HEALTHCHECK.fields_by_name['healthy_threshold'].message_type = google_dot_protobuf_dot_wrappers__pb2._UINT32VALUE
+_HEALTHCHECK.fields_by_name['alt_port'].message_type = google_dot_protobuf_dot_wrappers__pb2._UINT32VALUE
+_HEALTHCHECK.fields_by_name['reuse_connection'].message_type = google_dot_protobuf_dot_wrappers__pb2._BOOLVALUE
+_HEALTHCHECK.fields_by_name['http_health_check'].message_type = _HEALTHCHECK_HTTPHEALTHCHECK
+_HEALTHCHECK.fields_by_name['tcp_health_check'].message_type = _HEALTHCHECK_TCPHEALTHCHECK
+_HEALTHCHECK.fields_by_name['grpc_health_check'].message_type = _HEALTHCHECK_GRPCHEALTHCHECK
+_HEALTHCHECK.fields_by_name['custom_health_check'].message_type = _HEALTHCHECK_CUSTOMHEALTHCHECK
+_HEALTHCHECK.fields_by_name['no_traffic_interval'].message_type = google_dot_protobuf_dot_duration__pb2._DURATION
+_HEALTHCHECK.fields_by_name['no_traffic_healthy_interval'].message_type = google_dot_protobuf_dot_duration__pb2._DURATION
+_HEALTHCHECK.fields_by_name['unhealthy_interval'].message_type = google_dot_protobuf_dot_duration__pb2._DURATION
+_HEALTHCHECK.fields_by_name['unhealthy_edge_interval'].message_type = google_dot_protobuf_dot_duration__pb2._DURATION
+_HEALTHCHECK.fields_by_name['healthy_edge_interval'].message_type = google_dot_protobuf_dot_duration__pb2._DURATION
+_HEALTHCHECK.fields_by_name['tls_options'].message_type = _HEALTHCHECK_TLSOPTIONS
+_HEALTHCHECK.oneofs_by_name['health_checker'].fields.append(
+  _HEALTHCHECK.fields_by_name['http_health_check'])
+_HEALTHCHECK.fields_by_name['http_health_check'].containing_oneof = _HEALTHCHECK.oneofs_by_name['health_checker']
+_HEALTHCHECK.oneofs_by_name['health_checker'].fields.append(
+  _HEALTHCHECK.fields_by_name['tcp_health_check'])
+_HEALTHCHECK.fields_by_name['tcp_health_check'].containing_oneof = _HEALTHCHECK.oneofs_by_name['health_checker']
+_HEALTHCHECK.oneofs_by_name['health_checker'].fields.append(
+  _HEALTHCHECK.fields_by_name['grpc_health_check'])
+_HEALTHCHECK.fields_by_name['grpc_health_check'].containing_oneof = _HEALTHCHECK.oneofs_by_name['health_checker']
+_HEALTHCHECK.oneofs_by_name['health_checker'].fields.append(
+  _HEALTHCHECK.fields_by_name['custom_health_check'])
+_HEALTHCHECK.fields_by_name['custom_health_check'].containing_oneof = _HEALTHCHECK.oneofs_by_name['health_checker']
 DESCRIPTOR.message_types_by_name['DestinationRule'] = _DESTINATIONRULE
 DESCRIPTOR.message_types_by_name['TrafficPolicy'] = _TRAFFICPOLICY
 DESCRIPTOR.message_types_by_name['Subset'] = _SUBSET
@@ -1164,6 +1817,11 @@ DESCRIPTOR.message_types_by_name['ConnectionPoolSettings'] = _CONNECTIONPOOLSETT
 DESCRIPTOR.message_types_by_name['OutlierDetection'] = _OUTLIERDETECTION
 DESCRIPTOR.message_types_by_name['ClientTLSSettings'] = _CLIENTTLSSETTINGS
 DESCRIPTOR.message_types_by_name['LocalityLoadBalancerSetting'] = _LOCALITYLOADBALANCERSETTING
+DESCRIPTOR.message_types_by_name['Int64Range'] = _INT64RANGE
+DESCRIPTOR.message_types_by_name['HealthStatusSet'] = _HEALTHSTATUSSET
+DESCRIPTOR.message_types_by_name['Payload'] = _PAYLOAD
+DESCRIPTOR.message_types_by_name['HealthCheck'] = _HEALTHCHECK
+DESCRIPTOR.enum_types_by_name['HealthStatus'] = _HEALTHSTATUS
 _sym_db.RegisterFileDescriptor(DESCRIPTOR)
 
 DestinationRule = _reflection.GeneratedProtocolMessageType('DestinationRule', (_message.Message,), {
@@ -1302,6 +1960,82 @@ _sym_db.RegisterMessage(LocalityLoadBalancerSetting.Distribute)
 _sym_db.RegisterMessage(LocalityLoadBalancerSetting.Distribute.ToEntry)
 _sym_db.RegisterMessage(LocalityLoadBalancerSetting.Failover)
 
+Int64Range = _reflection.GeneratedProtocolMessageType('Int64Range', (_message.Message,), {
+  'DESCRIPTOR' : _INT64RANGE,
+  '__module__' : 'networking.v1alpha3.destination_rule_pb2'
+  # @@protoc_insertion_point(class_scope:istio.networking.v1alpha3.Int64Range)
+  })
+_sym_db.RegisterMessage(Int64Range)
+
+HealthStatusSet = _reflection.GeneratedProtocolMessageType('HealthStatusSet', (_message.Message,), {
+  'DESCRIPTOR' : _HEALTHSTATUSSET,
+  '__module__' : 'networking.v1alpha3.destination_rule_pb2'
+  # @@protoc_insertion_point(class_scope:istio.networking.v1alpha3.HealthStatusSet)
+  })
+_sym_db.RegisterMessage(HealthStatusSet)
+
+Payload = _reflection.GeneratedProtocolMessageType('Payload', (_message.Message,), {
+  'DESCRIPTOR' : _PAYLOAD,
+  '__module__' : 'networking.v1alpha3.destination_rule_pb2'
+  # @@protoc_insertion_point(class_scope:istio.networking.v1alpha3.Payload)
+  })
+_sym_db.RegisterMessage(Payload)
+
+HealthCheck = _reflection.GeneratedProtocolMessageType('HealthCheck', (_message.Message,), {
+
+  'HttpHealthCheck' : _reflection.GeneratedProtocolMessageType('HttpHealthCheck', (_message.Message,), {
+    'DESCRIPTOR' : _HEALTHCHECK_HTTPHEALTHCHECK,
+    '__module__' : 'networking.v1alpha3.destination_rule_pb2'
+    # @@protoc_insertion_point(class_scope:istio.networking.v1alpha3.HealthCheck.HttpHealthCheck)
+    })
+  ,
+
+  'TcpHealthCheck' : _reflection.GeneratedProtocolMessageType('TcpHealthCheck', (_message.Message,), {
+    'DESCRIPTOR' : _HEALTHCHECK_TCPHEALTHCHECK,
+    '__module__' : 'networking.v1alpha3.destination_rule_pb2'
+    # @@protoc_insertion_point(class_scope:istio.networking.v1alpha3.HealthCheck.TcpHealthCheck)
+    })
+  ,
+
+  'RedisHealthCheck' : _reflection.GeneratedProtocolMessageType('RedisHealthCheck', (_message.Message,), {
+    'DESCRIPTOR' : _HEALTHCHECK_REDISHEALTHCHECK,
+    '__module__' : 'networking.v1alpha3.destination_rule_pb2'
+    # @@protoc_insertion_point(class_scope:istio.networking.v1alpha3.HealthCheck.RedisHealthCheck)
+    })
+  ,
+
+  'GrpcHealthCheck' : _reflection.GeneratedProtocolMessageType('GrpcHealthCheck', (_message.Message,), {
+    'DESCRIPTOR' : _HEALTHCHECK_GRPCHEALTHCHECK,
+    '__module__' : 'networking.v1alpha3.destination_rule_pb2'
+    # @@protoc_insertion_point(class_scope:istio.networking.v1alpha3.HealthCheck.GrpcHealthCheck)
+    })
+  ,
+
+  'CustomHealthCheck' : _reflection.GeneratedProtocolMessageType('CustomHealthCheck', (_message.Message,), {
+    'DESCRIPTOR' : _HEALTHCHECK_CUSTOMHEALTHCHECK,
+    '__module__' : 'networking.v1alpha3.destination_rule_pb2'
+    # @@protoc_insertion_point(class_scope:istio.networking.v1alpha3.HealthCheck.CustomHealthCheck)
+    })
+  ,
+
+  'TlsOptions' : _reflection.GeneratedProtocolMessageType('TlsOptions', (_message.Message,), {
+    'DESCRIPTOR' : _HEALTHCHECK_TLSOPTIONS,
+    '__module__' : 'networking.v1alpha3.destination_rule_pb2'
+    # @@protoc_insertion_point(class_scope:istio.networking.v1alpha3.HealthCheck.TlsOptions)
+    })
+  ,
+  'DESCRIPTOR' : _HEALTHCHECK,
+  '__module__' : 'networking.v1alpha3.destination_rule_pb2'
+  # @@protoc_insertion_point(class_scope:istio.networking.v1alpha3.HealthCheck)
+  })
+_sym_db.RegisterMessage(HealthCheck)
+_sym_db.RegisterMessage(HealthCheck.HttpHealthCheck)
+_sym_db.RegisterMessage(HealthCheck.TcpHealthCheck)
+_sym_db.RegisterMessage(HealthCheck.RedisHealthCheck)
+_sym_db.RegisterMessage(HealthCheck.GrpcHealthCheck)
+_sym_db.RegisterMessage(HealthCheck.CustomHealthCheck)
+_sym_db.RegisterMessage(HealthCheck.TlsOptions)
+
 
 DESCRIPTOR._options = None
 _DESTINATIONRULE.fields_by_name['host']._options = None
diff --git a/python/istio_api/networking/v1alpha3/service_subscription_list_pb2.py b/python/istio_api/networking/v1alpha3/service_subscription_list_pb2.py
new file mode 100644
index 00000000..0cda50d6
--- /dev/null
+++ b/python/istio_api/networking/v1alpha3/service_subscription_list_pb2.py
@@ -0,0 +1,239 @@
+# -*- coding: utf-8 -*-
+# Generated by the protocol buffer compiler.  DO NOT EDIT!
+# source: networking/v1alpha3/service_subscription_list.proto
+"""Generated protocol buffer code."""
+from google.protobuf import descriptor as _descriptor
+from google.protobuf import message as _message
+from google.protobuf import reflection as _reflection
+from google.protobuf import symbol_database as _symbol_database
+# @@protoc_insertion_point(imports)
+
+_sym_db = _symbol_database.Default()
+
+
+from networking.v1alpha3 import gateway_pb2 as networking_dot_v1alpha3_dot_gateway__pb2
+
+
+DESCRIPTOR = _descriptor.FileDescriptor(
+  name='networking/v1alpha3/service_subscription_list.proto',
+  package='istio.networking.v1alpha3',
+  syntax='proto3',
+  serialized_options=b'Z istio.io/api/networking/v1alpha3',
+  create_key=_descriptor._internal_create_key,
+  serialized_pb=b'\n3networking/v1alpha3/service_subscription_list.proto\x12\x19istio.networking.v1alpha3\x1a!networking/v1alpha3/gateway.proto\"\x88\x02\n\x17ServiceSubscriptionList\x12]\n\nresolution\x18\x01 \x01(\x0e\x32=.istio.networking.v1alpha3.ServiceSubscriptionList.ResolutionR\nresolution\x12T\n\rsubscriptions\x18\x02 \x03(\x0b\x32..istio.networking.v1alpha3.ServiceSubscriptionR\rsubscriptions\"8\n\nResolution\x12\x10\n\x0c\x43ONFIGSERVER\x10\x00\x12\r\n\tVIPSERVER\x10\x01\x12\t\n\x05NACOS\x10\x02\"\xbb\x02\n\x13ServiceSubscription\x12\x1a\n\x08hostname\x18\x01 \x01(\tR\x08hostname\x12\x18\n\x07version\x18\x02 \x01(\tR\x07version\x12\x14\n\x05group\x18\x03 \x01(\tR\x05group\x12\x33\n\x04port\x18\x04 \x01(\x0b\x32\x1f.istio.networking.v1alpha3.PortR\x04port\x12\x14\n\x05units\x18\x05 \x03(\tR\x05units\x12R\n\x06labels\x18\x06 \x03(\x0b\x32:.istio.networking.v1alpha3.ServiceSubscription.LabelsEntryR\x06labels\x1a\x39\n\x0bLabelsEntry\x12\x10\n\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n\x05value\x18\x02 \x01(\tR\x05value:\x02\x38\x01\x42\"Z istio.io/api/networking/v1alpha3b\x06proto3'
+  ,
+  dependencies=[networking_dot_v1alpha3_dot_gateway__pb2.DESCRIPTOR,])
+
+
+
+_SERVICESUBSCRIPTIONLIST_RESOLUTION = _descriptor.EnumDescriptor(
+  name='Resolution',
+  full_name='istio.networking.v1alpha3.ServiceSubscriptionList.Resolution',
+  filename=None,
+  file=DESCRIPTOR,
+  create_key=_descriptor._internal_create_key,
+  values=[
+    _descriptor.EnumValueDescriptor(
+      name='CONFIGSERVER', index=0, number=0,
+      serialized_options=None,
+      type=None,
+      create_key=_descriptor._internal_create_key),
+    _descriptor.EnumValueDescriptor(
+      name='VIPSERVER', index=1, number=1,
+      serialized_options=None,
+      type=None,
+      create_key=_descriptor._internal_create_key),
+    _descriptor.EnumValueDescriptor(
+      name='NACOS', index=2, number=2,
+      serialized_options=None,
+      type=None,
+      create_key=_descriptor._internal_create_key),
+  ],
+  containing_type=None,
+  serialized_options=None,
+  serialized_start=326,
+  serialized_end=382,
+)
+_sym_db.RegisterEnumDescriptor(_SERVICESUBSCRIPTIONLIST_RESOLUTION)
+
+
+_SERVICESUBSCRIPTIONLIST = _descriptor.Descriptor(
+  name='ServiceSubscriptionList',
+  full_name='istio.networking.v1alpha3.ServiceSubscriptionList',
+  filename=None,
+  file=DESCRIPTOR,
+  containing_type=None,
+  create_key=_descriptor._internal_create_key,
+  fields=[
+    _descriptor.FieldDescriptor(
+      name='resolution', full_name='istio.networking.v1alpha3.ServiceSubscriptionList.resolution', index=0,
+      number=1, type=14, cpp_type=8, label=1,
+      has_default_value=False, default_value=0,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='resolution', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='subscriptions', full_name='istio.networking.v1alpha3.ServiceSubscriptionList.subscriptions', index=1,
+      number=2, type=11, cpp_type=10, label=3,
+      has_default_value=False, default_value=[],
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='subscriptions', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+  ],
+  extensions=[
+  ],
+  nested_types=[],
+  enum_types=[
+    _SERVICESUBSCRIPTIONLIST_RESOLUTION,
+  ],
+  serialized_options=None,
+  is_extendable=False,
+  syntax='proto3',
+  extension_ranges=[],
+  oneofs=[
+  ],
+  serialized_start=118,
+  serialized_end=382,
+)
+
+
+_SERVICESUBSCRIPTION_LABELSENTRY = _descriptor.Descriptor(
+  name='LabelsEntry',
+  full_name='istio.networking.v1alpha3.ServiceSubscription.LabelsEntry',
+  filename=None,
+  file=DESCRIPTOR,
+  containing_type=None,
+  create_key=_descriptor._internal_create_key,
+  fields=[
+    _descriptor.FieldDescriptor(
+      name='key', full_name='istio.networking.v1alpha3.ServiceSubscription.LabelsEntry.key', index=0,
+      number=1, type=9, cpp_type=9, label=1,
+      has_default_value=False, default_value=b"".decode('utf-8'),
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='key', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='value', full_name='istio.networking.v1alpha3.ServiceSubscription.LabelsEntry.value', index=1,
+      number=2, type=9, cpp_type=9, label=1,
+      has_default_value=False, default_value=b"".decode('utf-8'),
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='value', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+  ],
+  extensions=[
+  ],
+  nested_types=[],
+  enum_types=[
+  ],
+  serialized_options=b'8\001',
+  is_extendable=False,
+  syntax='proto3',
+  extension_ranges=[],
+  oneofs=[
+  ],
+  serialized_start=643,
+  serialized_end=700,
+)
+
+_SERVICESUBSCRIPTION = _descriptor.Descriptor(
+  name='ServiceSubscription',
+  full_name='istio.networking.v1alpha3.ServiceSubscription',
+  filename=None,
+  file=DESCRIPTOR,
+  containing_type=None,
+  create_key=_descriptor._internal_create_key,
+  fields=[
+    _descriptor.FieldDescriptor(
+      name='hostname', full_name='istio.networking.v1alpha3.ServiceSubscription.hostname', index=0,
+      number=1, type=9, cpp_type=9, label=1,
+      has_default_value=False, default_value=b"".decode('utf-8'),
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='hostname', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='version', full_name='istio.networking.v1alpha3.ServiceSubscription.version', index=1,
+      number=2, type=9, cpp_type=9, label=1,
+      has_default_value=False, default_value=b"".decode('utf-8'),
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='version', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='group', full_name='istio.networking.v1alpha3.ServiceSubscription.group', index=2,
+      number=3, type=9, cpp_type=9, label=1,
+      has_default_value=False, default_value=b"".decode('utf-8'),
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='group', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='port', full_name='istio.networking.v1alpha3.ServiceSubscription.port', index=3,
+      number=4, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='port', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='units', full_name='istio.networking.v1alpha3.ServiceSubscription.units', index=4,
+      number=5, type=9, cpp_type=9, label=3,
+      has_default_value=False, default_value=[],
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='units', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='labels', full_name='istio.networking.v1alpha3.ServiceSubscription.labels', index=5,
+      number=6, type=11, cpp_type=10, label=3,
+      has_default_value=False, default_value=[],
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='labels', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+  ],
+  extensions=[
+  ],
+  nested_types=[_SERVICESUBSCRIPTION_LABELSENTRY, ],
+  enum_types=[
+  ],
+  serialized_options=None,
+  is_extendable=False,
+  syntax='proto3',
+  extension_ranges=[],
+  oneofs=[
+  ],
+  serialized_start=385,
+  serialized_end=700,
+)
+
+_SERVICESUBSCRIPTIONLIST.fields_by_name['resolution'].enum_type = _SERVICESUBSCRIPTIONLIST_RESOLUTION
+_SERVICESUBSCRIPTIONLIST.fields_by_name['subscriptions'].message_type = _SERVICESUBSCRIPTION
+_SERVICESUBSCRIPTIONLIST_RESOLUTION.containing_type = _SERVICESUBSCRIPTIONLIST
+_SERVICESUBSCRIPTION_LABELSENTRY.containing_type = _SERVICESUBSCRIPTION
+_SERVICESUBSCRIPTION.fields_by_name['port'].message_type = networking_dot_v1alpha3_dot_gateway__pb2._PORT
+_SERVICESUBSCRIPTION.fields_by_name['labels'].message_type = _SERVICESUBSCRIPTION_LABELSENTRY
+DESCRIPTOR.message_types_by_name['ServiceSubscriptionList'] = _SERVICESUBSCRIPTIONLIST
+DESCRIPTOR.message_types_by_name['ServiceSubscription'] = _SERVICESUBSCRIPTION
+_sym_db.RegisterFileDescriptor(DESCRIPTOR)
+
+ServiceSubscriptionList = _reflection.GeneratedProtocolMessageType('ServiceSubscriptionList', (_message.Message,), {
+  'DESCRIPTOR' : _SERVICESUBSCRIPTIONLIST,
+  '__module__' : 'networking.v1alpha3.service_subscription_list_pb2'
+  # @@protoc_insertion_point(class_scope:istio.networking.v1alpha3.ServiceSubscriptionList)
+  })
+_sym_db.RegisterMessage(ServiceSubscriptionList)
+
+ServiceSubscription = _reflection.GeneratedProtocolMessageType('ServiceSubscription', (_message.Message,), {
+
+  'LabelsEntry' : _reflection.GeneratedProtocolMessageType('LabelsEntry', (_message.Message,), {
+    'DESCRIPTOR' : _SERVICESUBSCRIPTION_LABELSENTRY,
+    '__module__' : 'networking.v1alpha3.service_subscription_list_pb2'
+    # @@protoc_insertion_point(class_scope:istio.networking.v1alpha3.ServiceSubscription.LabelsEntry)
+    })
+  ,
+  'DESCRIPTOR' : _SERVICESUBSCRIPTION,
+  '__module__' : 'networking.v1alpha3.service_subscription_list_pb2'
+  # @@protoc_insertion_point(class_scope:istio.networking.v1alpha3.ServiceSubscription)
+  })
+_sym_db.RegisterMessage(ServiceSubscription)
+_sym_db.RegisterMessage(ServiceSubscription.LabelsEntry)
+
+
+DESCRIPTOR._options = None
+_SERVICESUBSCRIPTION_LABELSENTRY._options = None
+# @@protoc_insertion_point(module_scope)
diff --git a/python/istio_api/networking/v1alpha3/virtual_service_pb2.py b/python/istio_api/networking/v1alpha3/virtual_service_pb2.py
index 0895b5e0..3011a3a9 100644
--- a/python/istio_api/networking/v1alpha3/virtual_service_pb2.py
+++ b/python/istio_api/networking/v1alpha3/virtual_service_pb2.py
@@ -22,7 +22,7 @@ DESCRIPTOR = _descriptor.FileDescriptor(
   syntax='proto3',
   serialized_options=b'Z istio.io/api/networking/v1alpha3',
   create_key=_descriptor._internal_create_key,
-  serialized_pb=b'\n)networking/v1alpha3/virtual_service.proto\x12\x19istio.networking.v1alpha3\x1a\x1fgoogle/api/field_behavior.proto\x1a\x1egoogle/protobuf/duration.proto\x1a\x1egoogle/protobuf/wrappers.proto\"\x87\x02\n\x0eVirtualService\x12\x14\n\x05hosts\x18\x01 \x03(\tR\x05hosts\x12\x1a\n\x08gateways\x18\x02 \x03(\tR\x08gateways\x12\x38\n\x04http\x18\x03 \x03(\x0b\x32$.istio.networking.v1alpha3.HTTPRouteR\x04http\x12\x35\n\x03tls\x18\x05 \x03(\x0b\x32#.istio.networking.v1alpha3.TLSRouteR\x03tls\x12\x35\n\x03tcp\x18\x04 \x03(\x0b\x32#.istio.networking.v1alpha3.TCPRouteR\x03tcp\x12\x1b\n\texport_to\x18\x06 \x03(\tR\x08\x65xportTo\"|\n\x0b\x44\x65stination\x12\x18\n\x04host\x18\x01 \x01(\tB\x04\xe2\x41\x01\x02R\x04host\x12\x16\n\x06subset\x18\x02 \x01(\tR\x06subset\x12;\n\x04port\x18\x03 \x01(\x0b\x32\'.istio.networking.v1alpha3.PortSelectorR\x04port\"\x9c\x08\n\tHTTPRoute\x12\x12\n\x04name\x18\x11 \x01(\tR\x04name\x12\x41\n\x05match\x18\x01 \x03(\x0b\x32+.istio.networking.v1alpha3.HTTPMatchRequestR\x05match\x12\x45\n\x05route\x18\x02 \x03(\x0b\x32/.istio.networking.v1alpha3.HTTPRouteDestinationR\x05route\x12\x43\n\x08redirect\x18\x03 \x01(\x0b\x32\'.istio.networking.v1alpha3.HTTPRedirectR\x08redirect\x12?\n\x08\x64\x65legate\x18\x14 \x01(\x0b\x32#.istio.networking.v1alpha3.DelegateR\x08\x64\x65legate\x12@\n\x07rewrite\x18\x04 \x01(\x0b\x32&.istio.networking.v1alpha3.HTTPRewriteR\x07rewrite\x12\x33\n\x07timeout\x18\x06 \x01(\x0b\x32\x19.google.protobuf.DurationR\x07timeout\x12>\n\x07retries\x18\x07 \x01(\x0b\x32$.istio.networking.v1alpha3.HTTPRetryR\x07retries\x12\x43\n\x05\x66\x61ult\x18\x08 \x01(\x0b\x32-.istio.networking.v1alpha3.HTTPFaultInjectionR\x05\x66\x61ult\x12>\n\x06mirror\x18\t \x01(\x0b\x32&.istio.networking.v1alpha3.DestinationR\x06mirror\x12G\n\x0emirror_percent\x18\x12 \x01(\x0b\x32\x1c.google.protobuf.UInt32ValueB\x02\x18\x01R\rmirrorPercent\x12O\n\x11mirror_percentage\x18\x13 \x01(\x0b\x32\".istio.networking.v1alpha3.PercentR\x10mirrorPercentage\x12\x46\n\x0b\x63ors_policy\x18\n \x01(\x0b\x32%.istio.networking.v1alpha3.CorsPolicyR\ncorsPolicy\x12<\n\x07headers\x18\x10 \x01(\x0b\x32\".istio.networking.v1alpha3.HeadersR\x07headersJ\x04\x08\x05\x10\x06J\x04\x08\x0b\x10\x10R\x11websocket_upgradeR\x0e\x61ppend_headersR\x17remove_response_headersR\x17\x61ppend_response_headersR\x16remove_request_headersR\x16\x61ppend_request_headers\"<\n\x08\x44\x65legate\x12\x12\n\x04name\x18\x01 \x01(\tR\x04name\x12\x1c\n\tnamespace\x18\x02 \x01(\tR\tnamespace\"\xe6\x03\n\x07Headers\x12M\n\x07request\x18\x01 \x01(\x0b\x32\x33.istio.networking.v1alpha3.Headers.HeaderOperationsR\x07request\x12O\n\x08response\x18\x02 \x01(\x0b\x32\x33.istio.networking.v1alpha3.Headers.HeaderOperationsR\x08response\x1a\xba\x02\n\x10HeaderOperations\x12N\n\x03set\x18\x01 \x03(\x0b\x32<.istio.networking.v1alpha3.Headers.HeaderOperations.SetEntryR\x03set\x12N\n\x03\x61\x64\x64\x18\x02 \x03(\x0b\x32<.istio.networking.v1alpha3.Headers.HeaderOperations.AddEntryR\x03\x61\x64\x64\x12\x16\n\x06remove\x18\x03 \x03(\tR\x06remove\x1a\x36\n\x08SetEntry\x12\x10\n\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n\x05value\x18\x02 \x01(\tR\x05value:\x02\x38\x01\x1a\x36\n\x08\x41\x64\x64\x45ntry\x12\x10\n\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n\x05value\x18\x02 \x01(\tR\x05value:\x02\x38\x01\"\x98\x01\n\x08TLSRoute\x12I\n\x05match\x18\x01 \x03(\x0b\x32-.istio.networking.v1alpha3.TLSMatchAttributesB\x04\xe2\x41\x01\x02R\x05match\x12\x41\n\x05route\x18\x02 \x03(\x0b\x32+.istio.networking.v1alpha3.RouteDestinationR\x05route\"\x91\x01\n\x08TCPRoute\x12\x42\n\x05match\x18\x01 \x03(\x0b\x32,.istio.networking.v1alpha3.L4MatchAttributesR\x05match\x12\x41\n\x05route\x18\x02 \x03(\x0b\x32+.istio.networking.v1alpha3.RouteDestinationR\x05route\"\xa4\t\n\x10HTTPMatchRequest\x12\x12\n\x04name\x18\x0b \x01(\tR\x04name\x12\x38\n\x03uri\x18\x01 \x01(\x0b\x32&.istio.networking.v1alpha3.StringMatchR\x03uri\x12>\n\x06scheme\x18\x02 \x01(\x0b\x32&.istio.networking.v1alpha3.StringMatchR\x06scheme\x12>\n\x06method\x18\x03 \x01(\x0b\x32&.istio.networking.v1alpha3.StringMatchR\x06method\x12\x44\n\tauthority\x18\x04 \x01(\x0b\x32&.istio.networking.v1alpha3.StringMatchR\tauthority\x12R\n\x07headers\x18\x05 \x03(\x0b\x32\x38.istio.networking.v1alpha3.HTTPMatchRequest.HeadersEntryR\x07headers\x12\x12\n\x04port\x18\x06 \x01(\rR\x04port\x12\x62\n\rsource_labels\x18\x07 \x03(\x0b\x32=.istio.networking.v1alpha3.HTTPMatchRequest.SourceLabelsEntryR\x0csourceLabels\x12\x1a\n\x08gateways\x18\x08 \x03(\tR\x08gateways\x12_\n\x0cquery_params\x18\t \x03(\x0b\x32<.istio.networking.v1alpha3.HTTPMatchRequest.QueryParamsEntryR\x0bqueryParams\x12&\n\x0fignore_uri_case\x18\n \x01(\x08R\rignoreUriCase\x12h\n\x0fwithout_headers\x18\x0c \x03(\x0b\x32?.istio.networking.v1alpha3.HTTPMatchRequest.WithoutHeadersEntryR\x0ewithoutHeaders\x12)\n\x10source_namespace\x18\r \x01(\tR\x0fsourceNamespace\x1a\x62\n\x0cHeadersEntry\x12\x10\n\x03key\x18\x01 \x01(\tR\x03key\x12<\n\x05value\x18\x02 \x01(\x0b\x32&.istio.networking.v1alpha3.StringMatchR\x05value:\x02\x38\x01\x1a?\n\x11SourceLabelsEntry\x12\x10\n\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n\x05value\x18\x02 \x01(\tR\x05value:\x02\x38\x01\x1a\x66\n\x10QueryParamsEntry\x12\x10\n\x03key\x18\x01 \x01(\tR\x03key\x12<\n\x05value\x18\x02 \x01(\x0b\x32&.istio.networking.v1alpha3.StringMatchR\x05value:\x02\x38\x01\x1ai\n\x13WithoutHeadersEntry\x12\x10\n\x03key\x18\x01 \x01(\tR\x03key\x12<\n\x05value\x18\x02 \x01(\x0b\x32&.istio.networking.v1alpha3.StringMatchR\x05value:\x02\x38\x01\"\xa4\x02\n\x14HTTPRouteDestination\x12N\n\x0b\x64\x65stination\x18\x01 \x01(\x0b\x32&.istio.networking.v1alpha3.DestinationB\x04\xe2\x41\x01\x02R\x0b\x64\x65stination\x12\x16\n\x06weight\x18\x02 \x01(\x05R\x06weight\x12<\n\x07headers\x18\x07 \x01(\x0b\x32\".istio.networking.v1alpha3.HeadersR\x07headersJ\x04\x08\x03\x10\x07R\x17remove_response_headersR\x17\x61ppend_response_headersR\x16remove_request_headersR\x16\x61ppend_request_headers\"z\n\x10RouteDestination\x12N\n\x0b\x64\x65stination\x18\x01 \x01(\x0b\x32&.istio.networking.v1alpha3.DestinationB\x04\xe2\x41\x01\x02R\x0b\x64\x65stination\x12\x16\n\x06weight\x18\x02 \x01(\x05R\x06weight\"\xea\x02\n\x11L4MatchAttributes\x12/\n\x13\x64\x65stination_subnets\x18\x01 \x03(\tR\x12\x64\x65stinationSubnets\x12\x12\n\x04port\x18\x02 \x01(\rR\x04port\x12#\n\rsource_subnet\x18\x03 \x01(\tR\x0csourceSubnet\x12\x63\n\rsource_labels\x18\x04 \x03(\x0b\x32>.istio.networking.v1alpha3.L4MatchAttributes.SourceLabelsEntryR\x0csourceLabels\x12\x1a\n\x08gateways\x18\x05 \x03(\tR\x08gateways\x12)\n\x10source_namespace\x18\x06 \x01(\tR\x0fsourceNamespace\x1a?\n\x11SourceLabelsEntry\x12\x10\n\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n\x05value\x18\x02 \x01(\tR\x05value:\x02\x38\x01\"\xff\x02\n\x12TLSMatchAttributes\x12!\n\tsni_hosts\x18\x01 \x03(\tB\x04\xe2\x41\x01\x02R\x08sniHosts\x12/\n\x13\x64\x65stination_subnets\x18\x02 \x03(\tR\x12\x64\x65stinationSubnets\x12\x12\n\x04port\x18\x03 \x01(\rR\x04port\x12\x64\n\rsource_labels\x18\x05 \x03(\x0b\x32?.istio.networking.v1alpha3.TLSMatchAttributes.SourceLabelsEntryR\x0csourceLabels\x12\x1a\n\x08gateways\x18\x06 \x03(\tR\x08gateways\x12)\n\x10source_namespace\x18\x07 \x01(\tR\x0fsourceNamespace\x1a?\n\x11SourceLabelsEntry\x12\x10\n\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n\x05value\x18\x02 \x01(\tR\x05value:\x02\x38\x01J\x04\x08\x04\x10\x05R\rsource_subnet\"\xcf\x02\n\x0cHTTPRedirect\x12\x10\n\x03uri\x18\x01 \x01(\tR\x03uri\x12\x1c\n\tauthority\x18\x02 \x01(\tR\tauthority\x12\x14\n\x04port\x18\x04 \x01(\rH\x00R\x04port\x12`\n\x0b\x64\x65rive_port\x18\x05 \x01(\x0e\x32=.istio.networking.v1alpha3.HTTPRedirect.RedirectPortSelectionH\x00R\nderivePort\x12\x16\n\x06scheme\x18\x06 \x01(\tR\x06scheme\x12#\n\rredirect_code\x18\x03 \x01(\rR\x0credirectCode\"I\n\x15RedirectPortSelection\x12\x19\n\x15\x46ROM_PROTOCOL_DEFAULT\x10\x00\x12\x15\n\x11\x46ROM_REQUEST_PORT\x10\x01\x42\x0f\n\rredirect_port\"=\n\x0bHTTPRewrite\x12\x10\n\x03uri\x18\x01 \x01(\tR\x03uri\x12\x1c\n\tauthority\x18\x02 \x01(\tR\tauthority\"e\n\x0bStringMatch\x12\x16\n\x05\x65xact\x18\x01 \x01(\tH\x00R\x05\x65xact\x12\x18\n\x06prefix\x18\x02 \x01(\tH\x00R\x06prefix\x12\x16\n\x05regex\x18\x03 \x01(\tH\x00R\x05regexB\x0c\n\nmatch_type\"\xdf\x01\n\tHTTPRetry\x12 \n\x08\x61ttempts\x18\x01 \x01(\x05\x42\x04\xe2\x41\x01\x02R\x08\x61ttempts\x12\x41\n\x0fper_try_timeout\x18\x02 \x01(\x0b\x32\x19.google.protobuf.DurationR\rperTryTimeout\x12\x19\n\x08retry_on\x18\x03 \x01(\tR\x07retryOn\x12R\n\x17retry_remote_localities\x18\x04 \x01(\x0b\x32\x1a.google.protobuf.BoolValueR\x15retryRemoteLocalities\"\xee\x02\n\nCorsPolicy\x12%\n\x0c\x61llow_origin\x18\x01 \x03(\tB\x02\x18\x01R\x0b\x61llowOrigin\x12K\n\rallow_origins\x18\x07 \x03(\x0b\x32&.istio.networking.v1alpha3.StringMatchR\x0c\x61llowOrigins\x12#\n\rallow_methods\x18\x02 \x03(\tR\x0c\x61llowMethods\x12#\n\rallow_headers\x18\x03 \x03(\tR\x0c\x61llowHeaders\x12%\n\x0e\x65xpose_headers\x18\x04 \x03(\tR\rexposeHeaders\x12\x32\n\x07max_age\x18\x05 \x01(\x0b\x32\x19.google.protobuf.DurationR\x06maxAge\x12G\n\x11\x61llow_credentials\x18\x06 \x01(\x0b\x32\x1a.google.protobuf.BoolValueR\x10\x61llowCredentials\"\x91\x05\n\x12HTTPFaultInjection\x12I\n\x05\x64\x65lay\x18\x01 \x01(\x0b\x32\x33.istio.networking.v1alpha3.HTTPFaultInjection.DelayR\x05\x64\x65lay\x12I\n\x05\x61\x62ort\x18\x02 \x01(\x0b\x32\x33.istio.networking.v1alpha3.HTTPFaultInjection.AbortR\x05\x61\x62ort\x1a\x8a\x02\n\x05\x44\x65lay\x12\x1c\n\x07percent\x18\x01 \x01(\x05\x42\x02\x18\x01R\x07percent\x12\x42\n\x0b\x66ixed_delay\x18\x02 \x01(\x0b\x32\x19.google.protobuf.DurationB\x04\xe2\x41\x01\x02H\x00R\nfixedDelay\x12H\n\x11\x65xponential_delay\x18\x03 \x01(\x0b\x32\x19.google.protobuf.DurationH\x00R\x10\x65xponentialDelay\x12\x42\n\npercentage\x18\x05 \x01(\x0b\x32\".istio.networking.v1alpha3.PercentR\npercentageB\x11\n\x0fhttp_delay_type\x1a\xd7\x01\n\x05\x41\x62ort\x12\'\n\x0bhttp_status\x18\x02 \x01(\x05\x42\x04\xe2\x41\x01\x02H\x00R\nhttpStatus\x12!\n\x0bgrpc_status\x18\x03 \x01(\tH\x00R\ngrpcStatus\x12!\n\x0bhttp2_error\x18\x04 \x01(\tH\x00R\nhttp2Error\x12\x42\n\npercentage\x18\x05 \x01(\x0b\x32\".istio.networking.v1alpha3.PercentR\npercentageB\x0c\n\nerror_typeJ\x04\x08\x01\x10\x02R\x07percent\"2\n\x0cPortSelector\x12\x16\n\x06number\x18\x01 \x01(\rR\x06numberJ\x04\x08\x02\x10\x03R\x04name\"\x1f\n\x07Percent\x12\x14\n\x05value\x18\x01 \x01(\x01R\x05valueB\"Z istio.io/api/networking/v1alpha3b\x06proto3'
+  serialized_pb=b'\n)networking/v1alpha3/virtual_service.proto\x12\x19istio.networking.v1alpha3\x1a\x1fgoogle/api/field_behavior.proto\x1a\x1egoogle/protobuf/duration.proto\x1a\x1egoogle/protobuf/wrappers.proto\"\xd9\x02\n\x0eVirtualService\x12\x14\n\x05hosts\x18\x01 \x03(\tR\x05hosts\x12\x1a\n\x08gateways\x18\x02 \x03(\tR\x08gateways\x12P\n\x0fhostHTTPFilters\x18\xe8\x07 \x03(\x0b\x32%.istio.networking.v1alpha3.HTTPFilterR\x0fhostHTTPFilters\x12\x38\n\x04http\x18\x03 \x03(\x0b\x32$.istio.networking.v1alpha3.HTTPRouteR\x04http\x12\x35\n\x03tls\x18\x05 \x03(\x0b\x32#.istio.networking.v1alpha3.TLSRouteR\x03tls\x12\x35\n\x03tcp\x18\x04 \x03(\x0b\x32#.istio.networking.v1alpha3.TCPRouteR\x03tcp\x12\x1b\n\texport_to\x18\x06 \x03(\tR\x08\x65xportTo\"|\n\x0b\x44\x65stination\x12\x18\n\x04host\x18\x01 \x01(\tB\x04\xe2\x41\x01\x02R\x04host\x12\x16\n\x06subset\x18\x02 \x01(\tR\x06subset\x12;\n\x04port\x18\x03 \x01(\x0b\x32\'.istio.networking.v1alpha3.PortSelectorR\x04port\"\xb9\n\n\tHTTPRoute\x12\x12\n\x04name\x18\x11 \x01(\tR\x04name\x12\x41\n\x05match\x18\x01 \x03(\x0b\x32+.istio.networking.v1alpha3.HTTPMatchRequestR\x05match\x12\x45\n\x05route\x18\x02 \x03(\x0b\x32/.istio.networking.v1alpha3.HTTPRouteDestinationR\x05route\x12R\n\x10routeHTTPFilters\x18\xe8\x07 \x03(\x0b\x32%.istio.networking.v1alpha3.HTTPFilterR\x10routeHTTPFilters\x12\x43\n\x08redirect\x18\x03 \x01(\x0b\x32\'.istio.networking.v1alpha3.HTTPRedirectR\x08redirect\x12o\n\x18internal_active_redirect\x18\x19 \x01(\x0b\x32\x35.istio.networking.v1alpha3.HTTPInternalActiveRedirectR\x16internalActiveRedirect\x12V\n\x0f\x64irect_response\x18\x1a \x01(\x0b\x32-.istio.networking.v1alpha3.HTTPDirectResponseR\x0e\x64irectResponse\x12?\n\x08\x64\x65legate\x18\x14 \x01(\x0b\x32#.istio.networking.v1alpha3.DelegateR\x08\x64\x65legate\x12@\n\x07rewrite\x18\x04 \x01(\x0b\x32&.istio.networking.v1alpha3.HTTPRewriteR\x07rewrite\x12\x33\n\x07timeout\x18\x06 \x01(\x0b\x32\x19.google.protobuf.DurationR\x07timeout\x12>\n\x07retries\x18\x07 \x01(\x0b\x32$.istio.networking.v1alpha3.HTTPRetryR\x07retries\x12\x43\n\x05\x66\x61ult\x18\x08 \x01(\x0b\x32-.istio.networking.v1alpha3.HTTPFaultInjectionR\x05\x66\x61ult\x12>\n\x06mirror\x18\t \x01(\x0b\x32&.istio.networking.v1alpha3.DestinationR\x06mirror\x12G\n\x0emirror_percent\x18\x12 \x01(\x0b\x32\x1c.google.protobuf.UInt32ValueB\x02\x18\x01R\rmirrorPercent\x12O\n\x11mirror_percentage\x18\x13 \x01(\x0b\x32\".istio.networking.v1alpha3.PercentR\x10mirrorPercentage\x12\x46\n\x0b\x63ors_policy\x18\n \x01(\x0b\x32%.istio.networking.v1alpha3.CorsPolicyR\ncorsPolicy\x12<\n\x07headers\x18\x10 \x01(\x0b\x32\".istio.networking.v1alpha3.HeadersR\x07headersJ\x04\x08\x05\x10\x06J\x04\x08\x0b\x10\x10R\x11websocket_upgradeR\x0e\x61ppend_headersR\x17remove_response_headersR\x17\x61ppend_response_headersR\x16remove_request_headersR\x16\x61ppend_request_headers\"<\n\x08\x44\x65legate\x12\x12\n\x04name\x18\x01 \x01(\tR\x04name\x12\x1c\n\tnamespace\x18\x02 \x01(\tR\tnamespace\"\xe6\x03\n\x07Headers\x12M\n\x07request\x18\x01 \x01(\x0b\x32\x33.istio.networking.v1alpha3.Headers.HeaderOperationsR\x07request\x12O\n\x08response\x18\x02 \x01(\x0b\x32\x33.istio.networking.v1alpha3.Headers.HeaderOperationsR\x08response\x1a\xba\x02\n\x10HeaderOperations\x12N\n\x03set\x18\x01 \x03(\x0b\x32<.istio.networking.v1alpha3.Headers.HeaderOperations.SetEntryR\x03set\x12N\n\x03\x61\x64\x64\x18\x02 \x03(\x0b\x32<.istio.networking.v1alpha3.Headers.HeaderOperations.AddEntryR\x03\x61\x64\x64\x12\x16\n\x06remove\x18\x03 \x03(\tR\x06remove\x1a\x36\n\x08SetEntry\x12\x10\n\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n\x05value\x18\x02 \x01(\tR\x05value:\x02\x38\x01\x1a\x36\n\x08\x41\x64\x64\x45ntry\x12\x10\n\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n\x05value\x18\x02 \x01(\tR\x05value:\x02\x38\x01\"\x98\x01\n\x08TLSRoute\x12I\n\x05match\x18\x01 \x03(\x0b\x32-.istio.networking.v1alpha3.TLSMatchAttributesB\x04\xe2\x41\x01\x02R\x05match\x12\x41\n\x05route\x18\x02 \x03(\x0b\x32+.istio.networking.v1alpha3.RouteDestinationR\x05route\"\x91\x01\n\x08TCPRoute\x12\x42\n\x05match\x18\x01 \x03(\x0b\x32,.istio.networking.v1alpha3.L4MatchAttributesR\x05match\x12\x41\n\x05route\x18\x02 \x03(\x0b\x32+.istio.networking.v1alpha3.RouteDestinationR\x05route\"\xa4\t\n\x10HTTPMatchRequest\x12\x12\n\x04name\x18\x0b \x01(\tR\x04name\x12\x38\n\x03uri\x18\x01 \x01(\x0b\x32&.istio.networking.v1alpha3.StringMatchR\x03uri\x12>\n\x06scheme\x18\x02 \x01(\x0b\x32&.istio.networking.v1alpha3.StringMatchR\x06scheme\x12>\n\x06method\x18\x03 \x01(\x0b\x32&.istio.networking.v1alpha3.StringMatchR\x06method\x12\x44\n\tauthority\x18\x04 \x01(\x0b\x32&.istio.networking.v1alpha3.StringMatchR\tauthority\x12R\n\x07headers\x18\x05 \x03(\x0b\x32\x38.istio.networking.v1alpha3.HTTPMatchRequest.HeadersEntryR\x07headers\x12\x12\n\x04port\x18\x06 \x01(\rR\x04port\x12\x62\n\rsource_labels\x18\x07 \x03(\x0b\x32=.istio.networking.v1alpha3.HTTPMatchRequest.SourceLabelsEntryR\x0csourceLabels\x12\x1a\n\x08gateways\x18\x08 \x03(\tR\x08gateways\x12_\n\x0cquery_params\x18\t \x03(\x0b\x32<.istio.networking.v1alpha3.HTTPMatchRequest.QueryParamsEntryR\x0bqueryParams\x12&\n\x0fignore_uri_case\x18\n \x01(\x08R\rignoreUriCase\x12h\n\x0fwithout_headers\x18\x0c \x03(\x0b\x32?.istio.networking.v1alpha3.HTTPMatchRequest.WithoutHeadersEntryR\x0ewithoutHeaders\x12)\n\x10source_namespace\x18\r \x01(\tR\x0fsourceNamespace\x1a\x62\n\x0cHeadersEntry\x12\x10\n\x03key\x18\x01 \x01(\tR\x03key\x12<\n\x05value\x18\x02 \x01(\x0b\x32&.istio.networking.v1alpha3.StringMatchR\x05value:\x02\x38\x01\x1a?\n\x11SourceLabelsEntry\x12\x10\n\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n\x05value\x18\x02 \x01(\tR\x05value:\x02\x38\x01\x1a\x66\n\x10QueryParamsEntry\x12\x10\n\x03key\x18\x01 \x01(\tR\x03key\x12<\n\x05value\x18\x02 \x01(\x0b\x32&.istio.networking.v1alpha3.StringMatchR\x05value:\x02\x38\x01\x1ai\n\x13WithoutHeadersEntry\x12\x10\n\x03key\x18\x01 \x01(\tR\x03key\x12<\n\x05value\x18\x02 \x01(\x0b\x32&.istio.networking.v1alpha3.StringMatchR\x05value:\x02\x38\x01\"\xf9\x02\n\x14HTTPRouteDestination\x12N\n\x0b\x64\x65stination\x18\x01 \x01(\x0b\x32&.istio.networking.v1alpha3.DestinationB\x04\xe2\x41\x01\x02R\x0b\x64\x65stination\x12\x16\n\x06weight\x18\x02 \x01(\x05R\x06weight\x12<\n\x07headers\x18\x07 \x01(\x0b\x32\".istio.networking.v1alpha3.HeadersR\x07headers\x12S\n\x11\x66\x61llback_clusters\x18\x64 \x03(\x0b\x32&.istio.networking.v1alpha3.DestinationR\x10\x66\x61llbackClustersJ\x04\x08\x03\x10\x07R\x17remove_response_headersR\x17\x61ppend_response_headersR\x16remove_request_headersR\x16\x61ppend_request_headers\"z\n\x10RouteDestination\x12N\n\x0b\x64\x65stination\x18\x01 \x01(\x0b\x32&.istio.networking.v1alpha3.DestinationB\x04\xe2\x41\x01\x02R\x0b\x64\x65stination\x12\x16\n\x06weight\x18\x02 \x01(\x05R\x06weight\"\xea\x02\n\x11L4MatchAttributes\x12/\n\x13\x64\x65stination_subnets\x18\x01 \x03(\tR\x12\x64\x65stinationSubnets\x12\x12\n\x04port\x18\x02 \x01(\rR\x04port\x12#\n\rsource_subnet\x18\x03 \x01(\tR\x0csourceSubnet\x12\x63\n\rsource_labels\x18\x04 \x03(\x0b\x32>.istio.networking.v1alpha3.L4MatchAttributes.SourceLabelsEntryR\x0csourceLabels\x12\x1a\n\x08gateways\x18\x05 \x03(\tR\x08gateways\x12)\n\x10source_namespace\x18\x06 \x01(\tR\x0fsourceNamespace\x1a?\n\x11SourceLabelsEntry\x12\x10\n\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n\x05value\x18\x02 \x01(\tR\x05value:\x02\x38\x01\"\xff\x02\n\x12TLSMatchAttributes\x12!\n\tsni_hosts\x18\x01 \x03(\tB\x04\xe2\x41\x01\x02R\x08sniHosts\x12/\n\x13\x64\x65stination_subnets\x18\x02 \x03(\tR\x12\x64\x65stinationSubnets\x12\x12\n\x04port\x18\x03 \x01(\rR\x04port\x12\x64\n\rsource_labels\x18\x05 \x03(\x0b\x32?.istio.networking.v1alpha3.TLSMatchAttributes.SourceLabelsEntryR\x0csourceLabels\x12\x1a\n\x08gateways\x18\x06 \x03(\tR\x08gateways\x12)\n\x10source_namespace\x18\x07 \x01(\tR\x0fsourceNamespace\x1a?\n\x11SourceLabelsEntry\x12\x10\n\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n\x05value\x18\x02 \x01(\tR\x05value:\x02\x38\x01J\x04\x08\x04\x10\x05R\rsource_subnet\"\xcf\x02\n\x0cHTTPRedirect\x12\x10\n\x03uri\x18\x01 \x01(\tR\x03uri\x12\x1c\n\tauthority\x18\x02 \x01(\tR\tauthority\x12\x14\n\x04port\x18\x04 \x01(\rH\x00R\x04port\x12`\n\x0b\x64\x65rive_port\x18\x05 \x01(\x0e\x32=.istio.networking.v1alpha3.HTTPRedirect.RedirectPortSelectionH\x00R\nderivePort\x12\x16\n\x06scheme\x18\x06 \x01(\tR\x06scheme\x12#\n\rredirect_code\x18\x03 \x01(\rR\x0credirectCode\"I\n\x15RedirectPortSelection\x12\x19\n\x15\x46ROM_PROTOCOL_DEFAULT\x10\x00\x12\x15\n\x11\x46ROM_REQUEST_PORT\x10\x01\x42\x0f\n\rredirect_port\"\x8d\n\n\x1aHTTPInternalActiveRedirect\x12\x34\n\x16max_internal_redirects\x18\x01 \x01(\rR\x14maxInternalRedirects\x12\x36\n\x17redirect_response_codes\x18\x02 \x03(\rR\x15redirectResponseCodes\x12#\n\x0credirect_url\x18\x03 \x01(\tH\x00R\x0bredirectUrl\x12q\n\x1aredirect_url_rewrite_regex\x18\x04 \x01(\x0b\x32\x32.istio.networking.v1alpha3.RegexMatchAndSubstituteH\x00R\x17redirectUrlRewriteRegex\x12,\n\x12\x61llow_cross_scheme\x18\x05 \x01(\x08R\x10\x61llowCrossScheme\x12<\n\x07headers\x18\x06 \x01(\x0b\x32\".istio.networking.v1alpha3.HeadersR\x07headers\x12\x1c\n\tauthority\x18\x07 \x01(\tR\tauthority\x12\x37\n\x18\x66orced_use_original_host\x18\x10 \x01(\x08R\x15\x66orcedUseOriginalHost\x12Q\n&forced_add_header_before_route_matcher\x18\x11 \x01(\x08R!forcedAddHeaderBeforeRouteMatcher\x12`\n\x08policies\x18\x0f \x03(\x0b\x32\x44.istio.networking.v1alpha3.HTTPInternalActiveRedirect.RedirectPolicyR\x08policies\x1a\xce\x04\n\x0eRedirectPolicy\x12\x34\n\x16max_internal_redirects\x18\x08 \x01(\rR\x14maxInternalRedirects\x12\x36\n\x17redirect_response_codes\x18\t \x03(\rR\x15redirectResponseCodes\x12#\n\x0credirect_url\x18\n \x01(\tH\x00R\x0bredirectUrl\x12q\n\x1aredirect_url_rewrite_regex\x18\x0b \x01(\x0b\x32\x32.istio.networking.v1alpha3.RegexMatchAndSubstituteH\x00R\x17redirectUrlRewriteRegex\x12,\n\x12\x61llow_cross_scheme\x18\x0c \x01(\x08R\x10\x61llowCrossScheme\x12<\n\x07headers\x18\r \x01(\x0b\x32\".istio.networking.v1alpha3.HeadersR\x07headers\x12\x1c\n\tauthority\x18\x0e \x01(\tR\tauthority\x12\x37\n\x18\x66orced_use_original_host\x18\x11 \x01(\x08R\x15\x66orcedUseOriginalHost\x12Q\n&forced_add_header_before_route_matcher\x18\x12 \x01(\x08R!forcedAddHeaderBeforeRouteMatcherB \n\x1eredirect_url_rewrite_specifierB \n\x1eredirect_url_rewrite_specifier\"M\n\x12HTTPDirectResponse\x12#\n\rresponse_code\x18\x01 \x01(\rR\x0cresponseCode\x12\x12\n\x04\x62ody\x18\x02 \x01(\tR\x04\x62ody\"\x8e\x01\n\x0bHTTPRewrite\x12\x10\n\x03uri\x18\x01 \x01(\tR\x03uri\x12\x1c\n\tauthority\x18\x02 \x01(\tR\tauthority\x12O\n\turi_regex\x18\x03 \x01(\x0b\x32\x32.istio.networking.v1alpha3.RegexMatchAndSubstituteR\x08uriRegex\"W\n\x17RegexMatchAndSubstitute\x12\x18\n\x07pattern\x18\x01 \x01(\tR\x07pattern\x12\"\n\x0csubstitution\x18\x02 \x01(\tR\x0csubstitution\"e\n\x0bStringMatch\x12\x16\n\x05\x65xact\x18\x01 \x01(\tH\x00R\x05\x65xact\x12\x18\n\x06prefix\x18\x02 \x01(\tH\x00R\x06prefix\x12\x16\n\x05regex\x18\x03 \x01(\tH\x00R\x05regexB\x0c\n\nmatch_type\"\xdf\x01\n\tHTTPRetry\x12 \n\x08\x61ttempts\x18\x01 \x01(\x05\x42\x04\xe2\x41\x01\x02R\x08\x61ttempts\x12\x41\n\x0fper_try_timeout\x18\x02 \x01(\x0b\x32\x19.google.protobuf.DurationR\rperTryTimeout\x12\x19\n\x08retry_on\x18\x03 \x01(\tR\x07retryOn\x12R\n\x17retry_remote_localities\x18\x04 \x01(\x0b\x32\x1a.google.protobuf.BoolValueR\x15retryRemoteLocalities\"\xee\x02\n\nCorsPolicy\x12%\n\x0c\x61llow_origin\x18\x01 \x03(\tB\x02\x18\x01R\x0b\x61llowOrigin\x12K\n\rallow_origins\x18\x07 \x03(\x0b\x32&.istio.networking.v1alpha3.StringMatchR\x0c\x61llowOrigins\x12#\n\rallow_methods\x18\x02 \x03(\tR\x0c\x61llowMethods\x12#\n\rallow_headers\x18\x03 \x03(\tR\x0c\x61llowHeaders\x12%\n\x0e\x65xpose_headers\x18\x04 \x03(\tR\rexposeHeaders\x12\x32\n\x07max_age\x18\x05 \x01(\x0b\x32\x19.google.protobuf.DurationR\x06maxAge\x12G\n\x11\x61llow_credentials\x18\x06 \x01(\x0b\x32\x1a.google.protobuf.BoolValueR\x10\x61llowCredentials\"\x91\x05\n\x12HTTPFaultInjection\x12I\n\x05\x64\x65lay\x18\x01 \x01(\x0b\x32\x33.istio.networking.v1alpha3.HTTPFaultInjection.DelayR\x05\x64\x65lay\x12I\n\x05\x61\x62ort\x18\x02 \x01(\x0b\x32\x33.istio.networking.v1alpha3.HTTPFaultInjection.AbortR\x05\x61\x62ort\x1a\x8a\x02\n\x05\x44\x65lay\x12\x1c\n\x07percent\x18\x01 \x01(\x05\x42\x02\x18\x01R\x07percent\x12\x42\n\x0b\x66ixed_delay\x18\x02 \x01(\x0b\x32\x19.google.protobuf.DurationB\x04\xe2\x41\x01\x02H\x00R\nfixedDelay\x12H\n\x11\x65xponential_delay\x18\x03 \x01(\x0b\x32\x19.google.protobuf.DurationH\x00R\x10\x65xponentialDelay\x12\x42\n\npercentage\x18\x05 \x01(\x0b\x32\".istio.networking.v1alpha3.PercentR\npercentageB\x11\n\x0fhttp_delay_type\x1a\xd7\x01\n\x05\x41\x62ort\x12\'\n\x0bhttp_status\x18\x02 \x01(\x05\x42\x04\xe2\x41\x01\x02H\x00R\nhttpStatus\x12!\n\x0bgrpc_status\x18\x03 \x01(\tH\x00R\ngrpcStatus\x12!\n\x0bhttp2_error\x18\x04 \x01(\tH\x00R\nhttp2Error\x12\x42\n\npercentage\x18\x05 \x01(\x0b\x32\".istio.networking.v1alpha3.PercentR\npercentageB\x0c\n\nerror_typeJ\x04\x08\x01\x10\x02R\x07percent\"2\n\x0cPortSelector\x12\x16\n\x06number\x18\x01 \x01(\rR\x06numberJ\x04\x08\x02\x10\x03R\x04name\"\x1f\n\x07Percent\x12\x14\n\x05value\x18\x01 \x01(\x01R\x05value\"\xf5\x01\n\nHTTPFilter\x12\x12\n\x04name\x18\x01 \x01(\tR\x04name\x12\x18\n\x07\x64isable\x18\x02 \x01(\x08R\x07\x64isable\x12X\n\x11ip_access_control\x18\x03 \x01(\x0b\x32*.istio.networking.v1alpha3.IPAccessControlH\x00R\x0fipAccessControl\x12U\n\x10local_rate_limit\x18\x04 \x01(\x0b\x32).istio.networking.v1alpha3.LocalRateLimitH\x00R\x0elocalRateLimitB\x08\n\x06\x46ilter\"l\n\x0fIPAccessControl\x12(\n\x10remote_ip_blocks\x18\x01 \x03(\tR\x0eremoteIpBlocks\x12/\n\x14not_remote_ip_blocks\x18\x02 \x03(\tR\x11notRemoteIpBlocks\"\xb8\x01\n\x0eLocalRateLimit\x12I\n\x0ctoken_bucket\x18\x01 \x01(\x0b\x32&.istio.networking.v1alpha3.TokenBucketR\x0btokenBucket\x12:\n\x19per_downstream_connection\x18\x02 \x01(\x08R\x17perDownstreamConnection\x12\x1f\n\x0bstatus_code\x18\x03 \x01(\rR\nstatusCode\"\x94\x01\n\x0bTokenBucket\x12\x1d\n\nmax_tokens\x18\x01 \x01(\rR\tmaxTokens\x12&\n\x0ftokens_pef_fill\x18\x02 \x01(\rR\rtokensPefFill\x12>\n\rfill_interval\x18\x03 \x01(\x0b\x32\x19.google.protobuf.DurationR\x0c\x66illIntervalB\"Z istio.io/api/networking/v1alpha3b\x06proto3'
   ,
   dependencies=[google_dot_api_dot_field__behavior__pb2.DESCRIPTOR,google_dot_protobuf_dot_duration__pb2.DESCRIPTOR,google_dot_protobuf_dot_wrappers__pb2.DESCRIPTOR,])
 
@@ -48,8 +48,8 @@ _HTTPREDIRECT_REDIRECTPORTSELECTION = _descriptor.EnumDescriptor(
   ],
   containing_type=None,
   serialized_options=None,
-  serialized_start=5077,
-  serialized_end=5150,
+  serialized_start=5529,
+  serialized_end=5602,
 )
 _sym_db.RegisterEnumDescriptor(_HTTPREDIRECT_REDIRECTPORTSELECTION)
 
@@ -77,28 +77,35 @@ _VIRTUALSERVICE = _descriptor.Descriptor(
       is_extension=False, extension_scope=None,
       serialized_options=None, json_name='gateways', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
     _descriptor.FieldDescriptor(
-      name='http', full_name='istio.networking.v1alpha3.VirtualService.http', index=2,
+      name='hostHTTPFilters', full_name='istio.networking.v1alpha3.VirtualService.hostHTTPFilters', index=2,
+      number=1000, type=11, cpp_type=10, label=3,
+      has_default_value=False, default_value=[],
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='hostHTTPFilters', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='http', full_name='istio.networking.v1alpha3.VirtualService.http', index=3,
       number=3, type=11, cpp_type=10, label=3,
       has_default_value=False, default_value=[],
       message_type=None, enum_type=None, containing_type=None,
       is_extension=False, extension_scope=None,
       serialized_options=None, json_name='http', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
     _descriptor.FieldDescriptor(
-      name='tls', full_name='istio.networking.v1alpha3.VirtualService.tls', index=3,
+      name='tls', full_name='istio.networking.v1alpha3.VirtualService.tls', index=4,
       number=5, type=11, cpp_type=10, label=3,
       has_default_value=False, default_value=[],
       message_type=None, enum_type=None, containing_type=None,
       is_extension=False, extension_scope=None,
       serialized_options=None, json_name='tls', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
     _descriptor.FieldDescriptor(
-      name='tcp', full_name='istio.networking.v1alpha3.VirtualService.tcp', index=4,
+      name='tcp', full_name='istio.networking.v1alpha3.VirtualService.tcp', index=5,
       number=4, type=11, cpp_type=10, label=3,
       has_default_value=False, default_value=[],
       message_type=None, enum_type=None, containing_type=None,
       is_extension=False, extension_scope=None,
       serialized_options=None, json_name='tcp', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
     _descriptor.FieldDescriptor(
-      name='export_to', full_name='istio.networking.v1alpha3.VirtualService.export_to', index=5,
+      name='export_to', full_name='istio.networking.v1alpha3.VirtualService.export_to', index=6,
       number=6, type=9, cpp_type=9, label=3,
       has_default_value=False, default_value=[],
       message_type=None, enum_type=None, containing_type=None,
@@ -117,7 +124,7 @@ _VIRTUALSERVICE = _descriptor.Descriptor(
   oneofs=[
   ],
   serialized_start=170,
-  serialized_end=433,
+  serialized_end=515,
 )
 
 
@@ -162,8 +169,8 @@ _DESTINATION = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=435,
-  serialized_end=559,
+  serialized_start=517,
+  serialized_end=641,
 )
 
 
@@ -197,77 +204,98 @@ _HTTPROUTE = _descriptor.Descriptor(
       is_extension=False, extension_scope=None,
       serialized_options=None, json_name='route', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
     _descriptor.FieldDescriptor(
-      name='redirect', full_name='istio.networking.v1alpha3.HTTPRoute.redirect', index=3,
+      name='routeHTTPFilters', full_name='istio.networking.v1alpha3.HTTPRoute.routeHTTPFilters', index=3,
+      number=1000, type=11, cpp_type=10, label=3,
+      has_default_value=False, default_value=[],
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='routeHTTPFilters', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='redirect', full_name='istio.networking.v1alpha3.HTTPRoute.redirect', index=4,
       number=3, type=11, cpp_type=10, label=1,
       has_default_value=False, default_value=None,
       message_type=None, enum_type=None, containing_type=None,
       is_extension=False, extension_scope=None,
       serialized_options=None, json_name='redirect', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
     _descriptor.FieldDescriptor(
-      name='delegate', full_name='istio.networking.v1alpha3.HTTPRoute.delegate', index=4,
+      name='internal_active_redirect', full_name='istio.networking.v1alpha3.HTTPRoute.internal_active_redirect', index=5,
+      number=25, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='internalActiveRedirect', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='direct_response', full_name='istio.networking.v1alpha3.HTTPRoute.direct_response', index=6,
+      number=26, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='directResponse', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='delegate', full_name='istio.networking.v1alpha3.HTTPRoute.delegate', index=7,
       number=20, type=11, cpp_type=10, label=1,
       has_default_value=False, default_value=None,
       message_type=None, enum_type=None, containing_type=None,
       is_extension=False, extension_scope=None,
       serialized_options=None, json_name='delegate', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
     _descriptor.FieldDescriptor(
-      name='rewrite', full_name='istio.networking.v1alpha3.HTTPRoute.rewrite', index=5,
+      name='rewrite', full_name='istio.networking.v1alpha3.HTTPRoute.rewrite', index=8,
       number=4, type=11, cpp_type=10, label=1,
       has_default_value=False, default_value=None,
       message_type=None, enum_type=None, containing_type=None,
       is_extension=False, extension_scope=None,
       serialized_options=None, json_name='rewrite', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
     _descriptor.FieldDescriptor(
-      name='timeout', full_name='istio.networking.v1alpha3.HTTPRoute.timeout', index=6,
+      name='timeout', full_name='istio.networking.v1alpha3.HTTPRoute.timeout', index=9,
       number=6, type=11, cpp_type=10, label=1,
       has_default_value=False, default_value=None,
       message_type=None, enum_type=None, containing_type=None,
       is_extension=False, extension_scope=None,
       serialized_options=None, json_name='timeout', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
     _descriptor.FieldDescriptor(
-      name='retries', full_name='istio.networking.v1alpha3.HTTPRoute.retries', index=7,
+      name='retries', full_name='istio.networking.v1alpha3.HTTPRoute.retries', index=10,
       number=7, type=11, cpp_type=10, label=1,
       has_default_value=False, default_value=None,
       message_type=None, enum_type=None, containing_type=None,
       is_extension=False, extension_scope=None,
       serialized_options=None, json_name='retries', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
     _descriptor.FieldDescriptor(
-      name='fault', full_name='istio.networking.v1alpha3.HTTPRoute.fault', index=8,
+      name='fault', full_name='istio.networking.v1alpha3.HTTPRoute.fault', index=11,
       number=8, type=11, cpp_type=10, label=1,
       has_default_value=False, default_value=None,
       message_type=None, enum_type=None, containing_type=None,
       is_extension=False, extension_scope=None,
       serialized_options=None, json_name='fault', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
     _descriptor.FieldDescriptor(
-      name='mirror', full_name='istio.networking.v1alpha3.HTTPRoute.mirror', index=9,
+      name='mirror', full_name='istio.networking.v1alpha3.HTTPRoute.mirror', index=12,
       number=9, type=11, cpp_type=10, label=1,
       has_default_value=False, default_value=None,
       message_type=None, enum_type=None, containing_type=None,
       is_extension=False, extension_scope=None,
       serialized_options=None, json_name='mirror', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
     _descriptor.FieldDescriptor(
-      name='mirror_percent', full_name='istio.networking.v1alpha3.HTTPRoute.mirror_percent', index=10,
+      name='mirror_percent', full_name='istio.networking.v1alpha3.HTTPRoute.mirror_percent', index=13,
       number=18, type=11, cpp_type=10, label=1,
       has_default_value=False, default_value=None,
       message_type=None, enum_type=None, containing_type=None,
       is_extension=False, extension_scope=None,
       serialized_options=b'\030\001', json_name='mirrorPercent', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
     _descriptor.FieldDescriptor(
-      name='mirror_percentage', full_name='istio.networking.v1alpha3.HTTPRoute.mirror_percentage', index=11,
+      name='mirror_percentage', full_name='istio.networking.v1alpha3.HTTPRoute.mirror_percentage', index=14,
       number=19, type=11, cpp_type=10, label=1,
       has_default_value=False, default_value=None,
       message_type=None, enum_type=None, containing_type=None,
       is_extension=False, extension_scope=None,
       serialized_options=None, json_name='mirrorPercentage', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
     _descriptor.FieldDescriptor(
-      name='cors_policy', full_name='istio.networking.v1alpha3.HTTPRoute.cors_policy', index=12,
+      name='cors_policy', full_name='istio.networking.v1alpha3.HTTPRoute.cors_policy', index=15,
       number=10, type=11, cpp_type=10, label=1,
       has_default_value=False, default_value=None,
       message_type=None, enum_type=None, containing_type=None,
       is_extension=False, extension_scope=None,
       serialized_options=None, json_name='corsPolicy', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
     _descriptor.FieldDescriptor(
-      name='headers', full_name='istio.networking.v1alpha3.HTTPRoute.headers', index=13,
+      name='headers', full_name='istio.networking.v1alpha3.HTTPRoute.headers', index=16,
       number=16, type=11, cpp_type=10, label=1,
       has_default_value=False, default_value=None,
       message_type=None, enum_type=None, containing_type=None,
@@ -285,8 +313,8 @@ _HTTPROUTE = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=562,
-  serialized_end=1614,
+  serialized_start=644,
+  serialized_end=1981,
 )
 
 
@@ -324,8 +352,8 @@ _DELEGATE = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=1616,
-  serialized_end=1676,
+  serialized_start=1983,
+  serialized_end=2043,
 )
 
 
@@ -363,8 +391,8 @@ _HEADERS_HEADEROPERATIONS_SETENTRY = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=2055,
-  serialized_end=2109,
+  serialized_start=2422,
+  serialized_end=2476,
 )
 
 _HEADERS_HEADEROPERATIONS_ADDENTRY = _descriptor.Descriptor(
@@ -401,8 +429,8 @@ _HEADERS_HEADEROPERATIONS_ADDENTRY = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=2111,
-  serialized_end=2165,
+  serialized_start=2478,
+  serialized_end=2532,
 )
 
 _HEADERS_HEADEROPERATIONS = _descriptor.Descriptor(
@@ -446,8 +474,8 @@ _HEADERS_HEADEROPERATIONS = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=1851,
-  serialized_end=2165,
+  serialized_start=2218,
+  serialized_end=2532,
 )
 
 _HEADERS = _descriptor.Descriptor(
@@ -484,8 +512,8 @@ _HEADERS = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=1679,
-  serialized_end=2165,
+  serialized_start=2046,
+  serialized_end=2532,
 )
 
 
@@ -523,8 +551,8 @@ _TLSROUTE = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=2168,
-  serialized_end=2320,
+  serialized_start=2535,
+  serialized_end=2687,
 )
 
 
@@ -562,8 +590,8 @@ _TCPROUTE = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=2323,
-  serialized_end=2468,
+  serialized_start=2690,
+  serialized_end=2835,
 )
 
 
@@ -601,8 +629,8 @@ _HTTPMATCHREQUEST_HEADERSENTRY = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=3285,
-  serialized_end=3383,
+  serialized_start=3652,
+  serialized_end=3750,
 )
 
 _HTTPMATCHREQUEST_SOURCELABELSENTRY = _descriptor.Descriptor(
@@ -639,8 +667,8 @@ _HTTPMATCHREQUEST_SOURCELABELSENTRY = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=3385,
-  serialized_end=3448,
+  serialized_start=3752,
+  serialized_end=3815,
 )
 
 _HTTPMATCHREQUEST_QUERYPARAMSENTRY = _descriptor.Descriptor(
@@ -677,8 +705,8 @@ _HTTPMATCHREQUEST_QUERYPARAMSENTRY = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=3450,
-  serialized_end=3552,
+  serialized_start=3817,
+  serialized_end=3919,
 )
 
 _HTTPMATCHREQUEST_WITHOUTHEADERSENTRY = _descriptor.Descriptor(
@@ -715,8 +743,8 @@ _HTTPMATCHREQUEST_WITHOUTHEADERSENTRY = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=3554,
-  serialized_end=3659,
+  serialized_start=3921,
+  serialized_end=4026,
 )
 
 _HTTPMATCHREQUEST = _descriptor.Descriptor(
@@ -830,8 +858,8 @@ _HTTPMATCHREQUEST = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=2471,
-  serialized_end=3659,
+  serialized_start=2838,
+  serialized_end=4026,
 )
 
 
@@ -864,6 +892,13 @@ _HTTPROUTEDESTINATION = _descriptor.Descriptor(
       message_type=None, enum_type=None, containing_type=None,
       is_extension=False, extension_scope=None,
       serialized_options=None, json_name='headers', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='fallback_clusters', full_name='istio.networking.v1alpha3.HTTPRouteDestination.fallback_clusters', index=3,
+      number=100, type=11, cpp_type=10, label=3,
+      has_default_value=False, default_value=[],
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='fallbackClusters', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
   ],
   extensions=[
   ],
@@ -876,8 +911,8 @@ _HTTPROUTEDESTINATION = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=3662,
-  serialized_end=3954,
+  serialized_start=4029,
+  serialized_end=4406,
 )
 
 
@@ -915,8 +950,8 @@ _ROUTEDESTINATION = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=3956,
-  serialized_end=4078,
+  serialized_start=4408,
+  serialized_end=4530,
 )
 
 
@@ -954,8 +989,8 @@ _L4MATCHATTRIBUTES_SOURCELABELSENTRY = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=3385,
-  serialized_end=3448,
+  serialized_start=3752,
+  serialized_end=3815,
 )
 
 _L4MATCHATTRIBUTES = _descriptor.Descriptor(
@@ -1020,8 +1055,8 @@ _L4MATCHATTRIBUTES = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=4081,
-  serialized_end=4443,
+  serialized_start=4533,
+  serialized_end=4895,
 )
 
 
@@ -1059,8 +1094,8 @@ _TLSMATCHATTRIBUTES_SOURCELABELSENTRY = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=3385,
-  serialized_end=3448,
+  serialized_start=3752,
+  serialized_end=3815,
 )
 
 _TLSMATCHATTRIBUTES = _descriptor.Descriptor(
@@ -1125,8 +1160,8 @@ _TLSMATCHATTRIBUTES = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=4446,
-  serialized_end=4829,
+  serialized_start=4898,
+  serialized_end=5281,
 )
 
 
@@ -1198,8 +1233,239 @@ _HTTPREDIRECT = _descriptor.Descriptor(
       create_key=_descriptor._internal_create_key,
     fields=[]),
   ],
-  serialized_start=4832,
-  serialized_end=5167,
+  serialized_start=5284,
+  serialized_end=5619,
+)
+
+
+_HTTPINTERNALACTIVEREDIRECT_REDIRECTPOLICY = _descriptor.Descriptor(
+  name='RedirectPolicy',
+  full_name='istio.networking.v1alpha3.HTTPInternalActiveRedirect.RedirectPolicy',
+  filename=None,
+  file=DESCRIPTOR,
+  containing_type=None,
+  create_key=_descriptor._internal_create_key,
+  fields=[
+    _descriptor.FieldDescriptor(
+      name='max_internal_redirects', full_name='istio.networking.v1alpha3.HTTPInternalActiveRedirect.RedirectPolicy.max_internal_redirects', index=0,
+      number=8, type=13, cpp_type=3, label=1,
+      has_default_value=False, default_value=0,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='maxInternalRedirects', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='redirect_response_codes', full_name='istio.networking.v1alpha3.HTTPInternalActiveRedirect.RedirectPolicy.redirect_response_codes', index=1,
+      number=9, type=13, cpp_type=3, label=3,
+      has_default_value=False, default_value=[],
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='redirectResponseCodes', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='redirect_url', full_name='istio.networking.v1alpha3.HTTPInternalActiveRedirect.RedirectPolicy.redirect_url', index=2,
+      number=10, type=9, cpp_type=9, label=1,
+      has_default_value=False, default_value=b"".decode('utf-8'),
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='redirectUrl', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='redirect_url_rewrite_regex', full_name='istio.networking.v1alpha3.HTTPInternalActiveRedirect.RedirectPolicy.redirect_url_rewrite_regex', index=3,
+      number=11, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='redirectUrlRewriteRegex', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='allow_cross_scheme', full_name='istio.networking.v1alpha3.HTTPInternalActiveRedirect.RedirectPolicy.allow_cross_scheme', index=4,
+      number=12, type=8, cpp_type=7, label=1,
+      has_default_value=False, default_value=False,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='allowCrossScheme', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='headers', full_name='istio.networking.v1alpha3.HTTPInternalActiveRedirect.RedirectPolicy.headers', index=5,
+      number=13, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='headers', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='authority', full_name='istio.networking.v1alpha3.HTTPInternalActiveRedirect.RedirectPolicy.authority', index=6,
+      number=14, type=9, cpp_type=9, label=1,
+      has_default_value=False, default_value=b"".decode('utf-8'),
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='authority', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='forced_use_original_host', full_name='istio.networking.v1alpha3.HTTPInternalActiveRedirect.RedirectPolicy.forced_use_original_host', index=7,
+      number=17, type=8, cpp_type=7, label=1,
+      has_default_value=False, default_value=False,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='forcedUseOriginalHost', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='forced_add_header_before_route_matcher', full_name='istio.networking.v1alpha3.HTTPInternalActiveRedirect.RedirectPolicy.forced_add_header_before_route_matcher', index=8,
+      number=18, type=8, cpp_type=7, label=1,
+      has_default_value=False, default_value=False,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='forcedAddHeaderBeforeRouteMatcher', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+  ],
+  extensions=[
+  ],
+  nested_types=[],
+  enum_types=[
+  ],
+  serialized_options=None,
+  is_extendable=False,
+  syntax='proto3',
+  extension_ranges=[],
+  oneofs=[
+    _descriptor.OneofDescriptor(
+      name='redirect_url_rewrite_specifier', full_name='istio.networking.v1alpha3.HTTPInternalActiveRedirect.RedirectPolicy.redirect_url_rewrite_specifier',
+      index=0, containing_type=None,
+      create_key=_descriptor._internal_create_key,
+    fields=[]),
+  ],
+  serialized_start=6291,
+  serialized_end=6881,
+)
+
+_HTTPINTERNALACTIVEREDIRECT = _descriptor.Descriptor(
+  name='HTTPInternalActiveRedirect',
+  full_name='istio.networking.v1alpha3.HTTPInternalActiveRedirect',
+  filename=None,
+  file=DESCRIPTOR,
+  containing_type=None,
+  create_key=_descriptor._internal_create_key,
+  fields=[
+    _descriptor.FieldDescriptor(
+      name='max_internal_redirects', full_name='istio.networking.v1alpha3.HTTPInternalActiveRedirect.max_internal_redirects', index=0,
+      number=1, type=13, cpp_type=3, label=1,
+      has_default_value=False, default_value=0,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='maxInternalRedirects', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='redirect_response_codes', full_name='istio.networking.v1alpha3.HTTPInternalActiveRedirect.redirect_response_codes', index=1,
+      number=2, type=13, cpp_type=3, label=3,
+      has_default_value=False, default_value=[],
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='redirectResponseCodes', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='redirect_url', full_name='istio.networking.v1alpha3.HTTPInternalActiveRedirect.redirect_url', index=2,
+      number=3, type=9, cpp_type=9, label=1,
+      has_default_value=False, default_value=b"".decode('utf-8'),
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='redirectUrl', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='redirect_url_rewrite_regex', full_name='istio.networking.v1alpha3.HTTPInternalActiveRedirect.redirect_url_rewrite_regex', index=3,
+      number=4, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='redirectUrlRewriteRegex', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='allow_cross_scheme', full_name='istio.networking.v1alpha3.HTTPInternalActiveRedirect.allow_cross_scheme', index=4,
+      number=5, type=8, cpp_type=7, label=1,
+      has_default_value=False, default_value=False,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='allowCrossScheme', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='headers', full_name='istio.networking.v1alpha3.HTTPInternalActiveRedirect.headers', index=5,
+      number=6, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='headers', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='authority', full_name='istio.networking.v1alpha3.HTTPInternalActiveRedirect.authority', index=6,
+      number=7, type=9, cpp_type=9, label=1,
+      has_default_value=False, default_value=b"".decode('utf-8'),
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='authority', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='forced_use_original_host', full_name='istio.networking.v1alpha3.HTTPInternalActiveRedirect.forced_use_original_host', index=7,
+      number=16, type=8, cpp_type=7, label=1,
+      has_default_value=False, default_value=False,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='forcedUseOriginalHost', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='forced_add_header_before_route_matcher', full_name='istio.networking.v1alpha3.HTTPInternalActiveRedirect.forced_add_header_before_route_matcher', index=8,
+      number=17, type=8, cpp_type=7, label=1,
+      has_default_value=False, default_value=False,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='forcedAddHeaderBeforeRouteMatcher', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='policies', full_name='istio.networking.v1alpha3.HTTPInternalActiveRedirect.policies', index=9,
+      number=15, type=11, cpp_type=10, label=3,
+      has_default_value=False, default_value=[],
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='policies', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+  ],
+  extensions=[
+  ],
+  nested_types=[_HTTPINTERNALACTIVEREDIRECT_REDIRECTPOLICY, ],
+  enum_types=[
+  ],
+  serialized_options=None,
+  is_extendable=False,
+  syntax='proto3',
+  extension_ranges=[],
+  oneofs=[
+    _descriptor.OneofDescriptor(
+      name='redirect_url_rewrite_specifier', full_name='istio.networking.v1alpha3.HTTPInternalActiveRedirect.redirect_url_rewrite_specifier',
+      index=0, containing_type=None,
+      create_key=_descriptor._internal_create_key,
+    fields=[]),
+  ],
+  serialized_start=5622,
+  serialized_end=6915,
+)
+
+
+_HTTPDIRECTRESPONSE = _descriptor.Descriptor(
+  name='HTTPDirectResponse',
+  full_name='istio.networking.v1alpha3.HTTPDirectResponse',
+  filename=None,
+  file=DESCRIPTOR,
+  containing_type=None,
+  create_key=_descriptor._internal_create_key,
+  fields=[
+    _descriptor.FieldDescriptor(
+      name='response_code', full_name='istio.networking.v1alpha3.HTTPDirectResponse.response_code', index=0,
+      number=1, type=13, cpp_type=3, label=1,
+      has_default_value=False, default_value=0,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='responseCode', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='body', full_name='istio.networking.v1alpha3.HTTPDirectResponse.body', index=1,
+      number=2, type=9, cpp_type=9, label=1,
+      has_default_value=False, default_value=b"".decode('utf-8'),
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='body', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+  ],
+  extensions=[
+  ],
+  nested_types=[],
+  enum_types=[
+  ],
+  serialized_options=None,
+  is_extendable=False,
+  syntax='proto3',
+  extension_ranges=[],
+  oneofs=[
+  ],
+  serialized_start=6917,
+  serialized_end=6994,
 )
 
 
@@ -1225,6 +1491,52 @@ _HTTPREWRITE = _descriptor.Descriptor(
       message_type=None, enum_type=None, containing_type=None,
       is_extension=False, extension_scope=None,
       serialized_options=None, json_name='authority', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='uri_regex', full_name='istio.networking.v1alpha3.HTTPRewrite.uri_regex', index=2,
+      number=3, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='uriRegex', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+  ],
+  extensions=[
+  ],
+  nested_types=[],
+  enum_types=[
+  ],
+  serialized_options=None,
+  is_extendable=False,
+  syntax='proto3',
+  extension_ranges=[],
+  oneofs=[
+  ],
+  serialized_start=6997,
+  serialized_end=7139,
+)
+
+
+_REGEXMATCHANDSUBSTITUTE = _descriptor.Descriptor(
+  name='RegexMatchAndSubstitute',
+  full_name='istio.networking.v1alpha3.RegexMatchAndSubstitute',
+  filename=None,
+  file=DESCRIPTOR,
+  containing_type=None,
+  create_key=_descriptor._internal_create_key,
+  fields=[
+    _descriptor.FieldDescriptor(
+      name='pattern', full_name='istio.networking.v1alpha3.RegexMatchAndSubstitute.pattern', index=0,
+      number=1, type=9, cpp_type=9, label=1,
+      has_default_value=False, default_value=b"".decode('utf-8'),
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='pattern', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='substitution', full_name='istio.networking.v1alpha3.RegexMatchAndSubstitute.substitution', index=1,
+      number=2, type=9, cpp_type=9, label=1,
+      has_default_value=False, default_value=b"".decode('utf-8'),
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='substitution', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
   ],
   extensions=[
   ],
@@ -1237,8 +1549,8 @@ _HTTPREWRITE = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=5169,
-  serialized_end=5230,
+  serialized_start=7141,
+  serialized_end=7228,
 )
 
 
@@ -1288,8 +1600,8 @@ _STRINGMATCH = _descriptor.Descriptor(
       create_key=_descriptor._internal_create_key,
     fields=[]),
   ],
-  serialized_start=5232,
-  serialized_end=5333,
+  serialized_start=7230,
+  serialized_end=7331,
 )
 
 
@@ -1341,8 +1653,8 @@ _HTTPRETRY = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=5336,
-  serialized_end=5559,
+  serialized_start=7334,
+  serialized_end=7557,
 )
 
 
@@ -1415,8 +1727,8 @@ _CORSPOLICY = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=5562,
-  serialized_end=5928,
+  serialized_start=7560,
+  serialized_end=7926,
 )
 
 
@@ -1473,8 +1785,8 @@ _HTTPFAULTINJECTION_DELAY = _descriptor.Descriptor(
       create_key=_descriptor._internal_create_key,
     fields=[]),
   ],
-  serialized_start=6104,
-  serialized_end=6370,
+  serialized_start=8102,
+  serialized_end=8368,
 )
 
 _HTTPFAULTINJECTION_ABORT = _descriptor.Descriptor(
@@ -1530,8 +1842,8 @@ _HTTPFAULTINJECTION_ABORT = _descriptor.Descriptor(
       create_key=_descriptor._internal_create_key,
     fields=[]),
   ],
-  serialized_start=6373,
-  serialized_end=6588,
+  serialized_start=8371,
+  serialized_end=8586,
 )
 
 _HTTPFAULTINJECTION = _descriptor.Descriptor(
@@ -1568,8 +1880,8 @@ _HTTPFAULTINJECTION = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=5931,
-  serialized_end=6588,
+  serialized_start=7929,
+  serialized_end=8586,
 )
 
 
@@ -1600,8 +1912,8 @@ _PORTSELECTOR = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=6590,
-  serialized_end=6640,
+  serialized_start=8588,
+  serialized_end=8638,
 )
 
 
@@ -1632,17 +1944,210 @@ _PERCENT = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=6642,
-  serialized_end=6673,
+  serialized_start=8640,
+  serialized_end=8671,
+)
+
+
+_HTTPFILTER = _descriptor.Descriptor(
+  name='HTTPFilter',
+  full_name='istio.networking.v1alpha3.HTTPFilter',
+  filename=None,
+  file=DESCRIPTOR,
+  containing_type=None,
+  create_key=_descriptor._internal_create_key,
+  fields=[
+    _descriptor.FieldDescriptor(
+      name='name', full_name='istio.networking.v1alpha3.HTTPFilter.name', index=0,
+      number=1, type=9, cpp_type=9, label=1,
+      has_default_value=False, default_value=b"".decode('utf-8'),
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='name', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='disable', full_name='istio.networking.v1alpha3.HTTPFilter.disable', index=1,
+      number=2, type=8, cpp_type=7, label=1,
+      has_default_value=False, default_value=False,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='disable', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='ip_access_control', full_name='istio.networking.v1alpha3.HTTPFilter.ip_access_control', index=2,
+      number=3, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='ipAccessControl', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='local_rate_limit', full_name='istio.networking.v1alpha3.HTTPFilter.local_rate_limit', index=3,
+      number=4, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='localRateLimit', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+  ],
+  extensions=[
+  ],
+  nested_types=[],
+  enum_types=[
+  ],
+  serialized_options=None,
+  is_extendable=False,
+  syntax='proto3',
+  extension_ranges=[],
+  oneofs=[
+    _descriptor.OneofDescriptor(
+      name='Filter', full_name='istio.networking.v1alpha3.HTTPFilter.Filter',
+      index=0, containing_type=None,
+      create_key=_descriptor._internal_create_key,
+    fields=[]),
+  ],
+  serialized_start=8674,
+  serialized_end=8919,
+)
+
+
+_IPACCESSCONTROL = _descriptor.Descriptor(
+  name='IPAccessControl',
+  full_name='istio.networking.v1alpha3.IPAccessControl',
+  filename=None,
+  file=DESCRIPTOR,
+  containing_type=None,
+  create_key=_descriptor._internal_create_key,
+  fields=[
+    _descriptor.FieldDescriptor(
+      name='remote_ip_blocks', full_name='istio.networking.v1alpha3.IPAccessControl.remote_ip_blocks', index=0,
+      number=1, type=9, cpp_type=9, label=3,
+      has_default_value=False, default_value=[],
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='remoteIpBlocks', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='not_remote_ip_blocks', full_name='istio.networking.v1alpha3.IPAccessControl.not_remote_ip_blocks', index=1,
+      number=2, type=9, cpp_type=9, label=3,
+      has_default_value=False, default_value=[],
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='notRemoteIpBlocks', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+  ],
+  extensions=[
+  ],
+  nested_types=[],
+  enum_types=[
+  ],
+  serialized_options=None,
+  is_extendable=False,
+  syntax='proto3',
+  extension_ranges=[],
+  oneofs=[
+  ],
+  serialized_start=8921,
+  serialized_end=9029,
+)
+
+
+_LOCALRATELIMIT = _descriptor.Descriptor(
+  name='LocalRateLimit',
+  full_name='istio.networking.v1alpha3.LocalRateLimit',
+  filename=None,
+  file=DESCRIPTOR,
+  containing_type=None,
+  create_key=_descriptor._internal_create_key,
+  fields=[
+    _descriptor.FieldDescriptor(
+      name='token_bucket', full_name='istio.networking.v1alpha3.LocalRateLimit.token_bucket', index=0,
+      number=1, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='tokenBucket', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='per_downstream_connection', full_name='istio.networking.v1alpha3.LocalRateLimit.per_downstream_connection', index=1,
+      number=2, type=8, cpp_type=7, label=1,
+      has_default_value=False, default_value=False,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='perDownstreamConnection', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='status_code', full_name='istio.networking.v1alpha3.LocalRateLimit.status_code', index=2,
+      number=3, type=13, cpp_type=3, label=1,
+      has_default_value=False, default_value=0,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='statusCode', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+  ],
+  extensions=[
+  ],
+  nested_types=[],
+  enum_types=[
+  ],
+  serialized_options=None,
+  is_extendable=False,
+  syntax='proto3',
+  extension_ranges=[],
+  oneofs=[
+  ],
+  serialized_start=9032,
+  serialized_end=9216,
+)
+
+
+_TOKENBUCKET = _descriptor.Descriptor(
+  name='TokenBucket',
+  full_name='istio.networking.v1alpha3.TokenBucket',
+  filename=None,
+  file=DESCRIPTOR,
+  containing_type=None,
+  create_key=_descriptor._internal_create_key,
+  fields=[
+    _descriptor.FieldDescriptor(
+      name='max_tokens', full_name='istio.networking.v1alpha3.TokenBucket.max_tokens', index=0,
+      number=1, type=13, cpp_type=3, label=1,
+      has_default_value=False, default_value=0,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='maxTokens', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='tokens_pef_fill', full_name='istio.networking.v1alpha3.TokenBucket.tokens_pef_fill', index=1,
+      number=2, type=13, cpp_type=3, label=1,
+      has_default_value=False, default_value=0,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='tokensPefFill', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='fill_interval', full_name='istio.networking.v1alpha3.TokenBucket.fill_interval', index=2,
+      number=3, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='fillInterval', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+  ],
+  extensions=[
+  ],
+  nested_types=[],
+  enum_types=[
+  ],
+  serialized_options=None,
+  is_extendable=False,
+  syntax='proto3',
+  extension_ranges=[],
+  oneofs=[
+  ],
+  serialized_start=9219,
+  serialized_end=9367,
 )
 
+_VIRTUALSERVICE.fields_by_name['hostHTTPFilters'].message_type = _HTTPFILTER
 _VIRTUALSERVICE.fields_by_name['http'].message_type = _HTTPROUTE
 _VIRTUALSERVICE.fields_by_name['tls'].message_type = _TLSROUTE
 _VIRTUALSERVICE.fields_by_name['tcp'].message_type = _TCPROUTE
 _DESTINATION.fields_by_name['port'].message_type = _PORTSELECTOR
 _HTTPROUTE.fields_by_name['match'].message_type = _HTTPMATCHREQUEST
 _HTTPROUTE.fields_by_name['route'].message_type = _HTTPROUTEDESTINATION
+_HTTPROUTE.fields_by_name['routeHTTPFilters'].message_type = _HTTPFILTER
 _HTTPROUTE.fields_by_name['redirect'].message_type = _HTTPREDIRECT
+_HTTPROUTE.fields_by_name['internal_active_redirect'].message_type = _HTTPINTERNALACTIVEREDIRECT
+_HTTPROUTE.fields_by_name['direct_response'].message_type = _HTTPDIRECTRESPONSE
 _HTTPROUTE.fields_by_name['delegate'].message_type = _DELEGATE
 _HTTPROUTE.fields_by_name['rewrite'].message_type = _HTTPREWRITE
 _HTTPROUTE.fields_by_name['timeout'].message_type = google_dot_protobuf_dot_duration__pb2._DURATION
@@ -1681,6 +2186,7 @@ _HTTPMATCHREQUEST.fields_by_name['query_params'].message_type = _HTTPMATCHREQUES
 _HTTPMATCHREQUEST.fields_by_name['without_headers'].message_type = _HTTPMATCHREQUEST_WITHOUTHEADERSENTRY
 _HTTPROUTEDESTINATION.fields_by_name['destination'].message_type = _DESTINATION
 _HTTPROUTEDESTINATION.fields_by_name['headers'].message_type = _HEADERS
+_HTTPROUTEDESTINATION.fields_by_name['fallback_clusters'].message_type = _DESTINATION
 _ROUTEDESTINATION.fields_by_name['destination'].message_type = _DESTINATION
 _L4MATCHATTRIBUTES_SOURCELABELSENTRY.containing_type = _L4MATCHATTRIBUTES
 _L4MATCHATTRIBUTES.fields_by_name['source_labels'].message_type = _L4MATCHATTRIBUTES_SOURCELABELSENTRY
@@ -1694,6 +2200,25 @@ _HTTPREDIRECT.fields_by_name['port'].containing_oneof = _HTTPREDIRECT.oneofs_by_
 _HTTPREDIRECT.oneofs_by_name['redirect_port'].fields.append(
   _HTTPREDIRECT.fields_by_name['derive_port'])
 _HTTPREDIRECT.fields_by_name['derive_port'].containing_oneof = _HTTPREDIRECT.oneofs_by_name['redirect_port']
+_HTTPINTERNALACTIVEREDIRECT_REDIRECTPOLICY.fields_by_name['redirect_url_rewrite_regex'].message_type = _REGEXMATCHANDSUBSTITUTE
+_HTTPINTERNALACTIVEREDIRECT_REDIRECTPOLICY.fields_by_name['headers'].message_type = _HEADERS
+_HTTPINTERNALACTIVEREDIRECT_REDIRECTPOLICY.containing_type = _HTTPINTERNALACTIVEREDIRECT
+_HTTPINTERNALACTIVEREDIRECT_REDIRECTPOLICY.oneofs_by_name['redirect_url_rewrite_specifier'].fields.append(
+  _HTTPINTERNALACTIVEREDIRECT_REDIRECTPOLICY.fields_by_name['redirect_url'])
+_HTTPINTERNALACTIVEREDIRECT_REDIRECTPOLICY.fields_by_name['redirect_url'].containing_oneof = _HTTPINTERNALACTIVEREDIRECT_REDIRECTPOLICY.oneofs_by_name['redirect_url_rewrite_specifier']
+_HTTPINTERNALACTIVEREDIRECT_REDIRECTPOLICY.oneofs_by_name['redirect_url_rewrite_specifier'].fields.append(
+  _HTTPINTERNALACTIVEREDIRECT_REDIRECTPOLICY.fields_by_name['redirect_url_rewrite_regex'])
+_HTTPINTERNALACTIVEREDIRECT_REDIRECTPOLICY.fields_by_name['redirect_url_rewrite_regex'].containing_oneof = _HTTPINTERNALACTIVEREDIRECT_REDIRECTPOLICY.oneofs_by_name['redirect_url_rewrite_specifier']
+_HTTPINTERNALACTIVEREDIRECT.fields_by_name['redirect_url_rewrite_regex'].message_type = _REGEXMATCHANDSUBSTITUTE
+_HTTPINTERNALACTIVEREDIRECT.fields_by_name['headers'].message_type = _HEADERS
+_HTTPINTERNALACTIVEREDIRECT.fields_by_name['policies'].message_type = _HTTPINTERNALACTIVEREDIRECT_REDIRECTPOLICY
+_HTTPINTERNALACTIVEREDIRECT.oneofs_by_name['redirect_url_rewrite_specifier'].fields.append(
+  _HTTPINTERNALACTIVEREDIRECT.fields_by_name['redirect_url'])
+_HTTPINTERNALACTIVEREDIRECT.fields_by_name['redirect_url'].containing_oneof = _HTTPINTERNALACTIVEREDIRECT.oneofs_by_name['redirect_url_rewrite_specifier']
+_HTTPINTERNALACTIVEREDIRECT.oneofs_by_name['redirect_url_rewrite_specifier'].fields.append(
+  _HTTPINTERNALACTIVEREDIRECT.fields_by_name['redirect_url_rewrite_regex'])
+_HTTPINTERNALACTIVEREDIRECT.fields_by_name['redirect_url_rewrite_regex'].containing_oneof = _HTTPINTERNALACTIVEREDIRECT.oneofs_by_name['redirect_url_rewrite_specifier']
+_HTTPREWRITE.fields_by_name['uri_regex'].message_type = _REGEXMATCHANDSUBSTITUTE
 _STRINGMATCH.oneofs_by_name['match_type'].fields.append(
   _STRINGMATCH.fields_by_name['exact'])
 _STRINGMATCH.fields_by_name['exact'].containing_oneof = _STRINGMATCH.oneofs_by_name['match_type']
@@ -1731,6 +2256,16 @@ _HTTPFAULTINJECTION_ABORT.oneofs_by_name['error_type'].fields.append(
 _HTTPFAULTINJECTION_ABORT.fields_by_name['http2_error'].containing_oneof = _HTTPFAULTINJECTION_ABORT.oneofs_by_name['error_type']
 _HTTPFAULTINJECTION.fields_by_name['delay'].message_type = _HTTPFAULTINJECTION_DELAY
 _HTTPFAULTINJECTION.fields_by_name['abort'].message_type = _HTTPFAULTINJECTION_ABORT
+_HTTPFILTER.fields_by_name['ip_access_control'].message_type = _IPACCESSCONTROL
+_HTTPFILTER.fields_by_name['local_rate_limit'].message_type = _LOCALRATELIMIT
+_HTTPFILTER.oneofs_by_name['Filter'].fields.append(
+  _HTTPFILTER.fields_by_name['ip_access_control'])
+_HTTPFILTER.fields_by_name['ip_access_control'].containing_oneof = _HTTPFILTER.oneofs_by_name['Filter']
+_HTTPFILTER.oneofs_by_name['Filter'].fields.append(
+  _HTTPFILTER.fields_by_name['local_rate_limit'])
+_HTTPFILTER.fields_by_name['local_rate_limit'].containing_oneof = _HTTPFILTER.oneofs_by_name['Filter']
+_LOCALRATELIMIT.fields_by_name['token_bucket'].message_type = _TOKENBUCKET
+_TOKENBUCKET.fields_by_name['fill_interval'].message_type = google_dot_protobuf_dot_duration__pb2._DURATION
 DESCRIPTOR.message_types_by_name['VirtualService'] = _VIRTUALSERVICE
 DESCRIPTOR.message_types_by_name['Destination'] = _DESTINATION
 DESCRIPTOR.message_types_by_name['HTTPRoute'] = _HTTPROUTE
@@ -1744,13 +2279,20 @@ DESCRIPTOR.message_types_by_name['RouteDestination'] = _ROUTEDESTINATION
 DESCRIPTOR.message_types_by_name['L4MatchAttributes'] = _L4MATCHATTRIBUTES
 DESCRIPTOR.message_types_by_name['TLSMatchAttributes'] = _TLSMATCHATTRIBUTES
 DESCRIPTOR.message_types_by_name['HTTPRedirect'] = _HTTPREDIRECT
+DESCRIPTOR.message_types_by_name['HTTPInternalActiveRedirect'] = _HTTPINTERNALACTIVEREDIRECT
+DESCRIPTOR.message_types_by_name['HTTPDirectResponse'] = _HTTPDIRECTRESPONSE
 DESCRIPTOR.message_types_by_name['HTTPRewrite'] = _HTTPREWRITE
+DESCRIPTOR.message_types_by_name['RegexMatchAndSubstitute'] = _REGEXMATCHANDSUBSTITUTE
 DESCRIPTOR.message_types_by_name['StringMatch'] = _STRINGMATCH
 DESCRIPTOR.message_types_by_name['HTTPRetry'] = _HTTPRETRY
 DESCRIPTOR.message_types_by_name['CorsPolicy'] = _CORSPOLICY
 DESCRIPTOR.message_types_by_name['HTTPFaultInjection'] = _HTTPFAULTINJECTION
 DESCRIPTOR.message_types_by_name['PortSelector'] = _PORTSELECTOR
 DESCRIPTOR.message_types_by_name['Percent'] = _PERCENT
+DESCRIPTOR.message_types_by_name['HTTPFilter'] = _HTTPFILTER
+DESCRIPTOR.message_types_by_name['IPAccessControl'] = _IPACCESSCONTROL
+DESCRIPTOR.message_types_by_name['LocalRateLimit'] = _LOCALRATELIMIT
+DESCRIPTOR.message_types_by_name['TokenBucket'] = _TOKENBUCKET
 _sym_db.RegisterFileDescriptor(DESCRIPTOR)
 
 VirtualService = _reflection.GeneratedProtocolMessageType('VirtualService', (_message.Message,), {
@@ -1916,6 +2458,28 @@ HTTPRedirect = _reflection.GeneratedProtocolMessageType('HTTPRedirect', (_messag
   })
 _sym_db.RegisterMessage(HTTPRedirect)
 
+HTTPInternalActiveRedirect = _reflection.GeneratedProtocolMessageType('HTTPInternalActiveRedirect', (_message.Message,), {
+
+  'RedirectPolicy' : _reflection.GeneratedProtocolMessageType('RedirectPolicy', (_message.Message,), {
+    'DESCRIPTOR' : _HTTPINTERNALACTIVEREDIRECT_REDIRECTPOLICY,
+    '__module__' : 'networking.v1alpha3.virtual_service_pb2'
+    # @@protoc_insertion_point(class_scope:istio.networking.v1alpha3.HTTPInternalActiveRedirect.RedirectPolicy)
+    })
+  ,
+  'DESCRIPTOR' : _HTTPINTERNALACTIVEREDIRECT,
+  '__module__' : 'networking.v1alpha3.virtual_service_pb2'
+  # @@protoc_insertion_point(class_scope:istio.networking.v1alpha3.HTTPInternalActiveRedirect)
+  })
+_sym_db.RegisterMessage(HTTPInternalActiveRedirect)
+_sym_db.RegisterMessage(HTTPInternalActiveRedirect.RedirectPolicy)
+
+HTTPDirectResponse = _reflection.GeneratedProtocolMessageType('HTTPDirectResponse', (_message.Message,), {
+  'DESCRIPTOR' : _HTTPDIRECTRESPONSE,
+  '__module__' : 'networking.v1alpha3.virtual_service_pb2'
+  # @@protoc_insertion_point(class_scope:istio.networking.v1alpha3.HTTPDirectResponse)
+  })
+_sym_db.RegisterMessage(HTTPDirectResponse)
+
 HTTPRewrite = _reflection.GeneratedProtocolMessageType('HTTPRewrite', (_message.Message,), {
   'DESCRIPTOR' : _HTTPREWRITE,
   '__module__' : 'networking.v1alpha3.virtual_service_pb2'
@@ -1923,6 +2487,13 @@ HTTPRewrite = _reflection.GeneratedProtocolMessageType('HTTPRewrite', (_message.
   })
 _sym_db.RegisterMessage(HTTPRewrite)
 
+RegexMatchAndSubstitute = _reflection.GeneratedProtocolMessageType('RegexMatchAndSubstitute', (_message.Message,), {
+  'DESCRIPTOR' : _REGEXMATCHANDSUBSTITUTE,
+  '__module__' : 'networking.v1alpha3.virtual_service_pb2'
+  # @@protoc_insertion_point(class_scope:istio.networking.v1alpha3.RegexMatchAndSubstitute)
+  })
+_sym_db.RegisterMessage(RegexMatchAndSubstitute)
+
 StringMatch = _reflection.GeneratedProtocolMessageType('StringMatch', (_message.Message,), {
   'DESCRIPTOR' : _STRINGMATCH,
   '__module__' : 'networking.v1alpha3.virtual_service_pb2'
@@ -1981,6 +2552,34 @@ Percent = _reflection.GeneratedProtocolMessageType('Percent', (_message.Message,
   })
 _sym_db.RegisterMessage(Percent)
 
+HTTPFilter = _reflection.GeneratedProtocolMessageType('HTTPFilter', (_message.Message,), {
+  'DESCRIPTOR' : _HTTPFILTER,
+  '__module__' : 'networking.v1alpha3.virtual_service_pb2'
+  # @@protoc_insertion_point(class_scope:istio.networking.v1alpha3.HTTPFilter)
+  })
+_sym_db.RegisterMessage(HTTPFilter)
+
+IPAccessControl = _reflection.GeneratedProtocolMessageType('IPAccessControl', (_message.Message,), {
+  'DESCRIPTOR' : _IPACCESSCONTROL,
+  '__module__' : 'networking.v1alpha3.virtual_service_pb2'
+  # @@protoc_insertion_point(class_scope:istio.networking.v1alpha3.IPAccessControl)
+  })
+_sym_db.RegisterMessage(IPAccessControl)
+
+LocalRateLimit = _reflection.GeneratedProtocolMessageType('LocalRateLimit', (_message.Message,), {
+  'DESCRIPTOR' : _LOCALRATELIMIT,
+  '__module__' : 'networking.v1alpha3.virtual_service_pb2'
+  # @@protoc_insertion_point(class_scope:istio.networking.v1alpha3.LocalRateLimit)
+  })
+_sym_db.RegisterMessage(LocalRateLimit)
+
+TokenBucket = _reflection.GeneratedProtocolMessageType('TokenBucket', (_message.Message,), {
+  'DESCRIPTOR' : _TOKENBUCKET,
+  '__module__' : 'networking.v1alpha3.virtual_service_pb2'
+  # @@protoc_insertion_point(class_scope:istio.networking.v1alpha3.TokenBucket)
+  })
+_sym_db.RegisterMessage(TokenBucket)
+
 
 DESCRIPTOR._options = None
 _DESTINATION.fields_by_name['host']._options = None
diff --git a/python/istio_api/networking/v1beta1/destination_rule_pb2.py b/python/istio_api/networking/v1beta1/destination_rule_pb2.py
index cbb8b133..a9b58468 100644
--- a/python/istio_api/networking/v1beta1/destination_rule_pb2.py
+++ b/python/istio_api/networking/v1beta1/destination_rule_pb2.py
@@ -2,6 +2,7 @@
 # Generated by the protocol buffer compiler.  DO NOT EDIT!
 # source: networking/v1beta1/destination_rule.proto
 """Generated protocol buffer code."""
+from google.protobuf.internal import enum_type_wrapper
 from google.protobuf import descriptor as _descriptor
 from google.protobuf import message as _message
 from google.protobuf import reflection as _reflection
@@ -24,10 +25,62 @@ DESCRIPTOR = _descriptor.FileDescriptor(
   syntax='proto3',
   serialized_options=b'Z\037istio.io/api/networking/v1beta1',
   create_key=_descriptor._internal_create_key,
-  serialized_pb=b'\n)networking/v1beta1/destination_rule.proto\x12\x18istio.networking.v1beta1\x1a\x1fgoogle/api/field_behavior.proto\x1a\x1egoogle/protobuf/duration.proto\x1a\x1egoogle/protobuf/wrappers.proto\x1a(networking/v1beta1/virtual_service.proto\x1a\x14gogoproto/gogo.proto\"\xd4\x01\n\x0f\x44\x65stinationRule\x12\x18\n\x04host\x18\x01 \x01(\tB\x04\xe2\x41\x01\x02R\x04host\x12N\n\x0etraffic_policy\x18\x02 \x01(\x0b\x32\'.istio.networking.v1beta1.TrafficPolicyR\rtrafficPolicy\x12:\n\x07subsets\x18\x03 \x03(\x0b\x32 .istio.networking.v1beta1.SubsetR\x07subsets\x12\x1b\n\texport_to\x18\x04 \x03(\tR\x08\x65xportTo\"\xdc\x06\n\rTrafficPolicy\x12S\n\rload_balancer\x18\x01 \x01(\x0b\x32..istio.networking.v1beta1.LoadBalancerSettingsR\x0cloadBalancer\x12Y\n\x0f\x63onnection_pool\x18\x02 \x01(\x0b\x32\x30.istio.networking.v1beta1.ConnectionPoolSettingsR\x0e\x63onnectionPool\x12W\n\x11outlier_detection\x18\x03 \x01(\x0b\x32*.istio.networking.v1beta1.OutlierDetectionR\x10outlierDetection\x12=\n\x03tls\x18\x04 \x01(\x0b\x32+.istio.networking.v1beta1.ClientTLSSettingsR\x03tls\x12i\n\x13port_level_settings\x18\x05 \x03(\x0b\x32\x39.istio.networking.v1beta1.TrafficPolicy.PortTrafficPolicyR\x11portLevelSettings\x1a\x97\x03\n\x11PortTrafficPolicy\x12:\n\x04port\x18\x01 \x01(\x0b\x32&.istio.networking.v1beta1.PortSelectorR\x04port\x12S\n\rload_balancer\x18\x02 \x01(\x0b\x32..istio.networking.v1beta1.LoadBalancerSettingsR\x0cloadBalancer\x12Y\n\x0f\x63onnection_pool\x18\x03 \x01(\x0b\x32\x30.istio.networking.v1beta1.ConnectionPoolSettingsR\x0e\x63onnectionPool\x12W\n\x11outlier_detection\x18\x04 \x01(\x0b\x32*.istio.networking.v1beta1.OutlierDetectionR\x10outlierDetection\x12=\n\x03tls\x18\x05 \x01(\x0b\x32+.istio.networking.v1beta1.ClientTLSSettingsR\x03tls\"\xf3\x01\n\x06Subset\x12\x18\n\x04name\x18\x01 \x01(\tB\x04\xe2\x41\x01\x02R\x04name\x12\x44\n\x06labels\x18\x02 \x03(\x0b\x32,.istio.networking.v1beta1.Subset.LabelsEntryR\x06labels\x12N\n\x0etraffic_policy\x18\x03 \x01(\x0b\x32\'.istio.networking.v1beta1.TrafficPolicyR\rtrafficPolicy\x1a\x39\n\x0bLabelsEntry\x12\x10\n\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n\x05value\x18\x02 \x01(\tR\x05value:\x02\x38\x01\"\xcd\x06\n\x14LoadBalancerSettings\x12Q\n\x06simple\x18\x01 \x01(\x0e\x32\x37.istio.networking.v1beta1.LoadBalancerSettings.SimpleLBH\x00R\x06simple\x12j\n\x0f\x63onsistent_hash\x18\x02 \x01(\x0b\x32?.istio.networking.v1beta1.LoadBalancerSettings.ConsistentHashLBH\x00R\x0e\x63onsistentHash\x12\x65\n\x13locality_lb_setting\x18\x03 \x01(\x0b\x32\x35.istio.networking.v1beta1.LocalityLoadBalancerSettingR\x11localityLbSetting\x1a\xb7\x03\n\x10\x43onsistentHashLB\x12*\n\x10http_header_name\x18\x01 \x01(\tH\x00R\x0ehttpHeaderName\x12m\n\x0bhttp_cookie\x18\x02 \x01(\x0b\x32J.istio.networking.v1beta1.LoadBalancerSettings.ConsistentHashLB.HTTPCookieH\x00R\nhttpCookie\x12$\n\ruse_source_ip\x18\x03 \x01(\x08H\x00R\x0buseSourceIp\x12;\n\x19http_query_parameter_name\x18\x05 \x01(\tH\x00R\x16httpQueryParameterName\x12*\n\x11minimum_ring_size\x18\x04 \x01(\x04R\x0fminimumRingSize\x1am\n\nHTTPCookie\x12\x18\n\x04name\x18\x01 \x01(\tB\x04\xe2\x41\x01\x02R\x04name\x12\x12\n\x04path\x18\x02 \x01(\tR\x04path\x12\x31\n\x03ttl\x18\x03 \x01(\x0b\x32\x19.google.protobuf.DurationB\x04\xe2\x41\x01\x02R\x03ttlB\n\n\x08hash_key\"H\n\x08SimpleLB\x12\x0f\n\x0bROUND_ROBIN\x10\x00\x12\x0e\n\nLEAST_CONN\x10\x01\x12\n\n\x06RANDOM\x10\x02\x12\x0f\n\x0bPASSTHROUGH\x10\x03\x42\x0b\n\tlb_policy\"\xbd\x08\n\x16\x43onnectionPoolSettings\x12N\n\x03tcp\x18\x01 \x01(\x0b\x32<.istio.networking.v1beta1.ConnectionPoolSettings.TCPSettingsR\x03tcp\x12Q\n\x04http\x18\x02 \x01(\x0b\x32=.istio.networking.v1beta1.ConnectionPoolSettings.HTTPSettingsR\x04http\x1a\xf9\x02\n\x0bTCPSettings\x12\'\n\x0fmax_connections\x18\x01 \x01(\x05R\x0emaxConnections\x12\x42\n\x0f\x63onnect_timeout\x18\x02 \x01(\x0b\x32\x19.google.protobuf.DurationR\x0e\x63onnectTimeout\x12n\n\rtcp_keepalive\x18\x03 \x01(\x0b\x32I.istio.networking.v1beta1.ConnectionPoolSettings.TCPSettings.TcpKeepaliveR\x0ctcpKeepalive\x1a\x8c\x01\n\x0cTcpKeepalive\x12\x16\n\x06probes\x18\x01 \x01(\rR\x06probes\x12-\n\x04time\x18\x02 \x01(\x0b\x32\x19.google.protobuf.DurationR\x04time\x12\x35\n\x08interval\x18\x03 \x01(\x0b\x32\x19.google.protobuf.DurationR\x08interval\x1a\x83\x04\n\x0cHTTPSettings\x12;\n\x1ahttp1_max_pending_requests\x18\x01 \x01(\x05R\x17http1MaxPendingRequests\x12,\n\x12http2_max_requests\x18\x02 \x01(\x05R\x10http2MaxRequests\x12=\n\x1bmax_requests_per_connection\x18\x03 \x01(\x05R\x18maxRequestsPerConnection\x12\x1f\n\x0bmax_retries\x18\x04 \x01(\x05R\nmaxRetries\x12<\n\x0cidle_timeout\x18\x05 \x01(\x0b\x32\x19.google.protobuf.DurationR\x0bidleTimeout\x12y\n\x11h2_upgrade_policy\x18\x06 \x01(\x0e\x32M.istio.networking.v1beta1.ConnectionPoolSettings.HTTPSettings.H2UpgradePolicyR\x0fh2UpgradePolicy\x12.\n\x13use_client_protocol\x18\x07 \x01(\x08R\x11useClientProtocol\"?\n\x0fH2UpgradePolicy\x12\x0b\n\x07\x44\x45\x46\x41ULT\x10\x00\x12\x12\n\x0e\x44O_NOT_UPGRADE\x10\x01\x12\x0b\n\x07UPGRADE\x10\x02\"\x8a\x05\n\x10OutlierDetection\x12\x31\n\x12\x63onsecutive_errors\x18\x01 \x01(\x05\x42\x02\x18\x01R\x11\x63onsecutiveErrors\x12J\n\"split_external_local_origin_errors\x18\x08 \x01(\x08R\x1esplitExternalLocalOriginErrors\x12g\n!consecutive_local_origin_failures\x18\t \x01(\x0b\x32\x1c.google.protobuf.UInt32ValueR\x1e\x63onsecutiveLocalOriginFailures\x12Z\n\x1a\x63onsecutive_gateway_errors\x18\x06 \x01(\x0b\x32\x1c.google.protobuf.UInt32ValueR\x18\x63onsecutiveGatewayErrors\x12R\n\x16\x63onsecutive_5xx_errors\x18\x07 \x01(\x0b\x32\x1c.google.protobuf.UInt32ValueR\x14\x63onsecutive5xxErrors\x12\x35\n\x08interval\x18\x02 \x01(\x0b\x32\x19.google.protobuf.DurationR\x08interval\x12G\n\x12\x62\x61se_ejection_time\x18\x03 \x01(\x0b\x32\x19.google.protobuf.DurationR\x10\x62\x61seEjectionTime\x12\x30\n\x14max_ejection_percent\x18\x04 \x01(\x05R\x12maxEjectionPercent\x12,\n\x12min_health_percent\x18\x05 \x01(\x05R\x10minHealthPercent\"\xd2\x03\n\x11\x43lientTLSSettings\x12M\n\x04mode\x18\x01 \x01(\x0e\x32\x33.istio.networking.v1beta1.ClientTLSSettings.TLSmodeB\x04\xe2\x41\x01\x02R\x04mode\x12-\n\x12\x63lient_certificate\x18\x02 \x01(\tR\x11\x63lientCertificate\x12\x1f\n\x0bprivate_key\x18\x03 \x01(\tR\nprivateKey\x12\'\n\x0f\x63\x61_certificates\x18\x04 \x01(\tR\x0e\x63\x61\x43\x65rtificates\x12\'\n\x0f\x63redential_name\x18\x07 \x01(\tR\x0e\x63redentialName\x12*\n\x11subject_alt_names\x18\x05 \x03(\tR\x0fsubjectAltNames\x12\x10\n\x03sni\x18\x06 \x01(\tR\x03sni\x12L\n\x14insecure_skip_verify\x18\x08 \x01(\x0b\x32\x1a.google.protobuf.BoolValueR\x12insecureSkipVerify\"@\n\x07TLSmode\x12\x0b\n\x07\x44ISABLE\x10\x00\x12\n\n\x06SIMPLE\x10\x01\x12\n\n\x06MUTUAL\x10\x02\x12\x10\n\x0cISTIO_MUTUAL\x10\x03\"\xa2\x04\n\x1bLocalityLoadBalancerSetting\x12`\n\ndistribute\x18\x01 \x03(\x0b\x32@.istio.networking.v1beta1.LocalityLoadBalancerSetting.DistributeR\ndistribute\x12Z\n\x08\x66\x61ilover\x18\x02 \x03(\x0b\x32>.istio.networking.v1beta1.LocalityLoadBalancerSetting.FailoverR\x08\x66\x61ilover\x12+\n\x11\x66\x61ilover_priority\x18\x04 \x03(\tR\x10\x66\x61iloverPriority\x12\x34\n\x07\x65nabled\x18\x03 \x01(\x0b\x32\x1a.google.protobuf.BoolValueR\x07\x65nabled\x1a\xb1\x01\n\nDistribute\x12\x12\n\x04\x66rom\x18\x01 \x01(\tR\x04\x66rom\x12X\n\x02to\x18\x02 \x03(\x0b\x32H.istio.networking.v1beta1.LocalityLoadBalancerSetting.Distribute.ToEntryR\x02to\x1a\x35\n\x07ToEntry\x12\x10\n\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n\x05value\x18\x02 \x01(\rR\x05value:\x02\x38\x01\x1a.\n\x08\x46\x61ilover\x12\x12\n\x04\x66rom\x18\x01 \x01(\tR\x04\x66rom\x12\x0e\n\x02to\x18\x02 \x01(\tR\x02toB!Z\x1fistio.io/api/networking/v1beta1b\x06proto3'
+  serialized_pb=b'\n)networking/v1beta1/destination_rule.proto\x12\x18istio.networking.v1beta1\x1a\x1fgoogle/api/field_behavior.proto\x1a\x1egoogle/protobuf/duration.proto\x1a\x1egoogle/protobuf/wrappers.proto\x1a(networking/v1beta1/virtual_service.proto\x1a\x14gogoproto/gogo.proto\"\xd4\x01\n\x0f\x44\x65stinationRule\x12\x18\n\x04host\x18\x01 \x01(\tB\x04\xe2\x41\x01\x02R\x04host\x12N\n\x0etraffic_policy\x18\x02 \x01(\x0b\x32\'.istio.networking.v1beta1.TrafficPolicyR\rtrafficPolicy\x12:\n\x07subsets\x18\x03 \x03(\x0b\x32 .istio.networking.v1beta1.SubsetR\x07subsets\x12\x1b\n\texport_to\x18\x04 \x03(\tR\x08\x65xportTo\"\xf4\x07\n\rTrafficPolicy\x12S\n\rload_balancer\x18\x01 \x01(\x0b\x32..istio.networking.v1beta1.LoadBalancerSettingsR\x0cloadBalancer\x12Y\n\x0f\x63onnection_pool\x18\x02 \x01(\x0b\x32\x30.istio.networking.v1beta1.ConnectionPoolSettingsR\x0e\x63onnectionPool\x12W\n\x11outlier_detection\x18\x03 \x01(\x0b\x32*.istio.networking.v1beta1.OutlierDetectionR\x10outlierDetection\x12=\n\x03tls\x18\x04 \x01(\x0b\x32+.istio.networking.v1beta1.ClientTLSSettingsR\x03tls\x12i\n\x13port_level_settings\x18\x05 \x03(\x0b\x32\x39.istio.networking.v1beta1.TrafficPolicy.PortTrafficPolicyR\x11portLevelSettings\x12J\n\rhealth_checks\x18\x65 \x03(\x0b\x32%.istio.networking.v1beta1.HealthCheckR\x0chealthChecks\x1a\xe3\x03\n\x11PortTrafficPolicy\x12:\n\x04port\x18\x01 \x01(\x0b\x32&.istio.networking.v1beta1.PortSelectorR\x04port\x12S\n\rload_balancer\x18\x02 \x01(\x0b\x32..istio.networking.v1beta1.LoadBalancerSettingsR\x0cloadBalancer\x12Y\n\x0f\x63onnection_pool\x18\x03 \x01(\x0b\x32\x30.istio.networking.v1beta1.ConnectionPoolSettingsR\x0e\x63onnectionPool\x12W\n\x11outlier_detection\x18\x04 \x01(\x0b\x32*.istio.networking.v1beta1.OutlierDetectionR\x10outlierDetection\x12=\n\x03tls\x18\x05 \x01(\x0b\x32+.istio.networking.v1beta1.ClientTLSSettingsR\x03tls\x12J\n\rhealth_checks\x18\x65 \x03(\x0b\x32%.istio.networking.v1beta1.HealthCheckR\x0chealthChecks\"\xf3\x01\n\x06Subset\x12\x18\n\x04name\x18\x01 \x01(\tB\x04\xe2\x41\x01\x02R\x04name\x12\x44\n\x06labels\x18\x02 \x03(\x0b\x32,.istio.networking.v1beta1.Subset.LabelsEntryR\x06labels\x12N\n\x0etraffic_policy\x18\x03 \x01(\x0b\x32\'.istio.networking.v1beta1.TrafficPolicyR\rtrafficPolicy\x1a\x39\n\x0bLabelsEntry\x12\x10\n\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n\x05value\x18\x02 \x01(\tR\x05value:\x02\x38\x01\"\x9a\x07\n\x14LoadBalancerSettings\x12Q\n\x06simple\x18\x01 \x01(\x0e\x32\x37.istio.networking.v1beta1.LoadBalancerSettings.SimpleLBH\x00R\x06simple\x12j\n\x0f\x63onsistent_hash\x18\x02 \x01(\x0b\x32?.istio.networking.v1beta1.LoadBalancerSettings.ConsistentHashLBH\x00R\x0e\x63onsistentHash\x12\x65\n\x13locality_lb_setting\x18\x03 \x01(\x0b\x32\x35.istio.networking.v1beta1.LocalityLoadBalancerSettingR\x11localityLbSetting\x12K\n\x14warmup_duration_secs\x18\x04 \x01(\x0b\x32\x19.google.protobuf.DurationR\x12warmupDurationSecs\x1a\xb7\x03\n\x10\x43onsistentHashLB\x12*\n\x10http_header_name\x18\x01 \x01(\tH\x00R\x0ehttpHeaderName\x12m\n\x0bhttp_cookie\x18\x02 \x01(\x0b\x32J.istio.networking.v1beta1.LoadBalancerSettings.ConsistentHashLB.HTTPCookieH\x00R\nhttpCookie\x12$\n\ruse_source_ip\x18\x03 \x01(\x08H\x00R\x0buseSourceIp\x12;\n\x19http_query_parameter_name\x18\x05 \x01(\tH\x00R\x16httpQueryParameterName\x12*\n\x11minimum_ring_size\x18\x04 \x01(\x04R\x0fminimumRingSize\x1am\n\nHTTPCookie\x12\x18\n\x04name\x18\x01 \x01(\tB\x04\xe2\x41\x01\x02R\x04name\x12\x12\n\x04path\x18\x02 \x01(\tR\x04path\x12\x31\n\x03ttl\x18\x03 \x01(\x0b\x32\x19.google.protobuf.DurationB\x04\xe2\x41\x01\x02R\x03ttlB\n\n\x08hash_key\"H\n\x08SimpleLB\x12\x0f\n\x0bROUND_ROBIN\x10\x00\x12\x0e\n\nLEAST_CONN\x10\x01\x12\n\n\x06RANDOM\x10\x02\x12\x0f\n\x0bPASSTHROUGH\x10\x03\x42\x0b\n\tlb_policy\"\xbd\x08\n\x16\x43onnectionPoolSettings\x12N\n\x03tcp\x18\x01 \x01(\x0b\x32<.istio.networking.v1beta1.ConnectionPoolSettings.TCPSettingsR\x03tcp\x12Q\n\x04http\x18\x02 \x01(\x0b\x32=.istio.networking.v1beta1.ConnectionPoolSettings.HTTPSettingsR\x04http\x1a\xf9\x02\n\x0bTCPSettings\x12\'\n\x0fmax_connections\x18\x01 \x01(\x05R\x0emaxConnections\x12\x42\n\x0f\x63onnect_timeout\x18\x02 \x01(\x0b\x32\x19.google.protobuf.DurationR\x0e\x63onnectTimeout\x12n\n\rtcp_keepalive\x18\x03 \x01(\x0b\x32I.istio.networking.v1beta1.ConnectionPoolSettings.TCPSettings.TcpKeepaliveR\x0ctcpKeepalive\x1a\x8c\x01\n\x0cTcpKeepalive\x12\x16\n\x06probes\x18\x01 \x01(\rR\x06probes\x12-\n\x04time\x18\x02 \x01(\x0b\x32\x19.google.protobuf.DurationR\x04time\x12\x35\n\x08interval\x18\x03 \x01(\x0b\x32\x19.google.protobuf.DurationR\x08interval\x1a\x83\x04\n\x0cHTTPSettings\x12;\n\x1ahttp1_max_pending_requests\x18\x01 \x01(\x05R\x17http1MaxPendingRequests\x12,\n\x12http2_max_requests\x18\x02 \x01(\x05R\x10http2MaxRequests\x12=\n\x1bmax_requests_per_connection\x18\x03 \x01(\x05R\x18maxRequestsPerConnection\x12\x1f\n\x0bmax_retries\x18\x04 \x01(\x05R\nmaxRetries\x12<\n\x0cidle_timeout\x18\x05 \x01(\x0b\x32\x19.google.protobuf.DurationR\x0bidleTimeout\x12y\n\x11h2_upgrade_policy\x18\x06 \x01(\x0e\x32M.istio.networking.v1beta1.ConnectionPoolSettings.HTTPSettings.H2UpgradePolicyR\x0fh2UpgradePolicy\x12.\n\x13use_client_protocol\x18\x07 \x01(\x08R\x11useClientProtocol\"?\n\x0fH2UpgradePolicy\x12\x0b\n\x07\x44\x45\x46\x41ULT\x10\x00\x12\x12\n\x0e\x44O_NOT_UPGRADE\x10\x01\x12\x0b\n\x07UPGRADE\x10\x02\"\x8a\x05\n\x10OutlierDetection\x12\x31\n\x12\x63onsecutive_errors\x18\x01 \x01(\x05\x42\x02\x18\x01R\x11\x63onsecutiveErrors\x12J\n\"split_external_local_origin_errors\x18\x08 \x01(\x08R\x1esplitExternalLocalOriginErrors\x12g\n!consecutive_local_origin_failures\x18\t \x01(\x0b\x32\x1c.google.protobuf.UInt32ValueR\x1e\x63onsecutiveLocalOriginFailures\x12Z\n\x1a\x63onsecutive_gateway_errors\x18\x06 \x01(\x0b\x32\x1c.google.protobuf.UInt32ValueR\x18\x63onsecutiveGatewayErrors\x12R\n\x16\x63onsecutive_5xx_errors\x18\x07 \x01(\x0b\x32\x1c.google.protobuf.UInt32ValueR\x14\x63onsecutive5xxErrors\x12\x35\n\x08interval\x18\x02 \x01(\x0b\x32\x19.google.protobuf.DurationR\x08interval\x12G\n\x12\x62\x61se_ejection_time\x18\x03 \x01(\x0b\x32\x19.google.protobuf.DurationR\x10\x62\x61seEjectionTime\x12\x30\n\x14max_ejection_percent\x18\x04 \x01(\x05R\x12maxEjectionPercent\x12,\n\x12min_health_percent\x18\x05 \x01(\x05R\x10minHealthPercent\"\xd2\x03\n\x11\x43lientTLSSettings\x12M\n\x04mode\x18\x01 \x01(\x0e\x32\x33.istio.networking.v1beta1.ClientTLSSettings.TLSmodeB\x04\xe2\x41\x01\x02R\x04mode\x12-\n\x12\x63lient_certificate\x18\x02 \x01(\tR\x11\x63lientCertificate\x12\x1f\n\x0bprivate_key\x18\x03 \x01(\tR\nprivateKey\x12\'\n\x0f\x63\x61_certificates\x18\x04 \x01(\tR\x0e\x63\x61\x43\x65rtificates\x12\'\n\x0f\x63redential_name\x18\x07 \x01(\tR\x0e\x63redentialName\x12*\n\x11subject_alt_names\x18\x05 \x03(\tR\x0fsubjectAltNames\x12\x10\n\x03sni\x18\x06 \x01(\tR\x03sni\x12L\n\x14insecure_skip_verify\x18\x08 \x01(\x0b\x32\x1a.google.protobuf.BoolValueR\x12insecureSkipVerify\"@\n\x07TLSmode\x12\x0b\n\x07\x44ISABLE\x10\x00\x12\n\n\x06SIMPLE\x10\x01\x12\n\n\x06MUTUAL\x10\x02\x12\x10\n\x0cISTIO_MUTUAL\x10\x03\"\xa2\x04\n\x1bLocalityLoadBalancerSetting\x12`\n\ndistribute\x18\x01 \x03(\x0b\x32@.istio.networking.v1beta1.LocalityLoadBalancerSetting.DistributeR\ndistribute\x12Z\n\x08\x66\x61ilover\x18\x02 \x03(\x0b\x32>.istio.networking.v1beta1.LocalityLoadBalancerSetting.FailoverR\x08\x66\x61ilover\x12+\n\x11\x66\x61ilover_priority\x18\x04 \x03(\tR\x10\x66\x61iloverPriority\x12\x34\n\x07\x65nabled\x18\x03 \x01(\x0b\x32\x1a.google.protobuf.BoolValueR\x07\x65nabled\x1a\xb1\x01\n\nDistribute\x12\x12\n\x04\x66rom\x18\x01 \x01(\tR\x04\x66rom\x12X\n\x02to\x18\x02 \x03(\x0b\x32H.istio.networking.v1beta1.LocalityLoadBalancerSetting.Distribute.ToEntryR\x02to\x1a\x35\n\x07ToEntry\x12\x10\n\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n\x05value\x18\x02 \x01(\rR\x05value:\x02\x38\x01\x1a.\n\x08\x46\x61ilover\x12\x12\n\x04\x66rom\x18\x01 \x01(\tR\x04\x66rom\x12\x0e\n\x02to\x18\x02 \x01(\tR\x02to\"4\n\nInt64Range\x12\x14\n\x05start\x18\x01 \x01(\x03R\x05start\x12\x10\n\x03\x65nd\x18\x02 \x01(\x03R\x03\x65nd\"U\n\x0fHealthStatusSet\x12\x42\n\x08statuses\x18\x01 \x03(\x0e\x32&.istio.networking.v1beta1.HealthStatusR\x08statuses\"D\n\x07Payload\x12\x14\n\x04text\x18\x01 \x01(\tH\x00R\x04text\x12\x18\n\x06\x62inary\x18\x02 \x01(\x0cH\x00R\x06\x62inaryB\t\n\x07payload\"\xd4\x12\n\x0bHealthCheck\x12\x33\n\x07timeout\x18\x01 \x01(\x0b\x32\x19.google.protobuf.DurationR\x07timeout\x12\x35\n\x08interval\x18\x02 \x01(\x0b\x32\x19.google.protobuf.DurationR\x08interval\x12@\n\x0einitial_jitter\x18\x14 \x01(\x0b\x32\x19.google.protobuf.DurationR\rinitialJitter\x12\x42\n\x0finterval_jitter\x18\x03 \x01(\x0b\x32\x19.google.protobuf.DurationR\x0eintervalJitter\x12\x36\n\x17interval_jitter_percent\x18\x12 \x01(\rR\x15intervalJitterPercent\x12M\n\x13unhealthy_threshold\x18\x04 \x01(\x0b\x32\x1c.google.protobuf.UInt32ValueR\x12unhealthyThreshold\x12I\n\x11healthy_threshold\x18\x05 \x01(\x0b\x32\x1c.google.protobuf.UInt32ValueR\x10healthyThreshold\x12\x37\n\x08\x61lt_port\x18\x06 \x01(\x0b\x32\x1c.google.protobuf.UInt32ValueR\x07\x61ltPort\x12\x45\n\x10reuse_connection\x18\x07 \x01(\x0b\x32\x1a.google.protobuf.BoolValueR\x0freuseConnection\x12\x63\n\x11http_health_check\x18\x08 \x01(\x0b\x32\x35.istio.networking.v1beta1.HealthCheck.HttpHealthCheckH\x00R\x0fhttpHealthCheck\x12`\n\x10tcp_health_check\x18\t \x01(\x0b\x32\x34.istio.networking.v1beta1.HealthCheck.TcpHealthCheckH\x00R\x0etcpHealthCheck\x12\x63\n\x11grpc_health_check\x18\x0b \x01(\x0b\x32\x35.istio.networking.v1beta1.HealthCheck.GrpcHealthCheckH\x00R\x0fgrpcHealthCheck\x12i\n\x13\x63ustom_health_check\x18\r \x01(\x0b\x32\x37.istio.networking.v1beta1.HealthCheck.CustomHealthCheckH\x00R\x11\x63ustomHealthCheck\x12I\n\x13no_traffic_interval\x18\x0c \x01(\x0b\x32\x19.google.protobuf.DurationR\x11noTrafficInterval\x12X\n\x1bno_traffic_healthy_interval\x18\x18 \x01(\x0b\x32\x19.google.protobuf.DurationR\x18noTrafficHealthyInterval\x12H\n\x12unhealthy_interval\x18\x0e \x01(\x0b\x32\x19.google.protobuf.DurationR\x11unhealthyInterval\x12Q\n\x17unhealthy_edge_interval\x18\x0f \x01(\x0b\x32\x19.google.protobuf.DurationR\x15unhealthyEdgeInterval\x12M\n\x15healthy_edge_interval\x18\x10 \x01(\x0b\x32\x19.google.protobuf.DurationR\x13healthyEdgeInterval\x12$\n\x0e\x65vent_log_path\x18\x11 \x01(\tR\x0c\x65ventLogPath\x12\x46\n always_log_health_check_failures\x18\x13 \x01(\x08R\x1c\x61lwaysLogHealthCheckFailures\x12Q\n\x0btls_options\x18\x15 \x01(\x0b\x32\x30.istio.networking.v1beta1.HealthCheck.TlsOptionsR\ntlsOptions\x1a\x86\x03\n\x0fHttpHealthCheck\x12\x12\n\x04host\x18\x01 \x01(\tR\x04host\x12\x12\n\x04path\x18\x02 \x01(\tR\x04path\x12\x35\n\x04send\x18\x03 \x01(\x0b\x32!.istio.networking.v1beta1.PayloadR\x04send\x12;\n\x07receive\x18\x04 \x01(\x0b\x32!.istio.networking.v1beta1.PayloadR\x07receive\x12Q\n\x11\x65xpected_statuses\x18\t \x03(\x0b\x32$.istio.networking.v1beta1.Int64RangeR\x10\x65xpectedStatuses\x12S\n\x12retriable_statuses\x18\x0c \x03(\x0b\x32$.istio.networking.v1beta1.Int64RangeR\x11retriableStatusesJ\x04\x08\x05\x10\x06J\x04\x08\x07\x10\x08J\x04\x08\x06\x10\x07J\x04\x08\x08\x10\tR\x0cservice_nameR\tuse_http2\x1a\x84\x01\n\x0eTcpHealthCheck\x12\x35\n\x04send\x18\x01 \x01(\x0b\x32!.istio.networking.v1beta1.PayloadR\x04send\x12;\n\x07receive\x18\x02 \x03(\x0b\x32!.istio.networking.v1beta1.PayloadR\x07receive\x1a$\n\x10RedisHealthCheck\x12\x10\n\x03key\x18\x01 \x01(\tR\x03key\x1aX\n\x0fGrpcHealthCheck\x12!\n\x0cservice_name\x18\x01 \x01(\tR\x0bserviceName\x12\x1c\n\tauthority\x18\x02 \x01(\tR\tauthorityJ\x04\x08\x03\x10\x04\x1a\x35\n\x11\x43ustomHealthCheck\x12\x12\n\x04name\x18\x01 \x01(\tR\x04nameJ\x04\x08\x02\x10\x03R\x06\x63onfig\x1a\x33\n\nTlsOptions\x12%\n\x0e\x61lpn_protocols\x18\x01 \x03(\tR\ralpnProtocolsB\x10\n\x0ehealth_checkerJ\x04\x08\n\x10\x0bJ\x04\x08\x16\x10\x17*`\n\x0cHealthStatus\x12\x0b\n\x07UNKNOWN\x10\x00\x12\x0b\n\x07HEALTHY\x10\x01\x12\r\n\tUNHEALTHY\x10\x02\x12\x0c\n\x08\x44RAINING\x10\x03\x12\x0b\n\x07TIMEOUT\x10\x04\x12\x0c\n\x08\x44\x45GRADED\x10\x05\x42!Z\x1fistio.io/api/networking/v1beta1b\x06proto3'
   ,
   dependencies=[google_dot_api_dot_field__behavior__pb2.DESCRIPTOR,google_dot_protobuf_dot_duration__pb2.DESCRIPTOR,google_dot_protobuf_dot_wrappers__pb2.DESCRIPTOR,networking_dot_v1beta1_dot_virtual__service__pb2.DESCRIPTOR,gogoproto_dot_gogo__pb2.DESCRIPTOR,])
 
+_HEALTHSTATUS = _descriptor.EnumDescriptor(
+  name='HealthStatus',
+  full_name='istio.networking.v1beta1.HealthStatus',
+  filename=None,
+  file=DESCRIPTOR,
+  create_key=_descriptor._internal_create_key,
+  values=[
+    _descriptor.EnumValueDescriptor(
+      name='UNKNOWN', index=0, number=0,
+      serialized_options=None,
+      type=None,
+      create_key=_descriptor._internal_create_key),
+    _descriptor.EnumValueDescriptor(
+      name='HEALTHY', index=1, number=1,
+      serialized_options=None,
+      type=None,
+      create_key=_descriptor._internal_create_key),
+    _descriptor.EnumValueDescriptor(
+      name='UNHEALTHY', index=2, number=2,
+      serialized_options=None,
+      type=None,
+      create_key=_descriptor._internal_create_key),
+    _descriptor.EnumValueDescriptor(
+      name='DRAINING', index=3, number=3,
+      serialized_options=None,
+      type=None,
+      create_key=_descriptor._internal_create_key),
+    _descriptor.EnumValueDescriptor(
+      name='TIMEOUT', index=4, number=4,
+      serialized_options=None,
+      type=None,
+      create_key=_descriptor._internal_create_key),
+    _descriptor.EnumValueDescriptor(
+      name='DEGRADED', index=5, number=5,
+      serialized_options=None,
+      type=None,
+      create_key=_descriptor._internal_create_key),
+  ],
+  containing_type=None,
+  serialized_options=None,
+  serialized_start=7994,
+  serialized_end=8090,
+)
+_sym_db.RegisterEnumDescriptor(_HEALTHSTATUS)
+
+HealthStatus = enum_type_wrapper.EnumTypeWrapper(_HEALTHSTATUS)
+UNKNOWN = 0
+HEALTHY = 1
+UNHEALTHY = 2
+DRAINING = 3
+TIMEOUT = 4
+DEGRADED = 5
 
 
 _LOADBALANCERSETTINGS_SIMPLELB = _descriptor.EnumDescriptor(
@@ -60,8 +113,8 @@ _LOADBALANCERSETTINGS_SIMPLELB = _descriptor.EnumDescriptor(
   ],
   containing_type=None,
   serialized_options=None,
-  serialized_start=2317,
-  serialized_end=2389,
+  serialized_start=2546,
+  serialized_end=2618,
 )
 _sym_db.RegisterEnumDescriptor(_LOADBALANCERSETTINGS_SIMPLELB)
 
@@ -90,8 +143,8 @@ _CONNECTIONPOOLSETTINGS_HTTPSETTINGS_H2UPGRADEPOLICY = _descriptor.EnumDescripto
   ],
   containing_type=None,
   serialized_options=None,
-  serialized_start=3427,
-  serialized_end=3490,
+  serialized_start=3656,
+  serialized_end=3719,
 )
 _sym_db.RegisterEnumDescriptor(_CONNECTIONPOOLSETTINGS_HTTPSETTINGS_H2UPGRADEPOLICY)
 
@@ -125,8 +178,8 @@ _CLIENTTLSSETTINGS_TLSMODE = _descriptor.EnumDescriptor(
   ],
   containing_type=None,
   serialized_options=None,
-  serialized_start=4548,
-  serialized_end=4612,
+  serialized_start=4777,
+  serialized_end=4841,
 )
 _sym_db.RegisterEnumDescriptor(_CLIENTTLSSETTINGS_TLSMODE)
 
@@ -227,6 +280,13 @@ _TRAFFICPOLICY_PORTTRAFFICPOLICY = _descriptor.Descriptor(
       message_type=None, enum_type=None, containing_type=None,
       is_extension=False, extension_scope=None,
       serialized_options=None, json_name='tls', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='health_checks', full_name='istio.networking.v1beta1.TrafficPolicy.PortTrafficPolicy.health_checks', index=5,
+      number=101, type=11, cpp_type=10, label=3,
+      has_default_value=False, default_value=[],
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='healthChecks', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
   ],
   extensions=[
   ],
@@ -239,8 +299,8 @@ _TRAFFICPOLICY_PORTTRAFFICPOLICY = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=901,
-  serialized_end=1308,
+  serialized_start=977,
+  serialized_end=1460,
 )
 
 _TRAFFICPOLICY = _descriptor.Descriptor(
@@ -286,6 +346,13 @@ _TRAFFICPOLICY = _descriptor.Descriptor(
       message_type=None, enum_type=None, containing_type=None,
       is_extension=False, extension_scope=None,
       serialized_options=None, json_name='portLevelSettings', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='health_checks', full_name='istio.networking.v1beta1.TrafficPolicy.health_checks', index=5,
+      number=101, type=11, cpp_type=10, label=3,
+      has_default_value=False, default_value=[],
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='healthChecks', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
   ],
   extensions=[
   ],
@@ -299,7 +366,7 @@ _TRAFFICPOLICY = _descriptor.Descriptor(
   oneofs=[
   ],
   serialized_start=448,
-  serialized_end=1308,
+  serialized_end=1460,
 )
 
 
@@ -337,8 +404,8 @@ _SUBSET_LABELSENTRY = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=1497,
-  serialized_end=1554,
+  serialized_start=1649,
+  serialized_end=1706,
 )
 
 _SUBSET = _descriptor.Descriptor(
@@ -382,8 +449,8 @@ _SUBSET = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=1311,
-  serialized_end=1554,
+  serialized_start=1463,
+  serialized_end=1706,
 )
 
 
@@ -428,8 +495,8 @@ _LOADBALANCERSETTINGS_CONSISTENTHASHLB_HTTPCOOKIE = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=2194,
-  serialized_end=2303,
+  serialized_start=2423,
+  serialized_end=2532,
 )
 
 _LOADBALANCERSETTINGS_CONSISTENTHASHLB = _descriptor.Descriptor(
@@ -492,8 +559,8 @@ _LOADBALANCERSETTINGS_CONSISTENTHASHLB = _descriptor.Descriptor(
       create_key=_descriptor._internal_create_key,
     fields=[]),
   ],
-  serialized_start=1876,
-  serialized_end=2315,
+  serialized_start=2105,
+  serialized_end=2544,
 )
 
 _LOADBALANCERSETTINGS = _descriptor.Descriptor(
@@ -525,6 +592,13 @@ _LOADBALANCERSETTINGS = _descriptor.Descriptor(
       message_type=None, enum_type=None, containing_type=None,
       is_extension=False, extension_scope=None,
       serialized_options=None, json_name='localityLbSetting', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='warmup_duration_secs', full_name='istio.networking.v1beta1.LoadBalancerSettings.warmup_duration_secs', index=3,
+      number=4, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='warmupDurationSecs', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
   ],
   extensions=[
   ],
@@ -543,8 +617,8 @@ _LOADBALANCERSETTINGS = _descriptor.Descriptor(
       create_key=_descriptor._internal_create_key,
     fields=[]),
   ],
-  serialized_start=1557,
-  serialized_end=2402,
+  serialized_start=1709,
+  serialized_end=2631,
 )
 
 
@@ -589,8 +663,8 @@ _CONNECTIONPOOLSETTINGS_TCPSETTINGS_TCPKEEPALIVE = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=2832,
-  serialized_end=2972,
+  serialized_start=3061,
+  serialized_end=3201,
 )
 
 _CONNECTIONPOOLSETTINGS_TCPSETTINGS = _descriptor.Descriptor(
@@ -634,8 +708,8 @@ _CONNECTIONPOOLSETTINGS_TCPSETTINGS = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=2595,
-  serialized_end=2972,
+  serialized_start=2824,
+  serialized_end=3201,
 )
 
 _CONNECTIONPOOLSETTINGS_HTTPSETTINGS = _descriptor.Descriptor(
@@ -708,8 +782,8 @@ _CONNECTIONPOOLSETTINGS_HTTPSETTINGS = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=2975,
-  serialized_end=3490,
+  serialized_start=3204,
+  serialized_end=3719,
 )
 
 _CONNECTIONPOOLSETTINGS = _descriptor.Descriptor(
@@ -746,8 +820,8 @@ _CONNECTIONPOOLSETTINGS = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=2405,
-  serialized_end=3490,
+  serialized_start=2634,
+  serialized_end=3719,
 )
 
 
@@ -834,8 +908,8 @@ _OUTLIERDETECTION = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=3493,
-  serialized_end=4143,
+  serialized_start=3722,
+  serialized_end=4372,
 )
 
 
@@ -916,8 +990,8 @@ _CLIENTTLSSETTINGS = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=4146,
-  serialized_end=4612,
+  serialized_start=4375,
+  serialized_end=4841,
 )
 
 
@@ -955,8 +1029,8 @@ _LOCALITYLOADBALANCERSETTING_DISTRIBUTE_TOENTRY = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=5060,
-  serialized_end=5113,
+  serialized_start=5289,
+  serialized_end=5342,
 )
 
 _LOCALITYLOADBALANCERSETTING_DISTRIBUTE = _descriptor.Descriptor(
@@ -993,8 +1067,8 @@ _LOCALITYLOADBALANCERSETTING_DISTRIBUTE = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=4936,
-  serialized_end=5113,
+  serialized_start=5165,
+  serialized_end=5342,
 )
 
 _LOCALITYLOADBALANCERSETTING_FAILOVER = _descriptor.Descriptor(
@@ -1031,8 +1105,8 @@ _LOCALITYLOADBALANCERSETTING_FAILOVER = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=5115,
-  serialized_end=5161,
+  serialized_start=5344,
+  serialized_end=5390,
 )
 
 _LOCALITYLOADBALANCERSETTING = _descriptor.Descriptor(
@@ -1083,8 +1157,535 @@ _LOCALITYLOADBALANCERSETTING = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=4615,
-  serialized_end=5161,
+  serialized_start=4844,
+  serialized_end=5390,
+)
+
+
+_INT64RANGE = _descriptor.Descriptor(
+  name='Int64Range',
+  full_name='istio.networking.v1beta1.Int64Range',
+  filename=None,
+  file=DESCRIPTOR,
+  containing_type=None,
+  create_key=_descriptor._internal_create_key,
+  fields=[
+    _descriptor.FieldDescriptor(
+      name='start', full_name='istio.networking.v1beta1.Int64Range.start', index=0,
+      number=1, type=3, cpp_type=2, label=1,
+      has_default_value=False, default_value=0,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='start', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='end', full_name='istio.networking.v1beta1.Int64Range.end', index=1,
+      number=2, type=3, cpp_type=2, label=1,
+      has_default_value=False, default_value=0,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='end', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+  ],
+  extensions=[
+  ],
+  nested_types=[],
+  enum_types=[
+  ],
+  serialized_options=None,
+  is_extendable=False,
+  syntax='proto3',
+  extension_ranges=[],
+  oneofs=[
+  ],
+  serialized_start=5392,
+  serialized_end=5444,
+)
+
+
+_HEALTHSTATUSSET = _descriptor.Descriptor(
+  name='HealthStatusSet',
+  full_name='istio.networking.v1beta1.HealthStatusSet',
+  filename=None,
+  file=DESCRIPTOR,
+  containing_type=None,
+  create_key=_descriptor._internal_create_key,
+  fields=[
+    _descriptor.FieldDescriptor(
+      name='statuses', full_name='istio.networking.v1beta1.HealthStatusSet.statuses', index=0,
+      number=1, type=14, cpp_type=8, label=3,
+      has_default_value=False, default_value=[],
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='statuses', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+  ],
+  extensions=[
+  ],
+  nested_types=[],
+  enum_types=[
+  ],
+  serialized_options=None,
+  is_extendable=False,
+  syntax='proto3',
+  extension_ranges=[],
+  oneofs=[
+  ],
+  serialized_start=5446,
+  serialized_end=5531,
+)
+
+
+_PAYLOAD = _descriptor.Descriptor(
+  name='Payload',
+  full_name='istio.networking.v1beta1.Payload',
+  filename=None,
+  file=DESCRIPTOR,
+  containing_type=None,
+  create_key=_descriptor._internal_create_key,
+  fields=[
+    _descriptor.FieldDescriptor(
+      name='text', full_name='istio.networking.v1beta1.Payload.text', index=0,
+      number=1, type=9, cpp_type=9, label=1,
+      has_default_value=False, default_value=b"".decode('utf-8'),
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='text', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='binary', full_name='istio.networking.v1beta1.Payload.binary', index=1,
+      number=2, type=12, cpp_type=9, label=1,
+      has_default_value=False, default_value=b"",
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='binary', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+  ],
+  extensions=[
+  ],
+  nested_types=[],
+  enum_types=[
+  ],
+  serialized_options=None,
+  is_extendable=False,
+  syntax='proto3',
+  extension_ranges=[],
+  oneofs=[
+    _descriptor.OneofDescriptor(
+      name='payload', full_name='istio.networking.v1beta1.Payload.payload',
+      index=0, containing_type=None,
+      create_key=_descriptor._internal_create_key,
+    fields=[]),
+  ],
+  serialized_start=5533,
+  serialized_end=5601,
+)
+
+
+_HEALTHCHECK_HTTPHEALTHCHECK = _descriptor.Descriptor(
+  name='HttpHealthCheck',
+  full_name='istio.networking.v1beta1.HealthCheck.HttpHealthCheck',
+  filename=None,
+  file=DESCRIPTOR,
+  containing_type=None,
+  create_key=_descriptor._internal_create_key,
+  fields=[
+    _descriptor.FieldDescriptor(
+      name='host', full_name='istio.networking.v1beta1.HealthCheck.HttpHealthCheck.host', index=0,
+      number=1, type=9, cpp_type=9, label=1,
+      has_default_value=False, default_value=b"".decode('utf-8'),
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='host', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='path', full_name='istio.networking.v1beta1.HealthCheck.HttpHealthCheck.path', index=1,
+      number=2, type=9, cpp_type=9, label=1,
+      has_default_value=False, default_value=b"".decode('utf-8'),
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='path', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='send', full_name='istio.networking.v1beta1.HealthCheck.HttpHealthCheck.send', index=2,
+      number=3, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='send', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='receive', full_name='istio.networking.v1beta1.HealthCheck.HttpHealthCheck.receive', index=3,
+      number=4, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='receive', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='expected_statuses', full_name='istio.networking.v1beta1.HealthCheck.HttpHealthCheck.expected_statuses', index=4,
+      number=9, type=11, cpp_type=10, label=3,
+      has_default_value=False, default_value=[],
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='expectedStatuses', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='retriable_statuses', full_name='istio.networking.v1beta1.HealthCheck.HttpHealthCheck.retriable_statuses', index=5,
+      number=12, type=11, cpp_type=10, label=3,
+      has_default_value=False, default_value=[],
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='retriableStatuses', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+  ],
+  extensions=[
+  ],
+  nested_types=[],
+  enum_types=[
+  ],
+  serialized_options=None,
+  is_extendable=False,
+  syntax='proto3',
+  extension_ranges=[],
+  oneofs=[
+  ],
+  serialized_start=7201,
+  serialized_end=7591,
+)
+
+_HEALTHCHECK_TCPHEALTHCHECK = _descriptor.Descriptor(
+  name='TcpHealthCheck',
+  full_name='istio.networking.v1beta1.HealthCheck.TcpHealthCheck',
+  filename=None,
+  file=DESCRIPTOR,
+  containing_type=None,
+  create_key=_descriptor._internal_create_key,
+  fields=[
+    _descriptor.FieldDescriptor(
+      name='send', full_name='istio.networking.v1beta1.HealthCheck.TcpHealthCheck.send', index=0,
+      number=1, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='send', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='receive', full_name='istio.networking.v1beta1.HealthCheck.TcpHealthCheck.receive', index=1,
+      number=2, type=11, cpp_type=10, label=3,
+      has_default_value=False, default_value=[],
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='receive', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+  ],
+  extensions=[
+  ],
+  nested_types=[],
+  enum_types=[
+  ],
+  serialized_options=None,
+  is_extendable=False,
+  syntax='proto3',
+  extension_ranges=[],
+  oneofs=[
+  ],
+  serialized_start=7594,
+  serialized_end=7726,
+)
+
+_HEALTHCHECK_REDISHEALTHCHECK = _descriptor.Descriptor(
+  name='RedisHealthCheck',
+  full_name='istio.networking.v1beta1.HealthCheck.RedisHealthCheck',
+  filename=None,
+  file=DESCRIPTOR,
+  containing_type=None,
+  create_key=_descriptor._internal_create_key,
+  fields=[
+    _descriptor.FieldDescriptor(
+      name='key', full_name='istio.networking.v1beta1.HealthCheck.RedisHealthCheck.key', index=0,
+      number=1, type=9, cpp_type=9, label=1,
+      has_default_value=False, default_value=b"".decode('utf-8'),
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='key', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+  ],
+  extensions=[
+  ],
+  nested_types=[],
+  enum_types=[
+  ],
+  serialized_options=None,
+  is_extendable=False,
+  syntax='proto3',
+  extension_ranges=[],
+  oneofs=[
+  ],
+  serialized_start=7728,
+  serialized_end=7764,
+)
+
+_HEALTHCHECK_GRPCHEALTHCHECK = _descriptor.Descriptor(
+  name='GrpcHealthCheck',
+  full_name='istio.networking.v1beta1.HealthCheck.GrpcHealthCheck',
+  filename=None,
+  file=DESCRIPTOR,
+  containing_type=None,
+  create_key=_descriptor._internal_create_key,
+  fields=[
+    _descriptor.FieldDescriptor(
+      name='service_name', full_name='istio.networking.v1beta1.HealthCheck.GrpcHealthCheck.service_name', index=0,
+      number=1, type=9, cpp_type=9, label=1,
+      has_default_value=False, default_value=b"".decode('utf-8'),
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='serviceName', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='authority', full_name='istio.networking.v1beta1.HealthCheck.GrpcHealthCheck.authority', index=1,
+      number=2, type=9, cpp_type=9, label=1,
+      has_default_value=False, default_value=b"".decode('utf-8'),
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='authority', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+  ],
+  extensions=[
+  ],
+  nested_types=[],
+  enum_types=[
+  ],
+  serialized_options=None,
+  is_extendable=False,
+  syntax='proto3',
+  extension_ranges=[],
+  oneofs=[
+  ],
+  serialized_start=7766,
+  serialized_end=7854,
+)
+
+_HEALTHCHECK_CUSTOMHEALTHCHECK = _descriptor.Descriptor(
+  name='CustomHealthCheck',
+  full_name='istio.networking.v1beta1.HealthCheck.CustomHealthCheck',
+  filename=None,
+  file=DESCRIPTOR,
+  containing_type=None,
+  create_key=_descriptor._internal_create_key,
+  fields=[
+    _descriptor.FieldDescriptor(
+      name='name', full_name='istio.networking.v1beta1.HealthCheck.CustomHealthCheck.name', index=0,
+      number=1, type=9, cpp_type=9, label=1,
+      has_default_value=False, default_value=b"".decode('utf-8'),
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='name', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+  ],
+  extensions=[
+  ],
+  nested_types=[],
+  enum_types=[
+  ],
+  serialized_options=None,
+  is_extendable=False,
+  syntax='proto3',
+  extension_ranges=[],
+  oneofs=[
+  ],
+  serialized_start=7856,
+  serialized_end=7909,
+)
+
+_HEALTHCHECK_TLSOPTIONS = _descriptor.Descriptor(
+  name='TlsOptions',
+  full_name='istio.networking.v1beta1.HealthCheck.TlsOptions',
+  filename=None,
+  file=DESCRIPTOR,
+  containing_type=None,
+  create_key=_descriptor._internal_create_key,
+  fields=[
+    _descriptor.FieldDescriptor(
+      name='alpn_protocols', full_name='istio.networking.v1beta1.HealthCheck.TlsOptions.alpn_protocols', index=0,
+      number=1, type=9, cpp_type=9, label=3,
+      has_default_value=False, default_value=[],
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='alpnProtocols', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+  ],
+  extensions=[
+  ],
+  nested_types=[],
+  enum_types=[
+  ],
+  serialized_options=None,
+  is_extendable=False,
+  syntax='proto3',
+  extension_ranges=[],
+  oneofs=[
+  ],
+  serialized_start=7911,
+  serialized_end=7962,
+)
+
+_HEALTHCHECK = _descriptor.Descriptor(
+  name='HealthCheck',
+  full_name='istio.networking.v1beta1.HealthCheck',
+  filename=None,
+  file=DESCRIPTOR,
+  containing_type=None,
+  create_key=_descriptor._internal_create_key,
+  fields=[
+    _descriptor.FieldDescriptor(
+      name='timeout', full_name='istio.networking.v1beta1.HealthCheck.timeout', index=0,
+      number=1, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='timeout', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='interval', full_name='istio.networking.v1beta1.HealthCheck.interval', index=1,
+      number=2, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='interval', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='initial_jitter', full_name='istio.networking.v1beta1.HealthCheck.initial_jitter', index=2,
+      number=20, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='initialJitter', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='interval_jitter', full_name='istio.networking.v1beta1.HealthCheck.interval_jitter', index=3,
+      number=3, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='intervalJitter', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='interval_jitter_percent', full_name='istio.networking.v1beta1.HealthCheck.interval_jitter_percent', index=4,
+      number=18, type=13, cpp_type=3, label=1,
+      has_default_value=False, default_value=0,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='intervalJitterPercent', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='unhealthy_threshold', full_name='istio.networking.v1beta1.HealthCheck.unhealthy_threshold', index=5,
+      number=4, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='unhealthyThreshold', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='healthy_threshold', full_name='istio.networking.v1beta1.HealthCheck.healthy_threshold', index=6,
+      number=5, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='healthyThreshold', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='alt_port', full_name='istio.networking.v1beta1.HealthCheck.alt_port', index=7,
+      number=6, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='altPort', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='reuse_connection', full_name='istio.networking.v1beta1.HealthCheck.reuse_connection', index=8,
+      number=7, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='reuseConnection', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='http_health_check', full_name='istio.networking.v1beta1.HealthCheck.http_health_check', index=9,
+      number=8, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='httpHealthCheck', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='tcp_health_check', full_name='istio.networking.v1beta1.HealthCheck.tcp_health_check', index=10,
+      number=9, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='tcpHealthCheck', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='grpc_health_check', full_name='istio.networking.v1beta1.HealthCheck.grpc_health_check', index=11,
+      number=11, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='grpcHealthCheck', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='custom_health_check', full_name='istio.networking.v1beta1.HealthCheck.custom_health_check', index=12,
+      number=13, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='customHealthCheck', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='no_traffic_interval', full_name='istio.networking.v1beta1.HealthCheck.no_traffic_interval', index=13,
+      number=12, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='noTrafficInterval', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='no_traffic_healthy_interval', full_name='istio.networking.v1beta1.HealthCheck.no_traffic_healthy_interval', index=14,
+      number=24, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='noTrafficHealthyInterval', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='unhealthy_interval', full_name='istio.networking.v1beta1.HealthCheck.unhealthy_interval', index=15,
+      number=14, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='unhealthyInterval', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='unhealthy_edge_interval', full_name='istio.networking.v1beta1.HealthCheck.unhealthy_edge_interval', index=16,
+      number=15, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='unhealthyEdgeInterval', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='healthy_edge_interval', full_name='istio.networking.v1beta1.HealthCheck.healthy_edge_interval', index=17,
+      number=16, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='healthyEdgeInterval', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='event_log_path', full_name='istio.networking.v1beta1.HealthCheck.event_log_path', index=18,
+      number=17, type=9, cpp_type=9, label=1,
+      has_default_value=False, default_value=b"".decode('utf-8'),
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='eventLogPath', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='always_log_health_check_failures', full_name='istio.networking.v1beta1.HealthCheck.always_log_health_check_failures', index=19,
+      number=19, type=8, cpp_type=7, label=1,
+      has_default_value=False, default_value=False,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='alwaysLogHealthCheckFailures', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='tls_options', full_name='istio.networking.v1beta1.HealthCheck.tls_options', index=20,
+      number=21, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='tlsOptions', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+  ],
+  extensions=[
+  ],
+  nested_types=[_HEALTHCHECK_HTTPHEALTHCHECK, _HEALTHCHECK_TCPHEALTHCHECK, _HEALTHCHECK_REDISHEALTHCHECK, _HEALTHCHECK_GRPCHEALTHCHECK, _HEALTHCHECK_CUSTOMHEALTHCHECK, _HEALTHCHECK_TLSOPTIONS, ],
+  enum_types=[
+  ],
+  serialized_options=None,
+  is_extendable=False,
+  syntax='proto3',
+  extension_ranges=[],
+  oneofs=[
+    _descriptor.OneofDescriptor(
+      name='health_checker', full_name='istio.networking.v1beta1.HealthCheck.health_checker',
+      index=0, containing_type=None,
+      create_key=_descriptor._internal_create_key,
+    fields=[]),
+  ],
+  serialized_start=5604,
+  serialized_end=7992,
 )
 
 _DESTINATIONRULE.fields_by_name['traffic_policy'].message_type = _TRAFFICPOLICY
@@ -1094,12 +1695,14 @@ _TRAFFICPOLICY_PORTTRAFFICPOLICY.fields_by_name['load_balancer'].message_type =
 _TRAFFICPOLICY_PORTTRAFFICPOLICY.fields_by_name['connection_pool'].message_type = _CONNECTIONPOOLSETTINGS
 _TRAFFICPOLICY_PORTTRAFFICPOLICY.fields_by_name['outlier_detection'].message_type = _OUTLIERDETECTION
 _TRAFFICPOLICY_PORTTRAFFICPOLICY.fields_by_name['tls'].message_type = _CLIENTTLSSETTINGS
+_TRAFFICPOLICY_PORTTRAFFICPOLICY.fields_by_name['health_checks'].message_type = _HEALTHCHECK
 _TRAFFICPOLICY_PORTTRAFFICPOLICY.containing_type = _TRAFFICPOLICY
 _TRAFFICPOLICY.fields_by_name['load_balancer'].message_type = _LOADBALANCERSETTINGS
 _TRAFFICPOLICY.fields_by_name['connection_pool'].message_type = _CONNECTIONPOOLSETTINGS
 _TRAFFICPOLICY.fields_by_name['outlier_detection'].message_type = _OUTLIERDETECTION
 _TRAFFICPOLICY.fields_by_name['tls'].message_type = _CLIENTTLSSETTINGS
 _TRAFFICPOLICY.fields_by_name['port_level_settings'].message_type = _TRAFFICPOLICY_PORTTRAFFICPOLICY
+_TRAFFICPOLICY.fields_by_name['health_checks'].message_type = _HEALTHCHECK
 _SUBSET_LABELSENTRY.containing_type = _SUBSET
 _SUBSET.fields_by_name['labels'].message_type = _SUBSET_LABELSENTRY
 _SUBSET.fields_by_name['traffic_policy'].message_type = _TRAFFICPOLICY
@@ -1122,6 +1725,7 @@ _LOADBALANCERSETTINGS_CONSISTENTHASHLB.fields_by_name['http_query_parameter_name
 _LOADBALANCERSETTINGS.fields_by_name['simple'].enum_type = _LOADBALANCERSETTINGS_SIMPLELB
 _LOADBALANCERSETTINGS.fields_by_name['consistent_hash'].message_type = _LOADBALANCERSETTINGS_CONSISTENTHASHLB
 _LOADBALANCERSETTINGS.fields_by_name['locality_lb_setting'].message_type = _LOCALITYLOADBALANCERSETTING
+_LOADBALANCERSETTINGS.fields_by_name['warmup_duration_secs'].message_type = google_dot_protobuf_dot_duration__pb2._DURATION
 _LOADBALANCERSETTINGS_SIMPLELB.containing_type = _LOADBALANCERSETTINGS
 _LOADBALANCERSETTINGS.oneofs_by_name['lb_policy'].fields.append(
   _LOADBALANCERSETTINGS.fields_by_name['simple'])
@@ -1156,6 +1760,55 @@ _LOCALITYLOADBALANCERSETTING_FAILOVER.containing_type = _LOCALITYLOADBALANCERSET
 _LOCALITYLOADBALANCERSETTING.fields_by_name['distribute'].message_type = _LOCALITYLOADBALANCERSETTING_DISTRIBUTE
 _LOCALITYLOADBALANCERSETTING.fields_by_name['failover'].message_type = _LOCALITYLOADBALANCERSETTING_FAILOVER
 _LOCALITYLOADBALANCERSETTING.fields_by_name['enabled'].message_type = google_dot_protobuf_dot_wrappers__pb2._BOOLVALUE
+_HEALTHSTATUSSET.fields_by_name['statuses'].enum_type = _HEALTHSTATUS
+_PAYLOAD.oneofs_by_name['payload'].fields.append(
+  _PAYLOAD.fields_by_name['text'])
+_PAYLOAD.fields_by_name['text'].containing_oneof = _PAYLOAD.oneofs_by_name['payload']
+_PAYLOAD.oneofs_by_name['payload'].fields.append(
+  _PAYLOAD.fields_by_name['binary'])
+_PAYLOAD.fields_by_name['binary'].containing_oneof = _PAYLOAD.oneofs_by_name['payload']
+_HEALTHCHECK_HTTPHEALTHCHECK.fields_by_name['send'].message_type = _PAYLOAD
+_HEALTHCHECK_HTTPHEALTHCHECK.fields_by_name['receive'].message_type = _PAYLOAD
+_HEALTHCHECK_HTTPHEALTHCHECK.fields_by_name['expected_statuses'].message_type = _INT64RANGE
+_HEALTHCHECK_HTTPHEALTHCHECK.fields_by_name['retriable_statuses'].message_type = _INT64RANGE
+_HEALTHCHECK_HTTPHEALTHCHECK.containing_type = _HEALTHCHECK
+_HEALTHCHECK_TCPHEALTHCHECK.fields_by_name['send'].message_type = _PAYLOAD
+_HEALTHCHECK_TCPHEALTHCHECK.fields_by_name['receive'].message_type = _PAYLOAD
+_HEALTHCHECK_TCPHEALTHCHECK.containing_type = _HEALTHCHECK
+_HEALTHCHECK_REDISHEALTHCHECK.containing_type = _HEALTHCHECK
+_HEALTHCHECK_GRPCHEALTHCHECK.containing_type = _HEALTHCHECK
+_HEALTHCHECK_CUSTOMHEALTHCHECK.containing_type = _HEALTHCHECK
+_HEALTHCHECK_TLSOPTIONS.containing_type = _HEALTHCHECK
+_HEALTHCHECK.fields_by_name['timeout'].message_type = google_dot_protobuf_dot_duration__pb2._DURATION
+_HEALTHCHECK.fields_by_name['interval'].message_type = google_dot_protobuf_dot_duration__pb2._DURATION
+_HEALTHCHECK.fields_by_name['initial_jitter'].message_type = google_dot_protobuf_dot_duration__pb2._DURATION
+_HEALTHCHECK.fields_by_name['interval_jitter'].message_type = google_dot_protobuf_dot_duration__pb2._DURATION
+_HEALTHCHECK.fields_by_name['unhealthy_threshold'].message_type = google_dot_protobuf_dot_wrappers__pb2._UINT32VALUE
+_HEALTHCHECK.fields_by_name['healthy_threshold'].message_type = google_dot_protobuf_dot_wrappers__pb2._UINT32VALUE
+_HEALTHCHECK.fields_by_name['alt_port'].message_type = google_dot_protobuf_dot_wrappers__pb2._UINT32VALUE
+_HEALTHCHECK.fields_by_name['reuse_connection'].message_type = google_dot_protobuf_dot_wrappers__pb2._BOOLVALUE
+_HEALTHCHECK.fields_by_name['http_health_check'].message_type = _HEALTHCHECK_HTTPHEALTHCHECK
+_HEALTHCHECK.fields_by_name['tcp_health_check'].message_type = _HEALTHCHECK_TCPHEALTHCHECK
+_HEALTHCHECK.fields_by_name['grpc_health_check'].message_type = _HEALTHCHECK_GRPCHEALTHCHECK
+_HEALTHCHECK.fields_by_name['custom_health_check'].message_type = _HEALTHCHECK_CUSTOMHEALTHCHECK
+_HEALTHCHECK.fields_by_name['no_traffic_interval'].message_type = google_dot_protobuf_dot_duration__pb2._DURATION
+_HEALTHCHECK.fields_by_name['no_traffic_healthy_interval'].message_type = google_dot_protobuf_dot_duration__pb2._DURATION
+_HEALTHCHECK.fields_by_name['unhealthy_interval'].message_type = google_dot_protobuf_dot_duration__pb2._DURATION
+_HEALTHCHECK.fields_by_name['unhealthy_edge_interval'].message_type = google_dot_protobuf_dot_duration__pb2._DURATION
+_HEALTHCHECK.fields_by_name['healthy_edge_interval'].message_type = google_dot_protobuf_dot_duration__pb2._DURATION
+_HEALTHCHECK.fields_by_name['tls_options'].message_type = _HEALTHCHECK_TLSOPTIONS
+_HEALTHCHECK.oneofs_by_name['health_checker'].fields.append(
+  _HEALTHCHECK.fields_by_name['http_health_check'])
+_HEALTHCHECK.fields_by_name['http_health_check'].containing_oneof = _HEALTHCHECK.oneofs_by_name['health_checker']
+_HEALTHCHECK.oneofs_by_name['health_checker'].fields.append(
+  _HEALTHCHECK.fields_by_name['tcp_health_check'])
+_HEALTHCHECK.fields_by_name['tcp_health_check'].containing_oneof = _HEALTHCHECK.oneofs_by_name['health_checker']
+_HEALTHCHECK.oneofs_by_name['health_checker'].fields.append(
+  _HEALTHCHECK.fields_by_name['grpc_health_check'])
+_HEALTHCHECK.fields_by_name['grpc_health_check'].containing_oneof = _HEALTHCHECK.oneofs_by_name['health_checker']
+_HEALTHCHECK.oneofs_by_name['health_checker'].fields.append(
+  _HEALTHCHECK.fields_by_name['custom_health_check'])
+_HEALTHCHECK.fields_by_name['custom_health_check'].containing_oneof = _HEALTHCHECK.oneofs_by_name['health_checker']
 DESCRIPTOR.message_types_by_name['DestinationRule'] = _DESTINATIONRULE
 DESCRIPTOR.message_types_by_name['TrafficPolicy'] = _TRAFFICPOLICY
 DESCRIPTOR.message_types_by_name['Subset'] = _SUBSET
@@ -1164,6 +1817,11 @@ DESCRIPTOR.message_types_by_name['ConnectionPoolSettings'] = _CONNECTIONPOOLSETT
 DESCRIPTOR.message_types_by_name['OutlierDetection'] = _OUTLIERDETECTION
 DESCRIPTOR.message_types_by_name['ClientTLSSettings'] = _CLIENTTLSSETTINGS
 DESCRIPTOR.message_types_by_name['LocalityLoadBalancerSetting'] = _LOCALITYLOADBALANCERSETTING
+DESCRIPTOR.message_types_by_name['Int64Range'] = _INT64RANGE
+DESCRIPTOR.message_types_by_name['HealthStatusSet'] = _HEALTHSTATUSSET
+DESCRIPTOR.message_types_by_name['Payload'] = _PAYLOAD
+DESCRIPTOR.message_types_by_name['HealthCheck'] = _HEALTHCHECK
+DESCRIPTOR.enum_types_by_name['HealthStatus'] = _HEALTHSTATUS
 _sym_db.RegisterFileDescriptor(DESCRIPTOR)
 
 DestinationRule = _reflection.GeneratedProtocolMessageType('DestinationRule', (_message.Message,), {
@@ -1302,6 +1960,82 @@ _sym_db.RegisterMessage(LocalityLoadBalancerSetting.Distribute)
 _sym_db.RegisterMessage(LocalityLoadBalancerSetting.Distribute.ToEntry)
 _sym_db.RegisterMessage(LocalityLoadBalancerSetting.Failover)
 
+Int64Range = _reflection.GeneratedProtocolMessageType('Int64Range', (_message.Message,), {
+  'DESCRIPTOR' : _INT64RANGE,
+  '__module__' : 'networking.v1beta1.destination_rule_pb2'
+  # @@protoc_insertion_point(class_scope:istio.networking.v1beta1.Int64Range)
+  })
+_sym_db.RegisterMessage(Int64Range)
+
+HealthStatusSet = _reflection.GeneratedProtocolMessageType('HealthStatusSet', (_message.Message,), {
+  'DESCRIPTOR' : _HEALTHSTATUSSET,
+  '__module__' : 'networking.v1beta1.destination_rule_pb2'
+  # @@protoc_insertion_point(class_scope:istio.networking.v1beta1.HealthStatusSet)
+  })
+_sym_db.RegisterMessage(HealthStatusSet)
+
+Payload = _reflection.GeneratedProtocolMessageType('Payload', (_message.Message,), {
+  'DESCRIPTOR' : _PAYLOAD,
+  '__module__' : 'networking.v1beta1.destination_rule_pb2'
+  # @@protoc_insertion_point(class_scope:istio.networking.v1beta1.Payload)
+  })
+_sym_db.RegisterMessage(Payload)
+
+HealthCheck = _reflection.GeneratedProtocolMessageType('HealthCheck', (_message.Message,), {
+
+  'HttpHealthCheck' : _reflection.GeneratedProtocolMessageType('HttpHealthCheck', (_message.Message,), {
+    'DESCRIPTOR' : _HEALTHCHECK_HTTPHEALTHCHECK,
+    '__module__' : 'networking.v1beta1.destination_rule_pb2'
+    # @@protoc_insertion_point(class_scope:istio.networking.v1beta1.HealthCheck.HttpHealthCheck)
+    })
+  ,
+
+  'TcpHealthCheck' : _reflection.GeneratedProtocolMessageType('TcpHealthCheck', (_message.Message,), {
+    'DESCRIPTOR' : _HEALTHCHECK_TCPHEALTHCHECK,
+    '__module__' : 'networking.v1beta1.destination_rule_pb2'
+    # @@protoc_insertion_point(class_scope:istio.networking.v1beta1.HealthCheck.TcpHealthCheck)
+    })
+  ,
+
+  'RedisHealthCheck' : _reflection.GeneratedProtocolMessageType('RedisHealthCheck', (_message.Message,), {
+    'DESCRIPTOR' : _HEALTHCHECK_REDISHEALTHCHECK,
+    '__module__' : 'networking.v1beta1.destination_rule_pb2'
+    # @@protoc_insertion_point(class_scope:istio.networking.v1beta1.HealthCheck.RedisHealthCheck)
+    })
+  ,
+
+  'GrpcHealthCheck' : _reflection.GeneratedProtocolMessageType('GrpcHealthCheck', (_message.Message,), {
+    'DESCRIPTOR' : _HEALTHCHECK_GRPCHEALTHCHECK,
+    '__module__' : 'networking.v1beta1.destination_rule_pb2'
+    # @@protoc_insertion_point(class_scope:istio.networking.v1beta1.HealthCheck.GrpcHealthCheck)
+    })
+  ,
+
+  'CustomHealthCheck' : _reflection.GeneratedProtocolMessageType('CustomHealthCheck', (_message.Message,), {
+    'DESCRIPTOR' : _HEALTHCHECK_CUSTOMHEALTHCHECK,
+    '__module__' : 'networking.v1beta1.destination_rule_pb2'
+    # @@protoc_insertion_point(class_scope:istio.networking.v1beta1.HealthCheck.CustomHealthCheck)
+    })
+  ,
+
+  'TlsOptions' : _reflection.GeneratedProtocolMessageType('TlsOptions', (_message.Message,), {
+    'DESCRIPTOR' : _HEALTHCHECK_TLSOPTIONS,
+    '__module__' : 'networking.v1beta1.destination_rule_pb2'
+    # @@protoc_insertion_point(class_scope:istio.networking.v1beta1.HealthCheck.TlsOptions)
+    })
+  ,
+  'DESCRIPTOR' : _HEALTHCHECK,
+  '__module__' : 'networking.v1beta1.destination_rule_pb2'
+  # @@protoc_insertion_point(class_scope:istio.networking.v1beta1.HealthCheck)
+  })
+_sym_db.RegisterMessage(HealthCheck)
+_sym_db.RegisterMessage(HealthCheck.HttpHealthCheck)
+_sym_db.RegisterMessage(HealthCheck.TcpHealthCheck)
+_sym_db.RegisterMessage(HealthCheck.RedisHealthCheck)
+_sym_db.RegisterMessage(HealthCheck.GrpcHealthCheck)
+_sym_db.RegisterMessage(HealthCheck.CustomHealthCheck)
+_sym_db.RegisterMessage(HealthCheck.TlsOptions)
+
 
 DESCRIPTOR._options = None
 _DESTINATIONRULE.fields_by_name['host']._options = None
diff --git a/python/istio_api/networking/v1beta1/service_subscription_list_pb2.py b/python/istio_api/networking/v1beta1/service_subscription_list_pb2.py
new file mode 100644
index 00000000..c65668a4
--- /dev/null
+++ b/python/istio_api/networking/v1beta1/service_subscription_list_pb2.py
@@ -0,0 +1,239 @@
+# -*- coding: utf-8 -*-
+# Generated by the protocol buffer compiler.  DO NOT EDIT!
+# source: networking/v1beta1/service_subscription_list.proto
+"""Generated protocol buffer code."""
+from google.protobuf import descriptor as _descriptor
+from google.protobuf import message as _message
+from google.protobuf import reflection as _reflection
+from google.protobuf import symbol_database as _symbol_database
+# @@protoc_insertion_point(imports)
+
+_sym_db = _symbol_database.Default()
+
+
+from networking.v1beta1 import gateway_pb2 as networking_dot_v1beta1_dot_gateway__pb2
+
+
+DESCRIPTOR = _descriptor.FileDescriptor(
+  name='networking/v1beta1/service_subscription_list.proto',
+  package='istio.networking.v1beta1',
+  syntax='proto3',
+  serialized_options=b'Z\037istio.io/api/networking/v1beta1',
+  create_key=_descriptor._internal_create_key,
+  serialized_pb=b'\n2networking/v1beta1/service_subscription_list.proto\x12\x18istio.networking.v1beta1\x1a networking/v1beta1/gateway.proto\"\x86\x02\n\x17ServiceSubscriptionList\x12\\\n\nresolution\x18\x01 \x01(\x0e\x32<.istio.networking.v1beta1.ServiceSubscriptionList.ResolutionR\nresolution\x12S\n\rsubscriptions\x18\x02 \x03(\x0b\x32-.istio.networking.v1beta1.ServiceSubscriptionR\rsubscriptions\"8\n\nResolution\x12\x10\n\x0c\x43ONFIGSERVER\x10\x00\x12\r\n\tVIPSERVER\x10\x01\x12\t\n\x05NACOS\x10\x02\"\xb9\x02\n\x13ServiceSubscription\x12\x1a\n\x08hostname\x18\x01 \x01(\tR\x08hostname\x12\x18\n\x07version\x18\x02 \x01(\tR\x07version\x12\x14\n\x05group\x18\x03 \x01(\tR\x05group\x12\x32\n\x04port\x18\x04 \x01(\x0b\x32\x1e.istio.networking.v1beta1.PortR\x04port\x12\x14\n\x05units\x18\x05 \x03(\tR\x05units\x12Q\n\x06labels\x18\x06 \x03(\x0b\x32\x39.istio.networking.v1beta1.ServiceSubscription.LabelsEntryR\x06labels\x1a\x39\n\x0bLabelsEntry\x12\x10\n\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n\x05value\x18\x02 \x01(\tR\x05value:\x02\x38\x01\x42!Z\x1fistio.io/api/networking/v1beta1b\x06proto3'
+  ,
+  dependencies=[networking_dot_v1beta1_dot_gateway__pb2.DESCRIPTOR,])
+
+
+
+_SERVICESUBSCRIPTIONLIST_RESOLUTION = _descriptor.EnumDescriptor(
+  name='Resolution',
+  full_name='istio.networking.v1beta1.ServiceSubscriptionList.Resolution',
+  filename=None,
+  file=DESCRIPTOR,
+  create_key=_descriptor._internal_create_key,
+  values=[
+    _descriptor.EnumValueDescriptor(
+      name='CONFIGSERVER', index=0, number=0,
+      serialized_options=None,
+      type=None,
+      create_key=_descriptor._internal_create_key),
+    _descriptor.EnumValueDescriptor(
+      name='VIPSERVER', index=1, number=1,
+      serialized_options=None,
+      type=None,
+      create_key=_descriptor._internal_create_key),
+    _descriptor.EnumValueDescriptor(
+      name='NACOS', index=2, number=2,
+      serialized_options=None,
+      type=None,
+      create_key=_descriptor._internal_create_key),
+  ],
+  containing_type=None,
+  serialized_options=None,
+  serialized_start=321,
+  serialized_end=377,
+)
+_sym_db.RegisterEnumDescriptor(_SERVICESUBSCRIPTIONLIST_RESOLUTION)
+
+
+_SERVICESUBSCRIPTIONLIST = _descriptor.Descriptor(
+  name='ServiceSubscriptionList',
+  full_name='istio.networking.v1beta1.ServiceSubscriptionList',
+  filename=None,
+  file=DESCRIPTOR,
+  containing_type=None,
+  create_key=_descriptor._internal_create_key,
+  fields=[
+    _descriptor.FieldDescriptor(
+      name='resolution', full_name='istio.networking.v1beta1.ServiceSubscriptionList.resolution', index=0,
+      number=1, type=14, cpp_type=8, label=1,
+      has_default_value=False, default_value=0,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='resolution', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='subscriptions', full_name='istio.networking.v1beta1.ServiceSubscriptionList.subscriptions', index=1,
+      number=2, type=11, cpp_type=10, label=3,
+      has_default_value=False, default_value=[],
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='subscriptions', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+  ],
+  extensions=[
+  ],
+  nested_types=[],
+  enum_types=[
+    _SERVICESUBSCRIPTIONLIST_RESOLUTION,
+  ],
+  serialized_options=None,
+  is_extendable=False,
+  syntax='proto3',
+  extension_ranges=[],
+  oneofs=[
+  ],
+  serialized_start=115,
+  serialized_end=377,
+)
+
+
+_SERVICESUBSCRIPTION_LABELSENTRY = _descriptor.Descriptor(
+  name='LabelsEntry',
+  full_name='istio.networking.v1beta1.ServiceSubscription.LabelsEntry',
+  filename=None,
+  file=DESCRIPTOR,
+  containing_type=None,
+  create_key=_descriptor._internal_create_key,
+  fields=[
+    _descriptor.FieldDescriptor(
+      name='key', full_name='istio.networking.v1beta1.ServiceSubscription.LabelsEntry.key', index=0,
+      number=1, type=9, cpp_type=9, label=1,
+      has_default_value=False, default_value=b"".decode('utf-8'),
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='key', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='value', full_name='istio.networking.v1beta1.ServiceSubscription.LabelsEntry.value', index=1,
+      number=2, type=9, cpp_type=9, label=1,
+      has_default_value=False, default_value=b"".decode('utf-8'),
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='value', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+  ],
+  extensions=[
+  ],
+  nested_types=[],
+  enum_types=[
+  ],
+  serialized_options=b'8\001',
+  is_extendable=False,
+  syntax='proto3',
+  extension_ranges=[],
+  oneofs=[
+  ],
+  serialized_start=636,
+  serialized_end=693,
+)
+
+_SERVICESUBSCRIPTION = _descriptor.Descriptor(
+  name='ServiceSubscription',
+  full_name='istio.networking.v1beta1.ServiceSubscription',
+  filename=None,
+  file=DESCRIPTOR,
+  containing_type=None,
+  create_key=_descriptor._internal_create_key,
+  fields=[
+    _descriptor.FieldDescriptor(
+      name='hostname', full_name='istio.networking.v1beta1.ServiceSubscription.hostname', index=0,
+      number=1, type=9, cpp_type=9, label=1,
+      has_default_value=False, default_value=b"".decode('utf-8'),
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='hostname', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='version', full_name='istio.networking.v1beta1.ServiceSubscription.version', index=1,
+      number=2, type=9, cpp_type=9, label=1,
+      has_default_value=False, default_value=b"".decode('utf-8'),
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='version', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='group', full_name='istio.networking.v1beta1.ServiceSubscription.group', index=2,
+      number=3, type=9, cpp_type=9, label=1,
+      has_default_value=False, default_value=b"".decode('utf-8'),
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='group', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='port', full_name='istio.networking.v1beta1.ServiceSubscription.port', index=3,
+      number=4, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='port', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='units', full_name='istio.networking.v1beta1.ServiceSubscription.units', index=4,
+      number=5, type=9, cpp_type=9, label=3,
+      has_default_value=False, default_value=[],
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='units', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='labels', full_name='istio.networking.v1beta1.ServiceSubscription.labels', index=5,
+      number=6, type=11, cpp_type=10, label=3,
+      has_default_value=False, default_value=[],
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='labels', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+  ],
+  extensions=[
+  ],
+  nested_types=[_SERVICESUBSCRIPTION_LABELSENTRY, ],
+  enum_types=[
+  ],
+  serialized_options=None,
+  is_extendable=False,
+  syntax='proto3',
+  extension_ranges=[],
+  oneofs=[
+  ],
+  serialized_start=380,
+  serialized_end=693,
+)
+
+_SERVICESUBSCRIPTIONLIST.fields_by_name['resolution'].enum_type = _SERVICESUBSCRIPTIONLIST_RESOLUTION
+_SERVICESUBSCRIPTIONLIST.fields_by_name['subscriptions'].message_type = _SERVICESUBSCRIPTION
+_SERVICESUBSCRIPTIONLIST_RESOLUTION.containing_type = _SERVICESUBSCRIPTIONLIST
+_SERVICESUBSCRIPTION_LABELSENTRY.containing_type = _SERVICESUBSCRIPTION
+_SERVICESUBSCRIPTION.fields_by_name['port'].message_type = networking_dot_v1beta1_dot_gateway__pb2._PORT
+_SERVICESUBSCRIPTION.fields_by_name['labels'].message_type = _SERVICESUBSCRIPTION_LABELSENTRY
+DESCRIPTOR.message_types_by_name['ServiceSubscriptionList'] = _SERVICESUBSCRIPTIONLIST
+DESCRIPTOR.message_types_by_name['ServiceSubscription'] = _SERVICESUBSCRIPTION
+_sym_db.RegisterFileDescriptor(DESCRIPTOR)
+
+ServiceSubscriptionList = _reflection.GeneratedProtocolMessageType('ServiceSubscriptionList', (_message.Message,), {
+  'DESCRIPTOR' : _SERVICESUBSCRIPTIONLIST,
+  '__module__' : 'networking.v1beta1.service_subscription_list_pb2'
+  # @@protoc_insertion_point(class_scope:istio.networking.v1beta1.ServiceSubscriptionList)
+  })
+_sym_db.RegisterMessage(ServiceSubscriptionList)
+
+ServiceSubscription = _reflection.GeneratedProtocolMessageType('ServiceSubscription', (_message.Message,), {
+
+  'LabelsEntry' : _reflection.GeneratedProtocolMessageType('LabelsEntry', (_message.Message,), {
+    'DESCRIPTOR' : _SERVICESUBSCRIPTION_LABELSENTRY,
+    '__module__' : 'networking.v1beta1.service_subscription_list_pb2'
+    # @@protoc_insertion_point(class_scope:istio.networking.v1beta1.ServiceSubscription.LabelsEntry)
+    })
+  ,
+  'DESCRIPTOR' : _SERVICESUBSCRIPTION,
+  '__module__' : 'networking.v1beta1.service_subscription_list_pb2'
+  # @@protoc_insertion_point(class_scope:istio.networking.v1beta1.ServiceSubscription)
+  })
+_sym_db.RegisterMessage(ServiceSubscription)
+_sym_db.RegisterMessage(ServiceSubscription.LabelsEntry)
+
+
+DESCRIPTOR._options = None
+_SERVICESUBSCRIPTION_LABELSENTRY._options = None
+# @@protoc_insertion_point(module_scope)
diff --git a/python/istio_api/networking/v1beta1/virtual_service_pb2.py b/python/istio_api/networking/v1beta1/virtual_service_pb2.py
index 1a0cd157..20828646 100644
--- a/python/istio_api/networking/v1beta1/virtual_service_pb2.py
+++ b/python/istio_api/networking/v1beta1/virtual_service_pb2.py
@@ -22,7 +22,7 @@ DESCRIPTOR = _descriptor.FileDescriptor(
   syntax='proto3',
   serialized_options=b'Z\037istio.io/api/networking/v1beta1',
   create_key=_descriptor._internal_create_key,
-  serialized_pb=b'\n(networking/v1beta1/virtual_service.proto\x12\x18istio.networking.v1beta1\x1a\x1fgoogle/api/field_behavior.proto\x1a\x1egoogle/protobuf/duration.proto\x1a\x1egoogle/protobuf/wrappers.proto\"\x84\x02\n\x0eVirtualService\x12\x14\n\x05hosts\x18\x01 \x03(\tR\x05hosts\x12\x1a\n\x08gateways\x18\x02 \x03(\tR\x08gateways\x12\x37\n\x04http\x18\x03 \x03(\x0b\x32#.istio.networking.v1beta1.HTTPRouteR\x04http\x12\x34\n\x03tls\x18\x05 \x03(\x0b\x32\".istio.networking.v1beta1.TLSRouteR\x03tls\x12\x34\n\x03tcp\x18\x04 \x03(\x0b\x32\".istio.networking.v1beta1.TCPRouteR\x03tcp\x12\x1b\n\texport_to\x18\x06 \x03(\tR\x08\x65xportTo\"{\n\x0b\x44\x65stination\x12\x18\n\x04host\x18\x01 \x01(\tB\x04\xe2\x41\x01\x02R\x04host\x12\x16\n\x06subset\x18\x02 \x01(\tR\x06subset\x12:\n\x04port\x18\x03 \x01(\x0b\x32&.istio.networking.v1beta1.PortSelectorR\x04port\"\x91\x08\n\tHTTPRoute\x12\x12\n\x04name\x18\x11 \x01(\tR\x04name\x12@\n\x05match\x18\x01 \x03(\x0b\x32*.istio.networking.v1beta1.HTTPMatchRequestR\x05match\x12\x44\n\x05route\x18\x02 \x03(\x0b\x32..istio.networking.v1beta1.HTTPRouteDestinationR\x05route\x12\x42\n\x08redirect\x18\x03 \x01(\x0b\x32&.istio.networking.v1beta1.HTTPRedirectR\x08redirect\x12>\n\x08\x64\x65legate\x18\x14 \x01(\x0b\x32\".istio.networking.v1beta1.DelegateR\x08\x64\x65legate\x12?\n\x07rewrite\x18\x04 \x01(\x0b\x32%.istio.networking.v1beta1.HTTPRewriteR\x07rewrite\x12\x33\n\x07timeout\x18\x06 \x01(\x0b\x32\x19.google.protobuf.DurationR\x07timeout\x12=\n\x07retries\x18\x07 \x01(\x0b\x32#.istio.networking.v1beta1.HTTPRetryR\x07retries\x12\x42\n\x05\x66\x61ult\x18\x08 \x01(\x0b\x32,.istio.networking.v1beta1.HTTPFaultInjectionR\x05\x66\x61ult\x12=\n\x06mirror\x18\t \x01(\x0b\x32%.istio.networking.v1beta1.DestinationR\x06mirror\x12G\n\x0emirror_percent\x18\x12 \x01(\x0b\x32\x1c.google.protobuf.UInt32ValueB\x02\x18\x01R\rmirrorPercent\x12N\n\x11mirror_percentage\x18\x13 \x01(\x0b\x32!.istio.networking.v1beta1.PercentR\x10mirrorPercentage\x12\x45\n\x0b\x63ors_policy\x18\n \x01(\x0b\x32$.istio.networking.v1beta1.CorsPolicyR\ncorsPolicy\x12;\n\x07headers\x18\x10 \x01(\x0b\x32!.istio.networking.v1beta1.HeadersR\x07headersJ\x04\x08\x05\x10\x06J\x04\x08\x0b\x10\x10R\x11websocket_upgradeR\x0e\x61ppend_headersR\x17remove_response_headersR\x17\x61ppend_response_headersR\x16remove_request_headersR\x16\x61ppend_request_headers\"<\n\x08\x44\x65legate\x12\x12\n\x04name\x18\x01 \x01(\tR\x04name\x12\x1c\n\tnamespace\x18\x02 \x01(\tR\tnamespace\"\xe2\x03\n\x07Headers\x12L\n\x07request\x18\x01 \x01(\x0b\x32\x32.istio.networking.v1beta1.Headers.HeaderOperationsR\x07request\x12N\n\x08response\x18\x02 \x01(\x0b\x32\x32.istio.networking.v1beta1.Headers.HeaderOperationsR\x08response\x1a\xb8\x02\n\x10HeaderOperations\x12M\n\x03set\x18\x01 \x03(\x0b\x32;.istio.networking.v1beta1.Headers.HeaderOperations.SetEntryR\x03set\x12M\n\x03\x61\x64\x64\x18\x02 \x03(\x0b\x32;.istio.networking.v1beta1.Headers.HeaderOperations.AddEntryR\x03\x61\x64\x64\x12\x16\n\x06remove\x18\x03 \x03(\tR\x06remove\x1a\x36\n\x08SetEntry\x12\x10\n\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n\x05value\x18\x02 \x01(\tR\x05value:\x02\x38\x01\x1a\x36\n\x08\x41\x64\x64\x45ntry\x12\x10\n\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n\x05value\x18\x02 \x01(\tR\x05value:\x02\x38\x01\"\x96\x01\n\x08TLSRoute\x12H\n\x05match\x18\x01 \x03(\x0b\x32,.istio.networking.v1beta1.TLSMatchAttributesB\x04\xe2\x41\x01\x02R\x05match\x12@\n\x05route\x18\x02 \x03(\x0b\x32*.istio.networking.v1beta1.RouteDestinationR\x05route\"\x8f\x01\n\x08TCPRoute\x12\x41\n\x05match\x18\x01 \x03(\x0b\x32+.istio.networking.v1beta1.L4MatchAttributesR\x05match\x12@\n\x05route\x18\x02 \x03(\x0b\x32*.istio.networking.v1beta1.RouteDestinationR\x05route\"\x99\t\n\x10HTTPMatchRequest\x12\x12\n\x04name\x18\x0b \x01(\tR\x04name\x12\x37\n\x03uri\x18\x01 \x01(\x0b\x32%.istio.networking.v1beta1.StringMatchR\x03uri\x12=\n\x06scheme\x18\x02 \x01(\x0b\x32%.istio.networking.v1beta1.StringMatchR\x06scheme\x12=\n\x06method\x18\x03 \x01(\x0b\x32%.istio.networking.v1beta1.StringMatchR\x06method\x12\x43\n\tauthority\x18\x04 \x01(\x0b\x32%.istio.networking.v1beta1.StringMatchR\tauthority\x12Q\n\x07headers\x18\x05 \x03(\x0b\x32\x37.istio.networking.v1beta1.HTTPMatchRequest.HeadersEntryR\x07headers\x12\x12\n\x04port\x18\x06 \x01(\rR\x04port\x12\x61\n\rsource_labels\x18\x07 \x03(\x0b\x32<.istio.networking.v1beta1.HTTPMatchRequest.SourceLabelsEntryR\x0csourceLabels\x12\x1a\n\x08gateways\x18\x08 \x03(\tR\x08gateways\x12^\n\x0cquery_params\x18\t \x03(\x0b\x32;.istio.networking.v1beta1.HTTPMatchRequest.QueryParamsEntryR\x0bqueryParams\x12&\n\x0fignore_uri_case\x18\n \x01(\x08R\rignoreUriCase\x12g\n\x0fwithout_headers\x18\x0c \x03(\x0b\x32>.istio.networking.v1beta1.HTTPMatchRequest.WithoutHeadersEntryR\x0ewithoutHeaders\x12)\n\x10source_namespace\x18\r \x01(\tR\x0fsourceNamespace\x1a\x61\n\x0cHeadersEntry\x12\x10\n\x03key\x18\x01 \x01(\tR\x03key\x12;\n\x05value\x18\x02 \x01(\x0b\x32%.istio.networking.v1beta1.StringMatchR\x05value:\x02\x38\x01\x1a?\n\x11SourceLabelsEntry\x12\x10\n\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n\x05value\x18\x02 \x01(\tR\x05value:\x02\x38\x01\x1a\x65\n\x10QueryParamsEntry\x12\x10\n\x03key\x18\x01 \x01(\tR\x03key\x12;\n\x05value\x18\x02 \x01(\x0b\x32%.istio.networking.v1beta1.StringMatchR\x05value:\x02\x38\x01\x1ah\n\x13WithoutHeadersEntry\x12\x10\n\x03key\x18\x01 \x01(\tR\x03key\x12;\n\x05value\x18\x02 \x01(\x0b\x32%.istio.networking.v1beta1.StringMatchR\x05value:\x02\x38\x01\"\xa2\x02\n\x14HTTPRouteDestination\x12M\n\x0b\x64\x65stination\x18\x01 \x01(\x0b\x32%.istio.networking.v1beta1.DestinationB\x04\xe2\x41\x01\x02R\x0b\x64\x65stination\x12\x16\n\x06weight\x18\x02 \x01(\x05R\x06weight\x12;\n\x07headers\x18\x07 \x01(\x0b\x32!.istio.networking.v1beta1.HeadersR\x07headersJ\x04\x08\x03\x10\x07R\x17remove_response_headersR\x17\x61ppend_response_headersR\x16remove_request_headersR\x16\x61ppend_request_headers\"y\n\x10RouteDestination\x12M\n\x0b\x64\x65stination\x18\x01 \x01(\x0b\x32%.istio.networking.v1beta1.DestinationB\x04\xe2\x41\x01\x02R\x0b\x64\x65stination\x12\x16\n\x06weight\x18\x02 \x01(\x05R\x06weight\"\xe9\x02\n\x11L4MatchAttributes\x12/\n\x13\x64\x65stination_subnets\x18\x01 \x03(\tR\x12\x64\x65stinationSubnets\x12\x12\n\x04port\x18\x02 \x01(\rR\x04port\x12#\n\rsource_subnet\x18\x03 \x01(\tR\x0csourceSubnet\x12\x62\n\rsource_labels\x18\x04 \x03(\x0b\x32=.istio.networking.v1beta1.L4MatchAttributes.SourceLabelsEntryR\x0csourceLabels\x12\x1a\n\x08gateways\x18\x05 \x03(\tR\x08gateways\x12)\n\x10source_namespace\x18\x06 \x01(\tR\x0fsourceNamespace\x1a?\n\x11SourceLabelsEntry\x12\x10\n\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n\x05value\x18\x02 \x01(\tR\x05value:\x02\x38\x01\"\xfe\x02\n\x12TLSMatchAttributes\x12!\n\tsni_hosts\x18\x01 \x03(\tB\x04\xe2\x41\x01\x02R\x08sniHosts\x12/\n\x13\x64\x65stination_subnets\x18\x02 \x03(\tR\x12\x64\x65stinationSubnets\x12\x12\n\x04port\x18\x03 \x01(\rR\x04port\x12\x63\n\rsource_labels\x18\x05 \x03(\x0b\x32>.istio.networking.v1beta1.TLSMatchAttributes.SourceLabelsEntryR\x0csourceLabels\x12\x1a\n\x08gateways\x18\x06 \x03(\tR\x08gateways\x12)\n\x10source_namespace\x18\x07 \x01(\tR\x0fsourceNamespace\x1a?\n\x11SourceLabelsEntry\x12\x10\n\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n\x05value\x18\x02 \x01(\tR\x05value:\x02\x38\x01J\x04\x08\x04\x10\x05R\rsource_subnet\"\xce\x02\n\x0cHTTPRedirect\x12\x10\n\x03uri\x18\x01 \x01(\tR\x03uri\x12\x1c\n\tauthority\x18\x02 \x01(\tR\tauthority\x12\x14\n\x04port\x18\x04 \x01(\rH\x00R\x04port\x12_\n\x0b\x64\x65rive_port\x18\x05 \x01(\x0e\x32<.istio.networking.v1beta1.HTTPRedirect.RedirectPortSelectionH\x00R\nderivePort\x12\x16\n\x06scheme\x18\x06 \x01(\tR\x06scheme\x12#\n\rredirect_code\x18\x03 \x01(\rR\x0credirectCode\"I\n\x15RedirectPortSelection\x12\x19\n\x15\x46ROM_PROTOCOL_DEFAULT\x10\x00\x12\x15\n\x11\x46ROM_REQUEST_PORT\x10\x01\x42\x0f\n\rredirect_port\"=\n\x0bHTTPRewrite\x12\x10\n\x03uri\x18\x01 \x01(\tR\x03uri\x12\x1c\n\tauthority\x18\x02 \x01(\tR\tauthority\"e\n\x0bStringMatch\x12\x16\n\x05\x65xact\x18\x01 \x01(\tH\x00R\x05\x65xact\x12\x18\n\x06prefix\x18\x02 \x01(\tH\x00R\x06prefix\x12\x16\n\x05regex\x18\x03 \x01(\tH\x00R\x05regexB\x0c\n\nmatch_type\"\xdf\x01\n\tHTTPRetry\x12 \n\x08\x61ttempts\x18\x01 \x01(\x05\x42\x04\xe2\x41\x01\x02R\x08\x61ttempts\x12\x41\n\x0fper_try_timeout\x18\x02 \x01(\x0b\x32\x19.google.protobuf.DurationR\rperTryTimeout\x12\x19\n\x08retry_on\x18\x03 \x01(\tR\x07retryOn\x12R\n\x17retry_remote_localities\x18\x04 \x01(\x0b\x32\x1a.google.protobuf.BoolValueR\x15retryRemoteLocalities\"\xed\x02\n\nCorsPolicy\x12%\n\x0c\x61llow_origin\x18\x01 \x03(\tB\x02\x18\x01R\x0b\x61llowOrigin\x12J\n\rallow_origins\x18\x07 \x03(\x0b\x32%.istio.networking.v1beta1.StringMatchR\x0c\x61llowOrigins\x12#\n\rallow_methods\x18\x02 \x03(\tR\x0c\x61llowMethods\x12#\n\rallow_headers\x18\x03 \x03(\tR\x0c\x61llowHeaders\x12%\n\x0e\x65xpose_headers\x18\x04 \x03(\tR\rexposeHeaders\x12\x32\n\x07max_age\x18\x05 \x01(\x0b\x32\x19.google.protobuf.DurationR\x06maxAge\x12G\n\x11\x61llow_credentials\x18\x06 \x01(\x0b\x32\x1a.google.protobuf.BoolValueR\x10\x61llowCredentials\"\x8d\x05\n\x12HTTPFaultInjection\x12H\n\x05\x64\x65lay\x18\x01 \x01(\x0b\x32\x32.istio.networking.v1beta1.HTTPFaultInjection.DelayR\x05\x64\x65lay\x12H\n\x05\x61\x62ort\x18\x02 \x01(\x0b\x32\x32.istio.networking.v1beta1.HTTPFaultInjection.AbortR\x05\x61\x62ort\x1a\x89\x02\n\x05\x44\x65lay\x12\x1c\n\x07percent\x18\x01 \x01(\x05\x42\x02\x18\x01R\x07percent\x12\x42\n\x0b\x66ixed_delay\x18\x02 \x01(\x0b\x32\x19.google.protobuf.DurationB\x04\xe2\x41\x01\x02H\x00R\nfixedDelay\x12H\n\x11\x65xponential_delay\x18\x03 \x01(\x0b\x32\x19.google.protobuf.DurationH\x00R\x10\x65xponentialDelay\x12\x41\n\npercentage\x18\x05 \x01(\x0b\x32!.istio.networking.v1beta1.PercentR\npercentageB\x11\n\x0fhttp_delay_type\x1a\xd6\x01\n\x05\x41\x62ort\x12\'\n\x0bhttp_status\x18\x02 \x01(\x05\x42\x04\xe2\x41\x01\x02H\x00R\nhttpStatus\x12!\n\x0bgrpc_status\x18\x03 \x01(\tH\x00R\ngrpcStatus\x12!\n\x0bhttp2_error\x18\x04 \x01(\tH\x00R\nhttp2Error\x12\x41\n\npercentage\x18\x05 \x01(\x0b\x32!.istio.networking.v1beta1.PercentR\npercentageB\x0c\n\nerror_typeJ\x04\x08\x01\x10\x02R\x07percent\"2\n\x0cPortSelector\x12\x16\n\x06number\x18\x01 \x01(\rR\x06numberJ\x04\x08\x02\x10\x03R\x04name\"\x1f\n\x07Percent\x12\x14\n\x05value\x18\x01 \x01(\x01R\x05valueB!Z\x1fistio.io/api/networking/v1beta1b\x06proto3'
+  serialized_pb=b'\n(networking/v1beta1/virtual_service.proto\x12\x18istio.networking.v1beta1\x1a\x1fgoogle/api/field_behavior.proto\x1a\x1egoogle/protobuf/duration.proto\x1a\x1egoogle/protobuf/wrappers.proto\"\xd5\x02\n\x0eVirtualService\x12\x14\n\x05hosts\x18\x01 \x03(\tR\x05hosts\x12\x1a\n\x08gateways\x18\x02 \x03(\tR\x08gateways\x12O\n\x0fhostHTTPFilters\x18\xe8\x07 \x03(\x0b\x32$.istio.networking.v1beta1.HTTPFilterR\x0fhostHTTPFilters\x12\x37\n\x04http\x18\x03 \x03(\x0b\x32#.istio.networking.v1beta1.HTTPRouteR\x04http\x12\x34\n\x03tls\x18\x05 \x03(\x0b\x32\".istio.networking.v1beta1.TLSRouteR\x03tls\x12\x34\n\x03tcp\x18\x04 \x03(\x0b\x32\".istio.networking.v1beta1.TCPRouteR\x03tcp\x12\x1b\n\texport_to\x18\x06 \x03(\tR\x08\x65xportTo\"{\n\x0b\x44\x65stination\x12\x18\n\x04host\x18\x01 \x01(\tB\x04\xe2\x41\x01\x02R\x04host\x12\x16\n\x06subset\x18\x02 \x01(\tR\x06subset\x12:\n\x04port\x18\x03 \x01(\x0b\x32&.istio.networking.v1beta1.PortSelectorR\x04port\"\xab\n\n\tHTTPRoute\x12\x12\n\x04name\x18\x11 \x01(\tR\x04name\x12@\n\x05match\x18\x01 \x03(\x0b\x32*.istio.networking.v1beta1.HTTPMatchRequestR\x05match\x12\x44\n\x05route\x18\x02 \x03(\x0b\x32..istio.networking.v1beta1.HTTPRouteDestinationR\x05route\x12Q\n\x10routeHTTPFilters\x18\xe8\x07 \x03(\x0b\x32$.istio.networking.v1beta1.HTTPFilterR\x10routeHTTPFilters\x12\x42\n\x08redirect\x18\x03 \x01(\x0b\x32&.istio.networking.v1beta1.HTTPRedirectR\x08redirect\x12n\n\x18internal_active_redirect\x18\x19 \x01(\x0b\x32\x34.istio.networking.v1beta1.HTTPInternalActiveRedirectR\x16internalActiveRedirect\x12U\n\x0f\x64irect_response\x18\x1a \x01(\x0b\x32,.istio.networking.v1beta1.HTTPDirectResponseR\x0e\x64irectResponse\x12>\n\x08\x64\x65legate\x18\x14 \x01(\x0b\x32\".istio.networking.v1beta1.DelegateR\x08\x64\x65legate\x12?\n\x07rewrite\x18\x04 \x01(\x0b\x32%.istio.networking.v1beta1.HTTPRewriteR\x07rewrite\x12\x33\n\x07timeout\x18\x06 \x01(\x0b\x32\x19.google.protobuf.DurationR\x07timeout\x12=\n\x07retries\x18\x07 \x01(\x0b\x32#.istio.networking.v1beta1.HTTPRetryR\x07retries\x12\x42\n\x05\x66\x61ult\x18\x08 \x01(\x0b\x32,.istio.networking.v1beta1.HTTPFaultInjectionR\x05\x66\x61ult\x12=\n\x06mirror\x18\t \x01(\x0b\x32%.istio.networking.v1beta1.DestinationR\x06mirror\x12G\n\x0emirror_percent\x18\x12 \x01(\x0b\x32\x1c.google.protobuf.UInt32ValueB\x02\x18\x01R\rmirrorPercent\x12N\n\x11mirror_percentage\x18\x13 \x01(\x0b\x32!.istio.networking.v1beta1.PercentR\x10mirrorPercentage\x12\x45\n\x0b\x63ors_policy\x18\n \x01(\x0b\x32$.istio.networking.v1beta1.CorsPolicyR\ncorsPolicy\x12;\n\x07headers\x18\x10 \x01(\x0b\x32!.istio.networking.v1beta1.HeadersR\x07headersJ\x04\x08\x05\x10\x06J\x04\x08\x0b\x10\x10R\x11websocket_upgradeR\x0e\x61ppend_headersR\x17remove_response_headersR\x17\x61ppend_response_headersR\x16remove_request_headersR\x16\x61ppend_request_headers\"<\n\x08\x44\x65legate\x12\x12\n\x04name\x18\x01 \x01(\tR\x04name\x12\x1c\n\tnamespace\x18\x02 \x01(\tR\tnamespace\"\xe2\x03\n\x07Headers\x12L\n\x07request\x18\x01 \x01(\x0b\x32\x32.istio.networking.v1beta1.Headers.HeaderOperationsR\x07request\x12N\n\x08response\x18\x02 \x01(\x0b\x32\x32.istio.networking.v1beta1.Headers.HeaderOperationsR\x08response\x1a\xb8\x02\n\x10HeaderOperations\x12M\n\x03set\x18\x01 \x03(\x0b\x32;.istio.networking.v1beta1.Headers.HeaderOperations.SetEntryR\x03set\x12M\n\x03\x61\x64\x64\x18\x02 \x03(\x0b\x32;.istio.networking.v1beta1.Headers.HeaderOperations.AddEntryR\x03\x61\x64\x64\x12\x16\n\x06remove\x18\x03 \x03(\tR\x06remove\x1a\x36\n\x08SetEntry\x12\x10\n\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n\x05value\x18\x02 \x01(\tR\x05value:\x02\x38\x01\x1a\x36\n\x08\x41\x64\x64\x45ntry\x12\x10\n\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n\x05value\x18\x02 \x01(\tR\x05value:\x02\x38\x01\"\x96\x01\n\x08TLSRoute\x12H\n\x05match\x18\x01 \x03(\x0b\x32,.istio.networking.v1beta1.TLSMatchAttributesB\x04\xe2\x41\x01\x02R\x05match\x12@\n\x05route\x18\x02 \x03(\x0b\x32*.istio.networking.v1beta1.RouteDestinationR\x05route\"\x8f\x01\n\x08TCPRoute\x12\x41\n\x05match\x18\x01 \x03(\x0b\x32+.istio.networking.v1beta1.L4MatchAttributesR\x05match\x12@\n\x05route\x18\x02 \x03(\x0b\x32*.istio.networking.v1beta1.RouteDestinationR\x05route\"\x99\t\n\x10HTTPMatchRequest\x12\x12\n\x04name\x18\x0b \x01(\tR\x04name\x12\x37\n\x03uri\x18\x01 \x01(\x0b\x32%.istio.networking.v1beta1.StringMatchR\x03uri\x12=\n\x06scheme\x18\x02 \x01(\x0b\x32%.istio.networking.v1beta1.StringMatchR\x06scheme\x12=\n\x06method\x18\x03 \x01(\x0b\x32%.istio.networking.v1beta1.StringMatchR\x06method\x12\x43\n\tauthority\x18\x04 \x01(\x0b\x32%.istio.networking.v1beta1.StringMatchR\tauthority\x12Q\n\x07headers\x18\x05 \x03(\x0b\x32\x37.istio.networking.v1beta1.HTTPMatchRequest.HeadersEntryR\x07headers\x12\x12\n\x04port\x18\x06 \x01(\rR\x04port\x12\x61\n\rsource_labels\x18\x07 \x03(\x0b\x32<.istio.networking.v1beta1.HTTPMatchRequest.SourceLabelsEntryR\x0csourceLabels\x12\x1a\n\x08gateways\x18\x08 \x03(\tR\x08gateways\x12^\n\x0cquery_params\x18\t \x03(\x0b\x32;.istio.networking.v1beta1.HTTPMatchRequest.QueryParamsEntryR\x0bqueryParams\x12&\n\x0fignore_uri_case\x18\n \x01(\x08R\rignoreUriCase\x12g\n\x0fwithout_headers\x18\x0c \x03(\x0b\x32>.istio.networking.v1beta1.HTTPMatchRequest.WithoutHeadersEntryR\x0ewithoutHeaders\x12)\n\x10source_namespace\x18\r \x01(\tR\x0fsourceNamespace\x1a\x61\n\x0cHeadersEntry\x12\x10\n\x03key\x18\x01 \x01(\tR\x03key\x12;\n\x05value\x18\x02 \x01(\x0b\x32%.istio.networking.v1beta1.StringMatchR\x05value:\x02\x38\x01\x1a?\n\x11SourceLabelsEntry\x12\x10\n\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n\x05value\x18\x02 \x01(\tR\x05value:\x02\x38\x01\x1a\x65\n\x10QueryParamsEntry\x12\x10\n\x03key\x18\x01 \x01(\tR\x03key\x12;\n\x05value\x18\x02 \x01(\x0b\x32%.istio.networking.v1beta1.StringMatchR\x05value:\x02\x38\x01\x1ah\n\x13WithoutHeadersEntry\x12\x10\n\x03key\x18\x01 \x01(\tR\x03key\x12;\n\x05value\x18\x02 \x01(\x0b\x32%.istio.networking.v1beta1.StringMatchR\x05value:\x02\x38\x01\"\xf6\x02\n\x14HTTPRouteDestination\x12M\n\x0b\x64\x65stination\x18\x01 \x01(\x0b\x32%.istio.networking.v1beta1.DestinationB\x04\xe2\x41\x01\x02R\x0b\x64\x65stination\x12\x16\n\x06weight\x18\x02 \x01(\x05R\x06weight\x12;\n\x07headers\x18\x07 \x01(\x0b\x32!.istio.networking.v1beta1.HeadersR\x07headers\x12R\n\x11\x66\x61llback_clusters\x18\x64 \x03(\x0b\x32%.istio.networking.v1beta1.DestinationR\x10\x66\x61llbackClustersJ\x04\x08\x03\x10\x07R\x17remove_response_headersR\x17\x61ppend_response_headersR\x16remove_request_headersR\x16\x61ppend_request_headers\"y\n\x10RouteDestination\x12M\n\x0b\x64\x65stination\x18\x01 \x01(\x0b\x32%.istio.networking.v1beta1.DestinationB\x04\xe2\x41\x01\x02R\x0b\x64\x65stination\x12\x16\n\x06weight\x18\x02 \x01(\x05R\x06weight\"\xe9\x02\n\x11L4MatchAttributes\x12/\n\x13\x64\x65stination_subnets\x18\x01 \x03(\tR\x12\x64\x65stinationSubnets\x12\x12\n\x04port\x18\x02 \x01(\rR\x04port\x12#\n\rsource_subnet\x18\x03 \x01(\tR\x0csourceSubnet\x12\x62\n\rsource_labels\x18\x04 \x03(\x0b\x32=.istio.networking.v1beta1.L4MatchAttributes.SourceLabelsEntryR\x0csourceLabels\x12\x1a\n\x08gateways\x18\x05 \x03(\tR\x08gateways\x12)\n\x10source_namespace\x18\x06 \x01(\tR\x0fsourceNamespace\x1a?\n\x11SourceLabelsEntry\x12\x10\n\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n\x05value\x18\x02 \x01(\tR\x05value:\x02\x38\x01\"\xfe\x02\n\x12TLSMatchAttributes\x12!\n\tsni_hosts\x18\x01 \x03(\tB\x04\xe2\x41\x01\x02R\x08sniHosts\x12/\n\x13\x64\x65stination_subnets\x18\x02 \x03(\tR\x12\x64\x65stinationSubnets\x12\x12\n\x04port\x18\x03 \x01(\rR\x04port\x12\x63\n\rsource_labels\x18\x05 \x03(\x0b\x32>.istio.networking.v1beta1.TLSMatchAttributes.SourceLabelsEntryR\x0csourceLabels\x12\x1a\n\x08gateways\x18\x06 \x03(\tR\x08gateways\x12)\n\x10source_namespace\x18\x07 \x01(\tR\x0fsourceNamespace\x1a?\n\x11SourceLabelsEntry\x12\x10\n\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n\x05value\x18\x02 \x01(\tR\x05value:\x02\x38\x01J\x04\x08\x04\x10\x05R\rsource_subnet\"\xce\x02\n\x0cHTTPRedirect\x12\x10\n\x03uri\x18\x01 \x01(\tR\x03uri\x12\x1c\n\tauthority\x18\x02 \x01(\tR\tauthority\x12\x14\n\x04port\x18\x04 \x01(\rH\x00R\x04port\x12_\n\x0b\x64\x65rive_port\x18\x05 \x01(\x0e\x32<.istio.networking.v1beta1.HTTPRedirect.RedirectPortSelectionH\x00R\nderivePort\x12\x16\n\x06scheme\x18\x06 \x01(\tR\x06scheme\x12#\n\rredirect_code\x18\x03 \x01(\rR\x0credirectCode\"I\n\x15RedirectPortSelection\x12\x19\n\x15\x46ROM_PROTOCOL_DEFAULT\x10\x00\x12\x15\n\x11\x46ROM_REQUEST_PORT\x10\x01\x42\x0f\n\rredirect_port\"\x88\n\n\x1aHTTPInternalActiveRedirect\x12\x34\n\x16max_internal_redirects\x18\x01 \x01(\rR\x14maxInternalRedirects\x12\x36\n\x17redirect_response_codes\x18\x02 \x03(\rR\x15redirectResponseCodes\x12#\n\x0credirect_url\x18\x03 \x01(\tH\x00R\x0bredirectUrl\x12p\n\x1aredirect_url_rewrite_regex\x18\x04 \x01(\x0b\x32\x31.istio.networking.v1beta1.RegexMatchAndSubstituteH\x00R\x17redirectUrlRewriteRegex\x12,\n\x12\x61llow_cross_scheme\x18\x05 \x01(\x08R\x10\x61llowCrossScheme\x12;\n\x07headers\x18\x06 \x01(\x0b\x32!.istio.networking.v1beta1.HeadersR\x07headers\x12\x1c\n\tauthority\x18\x07 \x01(\tR\tauthority\x12\x37\n\x18\x66orced_use_original_host\x18\x10 \x01(\x08R\x15\x66orcedUseOriginalHost\x12Q\n&forced_add_header_before_route_matcher\x18\x11 \x01(\x08R!forcedAddHeaderBeforeRouteMatcher\x12_\n\x08policies\x18\x0f \x03(\x0b\x32\x43.istio.networking.v1beta1.HTTPInternalActiveRedirect.RedirectPolicyR\x08policies\x1a\xcc\x04\n\x0eRedirectPolicy\x12\x34\n\x16max_internal_redirects\x18\x08 \x01(\rR\x14maxInternalRedirects\x12\x36\n\x17redirect_response_codes\x18\t \x03(\rR\x15redirectResponseCodes\x12#\n\x0credirect_url\x18\n \x01(\tH\x00R\x0bredirectUrl\x12p\n\x1aredirect_url_rewrite_regex\x18\x0b \x01(\x0b\x32\x31.istio.networking.v1beta1.RegexMatchAndSubstituteH\x00R\x17redirectUrlRewriteRegex\x12,\n\x12\x61llow_cross_scheme\x18\x0c \x01(\x08R\x10\x61llowCrossScheme\x12;\n\x07headers\x18\r \x01(\x0b\x32!.istio.networking.v1beta1.HeadersR\x07headers\x12\x1c\n\tauthority\x18\x0e \x01(\tR\tauthority\x12\x37\n\x18\x66orced_use_original_host\x18\x11 \x01(\x08R\x15\x66orcedUseOriginalHost\x12Q\n&forced_add_header_before_route_matcher\x18\x12 \x01(\x08R!forcedAddHeaderBeforeRouteMatcherB \n\x1eredirect_url_rewrite_specifierB \n\x1eredirect_url_rewrite_specifier\"M\n\x12HTTPDirectResponse\x12#\n\rresponse_code\x18\x01 \x01(\rR\x0cresponseCode\x12\x12\n\x04\x62ody\x18\x02 \x01(\tR\x04\x62ody\"\x8d\x01\n\x0bHTTPRewrite\x12\x10\n\x03uri\x18\x01 \x01(\tR\x03uri\x12\x1c\n\tauthority\x18\x02 \x01(\tR\tauthority\x12N\n\turi_regex\x18\x03 \x01(\x0b\x32\x31.istio.networking.v1beta1.RegexMatchAndSubstituteR\x08uriRegex\"W\n\x17RegexMatchAndSubstitute\x12\x18\n\x07pattern\x18\x01 \x01(\tR\x07pattern\x12\"\n\x0csubstitution\x18\x02 \x01(\tR\x0csubstitution\"e\n\x0bStringMatch\x12\x16\n\x05\x65xact\x18\x01 \x01(\tH\x00R\x05\x65xact\x12\x18\n\x06prefix\x18\x02 \x01(\tH\x00R\x06prefix\x12\x16\n\x05regex\x18\x03 \x01(\tH\x00R\x05regexB\x0c\n\nmatch_type\"\xdf\x01\n\tHTTPRetry\x12 \n\x08\x61ttempts\x18\x01 \x01(\x05\x42\x04\xe2\x41\x01\x02R\x08\x61ttempts\x12\x41\n\x0fper_try_timeout\x18\x02 \x01(\x0b\x32\x19.google.protobuf.DurationR\rperTryTimeout\x12\x19\n\x08retry_on\x18\x03 \x01(\tR\x07retryOn\x12R\n\x17retry_remote_localities\x18\x04 \x01(\x0b\x32\x1a.google.protobuf.BoolValueR\x15retryRemoteLocalities\"\xed\x02\n\nCorsPolicy\x12%\n\x0c\x61llow_origin\x18\x01 \x03(\tB\x02\x18\x01R\x0b\x61llowOrigin\x12J\n\rallow_origins\x18\x07 \x03(\x0b\x32%.istio.networking.v1beta1.StringMatchR\x0c\x61llowOrigins\x12#\n\rallow_methods\x18\x02 \x03(\tR\x0c\x61llowMethods\x12#\n\rallow_headers\x18\x03 \x03(\tR\x0c\x61llowHeaders\x12%\n\x0e\x65xpose_headers\x18\x04 \x03(\tR\rexposeHeaders\x12\x32\n\x07max_age\x18\x05 \x01(\x0b\x32\x19.google.protobuf.DurationR\x06maxAge\x12G\n\x11\x61llow_credentials\x18\x06 \x01(\x0b\x32\x1a.google.protobuf.BoolValueR\x10\x61llowCredentials\"\x8d\x05\n\x12HTTPFaultInjection\x12H\n\x05\x64\x65lay\x18\x01 \x01(\x0b\x32\x32.istio.networking.v1beta1.HTTPFaultInjection.DelayR\x05\x64\x65lay\x12H\n\x05\x61\x62ort\x18\x02 \x01(\x0b\x32\x32.istio.networking.v1beta1.HTTPFaultInjection.AbortR\x05\x61\x62ort\x1a\x89\x02\n\x05\x44\x65lay\x12\x1c\n\x07percent\x18\x01 \x01(\x05\x42\x02\x18\x01R\x07percent\x12\x42\n\x0b\x66ixed_delay\x18\x02 \x01(\x0b\x32\x19.google.protobuf.DurationB\x04\xe2\x41\x01\x02H\x00R\nfixedDelay\x12H\n\x11\x65xponential_delay\x18\x03 \x01(\x0b\x32\x19.google.protobuf.DurationH\x00R\x10\x65xponentialDelay\x12\x41\n\npercentage\x18\x05 \x01(\x0b\x32!.istio.networking.v1beta1.PercentR\npercentageB\x11\n\x0fhttp_delay_type\x1a\xd6\x01\n\x05\x41\x62ort\x12\'\n\x0bhttp_status\x18\x02 \x01(\x05\x42\x04\xe2\x41\x01\x02H\x00R\nhttpStatus\x12!\n\x0bgrpc_status\x18\x03 \x01(\tH\x00R\ngrpcStatus\x12!\n\x0bhttp2_error\x18\x04 \x01(\tH\x00R\nhttp2Error\x12\x41\n\npercentage\x18\x05 \x01(\x0b\x32!.istio.networking.v1beta1.PercentR\npercentageB\x0c\n\nerror_typeJ\x04\x08\x01\x10\x02R\x07percent\"2\n\x0cPortSelector\x12\x16\n\x06number\x18\x01 \x01(\rR\x06numberJ\x04\x08\x02\x10\x03R\x04name\"\x1f\n\x07Percent\x12\x14\n\x05value\x18\x01 \x01(\x01R\x05value\"\xf3\x01\n\nHTTPFilter\x12\x12\n\x04name\x18\x01 \x01(\tR\x04name\x12\x18\n\x07\x64isable\x18\x02 \x01(\x08R\x07\x64isable\x12W\n\x11ip_access_control\x18\x03 \x01(\x0b\x32).istio.networking.v1beta1.IPAccessControlH\x00R\x0fipAccessControl\x12T\n\x10local_rate_limit\x18\x04 \x01(\x0b\x32(.istio.networking.v1beta1.LocalRateLimitH\x00R\x0elocalRateLimitB\x08\n\x06\x46ilter\"l\n\x0fIPAccessControl\x12(\n\x10remote_ip_blocks\x18\x01 \x03(\tR\x0eremoteIpBlocks\x12/\n\x14not_remote_ip_blocks\x18\x02 \x03(\tR\x11notRemoteIpBlocks\"\xb7\x01\n\x0eLocalRateLimit\x12H\n\x0ctoken_bucket\x18\x01 \x01(\x0b\x32%.istio.networking.v1beta1.TokenBucketR\x0btokenBucket\x12:\n\x19per_downstream_connection\x18\x02 \x01(\x08R\x17perDownstreamConnection\x12\x1f\n\x0bstatus_code\x18\x03 \x01(\rR\nstatusCode\"\x94\x01\n\x0bTokenBucket\x12\x1d\n\nmax_tokens\x18\x01 \x01(\rR\tmaxTokens\x12&\n\x0ftokens_pef_fill\x18\x02 \x01(\rR\rtokensPefFill\x12>\n\rfill_interval\x18\x03 \x01(\x0b\x32\x19.google.protobuf.DurationR\x0c\x66illIntervalB!Z\x1fistio.io/api/networking/v1beta1b\x06proto3'
   ,
   dependencies=[google_dot_api_dot_field__behavior__pb2.DESCRIPTOR,google_dot_protobuf_dot_duration__pb2.DESCRIPTOR,google_dot_protobuf_dot_wrappers__pb2.DESCRIPTOR,])
 
@@ -48,8 +48,8 @@ _HTTPREDIRECT_REDIRECTPORTSELECTION = _descriptor.EnumDescriptor(
   ],
   containing_type=None,
   serialized_options=None,
-  serialized_start=5035,
-  serialized_end=5108,
+  serialized_start=5482,
+  serialized_end=5555,
 )
 _sym_db.RegisterEnumDescriptor(_HTTPREDIRECT_REDIRECTPORTSELECTION)
 
@@ -77,28 +77,35 @@ _VIRTUALSERVICE = _descriptor.Descriptor(
       is_extension=False, extension_scope=None,
       serialized_options=None, json_name='gateways', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
     _descriptor.FieldDescriptor(
-      name='http', full_name='istio.networking.v1beta1.VirtualService.http', index=2,
+      name='hostHTTPFilters', full_name='istio.networking.v1beta1.VirtualService.hostHTTPFilters', index=2,
+      number=1000, type=11, cpp_type=10, label=3,
+      has_default_value=False, default_value=[],
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='hostHTTPFilters', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='http', full_name='istio.networking.v1beta1.VirtualService.http', index=3,
       number=3, type=11, cpp_type=10, label=3,
       has_default_value=False, default_value=[],
       message_type=None, enum_type=None, containing_type=None,
       is_extension=False, extension_scope=None,
       serialized_options=None, json_name='http', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
     _descriptor.FieldDescriptor(
-      name='tls', full_name='istio.networking.v1beta1.VirtualService.tls', index=3,
+      name='tls', full_name='istio.networking.v1beta1.VirtualService.tls', index=4,
       number=5, type=11, cpp_type=10, label=3,
       has_default_value=False, default_value=[],
       message_type=None, enum_type=None, containing_type=None,
       is_extension=False, extension_scope=None,
       serialized_options=None, json_name='tls', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
     _descriptor.FieldDescriptor(
-      name='tcp', full_name='istio.networking.v1beta1.VirtualService.tcp', index=4,
+      name='tcp', full_name='istio.networking.v1beta1.VirtualService.tcp', index=5,
       number=4, type=11, cpp_type=10, label=3,
       has_default_value=False, default_value=[],
       message_type=None, enum_type=None, containing_type=None,
       is_extension=False, extension_scope=None,
       serialized_options=None, json_name='tcp', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
     _descriptor.FieldDescriptor(
-      name='export_to', full_name='istio.networking.v1beta1.VirtualService.export_to', index=5,
+      name='export_to', full_name='istio.networking.v1beta1.VirtualService.export_to', index=6,
       number=6, type=9, cpp_type=9, label=3,
       has_default_value=False, default_value=[],
       message_type=None, enum_type=None, containing_type=None,
@@ -117,7 +124,7 @@ _VIRTUALSERVICE = _descriptor.Descriptor(
   oneofs=[
   ],
   serialized_start=168,
-  serialized_end=428,
+  serialized_end=509,
 )
 
 
@@ -162,8 +169,8 @@ _DESTINATION = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=430,
-  serialized_end=553,
+  serialized_start=511,
+  serialized_end=634,
 )
 
 
@@ -197,77 +204,98 @@ _HTTPROUTE = _descriptor.Descriptor(
       is_extension=False, extension_scope=None,
       serialized_options=None, json_name='route', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
     _descriptor.FieldDescriptor(
-      name='redirect', full_name='istio.networking.v1beta1.HTTPRoute.redirect', index=3,
+      name='routeHTTPFilters', full_name='istio.networking.v1beta1.HTTPRoute.routeHTTPFilters', index=3,
+      number=1000, type=11, cpp_type=10, label=3,
+      has_default_value=False, default_value=[],
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='routeHTTPFilters', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='redirect', full_name='istio.networking.v1beta1.HTTPRoute.redirect', index=4,
       number=3, type=11, cpp_type=10, label=1,
       has_default_value=False, default_value=None,
       message_type=None, enum_type=None, containing_type=None,
       is_extension=False, extension_scope=None,
       serialized_options=None, json_name='redirect', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
     _descriptor.FieldDescriptor(
-      name='delegate', full_name='istio.networking.v1beta1.HTTPRoute.delegate', index=4,
+      name='internal_active_redirect', full_name='istio.networking.v1beta1.HTTPRoute.internal_active_redirect', index=5,
+      number=25, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='internalActiveRedirect', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='direct_response', full_name='istio.networking.v1beta1.HTTPRoute.direct_response', index=6,
+      number=26, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='directResponse', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='delegate', full_name='istio.networking.v1beta1.HTTPRoute.delegate', index=7,
       number=20, type=11, cpp_type=10, label=1,
       has_default_value=False, default_value=None,
       message_type=None, enum_type=None, containing_type=None,
       is_extension=False, extension_scope=None,
       serialized_options=None, json_name='delegate', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
     _descriptor.FieldDescriptor(
-      name='rewrite', full_name='istio.networking.v1beta1.HTTPRoute.rewrite', index=5,
+      name='rewrite', full_name='istio.networking.v1beta1.HTTPRoute.rewrite', index=8,
       number=4, type=11, cpp_type=10, label=1,
       has_default_value=False, default_value=None,
       message_type=None, enum_type=None, containing_type=None,
       is_extension=False, extension_scope=None,
       serialized_options=None, json_name='rewrite', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
     _descriptor.FieldDescriptor(
-      name='timeout', full_name='istio.networking.v1beta1.HTTPRoute.timeout', index=6,
+      name='timeout', full_name='istio.networking.v1beta1.HTTPRoute.timeout', index=9,
       number=6, type=11, cpp_type=10, label=1,
       has_default_value=False, default_value=None,
       message_type=None, enum_type=None, containing_type=None,
       is_extension=False, extension_scope=None,
       serialized_options=None, json_name='timeout', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
     _descriptor.FieldDescriptor(
-      name='retries', full_name='istio.networking.v1beta1.HTTPRoute.retries', index=7,
+      name='retries', full_name='istio.networking.v1beta1.HTTPRoute.retries', index=10,
       number=7, type=11, cpp_type=10, label=1,
       has_default_value=False, default_value=None,
       message_type=None, enum_type=None, containing_type=None,
       is_extension=False, extension_scope=None,
       serialized_options=None, json_name='retries', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
     _descriptor.FieldDescriptor(
-      name='fault', full_name='istio.networking.v1beta1.HTTPRoute.fault', index=8,
+      name='fault', full_name='istio.networking.v1beta1.HTTPRoute.fault', index=11,
       number=8, type=11, cpp_type=10, label=1,
       has_default_value=False, default_value=None,
       message_type=None, enum_type=None, containing_type=None,
       is_extension=False, extension_scope=None,
       serialized_options=None, json_name='fault', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
     _descriptor.FieldDescriptor(
-      name='mirror', full_name='istio.networking.v1beta1.HTTPRoute.mirror', index=9,
+      name='mirror', full_name='istio.networking.v1beta1.HTTPRoute.mirror', index=12,
       number=9, type=11, cpp_type=10, label=1,
       has_default_value=False, default_value=None,
       message_type=None, enum_type=None, containing_type=None,
       is_extension=False, extension_scope=None,
       serialized_options=None, json_name='mirror', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
     _descriptor.FieldDescriptor(
-      name='mirror_percent', full_name='istio.networking.v1beta1.HTTPRoute.mirror_percent', index=10,
+      name='mirror_percent', full_name='istio.networking.v1beta1.HTTPRoute.mirror_percent', index=13,
       number=18, type=11, cpp_type=10, label=1,
       has_default_value=False, default_value=None,
       message_type=None, enum_type=None, containing_type=None,
       is_extension=False, extension_scope=None,
       serialized_options=b'\030\001', json_name='mirrorPercent', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
     _descriptor.FieldDescriptor(
-      name='mirror_percentage', full_name='istio.networking.v1beta1.HTTPRoute.mirror_percentage', index=11,
+      name='mirror_percentage', full_name='istio.networking.v1beta1.HTTPRoute.mirror_percentage', index=14,
       number=19, type=11, cpp_type=10, label=1,
       has_default_value=False, default_value=None,
       message_type=None, enum_type=None, containing_type=None,
       is_extension=False, extension_scope=None,
       serialized_options=None, json_name='mirrorPercentage', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
     _descriptor.FieldDescriptor(
-      name='cors_policy', full_name='istio.networking.v1beta1.HTTPRoute.cors_policy', index=12,
+      name='cors_policy', full_name='istio.networking.v1beta1.HTTPRoute.cors_policy', index=15,
       number=10, type=11, cpp_type=10, label=1,
       has_default_value=False, default_value=None,
       message_type=None, enum_type=None, containing_type=None,
       is_extension=False, extension_scope=None,
       serialized_options=None, json_name='corsPolicy', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
     _descriptor.FieldDescriptor(
-      name='headers', full_name='istio.networking.v1beta1.HTTPRoute.headers', index=13,
+      name='headers', full_name='istio.networking.v1beta1.HTTPRoute.headers', index=16,
       number=16, type=11, cpp_type=10, label=1,
       has_default_value=False, default_value=None,
       message_type=None, enum_type=None, containing_type=None,
@@ -285,8 +313,8 @@ _HTTPROUTE = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=556,
-  serialized_end=1597,
+  serialized_start=637,
+  serialized_end=1960,
 )
 
 
@@ -324,8 +352,8 @@ _DELEGATE = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=1599,
-  serialized_end=1659,
+  serialized_start=1962,
+  serialized_end=2022,
 )
 
 
@@ -363,8 +391,8 @@ _HEADERS_HEADEROPERATIONS_SETENTRY = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=2034,
-  serialized_end=2088,
+  serialized_start=2397,
+  serialized_end=2451,
 )
 
 _HEADERS_HEADEROPERATIONS_ADDENTRY = _descriptor.Descriptor(
@@ -401,8 +429,8 @@ _HEADERS_HEADEROPERATIONS_ADDENTRY = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=2090,
-  serialized_end=2144,
+  serialized_start=2453,
+  serialized_end=2507,
 )
 
 _HEADERS_HEADEROPERATIONS = _descriptor.Descriptor(
@@ -446,8 +474,8 @@ _HEADERS_HEADEROPERATIONS = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=1832,
-  serialized_end=2144,
+  serialized_start=2195,
+  serialized_end=2507,
 )
 
 _HEADERS = _descriptor.Descriptor(
@@ -484,8 +512,8 @@ _HEADERS = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=1662,
-  serialized_end=2144,
+  serialized_start=2025,
+  serialized_end=2507,
 )
 
 
@@ -523,8 +551,8 @@ _TLSROUTE = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=2147,
-  serialized_end=2297,
+  serialized_start=2510,
+  serialized_end=2660,
 )
 
 
@@ -562,8 +590,8 @@ _TCPROUTE = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=2300,
-  serialized_end=2443,
+  serialized_start=2663,
+  serialized_end=2806,
 )
 
 
@@ -601,8 +629,8 @@ _HTTPMATCHREQUEST_HEADERSENTRY = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=3252,
-  serialized_end=3349,
+  serialized_start=3615,
+  serialized_end=3712,
 )
 
 _HTTPMATCHREQUEST_SOURCELABELSENTRY = _descriptor.Descriptor(
@@ -639,8 +667,8 @@ _HTTPMATCHREQUEST_SOURCELABELSENTRY = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=3351,
-  serialized_end=3414,
+  serialized_start=3714,
+  serialized_end=3777,
 )
 
 _HTTPMATCHREQUEST_QUERYPARAMSENTRY = _descriptor.Descriptor(
@@ -677,8 +705,8 @@ _HTTPMATCHREQUEST_QUERYPARAMSENTRY = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=3416,
-  serialized_end=3517,
+  serialized_start=3779,
+  serialized_end=3880,
 )
 
 _HTTPMATCHREQUEST_WITHOUTHEADERSENTRY = _descriptor.Descriptor(
@@ -715,8 +743,8 @@ _HTTPMATCHREQUEST_WITHOUTHEADERSENTRY = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=3519,
-  serialized_end=3623,
+  serialized_start=3882,
+  serialized_end=3986,
 )
 
 _HTTPMATCHREQUEST = _descriptor.Descriptor(
@@ -830,8 +858,8 @@ _HTTPMATCHREQUEST = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=2446,
-  serialized_end=3623,
+  serialized_start=2809,
+  serialized_end=3986,
 )
 
 
@@ -864,6 +892,13 @@ _HTTPROUTEDESTINATION = _descriptor.Descriptor(
       message_type=None, enum_type=None, containing_type=None,
       is_extension=False, extension_scope=None,
       serialized_options=None, json_name='headers', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='fallback_clusters', full_name='istio.networking.v1beta1.HTTPRouteDestination.fallback_clusters', index=3,
+      number=100, type=11, cpp_type=10, label=3,
+      has_default_value=False, default_value=[],
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='fallbackClusters', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
   ],
   extensions=[
   ],
@@ -876,8 +911,8 @@ _HTTPROUTEDESTINATION = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=3626,
-  serialized_end=3916,
+  serialized_start=3989,
+  serialized_end=4363,
 )
 
 
@@ -915,8 +950,8 @@ _ROUTEDESTINATION = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=3918,
-  serialized_end=4039,
+  serialized_start=4365,
+  serialized_end=4486,
 )
 
 
@@ -954,8 +989,8 @@ _L4MATCHATTRIBUTES_SOURCELABELSENTRY = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=3351,
-  serialized_end=3414,
+  serialized_start=3714,
+  serialized_end=3777,
 )
 
 _L4MATCHATTRIBUTES = _descriptor.Descriptor(
@@ -1020,8 +1055,8 @@ _L4MATCHATTRIBUTES = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=4042,
-  serialized_end=4403,
+  serialized_start=4489,
+  serialized_end=4850,
 )
 
 
@@ -1059,8 +1094,8 @@ _TLSMATCHATTRIBUTES_SOURCELABELSENTRY = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=3351,
-  serialized_end=3414,
+  serialized_start=3714,
+  serialized_end=3777,
 )
 
 _TLSMATCHATTRIBUTES = _descriptor.Descriptor(
@@ -1125,8 +1160,8 @@ _TLSMATCHATTRIBUTES = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=4406,
-  serialized_end=4788,
+  serialized_start=4853,
+  serialized_end=5235,
 )
 
 
@@ -1198,8 +1233,239 @@ _HTTPREDIRECT = _descriptor.Descriptor(
       create_key=_descriptor._internal_create_key,
     fields=[]),
   ],
-  serialized_start=4791,
-  serialized_end=5125,
+  serialized_start=5238,
+  serialized_end=5572,
+)
+
+
+_HTTPINTERNALACTIVEREDIRECT_REDIRECTPOLICY = _descriptor.Descriptor(
+  name='RedirectPolicy',
+  full_name='istio.networking.v1beta1.HTTPInternalActiveRedirect.RedirectPolicy',
+  filename=None,
+  file=DESCRIPTOR,
+  containing_type=None,
+  create_key=_descriptor._internal_create_key,
+  fields=[
+    _descriptor.FieldDescriptor(
+      name='max_internal_redirects', full_name='istio.networking.v1beta1.HTTPInternalActiveRedirect.RedirectPolicy.max_internal_redirects', index=0,
+      number=8, type=13, cpp_type=3, label=1,
+      has_default_value=False, default_value=0,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='maxInternalRedirects', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='redirect_response_codes', full_name='istio.networking.v1beta1.HTTPInternalActiveRedirect.RedirectPolicy.redirect_response_codes', index=1,
+      number=9, type=13, cpp_type=3, label=3,
+      has_default_value=False, default_value=[],
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='redirectResponseCodes', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='redirect_url', full_name='istio.networking.v1beta1.HTTPInternalActiveRedirect.RedirectPolicy.redirect_url', index=2,
+      number=10, type=9, cpp_type=9, label=1,
+      has_default_value=False, default_value=b"".decode('utf-8'),
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='redirectUrl', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='redirect_url_rewrite_regex', full_name='istio.networking.v1beta1.HTTPInternalActiveRedirect.RedirectPolicy.redirect_url_rewrite_regex', index=3,
+      number=11, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='redirectUrlRewriteRegex', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='allow_cross_scheme', full_name='istio.networking.v1beta1.HTTPInternalActiveRedirect.RedirectPolicy.allow_cross_scheme', index=4,
+      number=12, type=8, cpp_type=7, label=1,
+      has_default_value=False, default_value=False,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='allowCrossScheme', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='headers', full_name='istio.networking.v1beta1.HTTPInternalActiveRedirect.RedirectPolicy.headers', index=5,
+      number=13, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='headers', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='authority', full_name='istio.networking.v1beta1.HTTPInternalActiveRedirect.RedirectPolicy.authority', index=6,
+      number=14, type=9, cpp_type=9, label=1,
+      has_default_value=False, default_value=b"".decode('utf-8'),
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='authority', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='forced_use_original_host', full_name='istio.networking.v1beta1.HTTPInternalActiveRedirect.RedirectPolicy.forced_use_original_host', index=7,
+      number=17, type=8, cpp_type=7, label=1,
+      has_default_value=False, default_value=False,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='forcedUseOriginalHost', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='forced_add_header_before_route_matcher', full_name='istio.networking.v1beta1.HTTPInternalActiveRedirect.RedirectPolicy.forced_add_header_before_route_matcher', index=8,
+      number=18, type=8, cpp_type=7, label=1,
+      has_default_value=False, default_value=False,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='forcedAddHeaderBeforeRouteMatcher', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+  ],
+  extensions=[
+  ],
+  nested_types=[],
+  enum_types=[
+  ],
+  serialized_options=None,
+  is_extendable=False,
+  syntax='proto3',
+  extension_ranges=[],
+  oneofs=[
+    _descriptor.OneofDescriptor(
+      name='redirect_url_rewrite_specifier', full_name='istio.networking.v1beta1.HTTPInternalActiveRedirect.RedirectPolicy.redirect_url_rewrite_specifier',
+      index=0, containing_type=None,
+      create_key=_descriptor._internal_create_key,
+    fields=[]),
+  ],
+  serialized_start=6241,
+  serialized_end=6829,
+)
+
+_HTTPINTERNALACTIVEREDIRECT = _descriptor.Descriptor(
+  name='HTTPInternalActiveRedirect',
+  full_name='istio.networking.v1beta1.HTTPInternalActiveRedirect',
+  filename=None,
+  file=DESCRIPTOR,
+  containing_type=None,
+  create_key=_descriptor._internal_create_key,
+  fields=[
+    _descriptor.FieldDescriptor(
+      name='max_internal_redirects', full_name='istio.networking.v1beta1.HTTPInternalActiveRedirect.max_internal_redirects', index=0,
+      number=1, type=13, cpp_type=3, label=1,
+      has_default_value=False, default_value=0,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='maxInternalRedirects', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='redirect_response_codes', full_name='istio.networking.v1beta1.HTTPInternalActiveRedirect.redirect_response_codes', index=1,
+      number=2, type=13, cpp_type=3, label=3,
+      has_default_value=False, default_value=[],
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='redirectResponseCodes', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='redirect_url', full_name='istio.networking.v1beta1.HTTPInternalActiveRedirect.redirect_url', index=2,
+      number=3, type=9, cpp_type=9, label=1,
+      has_default_value=False, default_value=b"".decode('utf-8'),
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='redirectUrl', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='redirect_url_rewrite_regex', full_name='istio.networking.v1beta1.HTTPInternalActiveRedirect.redirect_url_rewrite_regex', index=3,
+      number=4, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='redirectUrlRewriteRegex', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='allow_cross_scheme', full_name='istio.networking.v1beta1.HTTPInternalActiveRedirect.allow_cross_scheme', index=4,
+      number=5, type=8, cpp_type=7, label=1,
+      has_default_value=False, default_value=False,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='allowCrossScheme', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='headers', full_name='istio.networking.v1beta1.HTTPInternalActiveRedirect.headers', index=5,
+      number=6, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='headers', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='authority', full_name='istio.networking.v1beta1.HTTPInternalActiveRedirect.authority', index=6,
+      number=7, type=9, cpp_type=9, label=1,
+      has_default_value=False, default_value=b"".decode('utf-8'),
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='authority', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='forced_use_original_host', full_name='istio.networking.v1beta1.HTTPInternalActiveRedirect.forced_use_original_host', index=7,
+      number=16, type=8, cpp_type=7, label=1,
+      has_default_value=False, default_value=False,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='forcedUseOriginalHost', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='forced_add_header_before_route_matcher', full_name='istio.networking.v1beta1.HTTPInternalActiveRedirect.forced_add_header_before_route_matcher', index=8,
+      number=17, type=8, cpp_type=7, label=1,
+      has_default_value=False, default_value=False,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='forcedAddHeaderBeforeRouteMatcher', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='policies', full_name='istio.networking.v1beta1.HTTPInternalActiveRedirect.policies', index=9,
+      number=15, type=11, cpp_type=10, label=3,
+      has_default_value=False, default_value=[],
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='policies', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+  ],
+  extensions=[
+  ],
+  nested_types=[_HTTPINTERNALACTIVEREDIRECT_REDIRECTPOLICY, ],
+  enum_types=[
+  ],
+  serialized_options=None,
+  is_extendable=False,
+  syntax='proto3',
+  extension_ranges=[],
+  oneofs=[
+    _descriptor.OneofDescriptor(
+      name='redirect_url_rewrite_specifier', full_name='istio.networking.v1beta1.HTTPInternalActiveRedirect.redirect_url_rewrite_specifier',
+      index=0, containing_type=None,
+      create_key=_descriptor._internal_create_key,
+    fields=[]),
+  ],
+  serialized_start=5575,
+  serialized_end=6863,
+)
+
+
+_HTTPDIRECTRESPONSE = _descriptor.Descriptor(
+  name='HTTPDirectResponse',
+  full_name='istio.networking.v1beta1.HTTPDirectResponse',
+  filename=None,
+  file=DESCRIPTOR,
+  containing_type=None,
+  create_key=_descriptor._internal_create_key,
+  fields=[
+    _descriptor.FieldDescriptor(
+      name='response_code', full_name='istio.networking.v1beta1.HTTPDirectResponse.response_code', index=0,
+      number=1, type=13, cpp_type=3, label=1,
+      has_default_value=False, default_value=0,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='responseCode', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='body', full_name='istio.networking.v1beta1.HTTPDirectResponse.body', index=1,
+      number=2, type=9, cpp_type=9, label=1,
+      has_default_value=False, default_value=b"".decode('utf-8'),
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='body', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+  ],
+  extensions=[
+  ],
+  nested_types=[],
+  enum_types=[
+  ],
+  serialized_options=None,
+  is_extendable=False,
+  syntax='proto3',
+  extension_ranges=[],
+  oneofs=[
+  ],
+  serialized_start=6865,
+  serialized_end=6942,
 )
 
 
@@ -1225,6 +1491,52 @@ _HTTPREWRITE = _descriptor.Descriptor(
       message_type=None, enum_type=None, containing_type=None,
       is_extension=False, extension_scope=None,
       serialized_options=None, json_name='authority', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='uri_regex', full_name='istio.networking.v1beta1.HTTPRewrite.uri_regex', index=2,
+      number=3, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='uriRegex', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+  ],
+  extensions=[
+  ],
+  nested_types=[],
+  enum_types=[
+  ],
+  serialized_options=None,
+  is_extendable=False,
+  syntax='proto3',
+  extension_ranges=[],
+  oneofs=[
+  ],
+  serialized_start=6945,
+  serialized_end=7086,
+)
+
+
+_REGEXMATCHANDSUBSTITUTE = _descriptor.Descriptor(
+  name='RegexMatchAndSubstitute',
+  full_name='istio.networking.v1beta1.RegexMatchAndSubstitute',
+  filename=None,
+  file=DESCRIPTOR,
+  containing_type=None,
+  create_key=_descriptor._internal_create_key,
+  fields=[
+    _descriptor.FieldDescriptor(
+      name='pattern', full_name='istio.networking.v1beta1.RegexMatchAndSubstitute.pattern', index=0,
+      number=1, type=9, cpp_type=9, label=1,
+      has_default_value=False, default_value=b"".decode('utf-8'),
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='pattern', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='substitution', full_name='istio.networking.v1beta1.RegexMatchAndSubstitute.substitution', index=1,
+      number=2, type=9, cpp_type=9, label=1,
+      has_default_value=False, default_value=b"".decode('utf-8'),
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='substitution', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
   ],
   extensions=[
   ],
@@ -1237,8 +1549,8 @@ _HTTPREWRITE = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=5127,
-  serialized_end=5188,
+  serialized_start=7088,
+  serialized_end=7175,
 )
 
 
@@ -1288,8 +1600,8 @@ _STRINGMATCH = _descriptor.Descriptor(
       create_key=_descriptor._internal_create_key,
     fields=[]),
   ],
-  serialized_start=5190,
-  serialized_end=5291,
+  serialized_start=7177,
+  serialized_end=7278,
 )
 
 
@@ -1341,8 +1653,8 @@ _HTTPRETRY = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=5294,
-  serialized_end=5517,
+  serialized_start=7281,
+  serialized_end=7504,
 )
 
 
@@ -1415,8 +1727,8 @@ _CORSPOLICY = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=5520,
-  serialized_end=5885,
+  serialized_start=7507,
+  serialized_end=7872,
 )
 
 
@@ -1473,8 +1785,8 @@ _HTTPFAULTINJECTION_DELAY = _descriptor.Descriptor(
       create_key=_descriptor._internal_create_key,
     fields=[]),
   ],
-  serialized_start=6059,
-  serialized_end=6324,
+  serialized_start=8046,
+  serialized_end=8311,
 )
 
 _HTTPFAULTINJECTION_ABORT = _descriptor.Descriptor(
@@ -1530,8 +1842,8 @@ _HTTPFAULTINJECTION_ABORT = _descriptor.Descriptor(
       create_key=_descriptor._internal_create_key,
     fields=[]),
   ],
-  serialized_start=6327,
-  serialized_end=6541,
+  serialized_start=8314,
+  serialized_end=8528,
 )
 
 _HTTPFAULTINJECTION = _descriptor.Descriptor(
@@ -1568,8 +1880,8 @@ _HTTPFAULTINJECTION = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=5888,
-  serialized_end=6541,
+  serialized_start=7875,
+  serialized_end=8528,
 )
 
 
@@ -1600,8 +1912,8 @@ _PORTSELECTOR = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=6543,
-  serialized_end=6593,
+  serialized_start=8530,
+  serialized_end=8580,
 )
 
 
@@ -1632,17 +1944,210 @@ _PERCENT = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=6595,
-  serialized_end=6626,
+  serialized_start=8582,
+  serialized_end=8613,
+)
+
+
+_HTTPFILTER = _descriptor.Descriptor(
+  name='HTTPFilter',
+  full_name='istio.networking.v1beta1.HTTPFilter',
+  filename=None,
+  file=DESCRIPTOR,
+  containing_type=None,
+  create_key=_descriptor._internal_create_key,
+  fields=[
+    _descriptor.FieldDescriptor(
+      name='name', full_name='istio.networking.v1beta1.HTTPFilter.name', index=0,
+      number=1, type=9, cpp_type=9, label=1,
+      has_default_value=False, default_value=b"".decode('utf-8'),
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='name', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='disable', full_name='istio.networking.v1beta1.HTTPFilter.disable', index=1,
+      number=2, type=8, cpp_type=7, label=1,
+      has_default_value=False, default_value=False,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='disable', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='ip_access_control', full_name='istio.networking.v1beta1.HTTPFilter.ip_access_control', index=2,
+      number=3, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='ipAccessControl', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='local_rate_limit', full_name='istio.networking.v1beta1.HTTPFilter.local_rate_limit', index=3,
+      number=4, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='localRateLimit', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+  ],
+  extensions=[
+  ],
+  nested_types=[],
+  enum_types=[
+  ],
+  serialized_options=None,
+  is_extendable=False,
+  syntax='proto3',
+  extension_ranges=[],
+  oneofs=[
+    _descriptor.OneofDescriptor(
+      name='Filter', full_name='istio.networking.v1beta1.HTTPFilter.Filter',
+      index=0, containing_type=None,
+      create_key=_descriptor._internal_create_key,
+    fields=[]),
+  ],
+  serialized_start=8616,
+  serialized_end=8859,
+)
+
+
+_IPACCESSCONTROL = _descriptor.Descriptor(
+  name='IPAccessControl',
+  full_name='istio.networking.v1beta1.IPAccessControl',
+  filename=None,
+  file=DESCRIPTOR,
+  containing_type=None,
+  create_key=_descriptor._internal_create_key,
+  fields=[
+    _descriptor.FieldDescriptor(
+      name='remote_ip_blocks', full_name='istio.networking.v1beta1.IPAccessControl.remote_ip_blocks', index=0,
+      number=1, type=9, cpp_type=9, label=3,
+      has_default_value=False, default_value=[],
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='remoteIpBlocks', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='not_remote_ip_blocks', full_name='istio.networking.v1beta1.IPAccessControl.not_remote_ip_blocks', index=1,
+      number=2, type=9, cpp_type=9, label=3,
+      has_default_value=False, default_value=[],
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='notRemoteIpBlocks', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+  ],
+  extensions=[
+  ],
+  nested_types=[],
+  enum_types=[
+  ],
+  serialized_options=None,
+  is_extendable=False,
+  syntax='proto3',
+  extension_ranges=[],
+  oneofs=[
+  ],
+  serialized_start=8861,
+  serialized_end=8969,
+)
+
+
+_LOCALRATELIMIT = _descriptor.Descriptor(
+  name='LocalRateLimit',
+  full_name='istio.networking.v1beta1.LocalRateLimit',
+  filename=None,
+  file=DESCRIPTOR,
+  containing_type=None,
+  create_key=_descriptor._internal_create_key,
+  fields=[
+    _descriptor.FieldDescriptor(
+      name='token_bucket', full_name='istio.networking.v1beta1.LocalRateLimit.token_bucket', index=0,
+      number=1, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='tokenBucket', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='per_downstream_connection', full_name='istio.networking.v1beta1.LocalRateLimit.per_downstream_connection', index=1,
+      number=2, type=8, cpp_type=7, label=1,
+      has_default_value=False, default_value=False,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='perDownstreamConnection', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='status_code', full_name='istio.networking.v1beta1.LocalRateLimit.status_code', index=2,
+      number=3, type=13, cpp_type=3, label=1,
+      has_default_value=False, default_value=0,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='statusCode', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+  ],
+  extensions=[
+  ],
+  nested_types=[],
+  enum_types=[
+  ],
+  serialized_options=None,
+  is_extendable=False,
+  syntax='proto3',
+  extension_ranges=[],
+  oneofs=[
+  ],
+  serialized_start=8972,
+  serialized_end=9155,
+)
+
+
+_TOKENBUCKET = _descriptor.Descriptor(
+  name='TokenBucket',
+  full_name='istio.networking.v1beta1.TokenBucket',
+  filename=None,
+  file=DESCRIPTOR,
+  containing_type=None,
+  create_key=_descriptor._internal_create_key,
+  fields=[
+    _descriptor.FieldDescriptor(
+      name='max_tokens', full_name='istio.networking.v1beta1.TokenBucket.max_tokens', index=0,
+      number=1, type=13, cpp_type=3, label=1,
+      has_default_value=False, default_value=0,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='maxTokens', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='tokens_pef_fill', full_name='istio.networking.v1beta1.TokenBucket.tokens_pef_fill', index=1,
+      number=2, type=13, cpp_type=3, label=1,
+      has_default_value=False, default_value=0,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='tokensPefFill', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='fill_interval', full_name='istio.networking.v1beta1.TokenBucket.fill_interval', index=2,
+      number=3, type=11, cpp_type=10, label=1,
+      has_default_value=False, default_value=None,
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='fillInterval', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+  ],
+  extensions=[
+  ],
+  nested_types=[],
+  enum_types=[
+  ],
+  serialized_options=None,
+  is_extendable=False,
+  syntax='proto3',
+  extension_ranges=[],
+  oneofs=[
+  ],
+  serialized_start=9158,
+  serialized_end=9306,
 )
 
+_VIRTUALSERVICE.fields_by_name['hostHTTPFilters'].message_type = _HTTPFILTER
 _VIRTUALSERVICE.fields_by_name['http'].message_type = _HTTPROUTE
 _VIRTUALSERVICE.fields_by_name['tls'].message_type = _TLSROUTE
 _VIRTUALSERVICE.fields_by_name['tcp'].message_type = _TCPROUTE
 _DESTINATION.fields_by_name['port'].message_type = _PORTSELECTOR
 _HTTPROUTE.fields_by_name['match'].message_type = _HTTPMATCHREQUEST
 _HTTPROUTE.fields_by_name['route'].message_type = _HTTPROUTEDESTINATION
+_HTTPROUTE.fields_by_name['routeHTTPFilters'].message_type = _HTTPFILTER
 _HTTPROUTE.fields_by_name['redirect'].message_type = _HTTPREDIRECT
+_HTTPROUTE.fields_by_name['internal_active_redirect'].message_type = _HTTPINTERNALACTIVEREDIRECT
+_HTTPROUTE.fields_by_name['direct_response'].message_type = _HTTPDIRECTRESPONSE
 _HTTPROUTE.fields_by_name['delegate'].message_type = _DELEGATE
 _HTTPROUTE.fields_by_name['rewrite'].message_type = _HTTPREWRITE
 _HTTPROUTE.fields_by_name['timeout'].message_type = google_dot_protobuf_dot_duration__pb2._DURATION
@@ -1681,6 +2186,7 @@ _HTTPMATCHREQUEST.fields_by_name['query_params'].message_type = _HTTPMATCHREQUES
 _HTTPMATCHREQUEST.fields_by_name['without_headers'].message_type = _HTTPMATCHREQUEST_WITHOUTHEADERSENTRY
 _HTTPROUTEDESTINATION.fields_by_name['destination'].message_type = _DESTINATION
 _HTTPROUTEDESTINATION.fields_by_name['headers'].message_type = _HEADERS
+_HTTPROUTEDESTINATION.fields_by_name['fallback_clusters'].message_type = _DESTINATION
 _ROUTEDESTINATION.fields_by_name['destination'].message_type = _DESTINATION
 _L4MATCHATTRIBUTES_SOURCELABELSENTRY.containing_type = _L4MATCHATTRIBUTES
 _L4MATCHATTRIBUTES.fields_by_name['source_labels'].message_type = _L4MATCHATTRIBUTES_SOURCELABELSENTRY
@@ -1694,6 +2200,25 @@ _HTTPREDIRECT.fields_by_name['port'].containing_oneof = _HTTPREDIRECT.oneofs_by_
 _HTTPREDIRECT.oneofs_by_name['redirect_port'].fields.append(
   _HTTPREDIRECT.fields_by_name['derive_port'])
 _HTTPREDIRECT.fields_by_name['derive_port'].containing_oneof = _HTTPREDIRECT.oneofs_by_name['redirect_port']
+_HTTPINTERNALACTIVEREDIRECT_REDIRECTPOLICY.fields_by_name['redirect_url_rewrite_regex'].message_type = _REGEXMATCHANDSUBSTITUTE
+_HTTPINTERNALACTIVEREDIRECT_REDIRECTPOLICY.fields_by_name['headers'].message_type = _HEADERS
+_HTTPINTERNALACTIVEREDIRECT_REDIRECTPOLICY.containing_type = _HTTPINTERNALACTIVEREDIRECT
+_HTTPINTERNALACTIVEREDIRECT_REDIRECTPOLICY.oneofs_by_name['redirect_url_rewrite_specifier'].fields.append(
+  _HTTPINTERNALACTIVEREDIRECT_REDIRECTPOLICY.fields_by_name['redirect_url'])
+_HTTPINTERNALACTIVEREDIRECT_REDIRECTPOLICY.fields_by_name['redirect_url'].containing_oneof = _HTTPINTERNALACTIVEREDIRECT_REDIRECTPOLICY.oneofs_by_name['redirect_url_rewrite_specifier']
+_HTTPINTERNALACTIVEREDIRECT_REDIRECTPOLICY.oneofs_by_name['redirect_url_rewrite_specifier'].fields.append(
+  _HTTPINTERNALACTIVEREDIRECT_REDIRECTPOLICY.fields_by_name['redirect_url_rewrite_regex'])
+_HTTPINTERNALACTIVEREDIRECT_REDIRECTPOLICY.fields_by_name['redirect_url_rewrite_regex'].containing_oneof = _HTTPINTERNALACTIVEREDIRECT_REDIRECTPOLICY.oneofs_by_name['redirect_url_rewrite_specifier']
+_HTTPINTERNALACTIVEREDIRECT.fields_by_name['redirect_url_rewrite_regex'].message_type = _REGEXMATCHANDSUBSTITUTE
+_HTTPINTERNALACTIVEREDIRECT.fields_by_name['headers'].message_type = _HEADERS
+_HTTPINTERNALACTIVEREDIRECT.fields_by_name['policies'].message_type = _HTTPINTERNALACTIVEREDIRECT_REDIRECTPOLICY
+_HTTPINTERNALACTIVEREDIRECT.oneofs_by_name['redirect_url_rewrite_specifier'].fields.append(
+  _HTTPINTERNALACTIVEREDIRECT.fields_by_name['redirect_url'])
+_HTTPINTERNALACTIVEREDIRECT.fields_by_name['redirect_url'].containing_oneof = _HTTPINTERNALACTIVEREDIRECT.oneofs_by_name['redirect_url_rewrite_specifier']
+_HTTPINTERNALACTIVEREDIRECT.oneofs_by_name['redirect_url_rewrite_specifier'].fields.append(
+  _HTTPINTERNALACTIVEREDIRECT.fields_by_name['redirect_url_rewrite_regex'])
+_HTTPINTERNALACTIVEREDIRECT.fields_by_name['redirect_url_rewrite_regex'].containing_oneof = _HTTPINTERNALACTIVEREDIRECT.oneofs_by_name['redirect_url_rewrite_specifier']
+_HTTPREWRITE.fields_by_name['uri_regex'].message_type = _REGEXMATCHANDSUBSTITUTE
 _STRINGMATCH.oneofs_by_name['match_type'].fields.append(
   _STRINGMATCH.fields_by_name['exact'])
 _STRINGMATCH.fields_by_name['exact'].containing_oneof = _STRINGMATCH.oneofs_by_name['match_type']
@@ -1731,6 +2256,16 @@ _HTTPFAULTINJECTION_ABORT.oneofs_by_name['error_type'].fields.append(
 _HTTPFAULTINJECTION_ABORT.fields_by_name['http2_error'].containing_oneof = _HTTPFAULTINJECTION_ABORT.oneofs_by_name['error_type']
 _HTTPFAULTINJECTION.fields_by_name['delay'].message_type = _HTTPFAULTINJECTION_DELAY
 _HTTPFAULTINJECTION.fields_by_name['abort'].message_type = _HTTPFAULTINJECTION_ABORT
+_HTTPFILTER.fields_by_name['ip_access_control'].message_type = _IPACCESSCONTROL
+_HTTPFILTER.fields_by_name['local_rate_limit'].message_type = _LOCALRATELIMIT
+_HTTPFILTER.oneofs_by_name['Filter'].fields.append(
+  _HTTPFILTER.fields_by_name['ip_access_control'])
+_HTTPFILTER.fields_by_name['ip_access_control'].containing_oneof = _HTTPFILTER.oneofs_by_name['Filter']
+_HTTPFILTER.oneofs_by_name['Filter'].fields.append(
+  _HTTPFILTER.fields_by_name['local_rate_limit'])
+_HTTPFILTER.fields_by_name['local_rate_limit'].containing_oneof = _HTTPFILTER.oneofs_by_name['Filter']
+_LOCALRATELIMIT.fields_by_name['token_bucket'].message_type = _TOKENBUCKET
+_TOKENBUCKET.fields_by_name['fill_interval'].message_type = google_dot_protobuf_dot_duration__pb2._DURATION
 DESCRIPTOR.message_types_by_name['VirtualService'] = _VIRTUALSERVICE
 DESCRIPTOR.message_types_by_name['Destination'] = _DESTINATION
 DESCRIPTOR.message_types_by_name['HTTPRoute'] = _HTTPROUTE
@@ -1744,13 +2279,20 @@ DESCRIPTOR.message_types_by_name['RouteDestination'] = _ROUTEDESTINATION
 DESCRIPTOR.message_types_by_name['L4MatchAttributes'] = _L4MATCHATTRIBUTES
 DESCRIPTOR.message_types_by_name['TLSMatchAttributes'] = _TLSMATCHATTRIBUTES
 DESCRIPTOR.message_types_by_name['HTTPRedirect'] = _HTTPREDIRECT
+DESCRIPTOR.message_types_by_name['HTTPInternalActiveRedirect'] = _HTTPINTERNALACTIVEREDIRECT
+DESCRIPTOR.message_types_by_name['HTTPDirectResponse'] = _HTTPDIRECTRESPONSE
 DESCRIPTOR.message_types_by_name['HTTPRewrite'] = _HTTPREWRITE
+DESCRIPTOR.message_types_by_name['RegexMatchAndSubstitute'] = _REGEXMATCHANDSUBSTITUTE
 DESCRIPTOR.message_types_by_name['StringMatch'] = _STRINGMATCH
 DESCRIPTOR.message_types_by_name['HTTPRetry'] = _HTTPRETRY
 DESCRIPTOR.message_types_by_name['CorsPolicy'] = _CORSPOLICY
 DESCRIPTOR.message_types_by_name['HTTPFaultInjection'] = _HTTPFAULTINJECTION
 DESCRIPTOR.message_types_by_name['PortSelector'] = _PORTSELECTOR
 DESCRIPTOR.message_types_by_name['Percent'] = _PERCENT
+DESCRIPTOR.message_types_by_name['HTTPFilter'] = _HTTPFILTER
+DESCRIPTOR.message_types_by_name['IPAccessControl'] = _IPACCESSCONTROL
+DESCRIPTOR.message_types_by_name['LocalRateLimit'] = _LOCALRATELIMIT
+DESCRIPTOR.message_types_by_name['TokenBucket'] = _TOKENBUCKET
 _sym_db.RegisterFileDescriptor(DESCRIPTOR)
 
 VirtualService = _reflection.GeneratedProtocolMessageType('VirtualService', (_message.Message,), {
@@ -1916,6 +2458,28 @@ HTTPRedirect = _reflection.GeneratedProtocolMessageType('HTTPRedirect', (_messag
   })
 _sym_db.RegisterMessage(HTTPRedirect)
 
+HTTPInternalActiveRedirect = _reflection.GeneratedProtocolMessageType('HTTPInternalActiveRedirect', (_message.Message,), {
+
+  'RedirectPolicy' : _reflection.GeneratedProtocolMessageType('RedirectPolicy', (_message.Message,), {
+    'DESCRIPTOR' : _HTTPINTERNALACTIVEREDIRECT_REDIRECTPOLICY,
+    '__module__' : 'networking.v1beta1.virtual_service_pb2'
+    # @@protoc_insertion_point(class_scope:istio.networking.v1beta1.HTTPInternalActiveRedirect.RedirectPolicy)
+    })
+  ,
+  'DESCRIPTOR' : _HTTPINTERNALACTIVEREDIRECT,
+  '__module__' : 'networking.v1beta1.virtual_service_pb2'
+  # @@protoc_insertion_point(class_scope:istio.networking.v1beta1.HTTPInternalActiveRedirect)
+  })
+_sym_db.RegisterMessage(HTTPInternalActiveRedirect)
+_sym_db.RegisterMessage(HTTPInternalActiveRedirect.RedirectPolicy)
+
+HTTPDirectResponse = _reflection.GeneratedProtocolMessageType('HTTPDirectResponse', (_message.Message,), {
+  'DESCRIPTOR' : _HTTPDIRECTRESPONSE,
+  '__module__' : 'networking.v1beta1.virtual_service_pb2'
+  # @@protoc_insertion_point(class_scope:istio.networking.v1beta1.HTTPDirectResponse)
+  })
+_sym_db.RegisterMessage(HTTPDirectResponse)
+
 HTTPRewrite = _reflection.GeneratedProtocolMessageType('HTTPRewrite', (_message.Message,), {
   'DESCRIPTOR' : _HTTPREWRITE,
   '__module__' : 'networking.v1beta1.virtual_service_pb2'
@@ -1923,6 +2487,13 @@ HTTPRewrite = _reflection.GeneratedProtocolMessageType('HTTPRewrite', (_message.
   })
 _sym_db.RegisterMessage(HTTPRewrite)
 
+RegexMatchAndSubstitute = _reflection.GeneratedProtocolMessageType('RegexMatchAndSubstitute', (_message.Message,), {
+  'DESCRIPTOR' : _REGEXMATCHANDSUBSTITUTE,
+  '__module__' : 'networking.v1beta1.virtual_service_pb2'
+  # @@protoc_insertion_point(class_scope:istio.networking.v1beta1.RegexMatchAndSubstitute)
+  })
+_sym_db.RegisterMessage(RegexMatchAndSubstitute)
+
 StringMatch = _reflection.GeneratedProtocolMessageType('StringMatch', (_message.Message,), {
   'DESCRIPTOR' : _STRINGMATCH,
   '__module__' : 'networking.v1beta1.virtual_service_pb2'
@@ -1981,6 +2552,34 @@ Percent = _reflection.GeneratedProtocolMessageType('Percent', (_message.Message,
   })
 _sym_db.RegisterMessage(Percent)
 
+HTTPFilter = _reflection.GeneratedProtocolMessageType('HTTPFilter', (_message.Message,), {
+  'DESCRIPTOR' : _HTTPFILTER,
+  '__module__' : 'networking.v1beta1.virtual_service_pb2'
+  # @@protoc_insertion_point(class_scope:istio.networking.v1beta1.HTTPFilter)
+  })
+_sym_db.RegisterMessage(HTTPFilter)
+
+IPAccessControl = _reflection.GeneratedProtocolMessageType('IPAccessControl', (_message.Message,), {
+  'DESCRIPTOR' : _IPACCESSCONTROL,
+  '__module__' : 'networking.v1beta1.virtual_service_pb2'
+  # @@protoc_insertion_point(class_scope:istio.networking.v1beta1.IPAccessControl)
+  })
+_sym_db.RegisterMessage(IPAccessControl)
+
+LocalRateLimit = _reflection.GeneratedProtocolMessageType('LocalRateLimit', (_message.Message,), {
+  'DESCRIPTOR' : _LOCALRATELIMIT,
+  '__module__' : 'networking.v1beta1.virtual_service_pb2'
+  # @@protoc_insertion_point(class_scope:istio.networking.v1beta1.LocalRateLimit)
+  })
+_sym_db.RegisterMessage(LocalRateLimit)
+
+TokenBucket = _reflection.GeneratedProtocolMessageType('TokenBucket', (_message.Message,), {
+  'DESCRIPTOR' : _TOKENBUCKET,
+  '__module__' : 'networking.v1beta1.virtual_service_pb2'
+  # @@protoc_insertion_point(class_scope:istio.networking.v1beta1.TokenBucket)
+  })
+_sym_db.RegisterMessage(TokenBucket)
+
 
 DESCRIPTOR._options = None
 _DESTINATION.fields_by_name['host']._options = None
diff --git a/python/istio_api/security/v1beta1/authorization_policy_pb2.py b/python/istio_api/security/v1beta1/authorization_policy_pb2.py
index c560c978..659096bc 100644
--- a/python/istio_api/security/v1beta1/authorization_policy_pb2.py
+++ b/python/istio_api/security/v1beta1/authorization_policy_pb2.py
@@ -21,7 +21,7 @@ DESCRIPTOR = _descriptor.FileDescriptor(
   syntax='proto3',
   serialized_options=b'Z\035istio.io/api/security/v1beta1',
   create_key=_descriptor._internal_create_key,
-  serialized_pb=b'\n+security/v1beta1/authorization_policy.proto\x12\x16istio.security.v1beta1\x1a\x1fgoogle/api/field_behavior.proto\x1a\x1btype/v1beta1/selector.proto\"\xa4\x03\n\x13\x41uthorizationPolicy\x12@\n\x08selector\x18\x01 \x01(\x0b\x32$.istio.type.v1beta1.WorkloadSelectorR\x08selector\x12\x32\n\x05rules\x18\x02 \x03(\x0b\x32\x1c.istio.security.v1beta1.RuleR\x05rules\x12J\n\x06\x61\x63tion\x18\x03 \x01(\x0e\x32\x32.istio.security.v1beta1.AuthorizationPolicy.ActionR\x06\x61\x63tion\x12[\n\x08provider\x18\x04 \x01(\x0b\x32=.istio.security.v1beta1.AuthorizationPolicy.ExtensionProviderH\x00R\x08provider\x1a\'\n\x11\x45xtensionProvider\x12\x12\n\x04name\x18\x01 \x01(\tR\x04name\"4\n\x06\x41\x63tion\x12\t\n\x05\x41LLOW\x10\x00\x12\x08\n\x04\x44\x45NY\x10\x01\x12\t\n\x05\x41UDIT\x10\x02\x12\n\n\x06\x43USTOM\x10\x03\x42\x0f\n\raction_detail\"\xac\x02\n\x04Rule\x12\x35\n\x04\x66rom\x18\x01 \x03(\x0b\x32!.istio.security.v1beta1.Rule.FromR\x04\x66rom\x12/\n\x02to\x18\x02 \x03(\x0b\x32\x1f.istio.security.v1beta1.Rule.ToR\x02to\x12\x35\n\x04when\x18\x03 \x03(\x0b\x32!.istio.security.v1beta1.ConditionR\x04when\x1a>\n\x04\x46rom\x12\x36\n\x06source\x18\x01 \x01(\x0b\x32\x1e.istio.security.v1beta1.SourceR\x06source\x1a\x45\n\x02To\x12?\n\toperation\x18\x01 \x01(\x0b\x32!.istio.security.v1beta1.OperationR\toperation\"\x97\x03\n\x06Source\x12\x1e\n\nprincipals\x18\x01 \x03(\tR\nprincipals\x12%\n\x0enot_principals\x18\x05 \x03(\tR\rnotPrincipals\x12-\n\x12request_principals\x18\x02 \x03(\tR\x11requestPrincipals\x12\x34\n\x16not_request_principals\x18\x06 \x03(\tR\x14notRequestPrincipals\x12\x1e\n\nnamespaces\x18\x03 \x03(\tR\nnamespaces\x12%\n\x0enot_namespaces\x18\x07 \x03(\tR\rnotNamespaces\x12\x1b\n\tip_blocks\x18\x04 \x03(\tR\x08ipBlocks\x12\"\n\rnot_ip_blocks\x18\x08 \x03(\tR\x0bnotIpBlocks\x12(\n\x10remote_ip_blocks\x18\t \x03(\tR\x0eremoteIpBlocks\x12/\n\x14not_remote_ip_blocks\x18\n \x03(\tR\x11notRemoteIpBlocks\"\xdf\x01\n\tOperation\x12\x14\n\x05hosts\x18\x01 \x03(\tR\x05hosts\x12\x1b\n\tnot_hosts\x18\x05 \x03(\tR\x08notHosts\x12\x14\n\x05ports\x18\x02 \x03(\tR\x05ports\x12\x1b\n\tnot_ports\x18\x06 \x03(\tR\x08notPorts\x12\x18\n\x07methods\x18\x03 \x03(\tR\x07methods\x12\x1f\n\x0bnot_methods\x18\x07 \x03(\tR\nnotMethods\x12\x14\n\x05paths\x18\x04 \x03(\tR\x05paths\x12\x1b\n\tnot_paths\x18\x08 \x03(\tR\x08notPaths\"Z\n\tCondition\x12\x16\n\x03key\x18\x01 \x01(\tB\x04\xe2\x41\x01\x02R\x03key\x12\x16\n\x06values\x18\x02 \x03(\tR\x06values\x12\x1d\n\nnot_values\x18\x03 \x03(\tR\tnotValuesB\x1fZ\x1distio.io/api/security/v1beta1b\x06proto3'
+  serialized_pb=b'\n+security/v1beta1/authorization_policy.proto\x12\x16istio.security.v1beta1\x1a\x1fgoogle/api/field_behavior.proto\x1a\x1btype/v1beta1/selector.proto\"\xa4\x03\n\x13\x41uthorizationPolicy\x12@\n\x08selector\x18\x01 \x01(\x0b\x32$.istio.type.v1beta1.WorkloadSelectorR\x08selector\x12\x32\n\x05rules\x18\x02 \x03(\x0b\x32\x1c.istio.security.v1beta1.RuleR\x05rules\x12J\n\x06\x61\x63tion\x18\x03 \x01(\x0e\x32\x32.istio.security.v1beta1.AuthorizationPolicy.ActionR\x06\x61\x63tion\x12[\n\x08provider\x18\x04 \x01(\x0b\x32=.istio.security.v1beta1.AuthorizationPolicy.ExtensionProviderH\x00R\x08provider\x1a\'\n\x11\x45xtensionProvider\x12\x12\n\x04name\x18\x01 \x01(\tR\x04name\"4\n\x06\x41\x63tion\x12\t\n\x05\x41LLOW\x10\x00\x12\x08\n\x04\x44\x45NY\x10\x01\x12\t\n\x05\x41UDIT\x10\x02\x12\n\n\x06\x43USTOM\x10\x03\x42\x0f\n\raction_detail\"\xac\x02\n\x04Rule\x12\x35\n\x04\x66rom\x18\x01 \x03(\x0b\x32!.istio.security.v1beta1.Rule.FromR\x04\x66rom\x12/\n\x02to\x18\x02 \x03(\x0b\x32\x1f.istio.security.v1beta1.Rule.ToR\x02to\x12\x35\n\x04when\x18\x03 \x03(\x0b\x32!.istio.security.v1beta1.ConditionR\x04when\x1a>\n\x04\x46rom\x12\x36\n\x06source\x18\x01 \x01(\x0b\x32\x1e.istio.security.v1beta1.SourceR\x06source\x1a\x45\n\x02To\x12?\n\toperation\x18\x01 \x01(\x0b\x32!.istio.security.v1beta1.OperationR\toperation\"\x97\x03\n\x06Source\x12\x1e\n\nprincipals\x18\x01 \x03(\tR\nprincipals\x12%\n\x0enot_principals\x18\x05 \x03(\tR\rnotPrincipals\x12-\n\x12request_principals\x18\x02 \x03(\tR\x11requestPrincipals\x12\x34\n\x16not_request_principals\x18\x06 \x03(\tR\x14notRequestPrincipals\x12\x1e\n\nnamespaces\x18\x03 \x03(\tR\nnamespaces\x12%\n\x0enot_namespaces\x18\x07 \x03(\tR\rnotNamespaces\x12\x1b\n\tip_blocks\x18\x04 \x03(\tR\x08ipBlocks\x12\"\n\rnot_ip_blocks\x18\x08 \x03(\tR\x0bnotIpBlocks\x12(\n\x10remote_ip_blocks\x18\t \x03(\tR\x0eremoteIpBlocks\x12/\n\x14not_remote_ip_blocks\x18\n \x03(\tR\x11notRemoteIpBlocks\"\x84\x03\n\tOperation\x12\x14\n\x05hosts\x18\x01 \x03(\tR\x05hosts\x12\x1b\n\tnot_hosts\x18\x05 \x03(\tR\x08notHosts\x12\x14\n\x05ports\x18\x02 \x03(\tR\x05ports\x12\x1b\n\tnot_ports\x18\x06 \x03(\tR\x08notPorts\x12\x18\n\x07methods\x18\x03 \x03(\tR\x07methods\x12\x1f\n\x0bnot_methods\x18\x07 \x03(\tR\nnotMethods\x12\x14\n\x05paths\x18\x04 \x03(\tR\x05paths\x12\x1b\n\tnot_paths\x18\x08 \x03(\tR\x08notPaths\x12M\n\x0f\x65xtension_paths\x18\xe8\x07 \x03(\x0b\x32#.istio.security.v1beta1.StringMatchR\x0e\x65xtensionPaths\x12T\n\x13\x65xtension_not_paths\x18\xe9\x07 \x03(\x0b\x32#.istio.security.v1beta1.StringMatchR\x11\x65xtensionNotPaths\"Z\n\tCondition\x12\x16\n\x03key\x18\x01 \x01(\tB\x04\xe2\x41\x01\x02R\x03key\x12\x16\n\x06values\x18\x02 \x03(\tR\x06values\x12\x1d\n\nnot_values\x18\x03 \x03(\tR\tnotValues\"e\n\x0bStringMatch\x12\x16\n\x05\x65xact\x18\x01 \x01(\tH\x00R\x05\x65xact\x12\x18\n\x06prefix\x18\x02 \x01(\tH\x00R\x06prefix\x12\x16\n\x05regex\x18\x03 \x01(\tH\x00R\x05regexB\x0c\n\nmatch_typeB\x1fZ\x1distio.io/api/security/v1beta1b\x06proto3'
   ,
   dependencies=[google_dot_api_dot_field__behavior__pb2.DESCRIPTOR,type_dot_v1beta1_dot_selector__pb2.DESCRIPTOR,])
 
@@ -420,6 +420,20 @@ _OPERATION = _descriptor.Descriptor(
       message_type=None, enum_type=None, containing_type=None,
       is_extension=False, extension_scope=None,
       serialized_options=None, json_name='notPaths', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='extension_paths', full_name='istio.security.v1beta1.Operation.extension_paths', index=8,
+      number=1000, type=11, cpp_type=10, label=3,
+      has_default_value=False, default_value=[],
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='extensionPaths', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='extension_not_paths', full_name='istio.security.v1beta1.Operation.extension_not_paths', index=9,
+      number=1001, type=11, cpp_type=10, label=3,
+      has_default_value=False, default_value=[],
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='extensionNotPaths', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
   ],
   extensions=[
   ],
@@ -433,7 +447,7 @@ _OPERATION = _descriptor.Descriptor(
   oneofs=[
   ],
   serialized_start=1270,
-  serialized_end=1493,
+  serialized_end=1658,
 )
 
 
@@ -478,8 +492,59 @@ _CONDITION = _descriptor.Descriptor(
   extension_ranges=[],
   oneofs=[
   ],
-  serialized_start=1495,
-  serialized_end=1585,
+  serialized_start=1660,
+  serialized_end=1750,
+)
+
+
+_STRINGMATCH = _descriptor.Descriptor(
+  name='StringMatch',
+  full_name='istio.security.v1beta1.StringMatch',
+  filename=None,
+  file=DESCRIPTOR,
+  containing_type=None,
+  create_key=_descriptor._internal_create_key,
+  fields=[
+    _descriptor.FieldDescriptor(
+      name='exact', full_name='istio.security.v1beta1.StringMatch.exact', index=0,
+      number=1, type=9, cpp_type=9, label=1,
+      has_default_value=False, default_value=b"".decode('utf-8'),
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='exact', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='prefix', full_name='istio.security.v1beta1.StringMatch.prefix', index=1,
+      number=2, type=9, cpp_type=9, label=1,
+      has_default_value=False, default_value=b"".decode('utf-8'),
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='prefix', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+    _descriptor.FieldDescriptor(
+      name='regex', full_name='istio.security.v1beta1.StringMatch.regex', index=2,
+      number=3, type=9, cpp_type=9, label=1,
+      has_default_value=False, default_value=b"".decode('utf-8'),
+      message_type=None, enum_type=None, containing_type=None,
+      is_extension=False, extension_scope=None,
+      serialized_options=None, json_name='regex', file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),
+  ],
+  extensions=[
+  ],
+  nested_types=[],
+  enum_types=[
+  ],
+  serialized_options=None,
+  is_extendable=False,
+  syntax='proto3',
+  extension_ranges=[],
+  oneofs=[
+    _descriptor.OneofDescriptor(
+      name='match_type', full_name='istio.security.v1beta1.StringMatch.match_type',
+      index=0, containing_type=None,
+      create_key=_descriptor._internal_create_key,
+    fields=[]),
+  ],
+  serialized_start=1752,
+  serialized_end=1853,
 )
 
 _AUTHORIZATIONPOLICY_EXTENSIONPROVIDER.containing_type = _AUTHORIZATIONPOLICY
@@ -498,11 +563,23 @@ _RULE_TO.containing_type = _RULE
 _RULE.fields_by_name['from'].message_type = _RULE_FROM
 _RULE.fields_by_name['to'].message_type = _RULE_TO
 _RULE.fields_by_name['when'].message_type = _CONDITION
+_OPERATION.fields_by_name['extension_paths'].message_type = _STRINGMATCH
+_OPERATION.fields_by_name['extension_not_paths'].message_type = _STRINGMATCH
+_STRINGMATCH.oneofs_by_name['match_type'].fields.append(
+  _STRINGMATCH.fields_by_name['exact'])
+_STRINGMATCH.fields_by_name['exact'].containing_oneof = _STRINGMATCH.oneofs_by_name['match_type']
+_STRINGMATCH.oneofs_by_name['match_type'].fields.append(
+  _STRINGMATCH.fields_by_name['prefix'])
+_STRINGMATCH.fields_by_name['prefix'].containing_oneof = _STRINGMATCH.oneofs_by_name['match_type']
+_STRINGMATCH.oneofs_by_name['match_type'].fields.append(
+  _STRINGMATCH.fields_by_name['regex'])
+_STRINGMATCH.fields_by_name['regex'].containing_oneof = _STRINGMATCH.oneofs_by_name['match_type']
 DESCRIPTOR.message_types_by_name['AuthorizationPolicy'] = _AUTHORIZATIONPOLICY
 DESCRIPTOR.message_types_by_name['Rule'] = _RULE
 DESCRIPTOR.message_types_by_name['Source'] = _SOURCE
 DESCRIPTOR.message_types_by_name['Operation'] = _OPERATION
 DESCRIPTOR.message_types_by_name['Condition'] = _CONDITION
+DESCRIPTOR.message_types_by_name['StringMatch'] = _STRINGMATCH
 _sym_db.RegisterFileDescriptor(DESCRIPTOR)
 
 AuthorizationPolicy = _reflection.GeneratedProtocolMessageType('AuthorizationPolicy', (_message.Message,), {
@@ -564,6 +641,13 @@ Condition = _reflection.GeneratedProtocolMessageType('Condition', (_message.Mess
   })
 _sym_db.RegisterMessage(Condition)
 
+StringMatch = _reflection.GeneratedProtocolMessageType('StringMatch', (_message.Message,), {
+  'DESCRIPTOR' : _STRINGMATCH,
+  '__module__' : 'security.v1beta1.authorization_policy_pb2'
+  # @@protoc_insertion_point(class_scope:istio.security.v1beta1.StringMatch)
+  })
+_sym_db.RegisterMessage(StringMatch)
+
 
 DESCRIPTOR._options = None
 _CONDITION.fields_by_name['key']._options = None
diff --git a/releasenotes/notes/slow-start.yaml b/releasenotes/notes/slow-start.yaml
new file mode 100644
index 00000000..fabf1217
--- /dev/null
+++ b/releasenotes/notes/slow-start.yaml
@@ -0,0 +1,10 @@
+apiVersion: release-notes/v2
+
+kind: feature
+area: traffic-management
+issue:
+- 21228
+
+releaseNotes:
+- |
+    **Added** the ability for users to configure a service to specify warm duration.
diff --git a/security/v1beta1/authorization_policy.gen.json b/security/v1beta1/authorization_policy.gen.json
index 75221e42..707e7649 100644
--- a/security/v1beta1/authorization_policy.gen.json
+++ b/security/v1beta1/authorization_policy.gen.json
@@ -155,6 +155,18 @@
             "items": {
               "type": "string"
             }
+          },
+          "extensionPaths": {
+            "type": "array",
+            "items": {
+              "$ref": "#/components/schemas/istio.security.v1beta1.StringMatch"
+            }
+          },
+          "extensionNotPaths": {
+            "type": "array",
+            "items": {
+              "$ref": "#/components/schemas/istio.security.v1beta1.StringMatch"
+            }
           }
         }
       },
@@ -279,6 +291,84 @@
           }
         }
       },
+      "istio.security.v1beta1.StringMatch": {
+        "description": "Describes how to match a given string in HTTP headers. Match is case-sensitive.",
+        "type": "object",
+        "oneOf": [
+          {
+            "not": {
+              "anyOf": [
+                {
+                  "required": [
+                    "exact"
+                  ],
+                  "properties": {
+                    "exact": {
+                      "description": "exact string match",
+                      "type": "string"
+                    }
+                  }
+                },
+                {
+                  "required": [
+                    "prefix"
+                  ],
+                  "properties": {
+                    "prefix": {
+                      "description": "prefix-based match",
+                      "type": "string"
+                    }
+                  }
+                },
+                {
+                  "required": [
+                    "regex"
+                  ],
+                  "properties": {
+                    "regex": {
+                      "description": "RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).",
+                      "type": "string"
+                    }
+                  }
+                }
+              ]
+            }
+          },
+          {
+            "required": [
+              "exact"
+            ],
+            "properties": {
+              "exact": {
+                "description": "exact string match",
+                "type": "string"
+              }
+            }
+          },
+          {
+            "required": [
+              "prefix"
+            ],
+            "properties": {
+              "prefix": {
+                "description": "prefix-based match",
+                "type": "string"
+              }
+            }
+          },
+          {
+            "required": [
+              "regex"
+            ],
+            "properties": {
+              "regex": {
+                "description": "RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).",
+                "type": "string"
+              }
+            }
+          }
+        ]
+      },
       "istio.type.v1beta1.WorkloadSelector": {
         "description": "WorkloadSelector specifies the criteria used to determine if a policy can be applied to a proxy. The matching criteria includes the metadata associated with a proxy, workload instance info such as labels attached to the pod/VM, or any other info that the proxy provides to Istio during the initial handshake. If multiple conditions are specified, all conditions need to match in order for the workload instance to be selected. Currently, only label based selection mechanism is supported.",
         "type": "object",
diff --git a/security/v1beta1/authorization_policy.pb.go b/security/v1beta1/authorization_policy.pb.go
index b5016092..13c6ccb5 100644
--- a/security/v1beta1/authorization_policy.pb.go
+++ b/security/v1beta1/authorization_policy.pb.go
@@ -832,10 +832,12 @@ type Operation struct {
 	// If not set, any path is allowed. Must be used only with HTTP.
 	Paths []string `protobuf:"bytes,4,rep,name=paths,proto3" json:"paths,omitempty"`
 	// Optional. A list of negative match of paths.
-	NotPaths             []string `protobuf:"bytes,8,rep,name=not_paths,json=notPaths,proto3" json:"not_paths,omitempty"`
-	XXX_NoUnkeyedLiteral struct{} `json:"-"`
-	XXX_unrecognized     []byte   `json:"-"`
-	XXX_sizecache        int32    `json:"-"`
+	NotPaths             []string       `protobuf:"bytes,8,rep,name=not_paths,json=notPaths,proto3" json:"not_paths,omitempty"`
+	ExtensionPaths       []*StringMatch `protobuf:"bytes,1000,rep,name=extension_paths,json=extensionPaths,proto3" json:"extension_paths,omitempty"`
+	ExtensionNotPaths    []*StringMatch `protobuf:"bytes,1001,rep,name=extension_not_paths,json=extensionNotPaths,proto3" json:"extension_not_paths,omitempty"`
+	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
+	XXX_unrecognized     []byte         `json:"-"`
+	XXX_sizecache        int32          `json:"-"`
 }
 
 func (m *Operation) Reset()         { *m = Operation{} }
@@ -927,6 +929,20 @@ func (m *Operation) GetNotPaths() []string {
 	return nil
 }
 
+func (m *Operation) GetExtensionPaths() []*StringMatch {
+	if m != nil {
+		return m.ExtensionPaths
+	}
+	return nil
+}
+
+func (m *Operation) GetExtensionNotPaths() []*StringMatch {
+	if m != nil {
+		return m.ExtensionNotPaths
+	}
+	return nil
+}
+
 // Condition specifies additional required attributes.
 type Condition struct {
 	// The name of an Istio attribute.
@@ -997,6 +1013,109 @@ func (m *Condition) GetNotValues() []string {
 	return nil
 }
 
+// Describes how to match a given string in HTTP headers. Match is
+// case-sensitive.
+type StringMatch struct {
+	// Types that are valid to be assigned to MatchType:
+	//	*StringMatch_Exact
+	//	*StringMatch_Prefix
+	//	*StringMatch_Regex
+	MatchType            isStringMatch_MatchType `protobuf_oneof:"match_type"`
+	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
+	XXX_unrecognized     []byte                  `json:"-"`
+	XXX_sizecache        int32                   `json:"-"`
+}
+
+func (m *StringMatch) Reset()         { *m = StringMatch{} }
+func (m *StringMatch) String() string { return proto.CompactTextString(m) }
+func (*StringMatch) ProtoMessage()    {}
+func (*StringMatch) Descriptor() ([]byte, []int) {
+	return fileDescriptor_438e25379256bb35, []int{5}
+}
+func (m *StringMatch) XXX_Unmarshal(b []byte) error {
+	return m.Unmarshal(b)
+}
+func (m *StringMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	if deterministic {
+		return xxx_messageInfo_StringMatch.Marshal(b, m, deterministic)
+	} else {
+		b = b[:cap(b)]
+		n, err := m.MarshalToSizedBuffer(b)
+		if err != nil {
+			return nil, err
+		}
+		return b[:n], nil
+	}
+}
+func (m *StringMatch) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_StringMatch.Merge(m, src)
+}
+func (m *StringMatch) XXX_Size() int {
+	return m.Size()
+}
+func (m *StringMatch) XXX_DiscardUnknown() {
+	xxx_messageInfo_StringMatch.DiscardUnknown(m)
+}
+
+var xxx_messageInfo_StringMatch proto.InternalMessageInfo
+
+type isStringMatch_MatchType interface {
+	isStringMatch_MatchType()
+	MarshalTo([]byte) (int, error)
+	Size() int
+}
+
+type StringMatch_Exact struct {
+	Exact string `protobuf:"bytes,1,opt,name=exact,proto3,oneof" json:"exact,omitempty"`
+}
+type StringMatch_Prefix struct {
+	Prefix string `protobuf:"bytes,2,opt,name=prefix,proto3,oneof" json:"prefix,omitempty"`
+}
+type StringMatch_Regex struct {
+	Regex string `protobuf:"bytes,3,opt,name=regex,proto3,oneof" json:"regex,omitempty"`
+}
+
+func (*StringMatch_Exact) isStringMatch_MatchType()  {}
+func (*StringMatch_Prefix) isStringMatch_MatchType() {}
+func (*StringMatch_Regex) isStringMatch_MatchType()  {}
+
+func (m *StringMatch) GetMatchType() isStringMatch_MatchType {
+	if m != nil {
+		return m.MatchType
+	}
+	return nil
+}
+
+func (m *StringMatch) GetExact() string {
+	if x, ok := m.GetMatchType().(*StringMatch_Exact); ok {
+		return x.Exact
+	}
+	return ""
+}
+
+func (m *StringMatch) GetPrefix() string {
+	if x, ok := m.GetMatchType().(*StringMatch_Prefix); ok {
+		return x.Prefix
+	}
+	return ""
+}
+
+func (m *StringMatch) GetRegex() string {
+	if x, ok := m.GetMatchType().(*StringMatch_Regex); ok {
+		return x.Regex
+	}
+	return ""
+}
+
+// XXX_OneofWrappers is for the internal use of the proto package.
+func (*StringMatch) XXX_OneofWrappers() []interface{} {
+	return []interface{}{
+		(*StringMatch_Exact)(nil),
+		(*StringMatch_Prefix)(nil),
+		(*StringMatch_Regex)(nil),
+	}
+}
+
 func init() {
 	proto.RegisterEnum("istio.security.v1beta1.AuthorizationPolicy_Action", AuthorizationPolicy_Action_name, AuthorizationPolicy_Action_value)
 	proto.RegisterType((*AuthorizationPolicy)(nil), "istio.security.v1beta1.AuthorizationPolicy")
@@ -1007,6 +1126,7 @@ func init() {
 	proto.RegisterType((*Source)(nil), "istio.security.v1beta1.Source")
 	proto.RegisterType((*Operation)(nil), "istio.security.v1beta1.Operation")
 	proto.RegisterType((*Condition)(nil), "istio.security.v1beta1.Condition")
+	proto.RegisterType((*StringMatch)(nil), "istio.security.v1beta1.StringMatch")
 }
 
 func init() {
@@ -1014,55 +1134,62 @@ func init() {
 }
 
 var fileDescriptor_438e25379256bb35 = []byte{
-	// 768 bytes of a gzipped FileDescriptorProto
+	// 867 bytes of a gzipped FileDescriptorProto
 	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x95, 0xdd, 0x6e, 0xe3, 0x44,
-	0x14, 0xc7, 0xd7, 0x8e, 0xe3, 0xc6, 0xa7, 0xda, 0x92, 0x1d, 0xa2, 0x28, 0xca, 0xb2, 0x69, 0x89,
-	0x40, 0x44, 0x5a, 0xe1, 0x68, 0xc3, 0xc2, 0x1d, 0x1f, 0xc9, 0x6e, 0xd1, 0x16, 0xf5, 0x4b, 0x6e,
-	0x4a, 0x45, 0xb9, 0xb0, 0x1c, 0x67, 0xda, 0x8c, 0xea, 0xf8, 0x98, 0xf1, 0x24, 0x10, 0x5e, 0x84,
-	0x17, 0xe0, 0x92, 0x07, 0xe1, 0x92, 0x37, 0x00, 0xe5, 0x49, 0xd0, 0xcc, 0xd8, 0x8e, 0xe9, 0x97,
-	0xc4, 0x5d, 0xce, 0x9c, 0xdf, 0xff, 0x9c, 0x33, 0xff, 0x63, 0x3b, 0xf0, 0x32, 0xa5, 0xe1, 0x82,
-	0x33, 0xb1, 0xea, 0x2f, 0x5f, 0x4d, 0xa8, 0x08, 0x5e, 0xf5, 0x83, 0x85, 0x98, 0x21, 0x67, 0xbf,
-	0x06, 0x82, 0x61, 0xec, 0x27, 0x18, 0xb1, 0x70, 0xe5, 0x26, 0x1c, 0x05, 0x92, 0x26, 0x4b, 0x05,
-	0x43, 0x37, 0x97, 0xb8, 0x99, 0xa4, 0xbd, 0x7b, 0x8d, 0x78, 0x1d, 0xd1, 0x7e, 0x90, 0xb0, 0xfe,
-	0x15, 0xa3, 0xd1, 0xd4, 0x9f, 0xd0, 0x59, 0xb0, 0x64, 0xc8, 0xb5, 0xb0, 0xfd, 0x5c, 0xac, 0x12,
-	0x5a, 0x74, 0x48, 0x69, 0x44, 0x43, 0x91, 0x27, 0xbb, 0xbf, 0x57, 0xe0, 0xfd, 0x61, 0xb9, 0xe9,
-	0xa9, 0xea, 0x49, 0xbe, 0x81, 0x5a, 0x4e, 0xb6, 0x8c, 0x3d, 0xa3, 0xb7, 0x3d, 0xf8, 0xc8, 0xd5,
-	0x03, 0xc8, 0x6a, 0x79, 0x73, 0xf7, 0x02, 0xf9, 0x4d, 0x84, 0xc1, 0xf4, 0x2c, 0x63, 0xbd, 0x42,
-	0x45, 0x06, 0x50, 0xe5, 0x8b, 0x88, 0xa6, 0x2d, 0x73, 0xaf, 0xd2, 0xdb, 0x1e, 0x7c, 0xe0, 0xde,
-	0x3f, 0xbf, 0xeb, 0x2d, 0x22, 0xea, 0x69, 0x94, 0x7c, 0x07, 0x76, 0x10, 0xca, 0x29, 0x5a, 0x95,
-	0x3d, 0xa3, 0xb7, 0x33, 0x18, 0x3c, 0x24, 0xba, 0x67, 0x64, 0x77, 0xa8, 0x94, 0x5e, 0x56, 0x81,
-	0xfc, 0x08, 0xb5, 0x84, 0xe3, 0x92, 0x4d, 0x29, 0x6f, 0x59, 0xea, 0x06, 0x5f, 0xfe, 0x9f, 0x6a,
-	0xfb, 0xbf, 0x08, 0x1a, 0xa7, 0x32, 0xce, 0x8a, 0xbc, 0x7b, 0xe2, 0x15, 0x05, 0xdb, 0x9f, 0xc0,
-	0xb3, 0x3b, 0x00, 0x21, 0x60, 0xc5, 0xc1, 0x9c, 0x2a, 0xbf, 0x1c, 0x4f, 0xfd, 0xee, 0xbe, 0x06,
-	0x5b, 0xcf, 0x45, 0x1c, 0xa8, 0x0e, 0x0f, 0x0f, 0x4f, 0x2e, 0xea, 0x4f, 0x48, 0x0d, 0xac, 0xb7,
-	0xfb, 0xc7, 0x3f, 0xd4, 0x0d, 0x75, 0x78, 0xfe, 0xf6, 0x60, 0x5c, 0x37, 0x09, 0x80, 0xfd, 0xe6,
-	0xfc, 0x6c, 0x7c, 0x72, 0x54, 0xaf, 0x8c, 0xde, 0x83, 0xa7, 0xfa, 0x16, 0xfe, 0x94, 0x8a, 0x80,
-	0x45, 0xdd, 0x3f, 0x4c, 0xb0, 0xa4, 0x51, 0xe4, 0x73, 0xb0, 0xae, 0x38, 0xce, 0x5b, 0x86, 0x32,
-	0xf5, 0xc3, 0xc7, 0x4c, 0x75, 0xbf, 0xe5, 0x38, 0xf7, 0x14, 0x4e, 0xfa, 0x60, 0x0a, 0xcc, 0x36,
-	0xb1, 0xfb, 0xa8, 0x68, 0x8c, 0x9e, 0x29, 0x50, 0xf6, 0xf9, 0x79, 0x46, 0xe5, 0x1e, 0x1e, 0xed,
-	0xf3, 0x06, 0xe3, 0x29, 0x53, 0xb6, 0x2b, 0xbc, 0xfd, 0x15, 0x58, 0xb2, 0x2b, 0xf9, 0x02, 0xec,
-	0x14, 0x17, 0x3c, 0xa4, 0xd9, 0xc3, 0xd3, 0x79, 0xa8, 0xc0, 0x99, 0xa2, 0xbc, 0x8c, 0x6e, 0xef,
-	0x83, 0x39, 0x46, 0xf2, 0x35, 0x38, 0x98, 0x50, 0xae, 0xd6, 0x91, 0x15, 0x78, 0x70, 0x82, 0x93,
-	0x1c, 0xf4, 0x36, 0x9a, 0xee, 0x6f, 0x15, 0xb0, 0x75, 0x65, 0xd2, 0x01, 0x48, 0x38, 0x8b, 0x43,
-	0x96, 0x04, 0x51, 0xaa, 0x6c, 0x73, 0xbc, 0xd2, 0x09, 0xf9, 0x18, 0x76, 0x62, 0x14, 0x7e, 0x89,
-	0xa9, 0x2a, 0xe6, 0x69, 0x8c, 0xe2, 0x74, 0x83, 0x7d, 0x0a, 0x84, 0xd3, 0x9f, 0x16, 0x34, 0xfd,
-	0x0f, 0x6a, 0x2a, 0xf4, 0x59, 0x96, 0x29, 0xe1, 0xaf, 0xa1, 0x29, 0xab, 0xde, 0x23, 0xb1, 0x95,
-	0xa4, 0x11, 0xa3, 0xf0, 0xee, 0xa8, 0x3a, 0x00, 0xf2, 0xa1, 0x49, 0x93, 0x20, 0xa4, 0xa9, 0xb2,
-	0xde, 0xf1, 0x4a, 0x27, 0xf9, 0xac, 0x25, 0x66, 0xab, 0x98, 0xf5, 0x78, 0x83, 0x3d, 0x07, 0x87,
-	0x25, 0xfe, 0x24, 0xc2, 0xf0, 0x26, 0x6d, 0x59, 0x8a, 0xa8, 0xb1, 0x64, 0xa4, 0x62, 0xd2, 0x05,
-	0x49, 0xfb, 0x1b, 0xa0, 0xa6, 0x80, 0xed, 0x18, 0xc5, 0x41, 0xce, 0xf4, 0xa0, 0xce, 0xe9, 0x1c,
-	0x05, 0x2d, 0x61, 0x8e, 0xc2, 0x76, 0xf4, 0x79, 0x41, 0xf6, 0xa1, 0xa1, 0xef, 0x79, 0x8b, 0x06,
-	0x6d, 0x8c, 0xba, 0x65, 0x59, 0xd0, 0xfd, 0xdb, 0x00, 0xa7, 0x58, 0x19, 0x69, 0x40, 0x75, 0x86,
-	0xa9, 0xc8, 0xf7, 0xa2, 0x03, 0x39, 0xbf, 0x2c, 0xaa, 0x33, 0x7a, 0x1b, 0xb5, 0x18, 0xc5, 0x3b,
-	0x95, 0x6c, 0x40, 0x35, 0x41, 0x2e, 0x72, 0xef, 0x75, 0x90, 0x4b, 0x74, 0xc6, 0x2e, 0x24, 0xa7,
-	0x2a, 0xd9, 0x82, 0xad, 0x39, 0x15, 0x33, 0x9c, 0xe6, 0x9e, 0xe6, 0x21, 0xd9, 0x05, 0x79, 0x6f,
-	0x3f, 0xcf, 0x6e, 0x65, 0x8e, 0xa3, 0x38, 0xca, 0x00, 0xd9, 0x2d, 0x10, 0xb3, 0xdc, 0x46, 0x1d,
-	0x14, 0xdd, 0x54, 0xa6, 0xb6, 0xe9, 0x26, 0xe3, 0xee, 0x25, 0x38, 0xc5, 0x5b, 0x41, 0x9a, 0x50,
-	0xb9, 0xa1, 0x2b, 0xfd, 0x45, 0x18, 0x59, 0xeb, 0xa1, 0x61, 0x7a, 0xf2, 0x80, 0x34, 0xc1, 0x5e,
-	0x06, 0xd1, 0x82, 0xe6, 0xd7, 0xc8, 0x22, 0xf2, 0x02, 0x64, 0x77, 0x3f, 0xcb, 0xe9, 0x69, 0x65,
-	0xaf, 0xef, 0xd5, 0xc1, 0xe8, 0xe5, 0x9f, 0xeb, 0x8e, 0xf1, 0xd7, 0xba, 0x63, 0xfc, 0xb3, 0xee,
-	0x18, 0x97, 0x2f, 0xf4, 0x2b, 0xc1, 0x50, 0x7d, 0xfb, 0x6f, 0xff, 0x97, 0x4c, 0x6c, 0xf5, 0x85,
-	0xff, 0xec, 0xdf, 0x00, 0x00, 0x00, 0xff, 0xff, 0xe2, 0xda, 0xc0, 0xc7, 0x66, 0x06, 0x00, 0x00,
+	0x14, 0xc7, 0x6b, 0x27, 0x71, 0xe3, 0x53, 0xb6, 0x9b, 0xce, 0x56, 0x91, 0x95, 0x65, 0xd3, 0x62,
+	0x40, 0x54, 0x5a, 0xe1, 0x68, 0xc3, 0xc2, 0x1d, 0x1f, 0xcd, 0x6e, 0x51, 0x17, 0x6d, 0x3f, 0xe4,
+	0x66, 0x59, 0xb1, 0x5c, 0x58, 0xae, 0x33, 0x6d, 0x46, 0x75, 0x3c, 0x66, 0x3c, 0x29, 0x2d, 0xd7,
+	0xbc, 0x03, 0x2f, 0xc0, 0x25, 0x0f, 0xc2, 0x25, 0x8f, 0x80, 0x7a, 0x05, 0x6f, 0x81, 0xe6, 0xcc,
+	0xd8, 0x31, 0xbb, 0x6d, 0xa5, 0xde, 0xe5, 0xcc, 0xf9, 0xfd, 0xcf, 0x39, 0xf3, 0x9f, 0x8c, 0x07,
+	0x1e, 0x17, 0x34, 0x99, 0x0b, 0x26, 0x2f, 0x07, 0xe7, 0x4f, 0x8e, 0xa9, 0x8c, 0x9f, 0x0c, 0xe2,
+	0xb9, 0x9c, 0x72, 0xc1, 0x7e, 0x89, 0x25, 0xe3, 0x59, 0x94, 0xf3, 0x94, 0x25, 0x97, 0x41, 0x2e,
+	0xb8, 0xe4, 0xa4, 0xcb, 0x0a, 0xc9, 0x78, 0x50, 0x4a, 0x02, 0x23, 0xe9, 0x6d, 0x9c, 0x72, 0x7e,
+	0x9a, 0xd2, 0x41, 0x9c, 0xb3, 0xc1, 0x09, 0xa3, 0xe9, 0x24, 0x3a, 0xa6, 0xd3, 0xf8, 0x9c, 0x71,
+	0xa1, 0x85, 0xbd, 0x87, 0xf2, 0x32, 0xa7, 0x55, 0x87, 0x82, 0xa6, 0x34, 0x91, 0x65, 0xd2, 0xff,
+	0xbd, 0x01, 0x0f, 0xb6, 0xeb, 0x4d, 0x0f, 0xb1, 0x27, 0xf9, 0x06, 0xda, 0x25, 0xe9, 0x59, 0x9b,
+	0xd6, 0xd6, 0xca, 0xf0, 0xa3, 0x40, 0x0f, 0xa0, 0xaa, 0x95, 0xcd, 0x83, 0xd7, 0x5c, 0x9c, 0xa5,
+	0x3c, 0x9e, 0x1c, 0x19, 0x36, 0xac, 0x54, 0x64, 0x08, 0x2d, 0x31, 0x4f, 0x69, 0xe1, 0xd9, 0x9b,
+	0x8d, 0xad, 0x95, 0xe1, 0xfb, 0xc1, 0xf5, 0xf3, 0x07, 0xe1, 0x3c, 0xa5, 0xa1, 0x46, 0xc9, 0x77,
+	0xe0, 0xc4, 0x89, 0x9a, 0xc2, 0x6b, 0x6c, 0x5a, 0x5b, 0xab, 0xc3, 0xe1, 0x4d, 0xa2, 0x6b, 0x46,
+	0x0e, 0xb6, 0x51, 0x19, 0x9a, 0x0a, 0xe4, 0x47, 0x68, 0xe7, 0x82, 0x9f, 0xb3, 0x09, 0x15, 0x5e,
+	0x13, 0x77, 0xf0, 0xe5, 0x5d, 0xaa, 0xed, 0x5c, 0x48, 0x9a, 0x15, 0x2a, 0x36, 0x45, 0x76, 0x97,
+	0xc2, 0xaa, 0x60, 0xef, 0x13, 0x58, 0x7b, 0x07, 0x20, 0x04, 0x9a, 0x59, 0x3c, 0xa3, 0xe8, 0x97,
+	0x1b, 0xe2, 0x6f, 0xff, 0x29, 0x38, 0x7a, 0x2e, 0xe2, 0x42, 0x6b, 0xfb, 0xe5, 0xcb, 0x83, 0xd7,
+	0x9d, 0x25, 0xd2, 0x86, 0xe6, 0xf3, 0x9d, 0xfd, 0x1f, 0x3a, 0x16, 0x2e, 0xbe, 0x7a, 0xfe, 0x62,
+	0xdc, 0xb1, 0x09, 0x80, 0xf3, 0xec, 0xd5, 0xd1, 0xf8, 0x60, 0xaf, 0xd3, 0x18, 0xdd, 0x87, 0x7b,
+	0x7a, 0x17, 0xd1, 0x84, 0xca, 0x98, 0xa5, 0xfe, 0x1f, 0x36, 0x34, 0x95, 0x51, 0xe4, 0x73, 0x68,
+	0x9e, 0x08, 0x3e, 0xf3, 0x2c, 0x34, 0xf5, 0x83, 0xdb, 0x4c, 0x0d, 0xbe, 0x15, 0x7c, 0x16, 0x22,
+	0x4e, 0x06, 0x60, 0x4b, 0x6e, 0x4e, 0x62, 0xe3, 0x56, 0xd1, 0x98, 0x87, 0xb6, 0xe4, 0xaa, 0xcf,
+	0xcf, 0x53, 0xaa, 0xce, 0xe1, 0xd6, 0x3e, 0xcf, 0x78, 0x36, 0x61, 0x68, 0x3b, 0xe2, 0xbd, 0xaf,
+	0xa0, 0xa9, 0xba, 0x92, 0x2f, 0xc0, 0x29, 0xf8, 0x5c, 0x24, 0xd4, 0xfc, 0x79, 0xfa, 0x37, 0x15,
+	0x38, 0x42, 0x2a, 0x34, 0x74, 0x6f, 0x07, 0xec, 0x31, 0x27, 0x5f, 0x83, 0xcb, 0x73, 0x2a, 0xf0,
+	0x38, 0x4c, 0x81, 0x1b, 0x27, 0x38, 0x28, 0xc1, 0x70, 0xa1, 0xf1, 0x7f, 0x6b, 0x80, 0xa3, 0x2b,
+	0x93, 0x3e, 0x40, 0x2e, 0x58, 0x96, 0xb0, 0x3c, 0x4e, 0x0b, 0xb4, 0xcd, 0x0d, 0x6b, 0x2b, 0xe4,
+	0x63, 0x58, 0xcd, 0xb8, 0x8c, 0x6a, 0x4c, 0x0b, 0x99, 0x7b, 0x19, 0x97, 0x87, 0x0b, 0xec, 0x53,
+	0x20, 0x82, 0xfe, 0x34, 0xa7, 0xc5, 0xff, 0x50, 0x1b, 0xd1, 0x35, 0x93, 0xa9, 0xe1, 0x4f, 0xa1,
+	0xab, 0xaa, 0x5e, 0x23, 0x71, 0x50, 0xb2, 0x9e, 0x71, 0x19, 0xbe, 0xa3, 0xea, 0x03, 0xa8, 0x3f,
+	0x4d, 0x91, 0xc7, 0x09, 0x2d, 0xd0, 0x7a, 0x37, 0xac, 0xad, 0x94, 0xb3, 0xd6, 0x98, 0xe5, 0x6a,
+	0xd6, 0xfd, 0x05, 0xf6, 0x10, 0x5c, 0x96, 0x47, 0xc7, 0x29, 0x4f, 0xce, 0x0a, 0xaf, 0x89, 0x44,
+	0x9b, 0xe5, 0x23, 0x8c, 0x89, 0x0f, 0x8a, 0x8e, 0x16, 0x40, 0x1b, 0x81, 0x95, 0x8c, 0xcb, 0x17,
+	0x25, 0xb3, 0x05, 0x1d, 0x41, 0x67, 0x5c, 0xd2, 0x1a, 0xe6, 0x22, 0xb6, 0xaa, 0xd7, 0x2b, 0x72,
+	0x00, 0xeb, 0x7a, 0x9f, 0x6f, 0xd1, 0xa0, 0x8d, 0xc1, 0x5d, 0xd6, 0x05, 0xfe, 0xaf, 0x0d, 0x70,
+	0xab, 0x23, 0x23, 0xeb, 0xd0, 0x9a, 0xf2, 0x42, 0x96, 0xe7, 0xa2, 0x03, 0x35, 0xbf, 0x2a, 0xaa,
+	0x33, 0xfa, 0x34, 0xda, 0x19, 0x97, 0xbb, 0x98, 0x5c, 0x87, 0x56, 0xce, 0x85, 0x2c, 0xbd, 0xd7,
+	0x41, 0x29, 0xd1, 0x19, 0xa7, 0x92, 0x1c, 0x62, 0xd2, 0x83, 0xe5, 0x19, 0x95, 0x53, 0x3e, 0x29,
+	0x3d, 0x2d, 0x43, 0xb2, 0x01, 0x6a, 0xdf, 0x51, 0x99, 0x5d, 0x36, 0x8e, 0x73, 0xb9, 0x67, 0x00,
+	0xd5, 0x2d, 0x96, 0xd3, 0xd2, 0x46, 0x1d, 0x54, 0xdd, 0x30, 0xd3, 0x5e, 0x74, 0xc3, 0xe4, 0x1e,
+	0xdc, 0xa7, 0xe5, 0xa7, 0xc1, 0x20, 0xff, 0x2c, 0xe3, 0x2d, 0xfa, 0xf0, 0xc6, 0x4b, 0x20, 0x05,
+	0xcb, 0x4e, 0xf7, 0x62, 0x99, 0x4c, 0xc3, 0xd5, 0x4a, 0xac, 0xcb, 0x8d, 0xe1, 0xc1, 0xa2, 0xdc,
+	0xa2, 0xeb, 0xbf, 0x77, 0x28, 0xb9, 0x56, 0x15, 0xd8, 0x37, 0x43, 0xfa, 0x6f, 0xc0, 0xad, 0xae,
+	0x2e, 0xe9, 0x42, 0xe3, 0x8c, 0x5e, 0xea, 0xcf, 0xd6, 0xa8, 0x79, 0xb5, 0x6d, 0xd9, 0xa1, 0x5a,
+	0x20, 0x5d, 0x70, 0xce, 0xe3, 0x74, 0x4e, 0x4b, 0xaf, 0x4d, 0x44, 0x1e, 0x81, 0xb2, 0x28, 0x32,
+	0x39, 0x6d, 0xa9, 0x32, 0xe4, 0x7b, 0x5c, 0xf0, 0x29, 0xac, 0xd4, 0xba, 0x93, 0x2e, 0xb4, 0xe8,
+	0x45, 0x9c, 0x48, 0x5d, 0x7f, 0x77, 0x29, 0xd4, 0x21, 0xf1, 0xc0, 0xc9, 0x05, 0x3d, 0x61, 0x17,
+	0x9e, 0x6d, 0x12, 0x26, 0x56, 0x0a, 0x41, 0x4f, 0xe9, 0x05, 0x3e, 0x02, 0xa8, 0xc0, 0x70, 0xf4,
+	0x1e, 0xc0, 0x4c, 0x95, 0x8c, 0xd4, 0x13, 0x34, 0x7a, 0xfc, 0xe7, 0x55, 0xdf, 0xfa, 0xeb, 0xaa,
+	0x6f, 0xfd, 0x7d, 0xd5, 0xb7, 0xde, 0x3c, 0xd2, 0x3e, 0x30, 0x8e, 0xef, 0xe0, 0xdb, 0xef, 0xea,
+	0xb1, 0x83, 0xaf, 0xdd, 0x67, 0xff, 0x05, 0x00, 0x00, 0xff, 0xff, 0x84, 0x9a, 0xd5, 0x68, 0x72,
+	0x07, 0x00, 0x00,
 }
 
 func (m *AuthorizationPolicy) Marshal() (dAtA []byte, err error) {
@@ -1475,6 +1602,38 @@ func (m *Operation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 		i -= len(m.XXX_unrecognized)
 		copy(dAtA[i:], m.XXX_unrecognized)
 	}
+	if len(m.ExtensionNotPaths) > 0 {
+		for iNdEx := len(m.ExtensionNotPaths) - 1; iNdEx >= 0; iNdEx-- {
+			{
+				size, err := m.ExtensionNotPaths[iNdEx].MarshalToSizedBuffer(dAtA[:i])
+				if err != nil {
+					return 0, err
+				}
+				i -= size
+				i = encodeVarintAuthorizationPolicy(dAtA, i, uint64(size))
+			}
+			i--
+			dAtA[i] = 0x3e
+			i--
+			dAtA[i] = 0xca
+		}
+	}
+	if len(m.ExtensionPaths) > 0 {
+		for iNdEx := len(m.ExtensionPaths) - 1; iNdEx >= 0; iNdEx-- {
+			{
+				size, err := m.ExtensionPaths[iNdEx].MarshalToSizedBuffer(dAtA[:i])
+				if err != nil {
+					return 0, err
+				}
+				i -= size
+				i = encodeVarintAuthorizationPolicy(dAtA, i, uint64(size))
+			}
+			i--
+			dAtA[i] = 0x3e
+			i--
+			dAtA[i] = 0xc2
+		}
+	}
 	if len(m.NotPaths) > 0 {
 		for iNdEx := len(m.NotPaths) - 1; iNdEx >= 0; iNdEx-- {
 			i -= len(m.NotPaths[iNdEx])
@@ -1602,6 +1761,84 @@ func (m *Condition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 	return len(dAtA) - i, nil
 }
 
+func (m *StringMatch) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalToSizedBuffer(dAtA[:size])
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *StringMatch) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *StringMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	_ = i
+	var l int
+	_ = l
+	if m.XXX_unrecognized != nil {
+		i -= len(m.XXX_unrecognized)
+		copy(dAtA[i:], m.XXX_unrecognized)
+	}
+	if m.MatchType != nil {
+		{
+			size := m.MatchType.Size()
+			i -= size
+			if _, err := m.MatchType.MarshalTo(dAtA[i:]); err != nil {
+				return 0, err
+			}
+		}
+	}
+	return len(dAtA) - i, nil
+}
+
+func (m *StringMatch_Exact) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *StringMatch_Exact) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	i -= len(m.Exact)
+	copy(dAtA[i:], m.Exact)
+	i = encodeVarintAuthorizationPolicy(dAtA, i, uint64(len(m.Exact)))
+	i--
+	dAtA[i] = 0xa
+	return len(dAtA) - i, nil
+}
+func (m *StringMatch_Prefix) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *StringMatch_Prefix) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	i -= len(m.Prefix)
+	copy(dAtA[i:], m.Prefix)
+	i = encodeVarintAuthorizationPolicy(dAtA, i, uint64(len(m.Prefix)))
+	i--
+	dAtA[i] = 0x12
+	return len(dAtA) - i, nil
+}
+func (m *StringMatch_Regex) MarshalTo(dAtA []byte) (int, error) {
+	size := m.Size()
+	return m.MarshalToSizedBuffer(dAtA[:size])
+}
+
+func (m *StringMatch_Regex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
+	i := len(dAtA)
+	i -= len(m.Regex)
+	copy(dAtA[i:], m.Regex)
+	i = encodeVarintAuthorizationPolicy(dAtA, i, uint64(len(m.Regex)))
+	i--
+	dAtA[i] = 0x1a
+	return len(dAtA) - i, nil
+}
 func encodeVarintAuthorizationPolicy(dAtA []byte, offset int, v uint64) int {
 	offset -= sovAuthorizationPolicy(v)
 	base := offset
@@ -1857,6 +2094,18 @@ func (m *Operation) Size() (n int) {
 			n += 1 + l + sovAuthorizationPolicy(uint64(l))
 		}
 	}
+	if len(m.ExtensionPaths) > 0 {
+		for _, e := range m.ExtensionPaths {
+			l = e.Size()
+			n += 2 + l + sovAuthorizationPolicy(uint64(l))
+		}
+	}
+	if len(m.ExtensionNotPaths) > 0 {
+		for _, e := range m.ExtensionNotPaths {
+			l = e.Size()
+			n += 2 + l + sovAuthorizationPolicy(uint64(l))
+		}
+	}
 	if m.XXX_unrecognized != nil {
 		n += len(m.XXX_unrecognized)
 	}
@@ -1891,6 +2140,52 @@ func (m *Condition) Size() (n int) {
 	return n
 }
 
+func (m *StringMatch) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	if m.MatchType != nil {
+		n += m.MatchType.Size()
+	}
+	if m.XXX_unrecognized != nil {
+		n += len(m.XXX_unrecognized)
+	}
+	return n
+}
+
+func (m *StringMatch_Exact) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	l = len(m.Exact)
+	n += 1 + l + sovAuthorizationPolicy(uint64(l))
+	return n
+}
+func (m *StringMatch_Prefix) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	l = len(m.Prefix)
+	n += 1 + l + sovAuthorizationPolicy(uint64(l))
+	return n
+}
+func (m *StringMatch_Regex) Size() (n int) {
+	if m == nil {
+		return 0
+	}
+	var l int
+	_ = l
+	l = len(m.Regex)
+	n += 1 + l + sovAuthorizationPolicy(uint64(l))
+	return n
+}
+
 func sovAuthorizationPolicy(x uint64) (n int) {
 	return (math_bits.Len64(x|1) + 6) / 7
 }
@@ -3138,6 +3433,74 @@ func (m *Operation) Unmarshal(dAtA []byte) error {
 			}
 			m.NotPaths = append(m.NotPaths, string(dAtA[iNdEx:postIndex]))
 			iNdEx = postIndex
+		case 1000:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field ExtensionPaths", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowAuthorizationPolicy
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthAuthorizationPolicy
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthAuthorizationPolicy
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.ExtensionPaths = append(m.ExtensionPaths, &StringMatch{})
+			if err := m.ExtensionPaths[len(m.ExtensionPaths)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 1001:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field ExtensionNotPaths", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowAuthorizationPolicy
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthAuthorizationPolicy
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthAuthorizationPolicy
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.ExtensionNotPaths = append(m.ExtensionNotPaths, &StringMatch{})
+			if err := m.ExtensionNotPaths[len(m.ExtensionNotPaths)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
 		default:
 			iNdEx = preIndex
 			skippy, err := skipAuthorizationPolicy(dAtA[iNdEx:])
@@ -3307,6 +3670,153 @@ func (m *Condition) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
+func (m *StringMatch) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowAuthorizationPolicy
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= uint64(b&0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: StringMatch: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: StringMatch: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Exact", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowAuthorizationPolicy
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthAuthorizationPolicy
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthAuthorizationPolicy
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.MatchType = &StringMatch_Exact{string(dAtA[iNdEx:postIndex])}
+			iNdEx = postIndex
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowAuthorizationPolicy
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthAuthorizationPolicy
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthAuthorizationPolicy
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.MatchType = &StringMatch_Prefix{string(dAtA[iNdEx:postIndex])}
+			iNdEx = postIndex
+		case 3:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Regex", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowAuthorizationPolicy
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= uint64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthAuthorizationPolicy
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex < 0 {
+				return ErrInvalidLengthAuthorizationPolicy
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.MatchType = &StringMatch_Regex{string(dAtA[iNdEx:postIndex])}
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipAuthorizationPolicy(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
+				return ErrInvalidLengthAuthorizationPolicy
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
 func skipAuthorizationPolicy(dAtA []byte) (n int, err error) {
 	l := len(dAtA)
 	iNdEx := 0
diff --git a/security/v1beta1/authorization_policy.pb.html b/security/v1beta1/authorization_policy.pb.html
index 11f9f527..f9212ba2 100644
--- a/security/v1beta1/authorization_policy.pb.html
+++ b/security/v1beta1/authorization_policy.pb.html
@@ -7,7 +7,7 @@ generator: protoc-gen-docs
 schema: istio.security.v1beta1.AuthorizationPolicy
 weight: 20
 aliases: [/docs/reference/config/authorization/authorization-policy]
-number_of_entries: 9
+number_of_entries: 10
 ---
 <p>Istio Authorization Policy enables access control on workloads in the mesh.</p>
 
@@ -602,6 +602,24 @@ No
 <td>
 <p>Optional. A list of negative match of paths.</p>
 
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="Operation-extension_paths">
+<td><code>extensionPaths</code></td>
+<td><code><a href="#StringMatch">StringMatch[]</a></code></td>
+<td>
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="Operation-extension_not_paths">
+<td><code>extensionNotPaths</code></td>
+<td><code><a href="#StringMatch">StringMatch[]</a></code></td>
+<td>
 </td>
 <td>
 No
@@ -655,6 +673,57 @@ No
 <p>Optional. A list of negative match of values for the attribute.
 Note: at least one of values or not_values must be set.</p>
 
+</td>
+<td>
+No
+</td>
+</tr>
+</tbody>
+</table>
+</section>
+<h2 id="StringMatch">StringMatch</h2>
+<section>
+<p>Describes how to match a given string in HTTP headers. Match is
+case-sensitive.</p>
+
+<table class="message-fields">
+<thead>
+<tr>
+<th>Field</th>
+<th>Type</th>
+<th>Description</th>
+<th>Required</th>
+</tr>
+</thead>
+<tbody>
+<tr id="StringMatch-exact" class="oneof oneof-start">
+<td><code>exact</code></td>
+<td><code>string (oneof)</code></td>
+<td>
+<p>exact string match</p>
+
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="StringMatch-prefix" class="oneof">
+<td><code>prefix</code></td>
+<td><code>string (oneof)</code></td>
+<td>
+<p>prefix-based match</p>
+
+</td>
+<td>
+No
+</td>
+</tr>
+<tr id="StringMatch-regex" class="oneof">
+<td><code>regex</code></td>
+<td><code>string (oneof)</code></td>
+<td>
+<p>RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).</p>
+
 </td>
 <td>
 No
diff --git a/security/v1beta1/authorization_policy.proto b/security/v1beta1/authorization_policy.proto
index e719d95f..cbee564f 100644
--- a/security/v1beta1/authorization_policy.proto
+++ b/security/v1beta1/authorization_policy.proto
@@ -458,6 +458,10 @@ message Operation {
 
   // Optional. A list of negative match of paths.
   repeated string not_paths = 8;
+
+  repeated StringMatch extension_paths = 1000;
+
+  repeated StringMatch extension_not_paths = 1001;
 }
 
 // Condition specifies additional required attributes.
@@ -474,3 +478,19 @@ message Condition {
   // Note: at least one of values or not_values must be set.
   repeated string not_values = 3;
 }
+
+// Describes how to match a given string in HTTP headers. Match is
+// case-sensitive.
+message StringMatch {
+  oneof match_type {
+
+    // exact string match
+    string exact = 1;
+
+    // prefix-based match
+    string prefix = 2;
+
+    // RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
+    string regex = 3;
+  }
+}
diff --git a/security/v1beta1/authorization_policy_deepcopy.gen.go b/security/v1beta1/authorization_policy_deepcopy.gen.go
index 55c4e68f..c1fdc3fc 100644
--- a/security/v1beta1/authorization_policy_deepcopy.gen.go
+++ b/security/v1beta1/authorization_policy_deepcopy.gen.go
@@ -343,3 +343,24 @@ func (in *Condition) DeepCopy() *Condition {
 func (in *Condition) DeepCopyInterface() interface{} {
 	return in.DeepCopy()
 }
+
+// DeepCopyInto supports using StringMatch within kubernetes types, where deepcopy-gen is used.
+func (in *StringMatch) DeepCopyInto(out *StringMatch) {
+	p := proto.Clone(in).(*StringMatch)
+	*out = *p
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new StringMatch. Required by controller-gen.
+func (in *StringMatch) DeepCopy() *StringMatch {
+	if in == nil {
+		return nil
+	}
+	out := new(StringMatch)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInterface is an autogenerated deepcopy function, copying the receiver, creating a new StringMatch. Required by controller-gen.
+func (in *StringMatch) DeepCopyInterface() interface{} {
+	return in.DeepCopy()
+}
diff --git a/security/v1beta1/authorization_policy_json.gen.go b/security/v1beta1/authorization_policy_json.gen.go
index e6fcf4ad..19ff0bc1 100644
--- a/security/v1beta1/authorization_policy_json.gen.go
+++ b/security/v1beta1/authorization_policy_json.gen.go
@@ -266,6 +266,17 @@ func (this *Condition) UnmarshalJSON(b []byte) error {
 	return AuthorizationPolicyUnmarshaler.Unmarshal(bytes.NewReader(b), this)
 }
 
+// MarshalJSON is a custom marshaler for StringMatch
+func (this *StringMatch) MarshalJSON() ([]byte, error) {
+	str, err := AuthorizationPolicyMarshaler.MarshalToString(this)
+	return []byte(str), err
+}
+
+// UnmarshalJSON is a custom unmarshaler for StringMatch
+func (this *StringMatch) UnmarshalJSON(b []byte) error {
+	return AuthorizationPolicyUnmarshaler.Unmarshal(bytes.NewReader(b), this)
+}
+
 var (
 	AuthorizationPolicyMarshaler   = &github_com_gogo_protobuf_jsonpb.Marshaler{}
 	AuthorizationPolicyUnmarshaler = &github_com_gogo_protobuf_jsonpb.Unmarshaler{AllowUnknownFields: true}
