diff -Naur envoy/source/common/http/conn_manager_config.h envoy-new/source/common/http/conn_manager_config.h
--- envoy/source/common/http/conn_manager_config.h	2024-01-16 23:42:11.191853354 +0800
+++ envoy-new/source/common/http/conn_manager_config.h	2024-01-16 23:27:25.849358541 +0800
@@ -62,6 +62,7 @@
   COUNTER(downstream_rq_rejected_via_ip_detection)                                                 \
   COUNTER(downstream_rq_response_before_rq_complete)                                               \
   COUNTER(downstream_rq_rx_reset)                                                                  \
+  COUNTER(downstream_rq_too_many_premature_resets)                                                 \
   COUNTER(downstream_rq_timeout)                                                                   \
   COUNTER(downstream_rq_header_timeout)                                                            \
   COUNTER(downstream_rq_too_large)                                                                 \
diff -Naur envoy/source/common/http/conn_manager_impl.cc envoy-new/source/common/http/conn_manager_impl.cc
--- envoy/source/common/http/conn_manager_impl.cc	2024-01-16 23:42:11.307854195 +0800
+++ envoy-new/source/common/http/conn_manager_impl.cc	2024-01-16 23:27:25.853358572 +0800
@@ -1,5 +1,6 @@
 #include "source/common/http/conn_manager_impl.h"
 
+#include <chrono>
 #include <cstdint>
 #include <functional>
 #include <list>
@@ -52,6 +53,15 @@
 namespace Envoy {
 namespace Http {
 
+const absl::string_view ConnectionManagerImpl::PrematureResetTotalStreamCountKey =
+    "overload.premature_reset_total_stream_count";
+const absl::string_view ConnectionManagerImpl::PrematureResetMinStreamLifetimeSecondsKey =
+    "overload.premature_reset_min_stream_lifetime_seconds";
+// Runtime key for maximum number of requests that can be processed from a single connection per
+// I/O cycle. Requests over this limit are deferred until the next I/O cycle.
+const absl::string_view ConnectionManagerImpl::MaxRequestsPerIoCycle =
+    "http.max_requests_per_io_cycle";
+
 bool requestWasConnect(const RequestHeaderMapPtr& headers, Protocol protocol) {
   if (!headers) {
     return false;
@@ -102,8 +112,10 @@
       overload_disable_keepalive_ref_(
           overload_state_.getState(Server::OverloadActionNames::get().DisableHttpKeepAlive)),
       time_source_(time_source),
-      enable_internal_redirects_with_body_(Runtime::runtimeFeatureEnabled(
-          "envoy.reloadable_features.internal_redirects_with_body")) {}
+      enable_internal_redirects_with_body_(
+          Runtime::runtimeFeatureEnabled("envoy.reloadable_features.internal_redirects_with_body")),
+      max_requests_during_dispatch_(runtime_.snapshot().getInteger(
+          ConnectionManagerImpl::MaxRequestsPerIoCycle, UINT32_MAX)) {}
 
 const ResponseHeaderMap& ConnectionManagerImpl::continueHeader() {
   static const auto headers = createHeaderMap<ResponseHeaderMapImpl>(
@@ -113,6 +125,12 @@
 
 void ConnectionManagerImpl::initializeReadFilterCallbacks(Network::ReadFilterCallbacks& callbacks) {
   read_callbacks_ = &callbacks;
+  if (max_requests_during_dispatch_ != UINT32_MAX) {
+    deferred_request_processing_callback_ =
+        callbacks.connection().dispatcher().createSchedulableCallback(
+            [this]() -> void { onDeferredRequestProcessing(); });
+  }
+
   stats_.named_.downstream_cx_total_.inc();
   stats_.named_.downstream_cx_active_.inc();
   if (read_callbacks_->connection().ssl()) {
@@ -252,6 +270,10 @@
 }
 
 void ConnectionManagerImpl::doDeferredStreamDestroy(ActiveStream& stream) {
+  ++closed_non_internally_destroyed_requests_;
+  if (isPrematureRstStream(stream)) {
+    ++number_premature_stream_resets_;
+  }
   if (stream.max_stream_duration_timer_) {
     stream.max_stream_duration_timer_->disableTimer();
     stream.max_stream_duration_timer_ = nullptr;
@@ -277,6 +299,7 @@
   if (connection_idle_timer_ && streams_.empty()) {
     connection_idle_timer_->enableTimer(config_.idleTimeout().value());
   }
+  maybeDrainDueToPrematureResets();
 }
 
 RequestDecoder& ConnectionManagerImpl::newStream(ResponseEncoder& response_encoder,
@@ -356,6 +379,7 @@
 }
 
 Network::FilterStatus ConnectionManagerImpl::onData(Buffer::Instance& data, bool) {
+  requests_during_dispatch_count_ = 0;
   if (!codec_) {
     // Http3 codec should have been instantiated by now.
     createCodec(data);
@@ -510,6 +534,59 @@
   }
 }
 
+bool ConnectionManagerImpl::isPrematureRstStream(const ActiveStream& stream) const {
+  // Check if the request was prematurely reset, by comparing its lifetime to the configured
+  // threshold.
+  MonotonicTime current_time = time_source_.monotonicTime();
+  MonotonicTime request_start_time = stream.filter_manager_.streamInfo().startTimeMonotonic();
+  std::chrono::nanoseconds duration =
+      std::chrono::duration_cast<std::chrono::nanoseconds>(current_time - request_start_time);
+
+  // Check if request lifetime is longer than the premature reset threshold.
+  if (duration.count() > 0) {
+    const uint64_t lifetime = std::chrono::duration_cast<std::chrono::seconds>(duration).count();
+    const uint64_t min_lifetime = runtime_.snapshot().getInteger(
+        ConnectionManagerImpl::PrematureResetMinStreamLifetimeSecondsKey, 1);
+    if (lifetime > min_lifetime) {
+      return false;
+    }
+  }
+
+  // If request has completed before configured threshold, also check if the Envoy proxied the
+  // response from the upstream. Requests without the response status were reset.
+  // TODO(RyanTheOptimist): Possibly support half_closed_local instead.
+  return !stream.filter_manager_.streamInfo().responseCode();
+}
+
+// Sends a GOAWAY if too many streams have been reset prematurely on this
+// connection.
+void ConnectionManagerImpl::maybeDrainDueToPrematureResets() {
+  if (!Runtime::runtimeFeatureEnabled(
+          "envoy.restart_features.send_goaway_for_premature_rst_streams") ||
+      closed_non_internally_destroyed_requests_ == 0) {
+    return;
+  }
+
+  const uint64_t limit =
+      runtime_.snapshot().getInteger(ConnectionManagerImpl::PrematureResetTotalStreamCountKey, 500);
+
+  if (closed_non_internally_destroyed_requests_ < limit) {
+    return;
+  }
+
+  if (static_cast<double>(number_premature_stream_resets_) /
+          closed_non_internally_destroyed_requests_ <
+      .5) {
+    return;
+  }
+
+  if (drain_state_ == DrainState::NotDraining) {
+    stats_.named_.downstream_rq_too_many_premature_resets_.inc();
+    doConnectionClose(Network::ConnectionCloseType::NoFlush, absl::nullopt,
+                      "too_many_premature_resets");
+  }
+}
+
 void ConnectionManagerImpl::onGoAway(GoAwayErrorCode) {
   // Currently we do nothing with remote go away frames. In the future we can decide to no longer
   // push resources if applicable.
@@ -1093,7 +1170,12 @@
     traceRequest();
   }
 
-  filter_manager_.decodeHeaders(*request_headers_, end_stream);
+  if (!connection_manager_.shouldDeferRequestProxyingToNextIoCycle()) {
+    filter_manager_.decodeHeaders(*request_headers_, end_stream);
+  } else {
+    state_.deferred_to_next_io_iteration_ = true;
+    state_.deferred_end_stream_ = end_stream;
+  }
 
   // Reset it here for both global and overridden cases.
   resetIdleTimer();
@@ -1161,8 +1243,15 @@
                                connection_manager_.read_callbacks_->connection().dispatcher());
   filter_manager_.maybeEndDecode(end_stream);
   filter_manager_.streamInfo().addBytesReceived(data.length());
-
-  filter_manager_.decodeData(data, end_stream);
+  if (!state_.deferred_to_next_io_iteration_) {
+    filter_manager_.decodeData(data, end_stream);
+  } else {
+    if (!deferred_data_) {
+      deferred_data_ = std::make_unique<Buffer::OwnedImpl>();
+    }
+    deferred_data_->move(data);
+    state_.deferred_end_stream_ = end_stream;
+  }
 }
 
 void ConnectionManagerImpl::ActiveStream::decodeTrailers(RequestTrailerMapPtr&& trailers) {
@@ -1173,7 +1262,9 @@
   ASSERT(!request_trailers_);
   request_trailers_ = std::move(trailers);
   filter_manager_.maybeEndDecode(true);
-  filter_manager_.decodeTrailers(*request_trailers_);
+  if (!state_.deferred_to_next_io_iteration_) {
+    filter_manager_.decodeTrailers(*request_trailers_);
+  }
 }
 
 void ConnectionManagerImpl::ActiveStream::decodeMetadata(MetadataMapPtr&& metadata_map) {
@@ -1733,5 +1824,61 @@
   connection_manager_.doEndStream(*this);
 }
 
+bool ConnectionManagerImpl::ActiveStream::onDeferredRequestProcessing() {
+  // TODO(yanavlasov): Merge this with the filter manager continueIteration() method
+  if (!state_.deferred_to_next_io_iteration_) {
+    return false;
+  }
+  state_.deferred_to_next_io_iteration_ = false;
+  bool end_stream =
+      state_.deferred_end_stream_ && deferred_data_ == nullptr && request_trailers_ == nullptr;
+  filter_manager_.decodeHeaders(*request_headers_, end_stream);
+  if (end_stream) {
+    return true;
+  }
+  if (deferred_data_ != nullptr) {
+    end_stream = state_.deferred_end_stream_ && request_trailers_ == nullptr;
+    filter_manager_.decodeData(*deferred_data_, end_stream);
+  }
+  if (request_trailers_ != nullptr) {
+    filter_manager_.decodeTrailers(*request_trailers_);
+  }
+  return true;
+}
+
+bool ConnectionManagerImpl::shouldDeferRequestProxyingToNextIoCycle() {
+  // Do not defer this stream if stream deferral is disabled
+  if (deferred_request_processing_callback_ == nullptr) {
+    return false;
+  }
+  // Defer this stream if there are already deferred streams, so they are not
+  // processed out of order
+  if (deferred_request_processing_callback_->enabled()) {
+    return true;
+  }
+  ++requests_during_dispatch_count_;
+  bool defer = requests_during_dispatch_count_ > max_requests_during_dispatch_;
+  if (defer) {
+    deferred_request_processing_callback_->scheduleCallbackNextIteration();
+  }
+  return defer;
+}
+
+void ConnectionManagerImpl::onDeferredRequestProcessing() {
+  requests_during_dispatch_count_ = 1; // 1 stream is always let through
+  // Streams are inserted at the head of the list. As such process deferred
+  // streams at the back of the list first.
+  for (auto reverse_iter = streams_.rbegin(); reverse_iter != streams_.rend();) {
+    auto& stream_ptr = *reverse_iter;
+    // Move the iterator to the next item in case the `onDeferredRequestProcessing` call removes the
+    // stream from the list.
+    ++reverse_iter;
+    bool was_deferred = stream_ptr->onDeferredRequestProcessing();
+    if (was_deferred && shouldDeferRequestProxyingToNextIoCycle()) {
+      break;
+    }
+  }
+}
+
 } // namespace Http
 } // namespace Envoy
diff -Naur envoy/source/common/http/conn_manager_impl.h envoy-new/source/common/http/conn_manager_impl.h
--- envoy/source/common/http/conn_manager_impl.h	2024-01-16 23:42:11.275853963 +0800
+++ envoy-new/source/common/http/conn_manager_impl.h	2024-01-16 23:27:25.853358572 +0800
@@ -115,6 +115,15 @@
   void setClearHopByHopResponseHeaders(bool value) { clear_hop_by_hop_response_headers_ = value; }
   bool clearHopByHopResponseHeaders() const { return clear_hop_by_hop_response_headers_; }
 
+  // This runtime key configures the number of streams which must be closed on a connection before
+  // envoy will potentially drain a connection due to excessive prematurely reset streams.
+  static const absl::string_view PrematureResetTotalStreamCountKey;
+
+  // The minimum lifetime of a stream, in seconds, in order not to be considered
+  // prematurely closed.
+  static const absl::string_view PrematureResetMinStreamLifetimeSecondsKey;
+  static const absl::string_view MaxRequestsPerIoCycle;
+
 private:
   struct ActiveStream;
   class MobileConnectionManagerImpl;
@@ -308,7 +317,8 @@
     struct State {
       State()
           : codec_saw_local_complete_(false), saw_connection_close_(false),
-            successful_upgrade_(false), is_internally_created_(false), decorated_propagate_(true) {}
+            successful_upgrade_(false), is_internally_created_(false), decorated_propagate_(true),
+            deferred_to_next_io_iteration_(false) {}
 
       bool codec_saw_local_complete_ : 1; // This indicates that local is complete as written all
                                           // the way through to the codec.
@@ -320,6 +330,14 @@
       bool is_internally_created_ : 1;
 
       bool decorated_propagate_ : 1;
+
+      // Indicates that sending headers to the filter manager is deferred to the
+      // next I/O cycle. If data or trailers are received when this flag is set
+      // they are deferred too.
+      // TODO(yanavlasov): encapsulate the entire state of deferred streams into a separate
+      // structure, so it can be atomically created and cleared.
+      bool deferred_to_next_io_iteration_ : 1;
+      bool deferred_end_stream_ : 1;
     };
 
     // Per-stream idle timeout callback.
@@ -347,6 +365,11 @@
       return *tracing_custom_tags_;
     }
 
+    // Dispatch deferred headers, body and trailers to the filter manager.
+    // Return true if this stream was deferred and dispatched pending headers, body and trailers (if
+    // present). Return false if this stream was not deferred.
+    bool onDeferredRequestProcessing();
+
     ConnectionManagerImpl& connection_manager_;
     // TODO(snowp): It might make sense to move this to the FilterManager to avoid storing it in
     // both locations, then refer to the FM when doing stream logs.
@@ -390,6 +413,8 @@
     std::unique_ptr<Tracing::CustomTagMap> tracing_custom_tags_{nullptr};
 
     friend FilterManager;
+
+    std::unique_ptr<Buffer::OwnedImpl> deferred_data_;
   };
 
   using ActiveStreamPtr = std::unique_ptr<ActiveStream>;
@@ -422,6 +447,18 @@
   void doConnectionClose(absl::optional<Network::ConnectionCloseType> close_type,
                          absl::optional<StreamInfo::ResponseFlag> response_flag,
                          absl::string_view details);
+  // Returns true if a RST_STREAM for the given stream is premature. Premature
+  // means the RST_STREAM arrived before response headers were sent and than
+  // the stream was alive for short period of time. This period is specified
+  // by the optional runtime value PrematureResetMinStreamLifetimeSecondsKey,
+  // or one second if that is not present.
+  bool isPrematureRstStream(const ActiveStream& stream) const;
+  // Sends a GOAWAY if both sufficient streams have been closed on a connection
+  // and at least half have been prematurely reset?
+  void maybeDrainDueToPrematureResets();
+
+  bool shouldDeferRequestProxyingToNextIoCycle();
+  void onDeferredRequestProcessing();
 
   enum class DrainState { NotDraining, Draining, Closing };
 
@@ -461,6 +498,15 @@
   bool clear_hop_by_hop_response_headers_{true};
   // The number of requests accumulated on the current connection.
   uint64_t accumulated_requests_{};
+  // The number of requests closed on the current connection which were
+  // not internally destroyed
+  uint64_t closed_non_internally_destroyed_requests_{};
+  // The number of requests that received a premature RST_STREAM, according to
+  // the definition given in `isPrematureRstStream()`.
+  uint64_t number_premature_stream_resets_{0};
+  uint32_t requests_during_dispatch_count_{0};
+  const uint32_t max_requests_during_dispatch_{UINT32_MAX};
+  Event::SchedulableCallbackPtr deferred_request_processing_callback_;
 };
 
 } // namespace Http
diff -Naur envoy/source/common/runtime/runtime_features.cc envoy-new/source/common/runtime/runtime_features.cc
--- envoy/source/common/runtime/runtime_features.cc	2024-01-16 23:42:11.279853992 +0800
+++ envoy-new/source/common/runtime/runtime_features.cc	2024-01-16 23:27:25.853358572 +0800
@@ -100,6 +100,7 @@
     "envoy.reloadable_features.vhds_heartbeats",
     "envoy.reloadable_features.wasm_cluster_name_envoy_grpc",
     "envoy.reloadable_features.upstream_http2_flood_checks",
+    "envoy.restart_features.send_goaway_for_premature_rst_streams",
     "envoy.restart_features.use_apple_api_for_dns_lookups",
     "envoy.reloadable_features.header_map_correctly_coalesce_cookies",
     "envoy.reloadable_features.sanitize_http_header_referer",
diff -Naur envoy/test/common/http/conn_manager_impl_test_2.cc envoy-new/test/common/http/conn_manager_impl_test_2.cc
--- envoy/test/common/http/conn_manager_impl_test_2.cc	2024-01-16 23:42:11.223853586 +0800
+++ envoy-new/test/common/http/conn_manager_impl_test_2.cc	2024-01-16 23:27:25.853358572 +0800
@@ -13,6 +13,7 @@
 using testing::Property;
 using testing::Ref;
 using testing::Return;
+using testing::ReturnArg;
 using testing::ReturnRef;
 
 namespace Envoy {
@@ -2428,7 +2429,7 @@
 
   EXPECT_CALL(*static_cast<const Router::MockScopedConfig*>(
                   scopedRouteConfigProvider()->config<Router::ScopedConfig>().get()),
-              getRouteConfig(_))
+              getRouteConfig(_, _))
       .Times(2)
       .WillRepeatedly(Return(nullptr));
   EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance& data) -> Http::Status {
@@ -2460,7 +2461,7 @@
 
   EXPECT_CALL(*static_cast<const Router::MockScopedConfig*>(
                   scopedRouteConfigProvider()->config<Router::ScopedConfig>().get()),
-              getRouteConfig(_))
+              getRouteConfig(_, _))
       .Times(3)
       .WillOnce(Return(nullptr))
       .WillOnce(Return(nullptr))        // refreshCachedRoute first time.
@@ -2520,12 +2521,13 @@
   EXPECT_CALL(*route_config2, route(_, _, _, _)).WillRepeatedly(Return(route2));
   EXPECT_CALL(*static_cast<const Router::MockScopedConfig*>(
                   scopedRouteConfigProvider()->config<Router::ScopedConfig>().get()),
-              getRouteConfig(_))
+              getRouteConfig(_, _))
       // 1. Snap scoped route config;
       // 2. refreshCachedRoute (both in decodeHeaders(headers,end_stream);
       // 3. then refreshCachedRoute triggered by decoder_filters_[1]->callbacks_->route().
       .Times(3)
-      .WillRepeatedly(Invoke([&](const HeaderMap& headers) -> Router::ConfigConstSharedPtr {
+      .WillRepeatedly(Invoke([&](const HeaderMap& headers,
+                                 const StreamInfo::StreamInfo&) -> Router::ConfigConstSharedPtr {
         auto& test_headers = dynamic_cast<const TestRequestHeaderMapImpl&>(headers);
         if (test_headers.get_("scope_key") == "foo") {
           return route_config1;
@@ -2579,7 +2581,8 @@
   std::shared_ptr<Upstream::MockThreadLocalCluster> fake_cluster1 =
       std::make_shared<NiceMock<Upstream::MockThreadLocalCluster>>();
   EXPECT_CALL(cluster_manager_, getThreadLocalCluster(_)).WillOnce(Return(fake_cluster1.get()));
-  EXPECT_CALL(*scopedRouteConfigProvider()->config<Router::MockScopedConfig>(), getRouteConfig(_))
+  EXPECT_CALL(*scopedRouteConfigProvider()->config<Router::MockScopedConfig>(),
+              getRouteConfig(_, _))
       // 1. decodeHeaders() snapping route config.
       // 2. refreshCachedRoute() later in the same decodeHeaders().
       .Times(2);
@@ -2848,5 +2851,240 @@
   EXPECT_EQ(1U, stats_.named_.downstream_rq_rejected_via_ip_detection_.value());
 }
 
+// Validate that deferred streams are processed with a variety of
+// headers, data and trailer arriving in the same I/O cycle
+TEST_F(HttpConnectionManagerImplTest, LimitWorkPerIOCycle) {
+  const int kRequestsSentPerIOCycle = 100;
+  EXPECT_CALL(runtime_.snapshot_, getInteger(_, _)).WillRepeatedly(ReturnArg<1>());
+  // Process 1 request per I/O cycle
+  auto* deferred_request_callback = enableStreamsPerIoLimit(1);
+  setup(false, "");
+
+  // Store the basic request encoder during filter chain setup.
+  std::vector<std::shared_ptr<MockStreamDecoderFilter>> encoder_filters;
+  int decode_headers_call_count = 0;
+  for (int i = 0; i < kRequestsSentPerIOCycle; ++i) {
+    std::shared_ptr<MockStreamDecoderFilter> filter(new NiceMock<MockStreamDecoderFilter>());
+
+    // Each 4th request is headers only
+    EXPECT_CALL(*filter, decodeHeaders(_, i % 4 == 0 ? true : false))
+        .WillRepeatedly(Invoke([&](RequestHeaderMap&, bool) -> FilterHeadersStatus {
+          ++decode_headers_call_count;
+          return FilterHeadersStatus::StopIteration;
+        }));
+
+    // Each 1st request is headers and data only
+    // Each 2nd request is headers, data and trailers
+    if (i % 4 == 1 || i % 4 == 2) {
+      EXPECT_CALL(*filter, decodeData(_, i % 4 == 1 ? true : false))
+          .WillOnce(Return(FilterDataStatus::StopIterationNoBuffer));
+    }
+
+    // Each 3rd request is headers and trailers (no data)
+    if (i % 4 == 2 || i % 4 == 3) {
+      EXPECT_CALL(*filter, decodeTrailers(_)).WillOnce(Return(FilterTrailersStatus::StopIteration));
+    }
+
+    EXPECT_CALL(*filter, setDecoderFilterCallbacks(_));
+    encoder_filters.push_back(std::move(filter));
+  }
+
+  uint64_t random_value = 0;
+  EXPECT_CALL(random_, random()).WillRepeatedly(Invoke([&random_value]() {
+    return random_value++;
+  }));
+
+  EXPECT_CALL(filter_factory_, createFilterChain(_))
+      .Times(kRequestsSentPerIOCycle)
+      .WillRepeatedly(Invoke([&](FilterChainFactoryCallbacks& callbacks) -> void {
+        static int index = 0;
+        int i = index++;
+        callbacks.addStreamDecoderFilter(encoder_filters[i]);
+      }));
+
+  EXPECT_CALL(filter_callbacks_.connection_.dispatcher_, deferredDelete_(_))
+      .Times(kRequestsSentPerIOCycle);
+
+  std::vector<NiceMock<MockResponseEncoder>> response_encoders(kRequestsSentPerIOCycle);
+  for (auto& encoder : response_encoders) {
+    EXPECT_CALL(encoder, getStream()).WillRepeatedly(ReturnRef(encoder.stream_));
+  }
+
+  EXPECT_CALL(*codec_, dispatch(_))
+      .WillRepeatedly(Invoke([&](Buffer::Instance& data) -> Http::Status {
+        for (int i = 0; i < kRequestsSentPerIOCycle; ++i) {
+          decoder_ = &conn_manager_->newStream(response_encoders[i]);
+
+          RequestHeaderMapPtr headers{new TestRequestHeaderMapImpl{
+              {":authority", "host"}, {":path", "/"}, {":method", "GET"}}};
+
+          RequestTrailerMapPtr trailers{
+              new TestRequestTrailerMapImpl{{"key1", "value1"}, {"key2", "value2"}}};
+
+          Buffer::OwnedImpl data("data");
+
+          switch (i % 4) {
+          case 0:
+            decoder_->decodeHeaders(std::move(headers), true);
+            break;
+          case 1:
+            decoder_->decodeHeaders(std::move(headers), false);
+            decoder_->decodeData(data, true);
+            break;
+          case 2:
+            decoder_->decodeHeaders(std::move(headers), false);
+            decoder_->decodeData(data, false);
+            decoder_->decodeTrailers(std::move(trailers));
+            break;
+          case 3:
+            decoder_->decodeHeaders(std::move(headers), false);
+            decoder_->decodeTrailers(std::move(trailers));
+            break;
+          }
+        }
+
+        data.drain(4);
+        return Http::okStatus();
+      }));
+
+  // Kick off the incoming data.
+  Buffer::OwnedImpl fake_input("1234");
+  conn_manager_->onData(fake_input, false);
+
+  EXPECT_TRUE(deferred_request_callback->enabled_);
+  // Only one request should go through the filter chain
+  ASSERT_EQ(decode_headers_call_count, 1);
+
+  // Let other requests to go through the filter chain. Call expectations will fail
+  // if this is not the case.
+  int deferred_request_count = 0;
+  while (deferred_request_callback->enabled_) {
+    deferred_request_callback->invokeCallback();
+    ++deferred_request_count;
+  }
+
+  ASSERT_EQ(deferred_request_count, kRequestsSentPerIOCycle);
+
+  for (auto& filter : encoder_filters) {
+    ResponseHeaderMapPtr response_headers{new TestResponseHeaderMapImpl{{":status", "200"}}};
+    filter->callbacks_->streamInfo().setResponseCodeDetails("");
+    filter->callbacks_->encodeHeaders(std::move(response_headers), true, "details");
+  }
+
+  EXPECT_EQ(kRequestsSentPerIOCycle, stats_.named_.downstream_rq_2xx_.value());
+  EXPECT_EQ(kRequestsSentPerIOCycle, listener_stats_.downstream_rq_2xx_.value());
+  EXPECT_EQ(kRequestsSentPerIOCycle, stats_.named_.downstream_rq_completed_.value());
+  EXPECT_EQ(kRequestsSentPerIOCycle, listener_stats_.downstream_rq_completed_.value());
+}
+
+TEST_F(HttpConnectionManagerImplTest, StreamDeferralPreservesOrder) {
+  EXPECT_CALL(runtime_.snapshot_, getInteger(_, _)).WillRepeatedly(ReturnArg<1>());
+  // Process 1 request per I/O cycle
+  auto* deferred_request_callback = enableStreamsPerIoLimit(1);
+  setup(false, "");
+
+  std::vector<std::shared_ptr<MockStreamDecoderFilter>> encoder_filters;
+  int expected_request_id = 0;
+  const Http::LowerCaseString request_id_header(absl::string_view("request-id"));
+  // Two requests are processed in 2 I/O reads
+  const int TotalRequests = 2 * 2;
+  for (int i = 0; i < TotalRequests; ++i) {
+    std::shared_ptr<MockStreamDecoderFilter> filter(new NiceMock<MockStreamDecoderFilter>());
+
+    EXPECT_CALL(*filter, decodeHeaders(_, true))
+        .WillRepeatedly(Invoke([&](RequestHeaderMap& headers, bool) -> FilterHeadersStatus {
+          // Check that requests are decoded in expected order
+          int request_id = 0;
+          ASSERT(absl::SimpleAtoi(headers.get(request_id_header)[0]->value().getStringView(),
+                                  &request_id));
+          ASSERT(request_id == expected_request_id);
+          ++expected_request_id;
+          return FilterHeadersStatus::StopIteration;
+        }));
+
+    EXPECT_CALL(*filter, setDecoderFilterCallbacks(_));
+    encoder_filters.push_back(std::move(filter));
+  }
+
+  uint64_t random_value = 0;
+  EXPECT_CALL(random_, random()).WillRepeatedly(Invoke([&random_value]() {
+    return random_value++;
+  }));
+
+  EXPECT_CALL(filter_factory_, createFilterChain(_))
+      .Times(TotalRequests)
+      .WillRepeatedly(Invoke([&](FilterChainFactoryCallbacks& callbacks) -> void {
+        static int index = 0;
+        int i = index++;
+        callbacks.addStreamDecoderFilter(encoder_filters[i]);
+      }));
+
+  EXPECT_CALL(filter_callbacks_.connection_.dispatcher_, deferredDelete_(_)).Times(TotalRequests);
+
+  std::vector<NiceMock<MockResponseEncoder>> response_encoders(TotalRequests);
+  for (auto& encoder : response_encoders) {
+    EXPECT_CALL(encoder, getStream()).WillRepeatedly(ReturnRef(encoder.stream_));
+  }
+  auto response_encoders_iter = response_encoders.begin();
+
+  int request_id = 0;
+  EXPECT_CALL(*codec_, dispatch(_))
+      .WillRepeatedly(Invoke([&](Buffer::Instance& data) -> Http::Status {
+        // The second request should be deferred
+        for (int i = 0; i < 2; ++i) {
+          decoder_ = &conn_manager_->newStream(*response_encoders_iter);
+          ++response_encoders_iter;
+
+          RequestHeaderMapPtr headers{
+              new TestRequestHeaderMapImpl{{":authority", "host"},
+                                           {":path", "/"},
+                                           {":method", "GET"},
+                                           {"request-id", absl::StrCat(request_id)}}};
+
+          ++request_id;
+          decoder_->decodeHeaders(std::move(headers), true);
+        }
+
+        data.drain(4);
+        return Http::okStatus();
+      }));
+
+  // Kick off the incoming data.
+  Buffer::OwnedImpl fake_input("1234");
+  conn_manager_->onData(fake_input, false);
+
+  EXPECT_TRUE(deferred_request_callback->enabled_);
+  // Only one request should go through the filter chain
+  ASSERT_EQ(expected_request_id, 1);
+
+  // Test arrival of another request. New request is read from the socket before deferred callbacks.
+  Buffer::OwnedImpl fake_input2("1234");
+  conn_manager_->onData(fake_input2, false);
+
+  // No requests from the second read should go through as there are deferred stream present
+  ASSERT_EQ(expected_request_id, 1);
+
+  // Let other requests to go through the filter chain. Call expectations will fail
+  // if this is not the case.
+  int deferred_request_count = 0;
+  while (deferred_request_callback->enabled_) {
+    deferred_request_callback->invokeCallback();
+    ++deferred_request_count;
+  }
+
+  ASSERT_EQ(deferred_request_count, TotalRequests);
+
+  for (auto& filter : encoder_filters) {
+    ResponseHeaderMapPtr response_headers{new TestResponseHeaderMapImpl{{":status", "200"}}};
+    filter->callbacks_->streamInfo().setResponseCodeDetails("");
+    filter->callbacks_->encodeHeaders(std::move(response_headers), true, "details");
+  }
+
+  EXPECT_EQ(TotalRequests, stats_.named_.downstream_rq_2xx_.value());
+  EXPECT_EQ(TotalRequests, listener_stats_.downstream_rq_2xx_.value());
+  EXPECT_EQ(TotalRequests, stats_.named_.downstream_rq_completed_.value());
+  EXPECT_EQ(TotalRequests, listener_stats_.downstream_rq_completed_.value());
+}
+
 } // namespace Http
 } // namespace Envoy
diff -Naur envoy/test/common/http/conn_manager_impl_test_base.cc envoy-new/test/common/http/conn_manager_impl_test_base.cc
--- envoy/test/common/http/conn_manager_impl_test_base.cc	2024-01-16 23:42:11.223853586 +0800
+++ envoy-new/test/common/http/conn_manager_impl_test_base.cc	2024-01-16 23:27:25.853358572 +0800
@@ -77,6 +77,7 @@
   conn_manager_ = std::make_unique<ConnectionManagerImpl>(
       *this, drain_close_, random_, http_context_, runtime_, local_info_, cluster_manager_,
       overload_manager_, test_time_.timeSystem());
+
   conn_manager_->initializeReadFilterCallbacks(filter_callbacks_);
 
   if (tracing) {
@@ -294,5 +295,23 @@
   conn_manager_->onData(fake_input, false);
 }
 
+Event::MockSchedulableCallback*
+HttpConnectionManagerImplTest::enableStreamsPerIoLimit(uint32_t limit) {
+  EXPECT_CALL(runtime_.snapshot_, getInteger("http.max_requests_per_io_cycle", _))
+      .WillOnce(Return(limit));
+
+  // Expect HCM to create and set schedulable callback
+  auto* deferred_request_callback =
+      new Event::MockSchedulableCallback(&filter_callbacks_.connection_.dispatcher_);
+  EXPECT_CALL(*deferred_request_callback, enabled())
+      .WillRepeatedly(
+          Invoke([deferred_request_callback]() { return deferred_request_callback->enabled_; }));
+  EXPECT_CALL(*deferred_request_callback, scheduleCallbackNextIteration())
+      .WillRepeatedly(
+          Invoke([deferred_request_callback]() { deferred_request_callback->enabled_ = true; }));
+
+  return deferred_request_callback;
+}
+
 } // namespace Http
 } // namespace Envoy
diff -Naur envoy/test/common/http/conn_manager_impl_test_base.h envoy-new/test/common/http/conn_manager_impl_test_base.h
--- envoy/test/common/http/conn_manager_impl_test_base.h	2024-01-16 23:42:11.223853586 +0800
+++ envoy-new/test/common/http/conn_manager_impl_test_base.h	2024-01-16 23:27:25.853358572 +0800
@@ -155,6 +155,8 @@
   }
   uint64_t maxRequestsPerConnection() const override { return 0; }
 
+  Event::MockSchedulableCallback* enableStreamsPerIoLimit(uint32_t limit);
+
   Envoy::Event::SimulatedTimeSystem test_time_;
   NiceMock<Router::MockRouteConfigProvider> route_config_provider_;
   std::shared_ptr<Router::MockConfig> route_config_{new NiceMock<Router::MockConfig>()};
diff -Naur envoy/test/common/http/http2/http2_frame.cc envoy-new/test/common/http/http2/http2_frame.cc
--- envoy/test/common/http/http2/http2_frame.cc	2024-01-16 23:42:11.223853586 +0800
+++ envoy-new/test/common/http/http2/http2_frame.cc	2024-01-16 23:27:25.853358572 +0800
@@ -339,7 +339,11 @@
                     makeNetworkOrderStreamId(stream_index));
   frame.appendStaticHeader(StaticHeaderIndex::MethodGet);
   frame.appendStaticHeader(StaticHeaderIndex::SchemeHttps);
-  frame.appendHeaderWithoutIndexing(StaticHeaderIndex::Path, path);
+  if (path.empty() || path == "/") {
+    frame.appendStaticHeader(StaticHeaderIndex::Path);
+  } else {
+    frame.appendHeaderWithoutIndexing(StaticHeaderIndex::Path, path);
+  }
   frame.appendHeaderWithoutIndexing(StaticHeaderIndex::Host, host);
   frame.adjustPayloadSize();
   return frame;
@@ -363,7 +367,11 @@
                     makeNetworkOrderStreamId(stream_index));
   frame.appendStaticHeader(StaticHeaderIndex::MethodPost);
   frame.appendStaticHeader(StaticHeaderIndex::SchemeHttps);
-  frame.appendHeaderWithoutIndexing(StaticHeaderIndex::Path, path);
+  if (path.empty() || path == "/") {
+    frame.appendStaticHeader(StaticHeaderIndex::Path);
+  } else {
+    frame.appendHeaderWithoutIndexing(StaticHeaderIndex::Path, path);
+  }
   frame.appendHeaderWithoutIndexing(StaticHeaderIndex::Host, host);
   frame.adjustPayloadSize();
   return frame;
diff -Naur envoy/test/common/http/http2/http2_frame.h envoy-new/test/common/http/http2/http2_frame.h
--- envoy/test/common/http/http2/http2_frame.h	2024-01-16 23:42:11.223853586 +0800
+++ envoy-new/test/common/http/http2/http2_frame.h	2024-01-16 23:27:25.853358572 +0800
@@ -209,6 +209,13 @@
   ConstIterator end() const { return data_.end(); }
   bool empty() const { return data_.empty(); }
 
+  void appendHeaderWithoutIndexing(const Header& header);
+  // This method updates payload length in the HTTP2 header based on the size of the data_
+  void adjustPayloadSize() {
+    ASSERT(size() >= HeaderSize);
+    setPayloadSize(size() - HeaderSize);
+  }
+
 private:
   void buildHeader(Type type, uint32_t payload_size = 0, uint8_t flags = 0, uint32_t stream_id = 0);
   void setPayloadSize(uint32_t size);
@@ -228,15 +235,8 @@
   // Headers are directly encoded
   void appendStaticHeader(StaticHeaderIndex index);
   void appendHeaderWithoutIndexing(StaticHeaderIndex index, absl::string_view value);
-  void appendHeaderWithoutIndexing(const Header& header);
   void appendEmptyHeader();
 
-  // This method updates payload length in the HTTP2 header based on the size of the data_
-  void adjustPayloadSize() {
-    ASSERT(size() >= HeaderSize);
-    setPayloadSize(size() - HeaderSize);
-  }
-
   DataContainer data_;
 };
 
diff -Naur envoy/test/integration/BUILD envoy-new/test/integration/BUILD
--- envoy/test/integration/BUILD	2024-01-16 23:42:11.287854050 +0800
+++ envoy-new/test/integration/BUILD	2024-01-16 23:27:25.853358572 +0800
@@ -370,7 +370,6 @@
     name = "multiplexed_integration_test",
     srcs = [
         "multiplexed_integration_test.cc",
-        "multiplexed_integration_test.h",
     ],
     shard_count = 4,
     deps = [
diff -Naur envoy/test/integration/multiplexed_integration_test.cc envoy-new/test/integration/multiplexed_integration_test.cc
--- envoy/test/integration/multiplexed_integration_test.cc	2024-01-16 23:42:11.255853818 +0800
+++ envoy-new/test/integration/multiplexed_integration_test.cc	2024-01-16 23:27:25.853358572 +0800
@@ -1,12 +1,14 @@
-#include "test/integration/multiplexed_integration_test.h"
-
 #include <algorithm>
+#include <chrono>
+#include <memory>
 #include <string>
 
 #ifdef ENVOY_ENABLE_QUIC
 #include "source/common/quic/client_connection_factory_impl.h"
 #endif
 
+#include "absl/synchronization/mutex.h"
+
 #include "envoy/config/bootstrap/v3/bootstrap.pb.h"
 #include "envoy/config/cluster/v3/cluster.pb.h"
 #include "envoy/extensions/filters/network/http_connection_manager/v3/http_connection_manager.pb.h"
@@ -16,10 +18,12 @@
 #include "source/common/http/header_map_impl.h"
 
 #include "test/integration/filters/stop_and_continue_filter_config.pb.h"
+#include "test/integration/http_protocol_integration.h"
 #include "test/integration/utility.h"
 #include "test/mocks/http/mocks.h"
 #include "test/test_common/network_utility.h"
 #include "test/test_common/printers.h"
+#include "test/test_common/simulated_time_system.h"
 #include "test/test_common/utility.h"
 
 #include "gtest/gtest.h"
@@ -34,30 +38,42 @@
     return;                                                                                        \
   }
 
-INSTANTIATE_TEST_SUITE_P(IpVersions, Http2IntegrationTest,
+class MultiplexedIntegrationTest : public HttpProtocolIntegrationTest {
+public:
+  void simultaneousRequest(int32_t request1_bytes, int32_t request2_bytes);
+};
+
+INSTANTIATE_TEST_SUITE_P(IpVersions, MultiplexedIntegrationTest,
+                         testing::ValuesIn(HttpProtocolIntegrationTest::getProtocolTestParams(
+                             {Http::CodecType::HTTP2}, {Http::CodecType::HTTP1})),
+                         HttpProtocolIntegrationTest::protocolTestParamsToString);
+
+class MultiplexedIntegrationTestWithSimulatedTime : public Event::TestUsingSimulatedTime,
+                                                    public MultiplexedIntegrationTest {};
+
+INSTANTIATE_TEST_SUITE_P(IpVersions, MultiplexedIntegrationTestWithSimulatedTime,
                          testing::ValuesIn(HttpProtocolIntegrationTest::getProtocolTestParams(
-                             {Http::CodecType::HTTP2, Http::CodecType::HTTP3},
-                             {Http::CodecType::HTTP1})),
+                             {Http::CodecType::HTTP2}, {Http::CodecType::HTTP1})),
                          HttpProtocolIntegrationTest::protocolTestParamsToString);
 
-TEST_P(Http2IntegrationTest, RouterRequestAndResponseWithBodyNoBuffer) {
+TEST_P(MultiplexedIntegrationTest, RouterRequestAndResponseWithBodyNoBuffer) {
   testRouterRequestAndResponseWithBody(1024, 512, false, false);
 }
 
-TEST_P(Http2IntegrationTest, RouterRequestAndResponseWithGiantBodyNoBuffer) {
+TEST_P(MultiplexedIntegrationTest, RouterRequestAndResponseWithGiantBodyNoBuffer) {
   config_helper_.addConfigModifier(ConfigHelper::adjustUpstreamTimeoutForTsan);
   testRouterRequestAndResponseWithBody(10 * 1024 * 1024, 10 * 1024 * 1024, false, false, nullptr,
                                        TSAN_TIMEOUT_FACTOR * TestUtility::DefaultTimeout);
 }
 
-TEST_P(Http2IntegrationTest, FlowControlOnAndGiantBody) {
+TEST_P(MultiplexedIntegrationTest, FlowControlOnAndGiantBody) {
   config_helper_.addConfigModifier(ConfigHelper::adjustUpstreamTimeoutForTsan);
   config_helper_.setBufferLimits(1024, 1024); // Set buffer limits upstream and downstream.
   testRouterRequestAndResponseWithBody(10 * 1024 * 1024, 10 * 1024 * 1024, false, false, nullptr,
                                        TSAN_TIMEOUT_FACTOR * TestUtility::DefaultTimeout);
 }
 
-TEST_P(Http2IntegrationTest, LargeFlowControlOnAndGiantBody) {
+TEST_P(MultiplexedIntegrationTest, LargeFlowControlOnAndGiantBody) {
   config_helper_.addConfigModifier(ConfigHelper::adjustUpstreamTimeoutForTsan);
   config_helper_.setBufferLimits(128 * 1024,
                                  128 * 1024); // Set buffer limits upstream and downstream.
@@ -65,24 +81,24 @@
                                        TSAN_TIMEOUT_FACTOR * TestUtility::DefaultTimeout);
 }
 
-TEST_P(Http2IntegrationTest, RouterRequestAndResponseWithBodyAndContentLengthNoBuffer) {
+TEST_P(MultiplexedIntegrationTest, RouterRequestAndResponseWithBodyAndContentLengthNoBuffer) {
   testRouterRequestAndResponseWithBody(1024, 512, false, true);
 }
 
-TEST_P(Http2IntegrationTest, RouterRequestAndResponseWithGiantBodyAndContentLengthNoBuffer) {
+TEST_P(MultiplexedIntegrationTest, RouterRequestAndResponseWithGiantBodyAndContentLengthNoBuffer) {
   config_helper_.addConfigModifier(ConfigHelper::adjustUpstreamTimeoutForTsan);
   testRouterRequestAndResponseWithBody(10 * 1024 * 1024, 10 * 1024 * 1024, false, true, nullptr,
                                        TSAN_TIMEOUT_FACTOR * TestUtility::DefaultTimeout);
 }
 
-TEST_P(Http2IntegrationTest, FlowControlOnAndGiantBodyWithContentLength) {
+TEST_P(MultiplexedIntegrationTest, FlowControlOnAndGiantBodyWithContentLength) {
   config_helper_.addConfigModifier(ConfigHelper::adjustUpstreamTimeoutForTsan);
   config_helper_.setBufferLimits(1024, 1024); // Set buffer limits upstream and downstream.
   testRouterRequestAndResponseWithBody(10 * 1024 * 1024, 10 * 1024 * 1024, false, true, nullptr,
                                        TSAN_TIMEOUT_FACTOR * TestUtility::DefaultTimeout);
 }
 
-TEST_P(Http2IntegrationTest, LargeFlowControlOnAndGiantBodyWithContentLength) {
+TEST_P(MultiplexedIntegrationTest, LargeFlowControlOnAndGiantBodyWithContentLength) {
   config_helper_.addConfigModifier(ConfigHelper::adjustUpstreamTimeoutForTsan);
   config_helper_.setBufferLimits(128 * 1024,
                                  128 * 1024); // Set buffer limits upstream and downstream.
@@ -90,42 +106,44 @@
                                        TSAN_TIMEOUT_FACTOR * TestUtility::DefaultTimeout);
 }
 
-TEST_P(Http2IntegrationTest, RouterHeaderOnlyRequestAndResponseNoBuffer) {
+TEST_P(MultiplexedIntegrationTest, RouterHeaderOnlyRequestAndResponseNoBuffer) {
   testRouterHeaderOnlyRequestAndResponse();
 }
 
-TEST_P(Http2IntegrationTest, RouterRequestAndResponseLargeHeaderNoBuffer) {
+TEST_P(MultiplexedIntegrationTest, RouterRequestAndResponseLargeHeaderNoBuffer) {
   testRouterRequestAndResponseWithBody(1024, 512, true);
 }
 
-TEST_P(Http2IntegrationTest, RouterUpstreamDisconnectBeforeRequestcomplete) {
+TEST_P(MultiplexedIntegrationTest, RouterUpstreamDisconnectBeforeRequestcomplete) {
   testRouterUpstreamDisconnectBeforeRequestComplete();
 }
 
-TEST_P(Http2IntegrationTest, RouterUpstreamDisconnectBeforeResponseComplete) {
+TEST_P(MultiplexedIntegrationTest, RouterUpstreamDisconnectBeforeResponseComplete) {
   testRouterUpstreamDisconnectBeforeResponseComplete();
 }
 
-TEST_P(Http2IntegrationTest, RouterDownstreamDisconnectBeforeRequestComplete) {
+TEST_P(MultiplexedIntegrationTest, RouterDownstreamDisconnectBeforeRequestComplete) {
   testRouterDownstreamDisconnectBeforeRequestComplete();
 }
 
-TEST_P(Http2IntegrationTest, RouterDownstreamDisconnectBeforeResponseComplete) {
+TEST_P(MultiplexedIntegrationTest, RouterDownstreamDisconnectBeforeResponseComplete) {
   testRouterDownstreamDisconnectBeforeResponseComplete();
 }
 
-TEST_P(Http2IntegrationTest, RouterUpstreamResponseBeforeRequestComplete) {
+TEST_P(MultiplexedIntegrationTest, RouterUpstreamResponseBeforeRequestComplete) {
   testRouterUpstreamResponseBeforeRequestComplete();
 }
 
-TEST_P(Http2IntegrationTest, Retry) { testRetry(); }
+TEST_P(MultiplexedIntegrationTest, Retry) { testRetry(); }
 
-TEST_P(Http2IntegrationTest, RetryAttemptCount) { testRetryAttemptCountHeader(); }
+TEST_P(MultiplexedIntegrationTest, RetryAttemptCount) { testRetryAttemptCountHeader(); }
 
-TEST_P(Http2IntegrationTest, LargeRequestTrailersRejected) { testLargeRequestTrailers(66, 60); }
+TEST_P(MultiplexedIntegrationTest, LargeRequestTrailersRejected) {
+  testLargeRequestTrailers(66, 60);
+}
 
 // Verify downstream codec stream flush timeout.
-TEST_P(Http2IntegrationTest, CodecStreamIdleTimeout) {
+TEST_P(MultiplexedIntegrationTest, CodecStreamIdleTimeout) {
   config_helper_.setBufferLimits(1024, 1024);
   config_helper_.addConfigModifier(
       [&](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&
@@ -161,7 +179,7 @@
   ASSERT_TRUE(response->waitForReset());
 }
 
-TEST_P(Http2IntegrationTest, Http2DownstreamKeepalive) {
+TEST_P(MultiplexedIntegrationTest, Http2DownstreamKeepalive) {
   // TODO(#16751) Need to support keepalive.
   EXCLUDE_DOWNSTREAM_HTTP3;
   constexpr uint64_t interval_ms = 1;
@@ -197,6 +215,41 @@
   "@type": type.googleapis.com/google.protobuf.Empty
 )EOF";
 
+class Http2MetadataIntegrationTest : public HttpProtocolIntegrationTest {
+public:
+  void SetUp() override {
+    HttpProtocolIntegrationTest::SetUp();
+    config_helper_.addConfigModifier(
+        [&](envoy::config::bootstrap::v3::Bootstrap& bootstrap) -> void {
+          RELEASE_ASSERT(bootstrap.mutable_static_resources()->clusters_size() >= 1, "");
+          ConfigHelper::HttpProtocolOptions protocol_options;
+          protocol_options.mutable_explicit_http_config()
+              ->mutable_http2_protocol_options()
+              ->set_allow_metadata(true);
+          ConfigHelper::setProtocolOptions(
+              *bootstrap.mutable_static_resources()->mutable_clusters(0), protocol_options);
+        });
+    config_helper_.addConfigModifier(
+        [&](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&
+                hcm) -> void { hcm.mutable_http2_protocol_options()->set_allow_metadata(true); });
+  }
+
+  void testRequestMetadataWithStopAllFilter();
+
+  void verifyHeadersOnlyTest();
+
+  void runHeaderOnlyTest(bool send_request_body, size_t body_size);
+
+protected:
+  // Utility function to prepend filters. Note that the filters
+  // are added in reverse order.
+  void prependFilters(std::vector<std::string> filters) {
+    for (const auto& filter : filters) {
+      config_helper_.prependFilter(filter);
+    }
+  }
+};
+
 // Verifies metadata can be sent at different locations of the responses.
 TEST_P(Http2MetadataIntegrationTest, ProxyMetadataInResponse) {
   initialize();
@@ -888,7 +941,7 @@
   EXPECT_EQ(count * size + added_decoded_data_size * 2, response->body().size());
 }
 
-TEST_P(Http2IntegrationTest, GrpcRouterNotFound) {
+TEST_P(MultiplexedIntegrationTest, GrpcRouterNotFound) {
   config_helper_.setDefaultHostAndRoute("foo.com", "/found");
   initialize();
 
@@ -901,10 +954,10 @@
   EXPECT_EQ("12", response->headers().getGrpcStatusValue());
 }
 
-TEST_P(Http2IntegrationTest, GrpcRetry) { testGrpcRetry(); }
+TEST_P(MultiplexedIntegrationTest, GrpcRetry) { testGrpcRetry(); }
 
 // Verify the case where there is an HTTP/2 codec/protocol error with an active stream.
-TEST_P(Http2IntegrationTest, CodecErrorAfterStreamStart) {
+TEST_P(MultiplexedIntegrationTest, CodecErrorAfterStreamStart) {
   EXCLUDE_DOWNSTREAM_HTTP3; // The HTTP/3 client has no "bad frame" equivalent.
   initialize();
   codec_client_ = makeHttpConnection(lookupPort("http"));
@@ -921,7 +974,7 @@
   ASSERT_TRUE(response->waitForEndStream());
 }
 
-TEST_P(Http2IntegrationTest, Http2BadMagic) {
+TEST_P(MultiplexedIntegrationTest, Http2BadMagic) {
   if (downstreamProtocol() == Http::CodecType::HTTP3) {
     // The "magic" payload is an HTTP/2 specific thing.
     return;
@@ -937,7 +990,7 @@
   EXPECT_EQ("", response);
 }
 
-TEST_P(Http2IntegrationTest, BadFrame) {
+TEST_P(MultiplexedIntegrationTest, BadFrame) {
   EXCLUDE_DOWNSTREAM_HTTP3; // The HTTP/3 client has no "bad frame" equivalent.
 
   initialize();
@@ -953,7 +1006,7 @@
 
 // Send client headers, a GoAway and then a body and ensure the full request and
 // response are received.
-TEST_P(Http2IntegrationTest, GoAway) {
+TEST_P(MultiplexedIntegrationTest, GoAway) {
   config_helper_.prependFilter(ConfigHelper::defaultHealthCheckFilter());
   initialize();
 
@@ -971,14 +1024,75 @@
   EXPECT_EQ("200", response->headers().getStatusValue());
 }
 
-TEST_P(Http2IntegrationTest, Trailers) { testTrailers(1024, 2048, false, false); }
+// TODO(rch): Add a unit test which covers internal redirect handling.
+TEST_P(MultiplexedIntegrationTestWithSimulatedTime, GoAwayAfterTooManyResets) {
+  EXCLUDE_DOWNSTREAM_HTTP3; // Need to wait for the server to reset the stream
+                            // before opening new one.
+  config_helper_.addRuntimeOverride("envoy.restart_features.send_goaway_for_premature_rst_streams",
+                                    "true");
+  const int total_streams = 100;
+  config_helper_.addRuntimeOverride("overload.premature_reset_total_stream_count",
+                                    absl::StrCat(total_streams));
+  initialize();
+
+  Http::TestRequestHeaderMapImpl headers{
+      {":method", "GET"}, {":path", "/healthcheck"}, {":scheme", "http"}, {":authority", "host"}};
+  codec_client_ = makeHttpConnection(lookupPort("http"));
+  for (int i = 0; i < total_streams; ++i) {
+    auto encoder_decoder = codec_client_->startRequest(headers);
+    request_encoder_ = &encoder_decoder.first;
+    auto response = std::move(encoder_decoder.second);
+    codec_client_->sendReset(*request_encoder_);
+    ASSERT_TRUE(response->waitForReset());
+  }
 
-TEST_P(Http2IntegrationTest, TrailersGiantBody) {
+  // Envoy should disconnect client due to premature reset check
+  ASSERT_TRUE(codec_client_->waitForDisconnect());
+  test_server_->waitForCounterEq("http.config_test.downstream_rq_rx_reset", total_streams);
+  test_server_->waitForCounterEq("http.config_test.downstream_rq_too_many_premature_resets", 1);
+}
+
+TEST_P(MultiplexedIntegrationTestWithSimulatedTime, DontGoAwayAfterTooManyResetsForLongStreams) {
+  EXCLUDE_DOWNSTREAM_HTTP3; // Need to wait for the server to reset the stream
+                            // before opening new one.
+  config_helper_.addRuntimeOverride("envoy.restart_features.send_goaway_for_premature_rst_streams",
+                                    "true");
+  const int total_streams = 100;
+  const int stream_lifetime_seconds = 2;
+  config_helper_.addRuntimeOverride("overload.premature_reset_total_stream_count",
+                                    absl::StrCat(total_streams));
+
+  config_helper_.addRuntimeOverride("overload.premature_reset_min_stream_lifetime_seconds",
+                                    absl::StrCat(stream_lifetime_seconds));
+
+  initialize();
+
+  Http::TestRequestHeaderMapImpl headers{
+      {":method", "GET"}, {":path", "/healthcheck"}, {":scheme", "http"}, {":authority", "host"}};
+  codec_client_ = makeHttpConnection(lookupPort("http"));
+
+  std::string request_counter = "http.config_test.downstream_rq_total";
+  std::string reset_counter = "http.config_test.downstream_rq_rx_reset";
+  for (int i = 0; i < total_streams * 2; ++i) {
+    auto encoder_decoder = codec_client_->startRequest(headers);
+    request_encoder_ = &encoder_decoder.first;
+    auto response = std::move(encoder_decoder.second);
+    test_server_->waitForCounterEq(request_counter, i + 1);
+    timeSystem().advanceTimeWait(std::chrono::seconds(2 * stream_lifetime_seconds));
+    codec_client_->sendReset(*request_encoder_);
+    ASSERT_TRUE(response->waitForReset());
+    test_server_->waitForCounterEq(reset_counter, i + 1);
+  }
+}
+
+TEST_P(MultiplexedIntegrationTest, Trailers) { testTrailers(1024, 2048, false, false); }
+
+TEST_P(MultiplexedIntegrationTest, TrailersGiantBody) {
   testTrailers(1024 * 1024, 1024 * 1024, false, false);
 }
 
 // Ensure if new timeouts are set, legacy timeouts do not apply.
-TEST_P(Http2IntegrationTest, DEPRECATED_FEATURE_TEST(GrpcRequestTimeoutMixedLegacy)) {
+TEST_P(MultiplexedIntegrationTest, DEPRECATED_FEATURE_TEST(GrpcRequestTimeoutMixedLegacy)) {
   config_helper_.addConfigModifier(
       [&](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&
               hcm) -> void {
@@ -1011,7 +1125,7 @@
   EXPECT_THAT(waitForAccessLog(access_log_name_), HasSubstr("via_upstream\n"));
 }
 
-TEST_P(Http2IntegrationTest, GrpcRequestTimeout) {
+TEST_P(MultiplexedIntegrationTest, GrpcRequestTimeout) {
   config_helper_.addConfigModifier(
       [&](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&
               hcm) -> void {
@@ -1044,7 +1158,7 @@
 }
 
 // Interleave two requests and responses and make sure that idle timeout is handled correctly.
-TEST_P(Http2IntegrationTest, IdleTimeoutWithSimultaneousRequests) {
+TEST_P(MultiplexedIntegrationTest, IdleTimeoutWithSimultaneousRequests) {
   FakeHttpConnectionPtr fake_upstream_connection1;
   FakeHttpConnectionPtr fake_upstream_connection2;
   Http::RequestEncoder* encoder1;
@@ -1133,7 +1247,7 @@
 }
 
 // Test request mirroring / shadowing with an HTTP/2 downstream and a request with a body.
-TEST_P(Http2IntegrationTest, RequestMirrorWithBody) {
+TEST_P(MultiplexedIntegrationTest, RequestMirrorWithBody) {
   config_helper_.addConfigModifier(
       [&](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&
               hcm) -> void {
@@ -1181,7 +1295,8 @@
 }
 
 // Interleave two requests and responses and make sure the HTTP2 stack handles this correctly.
-void Http2IntegrationTest::simultaneousRequest(int32_t request1_bytes, int32_t request2_bytes) {
+void MultiplexedIntegrationTest::simultaneousRequest(int32_t request1_bytes,
+                                                     int32_t request2_bytes) {
   FakeHttpConnectionPtr fake_upstream_connection1;
   FakeHttpConnectionPtr fake_upstream_connection2;
   Http::RequestEncoder* encoder1;
@@ -1250,15 +1365,15 @@
   codec_client_->close();
 }
 
-TEST_P(Http2IntegrationTest, SimultaneousRequest) { simultaneousRequest(1024, 512); }
+TEST_P(MultiplexedIntegrationTest, SimultaneousRequest) { simultaneousRequest(1024, 512); }
 
-TEST_P(Http2IntegrationTest, SimultaneousRequestWithBufferLimits) {
+TEST_P(MultiplexedIntegrationTest, SimultaneousRequestWithBufferLimits) {
   config_helper_.setBufferLimits(1024, 1024); // Set buffer limits upstream and downstream.
   simultaneousRequest(1024 * 32, 1024 * 16);
 }
 
 // Test downstream connection delayed close processing.
-TEST_P(Http2IntegrationTest, DelayedCloseAfterBadFrame) {
+TEST_P(MultiplexedIntegrationTest, DelayedCloseAfterBadFrame) {
   EXCLUDE_DOWNSTREAM_HTTP3; // Needs HTTP/3 "bad frame" equivalent.
   config_helper_.addConfigModifier(
       [](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&
@@ -1288,7 +1403,7 @@
 }
 
 // Test disablement of delayed close processing on downstream connections.
-TEST_P(Http2IntegrationTest, DelayedCloseDisabled) {
+TEST_P(MultiplexedIntegrationTest, DelayedCloseDisabled) {
   EXCLUDE_DOWNSTREAM_HTTP3; // Needs HTTP/3 "bad frame" equivalent.
   config_helper_.addConfigModifier(
       [](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&
@@ -1315,7 +1430,7 @@
             0);
 }
 
-TEST_P(Http2IntegrationTest, PauseAndResume) {
+TEST_P(MultiplexedIntegrationTest, PauseAndResume) {
   config_helper_.prependFilter(R"EOF(
   name: stop-iteration-and-continue-filter
   typed_config:
@@ -1345,7 +1460,7 @@
   ASSERT_TRUE(response->complete());
 }
 
-TEST_P(Http2IntegrationTest, PauseAndResumeHeadersOnly) {
+TEST_P(MultiplexedIntegrationTest, PauseAndResumeHeadersOnly) {
   config_helper_.prependFilter(R"EOF(
   name: stop-iteration-and-continue-filter
   typed_config:
@@ -1368,7 +1483,7 @@
 // Verify the case when we have large pending data with empty trailers. It should not introduce
 // stack-overflow (on ASan build). This is a regression test for
 // https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=24714.
-TEST_P(Http2IntegrationTest, EmptyTrailers) {
+TEST_P(MultiplexedIntegrationTest, EmptyTrailers) {
   initialize();
   codec_client_ = makeHttpConnection(lookupPort("http"));
 
@@ -1386,7 +1501,22 @@
   ASSERT_TRUE(response->complete());
 }
 
-Http2RingHashIntegrationTest::Http2RingHashIntegrationTest() {
+class MultiplexedRingHashIntegrationTest : public HttpProtocolIntegrationTest {
+public:
+  MultiplexedRingHashIntegrationTest();
+
+  ~MultiplexedRingHashIntegrationTest() override;
+
+  void createUpstreams() override;
+
+  void sendMultipleRequests(int request_bytes, Http::TestRequestHeaderMapImpl headers,
+                            std::function<void(IntegrationStreamDecoder&)> cb);
+
+  std::vector<FakeHttpConnectionPtr> fake_upstream_connections_;
+  int num_upstreams_ = 5;
+};
+
+MultiplexedRingHashIntegrationTest::MultiplexedRingHashIntegrationTest() {
   config_helper_.addConfigModifier([&](envoy::config::bootstrap::v3::Bootstrap& bootstrap) -> void {
     auto* cluster = bootstrap.mutable_static_resources()->mutable_clusters(0);
     cluster->clear_load_assignment();
@@ -1405,7 +1535,7 @@
   });
 }
 
-Http2RingHashIntegrationTest::~Http2RingHashIntegrationTest() {
+MultiplexedRingHashIntegrationTest::~MultiplexedRingHashIntegrationTest() {
   if (codec_client_) {
     codec_client_->close();
     codec_client_ = nullptr;
@@ -1418,13 +1548,13 @@
   }
 }
 
-void Http2RingHashIntegrationTest::createUpstreams() {
+void MultiplexedRingHashIntegrationTest::createUpstreams() {
   for (int i = 0; i < num_upstreams_; i++) {
     addFakeUpstream(Http::CodecType::HTTP1);
   }
 }
 
-INSTANTIATE_TEST_SUITE_P(IpVersions, Http2RingHashIntegrationTest,
+INSTANTIATE_TEST_SUITE_P(IpVersions, MultiplexedRingHashIntegrationTest,
                          testing::ValuesIn(HttpProtocolIntegrationTest::getProtocolTestParams(
                              {Http::CodecType::HTTP2}, {Http::CodecType::HTTP1})),
                          HttpProtocolIntegrationTest::protocolTestParamsToString);
@@ -1434,7 +1564,7 @@
                              {Http::CodecType::HTTP2}, {Http::CodecType::HTTP2})),
                          HttpProtocolIntegrationTest::protocolTestParamsToString);
 
-void Http2RingHashIntegrationTest::sendMultipleRequests(
+void MultiplexedRingHashIntegrationTest::sendMultipleRequests(
     int request_bytes, Http::TestRequestHeaderMapImpl headers,
     std::function<void(IntegrationStreamDecoder&)> cb) {
   TestRandomGenerator rand;
@@ -1481,7 +1611,7 @@
   }
 }
 
-TEST_P(Http2RingHashIntegrationTest, CookieRoutingNoCookieNoTtl) {
+TEST_P(MultiplexedRingHashIntegrationTest, CookieRoutingNoCookieNoTtl) {
   config_helper_.addConfigModifier(
       [&](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&
               hcm) -> void {
@@ -1515,7 +1645,7 @@
   EXPECT_EQ(served_by.size(), num_upstreams_);
 }
 
-TEST_P(Http2RingHashIntegrationTest, CookieRoutingNoCookieWithNonzeroTtlSet) {
+TEST_P(MultiplexedRingHashIntegrationTest, CookieRoutingNoCookieWithNonzeroTtlSet) {
   config_helper_.addConfigModifier(
       [&](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&
               hcm) -> void {
@@ -1546,7 +1676,7 @@
   EXPECT_EQ(set_cookies.size(), 1);
 }
 
-TEST_P(Http2RingHashIntegrationTest, CookieRoutingNoCookieWithZeroTtlSet) {
+TEST_P(MultiplexedRingHashIntegrationTest, CookieRoutingNoCookieWithZeroTtlSet) {
   config_helper_.addConfigModifier(
       [&](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&
               hcm) -> void {
@@ -1577,7 +1707,7 @@
   EXPECT_EQ(set_cookies.size(), 1);
 }
 
-TEST_P(Http2RingHashIntegrationTest, CookieRoutingWithCookieNoTtl) {
+TEST_P(MultiplexedRingHashIntegrationTest, CookieRoutingWithCookieNoTtl) {
   config_helper_.addConfigModifier(
       [&](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&
               hcm) -> void {
@@ -1609,7 +1739,7 @@
   EXPECT_EQ(served_by.size(), 1);
 }
 
-TEST_P(Http2RingHashIntegrationTest, CookieRoutingWithCookieWithTtlSet) {
+TEST_P(MultiplexedRingHashIntegrationTest, CookieRoutingWithCookieWithTtlSet) {
   config_helper_.addConfigModifier(
       [&](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&
               hcm) -> void {
@@ -1826,7 +1956,7 @@
   "@type": type.googleapis.com/google.protobuf.Empty
 )EOF";
 
-TEST_P(Http2IntegrationTest, OnLocalReply) {
+TEST_P(MultiplexedIntegrationTest, OnLocalReply) {
   config_helper_.prependFilter(on_local_reply_filter);
   initialize();
 
@@ -1860,7 +1990,7 @@
   }
 }
 
-TEST_P(Http2IntegrationTest, InvalidTrailers) {
+TEST_P(MultiplexedIntegrationTest, InvalidTrailers) {
   useAccessLog("%RESPONSE_CODE_DETAILS%");
   autonomous_upstream_ = true;
   initialize();
diff -Naur envoy/test/integration/multiplexed_integration_test.h envoy-new/test/integration/multiplexed_integration_test.h
--- envoy/test/integration/multiplexed_integration_test.h	2024-01-16 23:42:11.255853818 +0800
+++ envoy-new/test/integration/multiplexed_integration_test.h	1970-01-01 08:00:00.000000000 +0800
@@ -1,69 +0,0 @@
-#pragma once
-
-#include <memory>
-
-#include "envoy/config/bootstrap/v3/bootstrap.pb.h"
-#include "envoy/extensions/filters/network/http_connection_manager/v3/http_connection_manager.pb.h"
-
-#include "test/integration/http_protocol_integration.h"
-
-#include "absl/synchronization/mutex.h"
-#include "gtest/gtest.h"
-
-namespace Envoy {
-class Http2IntegrationTest : public HttpProtocolIntegrationTest {
-public:
-  void simultaneousRequest(int32_t request1_bytes, int32_t request2_bytes);
-
-protected:
-  // Utility function to prepend filters. Note that the filters
-  // are added in reverse order.
-  void prependFilters(std::vector<std::string> filters) {
-    for (const auto& filter : filters) {
-      config_helper_.prependFilter(filter);
-    }
-  }
-};
-
-class Http2RingHashIntegrationTest : public Http2IntegrationTest {
-public:
-  Http2RingHashIntegrationTest();
-
-  ~Http2RingHashIntegrationTest() override;
-
-  void createUpstreams() override;
-
-  void sendMultipleRequests(int request_bytes, Http::TestRequestHeaderMapImpl headers,
-                            std::function<void(IntegrationStreamDecoder&)> cb);
-
-  std::vector<FakeHttpConnectionPtr> fake_upstream_connections_;
-  int num_upstreams_ = 5;
-};
-
-class Http2MetadataIntegrationTest : public Http2IntegrationTest {
-public:
-  void SetUp() override {
-    HttpProtocolIntegrationTest::SetUp();
-    config_helper_.addConfigModifier(
-        [&](envoy::config::bootstrap::v3::Bootstrap& bootstrap) -> void {
-          RELEASE_ASSERT(bootstrap.mutable_static_resources()->clusters_size() >= 1, "");
-          ConfigHelper::HttpProtocolOptions protocol_options;
-          protocol_options.mutable_explicit_http_config()
-              ->mutable_http2_protocol_options()
-              ->set_allow_metadata(true);
-          ConfigHelper::setProtocolOptions(
-              *bootstrap.mutable_static_resources()->mutable_clusters(0), protocol_options);
-        });
-    config_helper_.addConfigModifier(
-        [&](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&
-                hcm) -> void { hcm.mutable_http2_protocol_options()->set_allow_metadata(true); });
-  }
-
-  void testRequestMetadataWithStopAllFilter();
-
-  void verifyHeadersOnlyTest();
-
-  void runHeaderOnlyTest(bool send_request_body, size_t body_size);
-};
-
-} // namespace Envoy
diff -Naur envoy/test/mocks/router/mocks.cc envoy-new/test/mocks/router/mocks.cc
--- envoy/test/mocks/router/mocks.cc	2024-01-16 23:42:11.287854050 +0800
+++ envoy-new/test/mocks/router/mocks.cc	2024-01-16 23:27:25.853358572 +0800
@@ -154,7 +154,7 @@
 MockRouteConfigProviderManager::~MockRouteConfigProviderManager() = default;
 
 MockScopedConfig::MockScopedConfig() {
-  ON_CALL(*this, getRouteConfig(_)).WillByDefault(Return(route_config_));
+  ON_CALL(*this, getRouteConfig(_, _)).WillByDefault(Return(route_config_));
 }
 MockScopedConfig::~MockScopedConfig() = default;
 
diff -Naur envoy/test/mocks/router/mocks.h envoy-new/test/mocks/router/mocks.h
--- envoy/test/mocks/router/mocks.h	2024-01-16 23:42:11.303854166 +0800
+++ envoy-new/test/mocks/router/mocks.h	2024-01-16 23:27:25.853358572 +0800
@@ -566,8 +566,12 @@
 public:
   MockScopedConfig();
   ~MockScopedConfig() override;
-
+#if defined(ALIMESH)
+  MOCK_METHOD(ConfigConstSharedPtr, getRouteConfig,
+              (const Http::HeaderMap& headers, const StreamInfo::StreamInfo&), (const));
+#else
   MOCK_METHOD(ConfigConstSharedPtr, getRouteConfig, (const Http::HeaderMap& headers), (const));
+#endif
 
   std::shared_ptr<MockConfig> route_config_{new NiceMock<MockConfig>()};
 };
diff -Naur envoy/test/mocks/router/mocks.h.orig envoy-new/test/mocks/router/mocks.h.orig
--- envoy/test/mocks/router/mocks.h.orig	1970-01-01 08:00:00.000000000 +0800
+++ envoy-new/test/mocks/router/mocks.h.orig	2024-01-16 23:27:15.581282814 +0800
@@ -0,0 +1,658 @@
+#pragma once
+
+#include <chrono>
+#include <cstdint>
+#include <list>
+#include <map>
+#include <memory>
+#include <string>
+#include <vector>
+
+#include "envoy/common/time.h"
+#include "envoy/config/config_provider.h"
+#include "envoy/config/core/v3/base.pb.h"
+#include "envoy/config/route/v3/route.pb.h"
+#include "envoy/config/typed_metadata.h"
+#include "envoy/event/dispatcher.h"
+#include "envoy/extensions/filters/network/http_connection_manager/v3/http_connection_manager.pb.h"
+#include "envoy/http/hash_policy.h"
+#include "envoy/local_info/local_info.h"
+#include "envoy/router/cluster_specifier_plugin.h"
+#include "envoy/router/rds.h"
+#include "envoy/router/route_config_provider_manager.h"
+#include "envoy/router/router.h"
+#include "envoy/router/router_ratelimit.h"
+#include "envoy/router/scopes.h"
+#include "envoy/router/shadow_writer.h"
+#include "envoy/runtime/runtime.h"
+#include "envoy/stream_info/filter_state.h"
+#include "envoy/thread_local/thread_local.h"
+#include "envoy/type/v3/percent.pb.h"
+#include "envoy/upstream/cluster_manager.h"
+
+#include "source/common/stats/symbol_table_impl.h"
+
+#include "test/mocks/stats/mocks.h"
+#include "test/test_common/global.h"
+
+#include "gmock/gmock.h"
+
+namespace Envoy {
+namespace Router {
+using ::testing::NiceMock;
+
+class MockDirectResponseEntry : public DirectResponseEntry {
+public:
+  MockDirectResponseEntry();
+  ~MockDirectResponseEntry() override;
+
+  // DirectResponseEntry
+  MOCK_METHOD(void, finalizeResponseHeaders,
+              (Http::ResponseHeaderMap & headers, const StreamInfo::StreamInfo& stream_info),
+              (const));
+  MOCK_METHOD(Http::HeaderTransforms, responseHeaderTransforms,
+              (const StreamInfo::StreamInfo& stream_info, bool do_formatting), (const));
+  MOCK_METHOD(std::string, newPath, (const Http::RequestHeaderMap& headers), (const));
+  MOCK_METHOD(void, rewritePathHeader,
+              (Http::RequestHeaderMap & headers, bool insert_envoy_original_path), (const));
+  MOCK_METHOD(Http::Code, responseCode, (), (const));
+  MOCK_METHOD(const std::string&, responseBody, (), (const));
+  MOCK_METHOD(const std::string&, routeName, (), (const));
+};
+
+class TestCorsPolicy : public CorsPolicy {
+public:
+  // Router::CorsPolicy
+  const std::vector<Matchers::StringMatcherPtr>& allowOrigins() const override {
+    return allow_origins_;
+  };
+  const std::string& allowMethods() const override { return allow_methods_; };
+  const std::string& allowHeaders() const override { return allow_headers_; };
+  const std::string& exposeHeaders() const override { return expose_headers_; };
+  const std::string& maxAge() const override { return max_age_; };
+  const absl::optional<bool>& allowCredentials() const override { return allow_credentials_; };
+  bool enabled() const override { return enabled_; };
+  bool shadowEnabled() const override { return shadow_enabled_; };
+
+  std::vector<Matchers::StringMatcherPtr> allow_origins_;
+  std::string allow_methods_;
+  std::string allow_headers_;
+  std::string expose_headers_;
+  std::string max_age_{};
+  absl::optional<bool> allow_credentials_;
+  bool enabled_{};
+  bool shadow_enabled_{};
+};
+
+class TestHedgePolicy : public HedgePolicy {
+public:
+  // Router::HedgePolicy
+  uint32_t initialRequests() const override { return initial_requests_; }
+  const envoy::type::v3::FractionalPercent& additionalRequestChance() const override {
+    return additional_request_chance_;
+  }
+  bool hedgeOnPerTryTimeout() const override { return hedge_on_per_try_timeout_; }
+
+  uint32_t initial_requests_{};
+  envoy::type::v3::FractionalPercent additional_request_chance_{};
+  bool hedge_on_per_try_timeout_{};
+};
+
+class TestRetryPolicy : public RetryPolicy {
+public:
+  TestRetryPolicy();
+  ~TestRetryPolicy() override;
+
+  // Router::RetryPolicy
+  std::chrono::milliseconds perTryTimeout() const override { return per_try_timeout_; }
+  std::chrono::milliseconds perTryIdleTimeout() const override { return per_try_idle_timeout_; }
+  uint32_t numRetries() const override { return num_retries_; }
+  uint32_t retryOn() const override { return retry_on_; }
+  MOCK_METHOD(std::vector<Upstream::RetryHostPredicateSharedPtr>, retryHostPredicates, (), (const));
+  MOCK_METHOD(Upstream::RetryPrioritySharedPtr, retryPriority, (), (const));
+  absl::Span<const Upstream::RetryOptionsPredicateConstSharedPtr>
+  retryOptionsPredicates() const override {
+    return retry_options_predicates_;
+  }
+  uint32_t hostSelectionMaxAttempts() const override { return host_selection_max_attempts_; }
+  const std::vector<uint32_t>& retriableStatusCodes() const override {
+    return retriable_status_codes_;
+  }
+  const std::vector<Http::HeaderMatcherSharedPtr>& retriableHeaders() const override {
+    return retriable_headers_;
+  }
+  const std::vector<Http::HeaderMatcherSharedPtr>& retriableRequestHeaders() const override {
+    return retriable_request_headers_;
+  }
+
+  absl::optional<std::chrono::milliseconds> baseInterval() const override { return base_interval_; }
+  absl::optional<std::chrono::milliseconds> maxInterval() const override { return max_interval_; }
+  std::chrono::milliseconds resetMaxInterval() const override { return reset_max_interval_; }
+  const std::vector<ResetHeaderParserSharedPtr>& resetHeaders() const override {
+    return reset_headers_;
+  }
+
+  std::chrono::milliseconds per_try_timeout_{0};
+  std::chrono::milliseconds per_try_idle_timeout_{0};
+  uint32_t num_retries_{};
+  uint32_t retry_on_{};
+  uint32_t host_selection_max_attempts_;
+  std::vector<uint32_t> retriable_status_codes_;
+  std::vector<Http::HeaderMatcherSharedPtr> retriable_headers_;
+  std::vector<Http::HeaderMatcherSharedPtr> retriable_request_headers_;
+  absl::optional<std::chrono::milliseconds> base_interval_{};
+  absl::optional<std::chrono::milliseconds> max_interval_{};
+  std::vector<ResetHeaderParserSharedPtr> reset_headers_{};
+  std::chrono::milliseconds reset_max_interval_{300000};
+  std::vector<Upstream::RetryOptionsPredicateConstSharedPtr> retry_options_predicates_;
+};
+
+class MockInternalRedirectPolicy : public InternalRedirectPolicy {
+public:
+  MockInternalRedirectPolicy();
+  MOCK_METHOD(bool, enabled, (), (const));
+  MOCK_METHOD(bool, shouldRedirectForResponseCode, (const Http::Code& response_code), (const));
+  MOCK_METHOD(std::vector<InternalRedirectPredicateSharedPtr>, predicates, (), (const));
+  MOCK_METHOD(uint32_t, maxInternalRedirects, (), (const));
+  MOCK_METHOD(bool, isCrossSchemeRedirectAllowed, (), (const));
+};
+
+#if defined(ALIMESH)
+class MockInternalActiveRedirectPolicy : public InternalActiveRedirectPolicy {
+public:
+  MockInternalActiveRedirectPolicy();
+  MOCK_METHOD(bool, enabled, (), (const));
+  MOCK_METHOD(bool, shouldRedirectForResponseCode, (const Http::Code& response_code), (const));
+  MOCK_METHOD(std::vector<InternalRedirectPredicateSharedPtr>, predicates, (), (const));
+  MOCK_METHOD(uint32_t, maxInternalRedirects, (), (const));
+  MOCK_METHOD(bool, isCrossSchemeRedirectAllowed, (), (const));
+  MOCK_METHOD(void, evaluateHeaders, (Http::HeaderMap&, const StreamInfo::StreamInfo*), (const));
+  MOCK_METHOD(std::string, redirectUrl, (absl::optional<std::string>), (const));
+  MOCK_METHOD(bool, forcedUseOriginalHost, (), (const));
+  MOCK_METHOD(bool, forcedAddHeaderBeforeRouteMatcher, (), (const));
+};
+#endif
+
+class MockInternalRedirectPredicate : public InternalRedirectPredicate {
+public:
+  MOCK_METHOD(bool, acceptTargetRoute, (StreamInfo::FilterState&, absl::string_view, bool, bool));
+  MOCK_METHOD(absl::string_view, name, (), (const));
+};
+
+class MockRetryState : public RetryState {
+public:
+  MockRetryState();
+  ~MockRetryState() override;
+
+  void expectHeadersRetry();
+  void expectHedgedPerTryTimeoutRetry();
+  void expectResetRetry();
+
+  MOCK_METHOD(bool, enabled, ());
+  MOCK_METHOD(absl::optional<std::chrono::milliseconds>, parseResetInterval,
+              (const Http::ResponseHeaderMap& response_headers), (const));
+  MOCK_METHOD(RetryStatus, shouldRetryHeaders,
+              (const Http::ResponseHeaderMap& response_headers, DoRetryCallback callback));
+  MOCK_METHOD(bool, wouldRetryFromHeaders, (const Http::ResponseHeaderMap& response_headers));
+  MOCK_METHOD(RetryStatus, shouldRetryReset,
+              (const Http::StreamResetReason reset_reason, DoRetryCallback callback));
+  MOCK_METHOD(RetryStatus, shouldHedgeRetryPerTryTimeout, (DoRetryCallback callback));
+  MOCK_METHOD(void, onHostAttempted, (Upstream::HostDescriptionConstSharedPtr));
+  MOCK_METHOD(bool, shouldSelectAnotherHost, (const Upstream::Host& host));
+  MOCK_METHOD(const Upstream::HealthyAndDegradedLoad&, priorityLoadForRetry,
+              (const Upstream::PrioritySet&, const Upstream::HealthyAndDegradedLoad&,
+               const Upstream::RetryPriority::PriorityMappingFunc&));
+  MOCK_METHOD(uint32_t, hostSelectionMaxAttempts, (), (const));
+
+  DoRetryCallback callback_;
+};
+
+class MockRateLimitPolicyEntry : public RateLimitPolicyEntry {
+public:
+  MockRateLimitPolicyEntry();
+  ~MockRateLimitPolicyEntry() override;
+
+  // Router::RateLimitPolicyEntry
+  MOCK_METHOD(uint64_t, stage, (), (const));
+  MOCK_METHOD(const std::string&, disableKey, (), (const));
+  MOCK_METHOD(void, populateDescriptors,
+              (std::vector<Envoy::RateLimit::Descriptor> & descriptors,
+               const std::string& local_service_cluster, const Http::RequestHeaderMap& headers,
+               const StreamInfo::StreamInfo& info),
+              (const));
+  MOCK_METHOD(void, populateLocalDescriptors,
+              (std::vector<Envoy::RateLimit::LocalDescriptor> & descriptors,
+               const std::string& local_service_cluster, const Http::RequestHeaderMap& headers,
+               const StreamInfo::StreamInfo& info),
+              (const));
+
+  uint64_t stage_{};
+  std::string disable_key_;
+};
+
+class MockRateLimitPolicy : public RateLimitPolicy {
+public:
+  MockRateLimitPolicy();
+  ~MockRateLimitPolicy() override;
+
+  // Router::RateLimitPolicy
+  MOCK_METHOD(std::vector<std::reference_wrapper<const RateLimitPolicyEntry>>&,
+              getApplicableRateLimit, (uint64_t stage), (const));
+  MOCK_METHOD(bool, empty, (), (const));
+
+  std::vector<std::reference_wrapper<const Router::RateLimitPolicyEntry>> rate_limit_policy_entry_;
+};
+
+class TestShadowPolicy : public ShadowPolicy {
+public:
+  TestShadowPolicy(absl::string_view cluster = "", absl::string_view runtime_key = "",
+                   envoy::type::v3::FractionalPercent default_value = {}, bool trace_sampled = true)
+      : cluster_(cluster), runtime_key_(runtime_key), default_value_(default_value),
+        trace_sampled_(trace_sampled) {}
+  // Router::ShadowPolicy
+  const std::string& cluster() const override { return cluster_; }
+  const std::string& runtimeKey() const override { return runtime_key_; }
+  const envoy::type::v3::FractionalPercent& defaultValue() const override { return default_value_; }
+  bool traceSampled() const override { return trace_sampled_; }
+
+  std::string cluster_;
+  std::string runtime_key_;
+  envoy::type::v3::FractionalPercent default_value_;
+  bool trace_sampled_;
+};
+
+class MockShadowWriter : public ShadowWriter {
+public:
+  MockShadowWriter();
+  ~MockShadowWriter() override;
+
+  // Router::ShadowWriter
+  void shadow(const std::string& cluster, Http::RequestMessagePtr&& request,
+              const Http::AsyncClient::RequestOptions& options) override {
+    shadow_(cluster, request, options);
+  }
+
+  MOCK_METHOD(void, shadow_,
+              (const std::string& cluster, Http::RequestMessagePtr& request,
+               const Http::AsyncClient::RequestOptions& options));
+};
+
+class TestVirtualCluster : public VirtualCluster {
+public:
+  // Router::VirtualCluster
+  const absl::optional<std::string>& name() const override { return name_; }
+  Stats::StatName statName() const override { return stat_name_.statName(); }
+  VirtualClusterStats& stats() const override { return stats_; }
+
+  const absl::optional<std::string> name_ = "fake_virtual_cluster";
+  Stats::TestUtil::TestSymbolTable symbol_table_;
+  Stats::StatNameManagedStorage stat_name_{"fake_virtual_cluster", *symbol_table_};
+  Stats::IsolatedStoreImpl stats_store_;
+  VirtualClusterStatNames stat_names_{stats_store_.symbolTable()};
+  mutable VirtualClusterStats stats_{generateStats(stats_store_, stat_names_)};
+};
+
+class MockVirtualHost : public VirtualHost {
+public:
+  MockVirtualHost();
+  ~MockVirtualHost() override;
+
+  // Router::VirtualHost
+  MOCK_METHOD(const std::string&, name, (), (const));
+  MOCK_METHOD(const RateLimitPolicy&, rateLimitPolicy, (), (const));
+  MOCK_METHOD(const CorsPolicy*, corsPolicy, (), (const));
+  MOCK_METHOD(const Config&, routeConfig, (), (const));
+  MOCK_METHOD(const RouteSpecificFilterConfig*, perFilterConfig, (const std::string&), (const));
+  MOCK_METHOD(bool, includeAttemptCountInRequest, (), (const));
+  MOCK_METHOD(bool, includeAttemptCountInResponse, (), (const));
+  MOCK_METHOD(Upstream::RetryPrioritySharedPtr, retryPriority, ());
+  MOCK_METHOD(Upstream::RetryHostPredicateSharedPtr, retryHostPredicate, ());
+  MOCK_METHOD(uint32_t, retryShadowBufferLimit, (), (const));
+
+  Stats::StatName statName() const override {
+    stat_name_ = std::make_unique<Stats::StatNameManagedStorage>(name(), *symbol_table_);
+    return stat_name_->statName();
+  }
+
+  mutable Stats::TestUtil::TestSymbolTable symbol_table_;
+  std::string name_{"fake_vhost"};
+  mutable std::unique_ptr<Stats::StatNameManagedStorage> stat_name_;
+  testing::NiceMock<MockRateLimitPolicy> rate_limit_policy_;
+  TestCorsPolicy cors_policy_;
+};
+
+class MockHashPolicy : public Http::HashPolicy {
+public:
+  MockHashPolicy();
+  ~MockHashPolicy() override;
+
+  // Http::HashPolicy
+  MOCK_METHOD(absl::optional<uint64_t>, generateHash,
+              (const Network::Address::Instance* downstream_address,
+               const Http::RequestHeaderMap& headers, const AddCookieCallback add_cookie,
+               const StreamInfo::FilterStateSharedPtr filter_state),
+              (const));
+};
+
+class MockMetadataMatchCriteria : public MetadataMatchCriteria {
+public:
+  MockMetadataMatchCriteria();
+  ~MockMetadataMatchCriteria() override;
+
+  // Router::MetadataMatchCriteria
+  MOCK_METHOD(const std::vector<MetadataMatchCriterionConstSharedPtr>&, metadataMatchCriteria, (),
+              (const));
+  MOCK_METHOD(MetadataMatchCriteriaConstPtr, mergeMatchCriteria, (const ProtobufWkt::Struct&),
+              (const));
+  MOCK_METHOD(MetadataMatchCriteriaConstPtr, filterMatchCriteria, (const std::set<std::string>&),
+              (const));
+};
+
+class MockTlsContextMatchCriteria : public TlsContextMatchCriteria {
+public:
+  MockTlsContextMatchCriteria();
+  ~MockTlsContextMatchCriteria() override;
+
+  // Router::MockTlsContextMatchCriteria
+  MOCK_METHOD(const absl::optional<bool>&, presented, (), (const));
+  MOCK_METHOD(const absl::optional<bool>&, validated, (), (const));
+};
+
+class MockPathMatchCriterion : public PathMatchCriterion {
+public:
+  MockPathMatchCriterion();
+  ~MockPathMatchCriterion() override;
+
+  // Router::PathMatchCriterion
+  MOCK_METHOD(PathMatchType, matchType, (), (const));
+  MOCK_METHOD(const std::string&, matcher, (), (const));
+
+  PathMatchType type_;
+  std::string matcher_;
+};
+
+class MockRouteEntry : public RouteEntry {
+public:
+  MockRouteEntry();
+  ~MockRouteEntry() override;
+
+  // Router::Config
+  MOCK_METHOD(const std::string&, clusterName, (), (const));
+  MOCK_METHOD(Http::Code, clusterNotFoundResponseCode, (), (const));
+  MOCK_METHOD(void, finalizeRequestHeaders,
+              (Http::RequestHeaderMap & headers, const StreamInfo::StreamInfo& stream_info,
+               bool insert_envoy_original_path),
+              (const));
+  MOCK_METHOD(void, finalizeResponseHeaders,
+              (Http::ResponseHeaderMap & headers, const StreamInfo::StreamInfo& stream_info),
+              (const));
+  MOCK_METHOD(Http::HeaderTransforms, responseHeaderTransforms,
+              (const StreamInfo::StreamInfo& stream_info, bool do_formatting), (const));
+  MOCK_METHOD(const Http::HashPolicy*, hashPolicy, (), (const));
+  MOCK_METHOD(const HedgePolicy&, hedgePolicy, (), (const));
+  MOCK_METHOD(const Router::MetadataMatchCriteria*, metadataMatchCriteria, (), (const));
+  MOCK_METHOD(const Router::TlsContextMatchCriteria*, tlsContextMatchCriteria, (), (const));
+  MOCK_METHOD(Upstream::ResourcePriority, priority, (), (const));
+  MOCK_METHOD(const RateLimitPolicy&, rateLimitPolicy, (), (const));
+  MOCK_METHOD(const RetryPolicy&, retryPolicy, (), (const));
+  MOCK_METHOD(const InternalRedirectPolicy&, internalRedirectPolicy, (), (const));
+  MOCK_METHOD(uint32_t, retryShadowBufferLimit, (), (const));
+  MOCK_METHOD(const std::vector<ShadowPolicyPtr>&, shadowPolicies, (), (const));
+  MOCK_METHOD(std::chrono::milliseconds, timeout, (), (const));
+  MOCK_METHOD(absl::optional<std::chrono::milliseconds>, idleTimeout, (), (const));
+  MOCK_METHOD(bool, usingNewTimeouts, (), (const));
+  MOCK_METHOD(absl::optional<std::chrono::milliseconds>, maxStreamDuration, (), (const));
+  MOCK_METHOD(absl::optional<std::chrono::milliseconds>, grpcTimeoutHeaderMax, (), (const));
+  MOCK_METHOD(absl::optional<std::chrono::milliseconds>, grpcTimeoutHeaderOffset, (), (const));
+  MOCK_METHOD(absl::optional<std::chrono::milliseconds>, maxGrpcTimeout, (), (const));
+  MOCK_METHOD(absl::optional<std::chrono::milliseconds>, grpcTimeoutOffset, (), (const));
+  MOCK_METHOD(const VirtualCluster*, virtualCluster, (const Http::HeaderMap& headers), (const));
+  MOCK_METHOD(const VirtualHost&, virtualHost, (), (const));
+  MOCK_METHOD(bool, autoHostRewrite, (), (const));
+  MOCK_METHOD(bool, appendXfh, (), (const));
+  MOCK_METHOD((const std::multimap<std::string, std::string>&), opaqueConfig, (), (const));
+  MOCK_METHOD(bool, includeVirtualHostRateLimits, (), (const));
+  MOCK_METHOD(const CorsPolicy*, corsPolicy, (), (const));
+  MOCK_METHOD(absl::optional<std::string>, currentUrlPathAfterRewrite,
+              (const Http::RequestHeaderMap&), (const));
+  MOCK_METHOD(const PathMatchCriterion&, pathMatchCriterion, (), (const));
+  MOCK_METHOD(bool, includeAttemptCountInRequest, (), (const));
+  MOCK_METHOD(bool, includeAttemptCountInResponse, (), (const));
+  MOCK_METHOD(const absl::optional<ConnectConfig>&, connectConfig, (), (const));
+  MOCK_METHOD(const UpgradeMap&, upgradeMap, (), (const));
+  MOCK_METHOD(const std::string&, routeName, (), (const));
+
+#if defined(ALIMESH)
+  MOCK_METHOD(const InternalActiveRedirectPolicy&, internalActiveRedirectPolicy, (), (const));
+#endif
+
+  const RouteStatsContextOptRef routeStatsContext() const override {
+    return RouteStatsContextOptRef();
+  }
+
+  std::string cluster_name_{"fake_cluster"};
+  std::string route_name_{"fake_route_name"};
+  std::multimap<std::string, std::string> opaque_config_;
+  TestVirtualCluster virtual_cluster_;
+  TestRetryPolicy retry_policy_;
+  testing::NiceMock<MockInternalRedirectPolicy> internal_redirect_policy_;
+  TestHedgePolicy hedge_policy_;
+  testing::NiceMock<MockRateLimitPolicy> rate_limit_policy_;
+  std::vector<ShadowPolicyPtr> shadow_policies_;
+  testing::NiceMock<MockVirtualHost> virtual_host_;
+  MockHashPolicy hash_policy_;
+  MockMetadataMatchCriteria metadata_matches_criteria_;
+  MockTlsContextMatchCriteria tls_context_matches_criteria_;
+  TestCorsPolicy cors_policy_;
+  testing::NiceMock<MockPathMatchCriterion> path_match_criterion_;
+  UpgradeMap upgrade_map_;
+  absl::optional<ConnectConfig> connect_config_;
+
+#if defined(ALIMESH)
+  testing::NiceMock<MockInternalActiveRedirectPolicy> internal_active_redirect_policy_;
+#endif
+};
+
+class MockDecorator : public Decorator {
+public:
+  MockDecorator();
+  ~MockDecorator() override;
+
+  // Router::Decorator
+  MOCK_METHOD(const std::string&, getOperation, (), (const));
+  MOCK_METHOD(bool, propagate, (), (const));
+  MOCK_METHOD(void, apply, (Tracing::Span & span), (const));
+
+  std::string operation_{"fake_operation"};
+};
+
+class MockRouteTracing : public RouteTracing {
+public:
+  MockRouteTracing();
+  ~MockRouteTracing() override;
+
+  // Router::RouteTracing
+  MOCK_METHOD(const envoy::type::v3::FractionalPercent&, getClientSampling, (), (const));
+  MOCK_METHOD(const envoy::type::v3::FractionalPercent&, getRandomSampling, (), (const));
+  MOCK_METHOD(const envoy::type::v3::FractionalPercent&, getOverallSampling, (), (const));
+  MOCK_METHOD(const Tracing::CustomTagMap&, getCustomTags, (), (const));
+};
+
+class MockRoute : public Route {
+public:
+  MockRoute();
+  ~MockRoute() override;
+
+  // Router::Route
+  MOCK_METHOD(const DirectResponseEntry*, directResponseEntry, (), (const));
+  MOCK_METHOD(const RouteEntry*, routeEntry, (), (const));
+  MOCK_METHOD(const Decorator*, decorator, (), (const));
+  MOCK_METHOD(const RouteTracing*, tracingConfig, (), (const));
+  MOCK_METHOD(const RouteSpecificFilterConfig*, perFilterConfig, (const std::string&), (const));
+  MOCK_METHOD(const RouteSpecificFilterConfig*, mostSpecificPerFilterConfig, (const std::string&),
+              (const));
+  MOCK_METHOD(void, traversePerFilterConfig,
+              (const std::string&, std::function<void(const Router::RouteSpecificFilterConfig&)>),
+              (const));
+  MOCK_METHOD(const envoy::config::core::v3::Metadata&, metadata, (), (const));
+  MOCK_METHOD(const Envoy::Config::TypedMetadata&, typedMetadata, (), (const));
+
+  testing::NiceMock<MockRouteEntry> route_entry_;
+  testing::NiceMock<MockDecorator> decorator_;
+  testing::NiceMock<MockRouteTracing> route_tracing_;
+  envoy::config::core::v3::Metadata metadata_;
+};
+
+class MockConfig : public Config {
+public:
+  MockConfig();
+  ~MockConfig() override;
+
+  // Router::Config
+  MOCK_METHOD(RouteConstSharedPtr, route,
+              (const Http::RequestHeaderMap&, const Envoy::StreamInfo::StreamInfo&,
+               uint64_t random_value),
+              (const));
+  MOCK_METHOD(RouteConstSharedPtr, route,
+              (const RouteCallback& cb, const Http::RequestHeaderMap&,
+               const Envoy::StreamInfo::StreamInfo&, uint64_t random_value),
+              (const));
+
+  MOCK_METHOD(const std::list<Http::LowerCaseString>&, internalOnlyHeaders, (), (const));
+  MOCK_METHOD(const std::string&, name, (), (const));
+  MOCK_METHOD(bool, usesVhds, (), (const));
+  MOCK_METHOD(bool, mostSpecificHeaderMutationsWins, (), (const));
+  MOCK_METHOD(uint32_t, maxDirectResponseBodySizeBytes, (), (const));
+
+  std::shared_ptr<MockRoute> route_;
+  std::list<Http::LowerCaseString> internal_only_headers_;
+  std::string name_{"fake_config"};
+};
+
+class MockRouteConfigProvider : public RouteConfigProvider {
+public:
+  MockRouteConfigProvider();
+  ~MockRouteConfigProvider() override;
+
+  MOCK_METHOD(ConfigConstSharedPtr, config, ());
+  MOCK_METHOD(absl::optional<ConfigInfo>, configInfo, (), (const));
+  MOCK_METHOD(SystemTime, lastUpdated, (), (const));
+  MOCK_METHOD(void, onConfigUpdate, ());
+  MOCK_METHOD(void, requestVirtualHostsUpdate,
+              (const std::string&, Event::Dispatcher&,
+               std::weak_ptr<Http::RouteConfigUpdatedCallback> route_config_updated_cb));
+
+  std::shared_ptr<NiceMock<MockConfig>> route_config_{new NiceMock<MockConfig>()};
+};
+
+class MockRouteConfigProviderManager : public RouteConfigProviderManager {
+public:
+  MockRouteConfigProviderManager();
+  ~MockRouteConfigProviderManager() override;
+
+  MOCK_METHOD(RouteConfigProviderSharedPtr, createRdsRouteConfigProvider,
+              (const envoy::extensions::filters::network::http_connection_manager::v3::Rds& rds,
+               const OptionalHttpFilters& optional_http_filters,
+               Server::Configuration::ServerFactoryContext& factory_context,
+               const std::string& stat_prefix, Init::Manager& init_manager));
+  MOCK_METHOD(RouteConfigProviderPtr, createStaticRouteConfigProvider,
+              (const envoy::config::route::v3::RouteConfiguration& route_config,
+               const OptionalHttpFilters& optional_http_filters,
+               Server::Configuration::ServerFactoryContext& factory_context,
+               ProtobufMessage::ValidationVisitor& validator));
+};
+
+class MockScopedConfig : public ScopedConfig {
+public:
+  MockScopedConfig();
+  ~MockScopedConfig() override;
+
+  MOCK_METHOD(ConfigConstSharedPtr, getRouteConfig, (const Http::HeaderMap& headers), (const));
+
+  std::shared_ptr<MockConfig> route_config_{new NiceMock<MockConfig>()};
+};
+
+class MockScopedRouteConfigProvider : public Envoy::Config::ConfigProvider {
+public:
+  MockScopedRouteConfigProvider();
+  ~MockScopedRouteConfigProvider() override;
+
+  // Config::ConfigProvider
+  MOCK_METHOD(SystemTime, lastUpdated, (), (const));
+  MOCK_METHOD(Protobuf::Message*, getConfigProto, (), (const));
+  MOCK_METHOD(Envoy::Config::ConfigProvider::ConfigProtoVector, getConfigProtos, (), (const));
+  MOCK_METHOD(ConfigConstSharedPtr, getConfig, (), (const));
+  MOCK_METHOD(ApiType, apiType, (), (const));
+
+  std::shared_ptr<MockScopedConfig> config_;
+};
+
+class MockGenericConnPool : public GenericConnPool {
+  MOCK_METHOD(void, newStream, (GenericConnectionPoolCallbacks * request));
+  MOCK_METHOD(bool, cancelAnyPendingStream, ());
+  MOCK_METHOD(absl::optional<Http::Protocol>, protocol, (), (const));
+  MOCK_METHOD(bool, initialize,
+              (Upstream::ClusterManager&, const RouteEntry&, Http::Protocol,
+               Upstream::LoadBalancerContext*));
+  MOCK_METHOD(Upstream::HostDescriptionConstSharedPtr, host, (), (const));
+};
+
+class MockUpstreamToDownstream : public UpstreamToDownstream {
+public:
+  MOCK_METHOD(const Route&, route, (), (const));
+  MOCK_METHOD(const Network::Connection&, connection, (), (const));
+
+  MOCK_METHOD(void, decodeData, (Buffer::Instance&, bool));
+  MOCK_METHOD(void, decodeMetadata, (Http::MetadataMapPtr &&));
+  MOCK_METHOD(void, decode100ContinueHeaders, (Http::ResponseHeaderMapPtr &&));
+  MOCK_METHOD(void, decodeHeaders, (Http::ResponseHeaderMapPtr&&, bool));
+  MOCK_METHOD(void, decodeTrailers, (Http::ResponseTrailerMapPtr &&));
+  MOCK_METHOD(void, dumpState, (std::ostream&, int), (const));
+
+  MOCK_METHOD(void, onResetStream, (Http::StreamResetReason, absl::string_view));
+  MOCK_METHOD(void, onAboveWriteBufferHighWatermark, ());
+  MOCK_METHOD(void, onBelowWriteBufferLowWatermark, ());
+};
+
+class MockGenericConnectionPoolCallbacks : public GenericConnectionPoolCallbacks {
+public:
+  MockGenericConnectionPoolCallbacks();
+
+  MOCK_METHOD(void, onPoolFailure,
+              (Http::ConnectionPool::PoolFailureReason reason,
+               absl::string_view transport_failure_reason,
+               Upstream::HostDescriptionConstSharedPtr host));
+  MOCK_METHOD(void, onPoolReady,
+              (std::unique_ptr<GenericUpstream> && upstream,
+               Upstream::HostDescriptionConstSharedPtr host,
+               const Network::Address::InstanceConstSharedPtr& upstream_local_address,
+               const StreamInfo::StreamInfo& info, absl::optional<Http::Protocol> protocol));
+  MOCK_METHOD(UpstreamToDownstream&, upstreamToDownstream, ());
+
+  NiceMock<MockUpstreamToDownstream> upstream_to_downstream_;
+};
+
+class MockClusterSpecifierPlugin : public ClusterSpecifierPlugin {
+public:
+  MockClusterSpecifierPlugin();
+
+  MOCK_METHOD(RouteConstSharedPtr, route,
+              (const RouteEntry& parent, const Http::RequestHeaderMap& header), (const));
+};
+
+class MockClusterSpecifierPluginFactoryConfig : public ClusterSpecifierPluginFactoryConfig {
+public:
+  MockClusterSpecifierPluginFactoryConfig();
+  MOCK_METHOD(ClusterSpecifierPluginSharedPtr, createClusterSpecifierPlugin,
+              (const Protobuf::Message& config,
+               Server::Configuration::CommonFactoryContext& context));
+
+  ProtobufTypes::MessagePtr createEmptyConfigProto() override {
+    return std::make_unique<ProtobufWkt::Struct>();
+  }
+
+  std::string name() const override { return "envoy.router.cluster_specifier_plugin.mock"; }
+};
+
+} // namespace Router
+} // namespace Envoy
