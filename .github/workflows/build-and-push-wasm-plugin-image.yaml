name: Build and Push Wasm Plugin Image

on:
  push:
    branches: [main]
    tags:
      - "wasm-*-*-v*.*.*"  # 匹配 wasm-{go|rust}-{pluginName}-vX.Y.Z
    paths:
      - 'plugins/wasm-go/extensions/**'
      - 'plugins/wasm-rust/extensions/**'
  pull_request:
    types: [closed]      # 只在 PR 合并到 main 时触发（closed 且 merged）
    branches: [main]
    paths:
      - 'plugins/wasm-go/extensions/**'
      - 'plugins/wasm-rust/extensions/**'
  workflow_dispatch:
    inputs:
      plugin_type:
        description: 'Type of the plugin'
        required: true
        type: choice
        options: [go, rust]
      plugin_name:
        description: 'Name of the plugin'
        required: true
        type: string

jobs:
  detect:
    runs-on: ubuntu-latest
    outputs:
      plugins: ${{ steps.set-plugins.outputs.changed_plugins }}
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0   # 需要完整历史以 diff PR 和分支间差异

      # ─────────────────────────────────────────────────────────────────────
      # 1) Use GitHub REST API to get PR files
      - name: Get PR changed files via API
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v6
        id: pr_files
        with:
          script: |
            const pr = context.payload.pull_request;
            const resp = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr.number
            });
            const files = resp.data.map(f => f.filename).join('\n');
            core.setOutput('files', files);

      # ─────────────────────────────────────────────────────────────────────
      # 2) Fallback to git-diff for push or manual dispatch
      - name: Diff changed files (push or manual)
        if: github.event_name != 'pull_request'
        id: diff
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            files="plugins/wasm-${{ github.event.inputs.plugin_type }}/extensions/${{ github.event.inputs.plugin_name }}"
          else
            git fetch origin ${{ github.event.before }}:base
            files=$(git diff --name-only ${{ github.event.before }} ${{ github.sha }})
          fi
          echo "$files" > changed.txt
          echo "::set-output name=files::$(cat changed.txt)"

      # ─────────────────────────────────────────────────────────────────────
      # 3) Compile unified file list, extract plugin names
      - name: Compute changed plugins
        id: set-plugins
        run: |
          # merge API-based PR list + git-diff list
          files="${{ steps.pr_files.outputs.files }}${{ steps.diff.outputs.files }}"
          echo "All changed files:"; echo "$files"

          plugins=$(echo "$files" \
            | grep -E '^plugins/wasm-(go|rust)/extensions/[^/]+' \
            | awk -F/ '{print $4}' \
            | sort -u)

          if [ -z "$plugins" ]; then
            echo "::set-output name=changed_plugins::[]"
          else
            # always tag as 1.0.0 and latest
            arr=$(printf '"%s",' $plugins | sed 's/,$//')
            echo "::set-output name=changed_plugins::[${arr}]"
          fi

  build:
    needs: detect
    if: needs.detect.outputs.plugins != '[]'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        plugin: ${{ fromJson(needs.detect.outputs.plugins) }}
    environment:
      name: image-registry-msg
    env:
      IMAGE_REGISTRY_SERVICE: ${{ vars.IMAGE_REGISTRY || 'higress-registry.cn-hangzhou.cr.aliyuncs.com' }}
      IMAGE_REPOSITORY: ${{ vars.PLUGIN_IMAGE_REPOSITORY || 'plugins' }}
      RUST_VERSION: 1.82
      GO_VERSION: 1.19
      TINYGO_VERSION: 0.28.1
      ORAS_VERSION: 1.0.0

    steps:
      - name: Set PLUGIN_NAME from matrix
        run: echo "PLUGIN_NAME=${{ matrix.plugin }}" >> $GITHUB_ENV

      - name: Determine plugin_type, builder_image and version  # 设置插件类型、构建器镜像、版本
        id: set_vars
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            plugin_type="${{ github.event.inputs.plugin_type }}"
            # plugin_name is now used for manual builds
          elif [[ -d plugins/wasm-go/extensions/${PLUGIN_NAME} ]]; then
            plugin_type=go
          else
            plugin_type=rust
          fi

          # 版本固定为 1.0.0
          version="1.0.0"

          if [[ "$plugin_type" == "rust" ]]; then
            builder="higress-registry.cn-hangzhou.cr.aliyuncs.com/plugins/wasm-rust-builder:rust${RUST_VERSION}-oras${ORAS_VERSION}"
          else
            builder="higress-registry.cn-hangzhou.cr.aliyuncs.com/plugins/wasm-go-builder:go${GO_VERSION}-tinygo${TINYGO_VERSION}-oras${ORAS_VERSION}"
          fi

          echo "PLUGIN_TYPE=$plugin_type" >> $GITHUB_ENV
          echo "VERSION=$version" >> $GITHUB_ENV
          echo "BUILDER_IMAGE=$builder" >> $GITHUB_ENV

      - name: Checkout code
        uses: actions/checkout@v3

      - name: Run a wasm-builder
        run: |
          docker run -d --name builder -v "${{ github.workspace }}:/workspace" \
            -e PLUGIN_NAME -e VERSION "${{ env.BUILDER_IMAGE }}" tail -f /dev/null

      # ─────────────────────────────────────────────────────────────────────
      # Re‑added .prebuild and .buildrc sourcing
      - name: Prebuild & Build inside builder container
        run: |
          cd plugins/wasm-${PLUGIN_TYPE}/extensions/${PLUGIN_NAME}

          if [ -f ./.prebuild ]; then
            echo 'Found .prebuild file, sourcing it...'
            . ./.prebuild
          fi

          if [ -f ./.buildrc ]; then
            echo 'Found .buildrc file, sourcing it...'
            . ./.buildrc
          else
            echo '.buildrc file not found'
          fi

          rustup target add wasm32-wasip1
          cargo build --target wasm32-wasip1 --release

      - name: File Check  # 检查 spec.yaml, README.md 等，并拼装 push 命令
        run: |
          workspace="${{ github.workspace }}/plugins/wasm-${PLUGIN_TYPE}/extensions/${PLUGIN_NAME}"
          push_command="./plugin.tar.gz:application/vnd.oci.image.layer.v1.tar+gzip"
          # spec.yaml
          if [[ -f "${workspace}/spec.yaml" ]]; then
            push_command="./spec.yaml:application/vnd.module.wasm.spec.v1+yaml $push_command"
          fi
          # README.md
          if [[ -f "${workspace}/README.md" ]]; then
            push_command="./README.md:application/vnd.module.wasm.doc.v1+markdown $push_command"
          fi
          # 多语言 README_{lang}.md
          for f in ${workspace}/README_*.md; do
            if [[ -f "$f" ]]; then
              lang=$(basename "$f" | sed 's/README_//; s/.md//')
              push_command="./$(basename "$f"):application/vnd.module.wasm.doc.v1.$lang+markdown $push_command"
            fi
          done
          echo "PUSH_COMMAND=$push_command" >> $GITHUB_ENV

      - name: Build Image and Push  # 执行构建并推送镜像
        env:
          IMAGE_REGISTRY_SERVICE: ${{ env.IMAGE_REGISTRY_SERVICE }}
          IMAGE_REPOSITORY: ${{ env.IMAGE_REPOSITORY }}
          PLUGIN_NAME: ${{ env.PLUGIN_NAME }}
          VERSION: ${{ env.VERSION }}
          PUSH_COMMAND: ${{ env.PUSH_COMMAND }}
        run: |
          target="${IMAGE_REGISTRY_SERVICE}/${IMAGE_REPOSITORY}/${PLUGIN_NAME}:${VERSION}"
          target_latest="${IMAGE_REGISTRY_SERVICE}/${IMAGE_REPOSITORY}/${PLUGIN_NAME}:latest"
          cd plugins/wasm-${PLUGIN_TYPE}/extensions/${PLUGIN_NAME}
          # 构建 artifact（若 plugin.wasm 不存在，也确保有 plugin.tar.gz）
          tar czvf plugin.tar.gz plugin.wasm || true
          # 登录并推送
          echo "${{ secrets.REGISTRY_PASSWORD }}" \
            | oras login -u "${{ secrets.REGISTRY_USERNAME }}" --password-stdin "${IMAGE_REGISTRY_SERVICE}"
          oras push "$target" "$PUSH_COMMAND"
          oras push "$target_latest" "$PUSH_COMMAND"
