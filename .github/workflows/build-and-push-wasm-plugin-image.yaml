name: Build and Push Wasm Plugin Image

on:
  push:
    branches: [main]
    tags:
      - "wasm-*-*-v*.*.*"  # 匹配 wasm-{go|rust}-{pluginName}-vX.Y.Z
    paths:
      - 'plugins/wasm-go/extensions/**'
      - 'plugins/wasm-rust/extensions/**'
  pull_request:
    # 只在 PR 合并到 main 时触发（closed 且 merged）
    types: [closed]
    branches: [main]
    paths:
      - 'plugins/wasm-go/extensions/**'
      - 'plugins/wasm-rust/extensions/**'
  workflow_dispatch:
    inputs:
      plugin_type:
        description: 'Type of the plugin'
        required: true
        type: choice
        options: [go, rust]
      plugin_name:
        description: 'Name of the plugin'
        required: true
        type: string
      version:
        description: 'Version of the plugin (optional, without leading v)'
        required: false
        type: string

jobs:
  detect:
    runs-on: ubuntu-latest
    outputs:
      plugins: ${{ steps.diff.outputs.changed_plugins }}
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0   # 需要完整历史以 diff PR 和分支间差异
      - name: Detect changed plugins  # 检查哪些插件被修改
        id: diff
        run: |
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            git fetch origin ${{ github.event.pull_request.base.ref }}:base
            files=$(git diff --name-only base...HEAD)
          else
            files=$(git diff --name-only ${{ github.event.before }} ${{ github.sha }})
          fi
          echo "Changed files:"
          echo "$files"
          # 提取所有被改动插件目录名（第四段路径）
          plugins=$(echo "$files" \
            | grep -E '^plugins/wasm-(go|rust)/extensions/[^/]+' \
            | awk -F/ '{print $4}' | sort -u | paste -sd ' ' -)
          # 转成 ["a","b",...] 格式输出给后续 matrix
          if [[ -z "$plugins" ]]; then
            echo "::set-output name=changed_plugins::[]"
          else
            arr=$(printf '"%s",' $plugins | sed 's/,$//')
            echo "::set-output name=changed_plugins::[${arr}]"
          fi

  build:
    needs: detect
    if: needs.detect.outputs.plugins != '[]'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        plugin: ${{ fromJson(needs.detect.outputs.plugins) }}
    environment:
      name: image-registry-msg
    env:
      IMAGE_REGISTRY_SERVICE: ${{ vars.IMAGE_REGISTRY || 'higress-registry.cn-hangzhou.cr.aliyuncs.com' }}
      IMAGE_REPOSITORY: ${{ vars.PLUGIN_IMAGE_REPOSITORY || 'plugins' }}
      RUST_VERSION: 1.82
      GO_VERSION: 1.19
      TINYGO_VERSION: 0.28.1
      ORAS_VERSION: 1.0.0

    steps:
      - name: Set PLUGIN_NAME from matrix
        run: echo "PLUGIN_NAME=${{ matrix.plugin }}" >> $GITHUB_ENV

      - name: Determine plugin_type, builder_image and version  # 设置插件类型、构建器镜像、版本
        id: set_vars
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            plugin_type="${{ github.event.inputs.plugin_type }}"
            version="${{ github.event.inputs.version }}"
          else
            # 通过目录判断类型
            if [[ -d plugins/wasm-go/extensions/${PLUGIN_NAME} ]]; then
              plugin_type=go
            else
              plugin_type=rust
            fi
            # 如果是标签事件，则提取版本号；否则为 PR 构建，打 pr-<sha>
            if [[ "${{ github.ref_name }}" =~ ^wasm- ]]; then
              version="${{ github.ref_name#*v }}"
            else
              version="pr-${GITHUB_SHA:0:7}"
            fi
          fi
          echo "PLUGIN_TYPE=$plugin_type" >> $GITHUB_ENV
          echo "VERSION=$version" >> $GITHUB_ENV

          # 根据类型选择对应 builder 镜像
          if [[ "$plugin_type" == "rust" ]]; then
            builder="higress-registry.cn-hangzhou.cr.aliyuncs.com/plugins/wasm-rust-builder:rust${RUST_VERSION}-oras${ORAS_VERSION}"
          else
            builder="higress-registry.cn-hangzhou.cr.aliyuncs.com/plugins/wasm-go-builder:go${GO_VERSION}-tinygo${TINYGO_VERSION}-oras${ORAS_VERSION}"
          fi
          echo "BUILDER_IMAGE=$builder" >> $GITHUB_ENV

      - name: Checkout code
        uses: actions/checkout@v3

      - name: File Check  # 检查 spec.yaml, README.md 等，并拼装 push 命令
        run: |
          workspace="${{ github.workspace }}/plugins/wasm-${PLUGIN_TYPE}/extensions/${PLUGIN_NAME}"
          push_command="./plugin.tar.gz:application/vnd.oci.image.layer.v1.tar+gzip"
          # spec.yaml
          if [[ -f "${workspace}/spec.yaml" ]]; then
            push_command="./spec.yaml:application/vnd.module.wasm.spec.v1+yaml $push_command"
          fi
          # README.md
          if [[ -f "${workspace}/README.md" ]]; then
            push_command="./README.md:application/vnd.module.wasm.doc.v1+markdown $push_command"
          fi
          # 多语言 README_{lang}.md
          for f in ${workspace}/README_*.md; do
            if [[ -f "$f" ]]; then
              lang=$(basename "$f" | sed 's/README_//; s/.md//')
              push_command="./$(basename "$f"):application/vnd.module.wasm.doc.v1.$lang+markdown $push_command"
            fi
          done
          echo "PUSH_COMMAND=$push_command" >> $GITHUB_ENV

      - name: Run a wasm-builder 
        run: |
          docker run -d --name builder -v "${{ github.workspace }}:/workspace" \
            -e PLUGIN_NAME -e PUSH_COMMAND -e VERSION "${{ env.BUILDER_IMAGE }}" tail -f /dev/null

      - name: Build Image and Push  # 执行构建并推送镜像
        env:
          IMAGE_REGISTRY_SERVICE: ${{ env.IMAGE_REGISTRY_SERVICE }}
          IMAGE_REPOSITORY: ${{ env.IMAGE_REPOSITORY }}
          PLUGIN_NAME: ${{ env.PLUGIN_NAME }}
          VERSION: ${{ env.VERSION }}
          PUSH_COMMAND: ${{ env.PUSH_COMMAND }}
        run: |
          target="${IMAGE_REGISTRY_SERVICE}/${IMAGE_REPOSITORY}/${PLUGIN_NAME}:${VERSION}"
          target_latest="${IMAGE_REGISTRY_SERVICE}/${IMAGE_REPOSITORY}/${PLUGIN_NAME}:latest"
          cd plugins/wasm-${PLUGIN_TYPE}/extensions/${PLUGIN_NAME}
          # 构建 artifact（若 plugin.wasm 不存在，也确保有 plugin.tar.gz）
          tar czvf plugin.tar.gz plugin.wasm || true
          # 登录并推送
          echo "${{ secrets.REGISTRY_PASSWORD }}" \
            | oras login -u "${{ secrets.REGISTRY_USERNAME }}" --password-stdin "${IMAGE_REGISTRY_SERVICE}"
          oras push "$target" "$PUSH_COMMAND"
          oras push "$target_latest" "$PUSH_COMMAND"
